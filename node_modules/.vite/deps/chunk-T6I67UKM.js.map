{
  "version": 3,
  "sources": ["../../three/examples/jsm/utils/BufferGeometryUtils.js", "../../src/geometry-utils.ts", "../../three/examples/jsm/exporters/GLTFExporter.js", "../../three/src/math/MathUtils.js", "../../three/src/math/Quaternion.js", "../../three/src/math/Vector3.js", "../../three/src/math/Vector2.js", "../../three/src/constants.js", "../../three/src/extras/DataUtils.js", "../../three/src/core/BufferAttribute.js", "../../src/fragment-mesh.ts", "../../src/blocks.ts", "../../three-mesh-bvh/src/core/Constants.js", "../../three-mesh-bvh/src/core/MeshBVHNode.js", "../../three-mesh-bvh/src/utils/ArrayBoxUtilities.js", "../../three-mesh-bvh/src/core/buildFunctions.js", "../../three-mesh-bvh/src/math/SeparatingAxisBounds.js", "../../three-mesh-bvh/src/math/MathUtilities.js", "../../three-mesh-bvh/src/math/ExtendedTriangle.js", "../../three-mesh-bvh/src/math/OrientedBox.js", "../../three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js", "../../three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js", "../../three-mesh-bvh/src/utils/TriangleUtilities.js", "../../three-mesh-bvh/src/utils/PrimitivePool.js", "../../three-mesh-bvh/src/core/nodeBufferFunctions.js", "../../three-mesh-bvh/src/core/castFunctions.js", "../../three-mesh-bvh/src/core/MeshBVH.js", "../../three-mesh-bvh/src/objects/MeshBVHVisualizer.js", "../../three-mesh-bvh/src/debug/Debug.js", "../../three-mesh-bvh/src/utils/ExtensionUtilities.js", "../../three-mesh-bvh/src/utils/StaticGeometryGenerator.js", "../../src/bvh.ts", "../../src/fragment.ts", "../../flatbuffers/mjs/constants.js", "../../flatbuffers/mjs/utils.js", "../../flatbuffers/mjs/encoding.js", "../../flatbuffers/mjs/byte-buffer.js", "../../flatbuffers/mjs/builder.js", "../../src/flatbuffers/fragments/index/fragment.ts", "../../src/flatbuffers/fragments/index/fragments-group.ts", "../../src/fragments-group.ts", "../../src/serializer.ts"],
  "sourcesContent": ["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n// Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at\n// an angle greater than the crease angle.\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vertors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\tconst resultGeometry = geometry.toNonIndexed();\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().' ); // @deprecated, r151\n\treturn mergeGeometries( geometries, useGroups );\n\n}\n\nfunction mergeBufferAttributes( attributes ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().' ); // @deprecated, r151\n\treturn mergeAttributes( attributes );\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeBufferGeometries,\n\tmergeAttributes,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n", null, "import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tNoColorSpace,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tSRGBColorSpace,\n\tVector3\n} from 'three';\n\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n\tPOSITION: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'unsigned byte normalized',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t\t'unsigned short normalized',\n\t],\n\tNORMAL: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTANGENT: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTEXCOORD: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t],\n};\n\n\nclass GLTFExporter {\n\n\tconstructor() {\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( writer );\n\n\t\t} );\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Function} onError  Callback on errors\n\t * @param  {Object} options options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.write( input, onDone, options ).catch( onError );\n\n\t}\n\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tBYTE: 0x1400,\n\tUNSIGNED_BYTE: 0x1401,\n\tSHORT: 0x1402,\n\tUNSIGNED_SHORT: 0x1403,\n\tINT: 0x1404,\n\tUNSIGNED_INT: 0x1405,\n\tFLOAT: 0x1406,\n\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\nconst DEFAULT_SPECULAR_COLOR = new Color();\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nfunction getCanvas() {\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\treturn new OffscreenCanvas( 1, 1 );\n\n\t}\n\n\treturn document.createElement( 'canvas' );\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( canvas.toBlob !== undefined ) {\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n\tlet quality;\n\n\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\tif ( mimeType === 'image/jpeg' ) {\n\n\t\tquality = 0.92;\n\n\t} else if ( mimeType === 'image/webp' ) {\n\n\t\tquality = 0.8;\n\n\t}\n\n\treturn canvas.convertToBlob( {\n\n\t\ttype: mimeType,\n\t\tquality: quality\n\n\t} );\n\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\n\t\tthis.extensionsUsed = {};\n\t\tthis.extensionsRequired = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter'\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Object} options options\n\t */\n\tasync write( input, onDone, options = {} ) {\n\n\t\tthis.options = Object.assign( {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tthis.processInput( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\t\tconst extensionsRequired = writer.extensionsRequired;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\t\tconst extensionsRequiredList = Object.keys( extensionsRequired );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\t\tif ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t * @param  {Object} object\n\t * @return {Integer}\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {Boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tbuildMetalRoughTexture( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tfunction getEncodingConversion( map ) {\n\n\t\t\tif ( map.colorSpace === SRGBColorSpace ) {\n\n\t\t\t\treturn function SRGBToLinear( c ) {\n\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn function LinearToLinear( c ) {\n\n\t\t\t\treturn c;\n\n\t\t\t};\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\tconst metalness = metalnessMap ? metalnessMap.image : null;\n\t\tconst roughness = roughnessMap ? roughnessMap.image : null;\n\n\t\tconst width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );\n\t\tconst height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\t\ttexture.colorSpace = NoColorSpace;\n\t\ttexture.channel = ( metalnessMap || roughnessMap ).channel;\n\n\t\tif ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param  {ArrayBuffer} buffer\n\t * @return {Integer}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param  {BufferAttribute} attribute\n\t * @param  {number} componentType\n\t * @param  {number} start\n\t * @param  {number} count\n\t * @param  {number} target (Optional) Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tswitch ( componentType ) {\n\n\t\t\tcase WEBGL_CONSTANTS.BYTE:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_BYTE:\n\n\t\t\t\tcomponentSize = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase WEBGL_CONSTANTS.SHORT:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_SHORT:\n\n\t\t\t\tcomponentSize = 2;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.INT ) {\n\n\t\t\t\t\tdataView.setInt32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {\n\n\t\t\t\t\tdataView.setInt16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {\n\n\t\t\t\t\tdataView.setInt8( offset, value );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = attribute.itemSize * componentSize;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<Integer>}\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param  {BufferAttribute} attribute Attribute to process\n\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t * @param  {Integer} start (Optional)\n\t * @param  {Integer} count (Optional)\n\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t9: 'MAT3',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Int32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.INT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Int16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Int8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.BYTE;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param  {Image} image to process\n\t * @param  {Integer} format of the image (RGBAFormat)\n\t * @param  {Boolean} flipY before writing out the image\n\t * @param  {String} mimeType export format\n\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tif ( image !== null ) {\n\n\t\t\tconst writer = this;\n\t\t\tconst cache = writer.cache;\n\t\t\tconst json = writer.json;\n\t\t\tconst options = writer.options;\n\t\t\tconst pending = writer.pending;\n\n\t\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\t\tconst cachedImages = cache.images.get( image );\n\n\t\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\t\tif ( ! json.images ) json.images = [];\n\n\t\t\tconst imageDef = { mimeType: mimeType };\n\n\t\t\tconst canvas = getCanvas();\n\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\tconst ctx = canvas.getContext( '2d' );\n\n\t\t\tif ( flipY === true ) {\n\n\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t}\n\n\t\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t\t}\n\n\t\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t}\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tif ( canvas.toDataURL !== undefined ) {\n\n\t\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpending.push(\n\n\t\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t\t.then( blob => new FileReader().readAsDataURL( blob ) )\n\t\t\t\t\t\t\t.then( dataURL => {\n\n\t\t\t\t\t\t\t\timageDef.uri = dataURL;\n\n\t\t\t\t\t\t\t} )\n\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst index = json.images.push( imageDef ) - 1;\n\t\t\tcachedImages[ key ] = index;\n\t\t\treturn index;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param  {Texture} map Texture to process\n\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param  {Texture} map Map to process\n\t * @return {Integer} Index of the processed texture in the \"textures\" array\n\t */\n\tprocessTexture( map ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeTexture && ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param  {THREE.Material} material Material to process\n\t * @return {Integer|null} Index of the processed material in the \"materials\" array\n\t */\n\tprocessMaterial( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = {\n\t\t\t\tindex: this.processTexture( metalRoughTexture ),\n\t\t\t\tchannel: metalRoughTexture.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = {\n\t\t\t\tindex: this.processTexture( material.map ),\n\t\t\t\ttexCoord: material.map.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tconst emissive = material.emissive;\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = material.emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = {\n\t\t\t\t\tindex: this.processTexture( material.emissiveMap ),\n\t\t\t\t\ttexCoord: material.emissiveMap.channel\n\t\t\t\t};\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = {\n\t\t\t\tindex: this.processTexture( material.normalMap ),\n\t\t\t\ttexCoord: material.normalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: this.processTexture( material.aoMap ),\n\t\t\t\ttexCoord: material.aoMap.channel\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMaterial && ext.writeMaterial( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param  {THREE.Mesh} mesh Mesh to process\n\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n\t */\n\tprocessMesh( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv1: 'TEXCOORD_1',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tif ( ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\t\tthis.detectMeshQuantization( attributeName, attribute );\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t\t\tif ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );\n\t\t\t\t\t\t\t\tif ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );\n\t\t\t\t\t\t\t\tif ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );\n\t\t\t\t\t\t\t\tif ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = this.processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * If a vertex attribute with a\n\t * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n\t * is used, it is checked whether it is a valid data type according to the\n\t * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n\t * extension.\n\t * In this case the extension is automatically added to the list of used extensions.\n\t *\n\t * @param {string} attributeName\n\t * @param {THREE.BufferAttribute} attribute\n\t */\n\tdetectMeshQuantization( attributeName, attribute ) {\n\n\t\tif ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;\n\n\t\tlet attrType = undefined;\n\n\t\tswitch ( attribute.array.constructor ) {\n\n\t\t\tcase Int8Array:\n\n\t\t\t\tattrType = 'byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint8Array:\n\n\t\t\t\tattrType = 'unsigned byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Int16Array:\n\n\t\t\t\tattrType = 'short';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint16Array:\n\n\t\t\t\tattrType = 'unsigned short';\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.normalized ) attrType += ' normalized';\n\n\t\tconst attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];\n\n\t\tif ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {\n\n\t\t\tthis.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;\n\t\t\tthis.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param  {THREE.Camera} camera Camera to process\n\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {number|null}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tjson.animations.push( {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t} );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {number|null}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param  {THREE.Object3D} node Object3D to processNode\n\t * @return {Integer} Index of the node in the nodes list\n\t */\n\tprocessNode( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = this.processMesh( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param  {Scene} node Scene to process\n\t */\n\tprocessScene( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param  {Array} objects List of objects to process\n\t */\n\tprocessObjects( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tthis.processScene( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tprocessInput( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tthis.processScene( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tfunc( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = {\n\t\t\t\tindex: writer.processTexture( material.clearcoatMap ),\n\t\t\t\ttexCoord: material.clearcoatMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.clearcoatRoughnessMap ),\n\t\t\t\ttexCoord: material.clearcoatRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = {\n\t\t\t\tindex: writer.processTexture( material.clearcoatNormalMap ),\n\t\t\t\ttexCoord: material.clearcoatNormalMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = {\n\t\t\t\tindex: writer.processTexture( material.iridescenceMap ),\n\t\t\t\ttexCoord: material.iridescenceMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.iridescenceThicknessMap ),\n\t\t\t\ttexCoord: material.iridescenceThicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = {\n\t\t\t\tindex: writer.processTexture( material.transmissionMap ),\n\t\t\t\ttexCoord: material.transmissionMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.thicknessMap ),\n\t\t\t\ttexCoord: material.thicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_ior';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.ior = material.ior;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_specular';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&\n\t\t       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&\n\t\t     ! material.specularIntensityMap && ! material.specularColorTexture ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tconst specularIntensityMapDef = {\n\t\t\t\tindex: writer.processTexture( material.specularIntensityMap ),\n\t\t\t\ttexCoord: material.specularIntensityMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );\n\t\t\textensionDef.specularTexture = specularIntensityMapDef;\n\n\t\t}\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tconst specularColorMapDef = {\n\t\t\t\tindex: writer.processTexture( material.specularColorMap ),\n\t\t\t\ttexCoord: material.specularColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularColorMapDef, material.specularColorMap );\n\t\t\textensionDef.specularColorTexture = specularColorMapDef;\n\n\t\t}\n\n\t\textensionDef.specularFactor = material.specularIntensity;\n\t\textensionDef.specularColorFactor = material.specularColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_sheen';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\tconst sheenRoughnessMapDef = {\n\t\t\t\tindex: writer.processTexture( material.sheenRoughnessMap ),\n\t\t\t\ttexCoord: material.sheenRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );\n\t\t\textensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.sheenColorMap ) {\n\n\t\t\tconst sheenColorMapDef = {\n\t\t\t\tindex: writer.processTexture( material.sheenColorMap ),\n\t\t\t\ttexCoord: material.sheenColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );\n\t\t\textensionDef.sheenColorTexture = sheenColorMapDef;\n\n\t\t}\n\n\t\textensionDef.sheenRoughnessFactor = material.sheenRoughness;\n\t\textensionDef.sheenColorFactor = material.sheenColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_emissive_strength';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.emissiveStrength = material.emissiveIntensity;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t}\n\n};\n\nexport { GLTFExporter };\n", "const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n", "import * as MathUtils from './MathUtils.js';\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.isQuaternion = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update ) {\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update !== false ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize();\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\treturn this.copy( qa ).slerp( qb, t );\n\n\t}\n\n\trandom() {\n\n\t\t// Derived from http://planning.cs.uiuc.edu/node198.html\n\t\t// Note, this source uses w, x, y, z ordering,\n\t\t// so we swap the order below.\n\n\t\tconst u1 = Math.random();\n\t\tconst sqrt1u1 = Math.sqrt( 1 - u1 );\n\t\tconst sqrtu1 = Math.sqrt( u1 );\n\n\t\tconst u2 = 2 * Math.PI * Math.random();\n\n\t\tconst u3 = 2 * Math.PI * Math.random();\n\n\t\treturn this.set(\n\t\t\tsqrt1u1 * Math.cos( u2 ),\n\t\t\tsqrtu1 * Math.sin( u3 ),\n\t\t\tsqrtu1 * Math.cos( u3 ),\n\t\t\tsqrt1u1 * Math.sin( u2 ),\n\t\t);\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.toArray();\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._w;\n\n\t}\n\n}\n\nexport { Quaternion };\n", "import * as MathUtils from './MathUtils.js';\nimport { Quaternion } from './Quaternion.js';\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tVector3.prototype.isVector3 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\treturn this.applyQuaternion( _quaternion.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tconst ix = qw * x + qy * z - qz * y;\n\t\tconst iy = qw * y + qz * x - qx * z;\n\t\tconst iz = qw * z + qx * y - qy * x;\n\t\tconst iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tsetFromEuler( e ) {\n\n\t\tthis.x = e._x;\n\t\tthis.y = e._y;\n\t\tthis.z = e._z;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromColor( c ) {\n\n\t\tthis.x = c.r;\n\t\tthis.y = c.g;\n\t\tthis.z = c.b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\trandomDirection() {\n\n\t\t// Derived from https://mathworld.wolfram.com/SpherePointPicking.html\n\n\t\tconst u = ( Math.random() - 0.5 ) * 2;\n\t\tconst t = Math.random() * Math.PI * 2;\n\t\tconst f = Math.sqrt( 1 - u ** 2 );\n\n\t\tthis.x = f * Math.cos( t );\n\t\tthis.y = f * Math.sin( t );\n\t\tthis.z = u;\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\n\nexport { Vector3 };\n", "import * as MathUtils from './MathUtils.js';\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tVector2.prototype.isVector2 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\n\t}\n\n}\n\nexport { Vector2 };\n", "export const REVISION = '152';\n\nexport const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nexport const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nexport const CullFaceNone = 0;\nexport const CullFaceBack = 1;\nexport const CullFaceFront = 2;\nexport const CullFaceFrontBack = 3;\nexport const BasicShadowMap = 0;\nexport const PCFShadowMap = 1;\nexport const PCFSoftShadowMap = 2;\nexport const VSMShadowMap = 3;\nexport const FrontSide = 0;\nexport const BackSide = 1;\nexport const DoubleSide = 2;\nexport const TwoPassDoubleSide = 2; // r149\nexport const NoBlending = 0;\nexport const NormalBlending = 1;\nexport const AdditiveBlending = 2;\nexport const SubtractiveBlending = 3;\nexport const MultiplyBlending = 4;\nexport const CustomBlending = 5;\nexport const AddEquation = 100;\nexport const SubtractEquation = 101;\nexport const ReverseSubtractEquation = 102;\nexport const MinEquation = 103;\nexport const MaxEquation = 104;\nexport const ZeroFactor = 200;\nexport const OneFactor = 201;\nexport const SrcColorFactor = 202;\nexport const OneMinusSrcColorFactor = 203;\nexport const SrcAlphaFactor = 204;\nexport const OneMinusSrcAlphaFactor = 205;\nexport const DstAlphaFactor = 206;\nexport const OneMinusDstAlphaFactor = 207;\nexport const DstColorFactor = 208;\nexport const OneMinusDstColorFactor = 209;\nexport const SrcAlphaSaturateFactor = 210;\nexport const NeverDepth = 0;\nexport const AlwaysDepth = 1;\nexport const LessDepth = 2;\nexport const LessEqualDepth = 3;\nexport const EqualDepth = 4;\nexport const GreaterEqualDepth = 5;\nexport const GreaterDepth = 6;\nexport const NotEqualDepth = 7;\nexport const MultiplyOperation = 0;\nexport const MixOperation = 1;\nexport const AddOperation = 2;\nexport const NoToneMapping = 0;\nexport const LinearToneMapping = 1;\nexport const ReinhardToneMapping = 2;\nexport const CineonToneMapping = 3;\nexport const ACESFilmicToneMapping = 4;\nexport const CustomToneMapping = 5;\n\nexport const UVMapping = 300;\nexport const CubeReflectionMapping = 301;\nexport const CubeRefractionMapping = 302;\nexport const EquirectangularReflectionMapping = 303;\nexport const EquirectangularRefractionMapping = 304;\nexport const CubeUVReflectionMapping = 306;\nexport const RepeatWrapping = 1000;\nexport const ClampToEdgeWrapping = 1001;\nexport const MirroredRepeatWrapping = 1002;\nexport const NearestFilter = 1003;\nexport const NearestMipmapNearestFilter = 1004;\nexport const NearestMipMapNearestFilter = 1004;\nexport const NearestMipmapLinearFilter = 1005;\nexport const NearestMipMapLinearFilter = 1005;\nexport const LinearFilter = 1006;\nexport const LinearMipmapNearestFilter = 1007;\nexport const LinearMipMapNearestFilter = 1007;\nexport const LinearMipmapLinearFilter = 1008;\nexport const LinearMipMapLinearFilter = 1008;\nexport const UnsignedByteType = 1009;\nexport const ByteType = 1010;\nexport const ShortType = 1011;\nexport const UnsignedShortType = 1012;\nexport const IntType = 1013;\nexport const UnsignedIntType = 1014;\nexport const FloatType = 1015;\nexport const HalfFloatType = 1016;\nexport const UnsignedShort4444Type = 1017;\nexport const UnsignedShort5551Type = 1018;\nexport const UnsignedInt248Type = 1020;\nexport const AlphaFormat = 1021;\nexport const RGBAFormat = 1023;\nexport const LuminanceFormat = 1024;\nexport const LuminanceAlphaFormat = 1025;\nexport const DepthFormat = 1026;\nexport const DepthStencilFormat = 1027;\nexport const RedFormat = 1028;\nexport const RedIntegerFormat = 1029;\nexport const RGFormat = 1030;\nexport const RGIntegerFormat = 1031;\nexport const RGBAIntegerFormat = 1033;\n\nexport const RGB_S3TC_DXT1_Format = 33776;\nexport const RGBA_S3TC_DXT1_Format = 33777;\nexport const RGBA_S3TC_DXT3_Format = 33778;\nexport const RGBA_S3TC_DXT5_Format = 33779;\nexport const RGB_PVRTC_4BPPV1_Format = 35840;\nexport const RGB_PVRTC_2BPPV1_Format = 35841;\nexport const RGBA_PVRTC_4BPPV1_Format = 35842;\nexport const RGBA_PVRTC_2BPPV1_Format = 35843;\nexport const RGB_ETC1_Format = 36196;\nexport const RGB_ETC2_Format = 37492;\nexport const RGBA_ETC2_EAC_Format = 37496;\nexport const RGBA_ASTC_4x4_Format = 37808;\nexport const RGBA_ASTC_5x4_Format = 37809;\nexport const RGBA_ASTC_5x5_Format = 37810;\nexport const RGBA_ASTC_6x5_Format = 37811;\nexport const RGBA_ASTC_6x6_Format = 37812;\nexport const RGBA_ASTC_8x5_Format = 37813;\nexport const RGBA_ASTC_8x6_Format = 37814;\nexport const RGBA_ASTC_8x8_Format = 37815;\nexport const RGBA_ASTC_10x5_Format = 37816;\nexport const RGBA_ASTC_10x6_Format = 37817;\nexport const RGBA_ASTC_10x8_Format = 37818;\nexport const RGBA_ASTC_10x10_Format = 37819;\nexport const RGBA_ASTC_12x10_Format = 37820;\nexport const RGBA_ASTC_12x12_Format = 37821;\nexport const RGBA_BPTC_Format = 36492;\nexport const RED_RGTC1_Format = 36283;\nexport const SIGNED_RED_RGTC1_Format = 36284;\nexport const RED_GREEN_RGTC2_Format = 36285;\nexport const SIGNED_RED_GREEN_RGTC2_Format = 36286;\nexport const LoopOnce = 2200;\nexport const LoopRepeat = 2201;\nexport const LoopPingPong = 2202;\nexport const InterpolateDiscrete = 2300;\nexport const InterpolateLinear = 2301;\nexport const InterpolateSmooth = 2302;\nexport const ZeroCurvatureEnding = 2400;\nexport const ZeroSlopeEnding = 2401;\nexport const WrapAroundEnding = 2402;\nexport const NormalAnimationBlendMode = 2500;\nexport const AdditiveAnimationBlendMode = 2501;\nexport const TrianglesDrawMode = 0;\nexport const TriangleStripDrawMode = 1;\nexport const TriangleFanDrawMode = 2;\n/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */\nexport const LinearEncoding = 3000;\n/** @deprecated Use SRGBColorSpace in three.js r152+. */\nexport const sRGBEncoding = 3001;\nexport const BasicDepthPacking = 3200;\nexport const RGBADepthPacking = 3201;\nexport const TangentSpaceNormalMap = 0;\nexport const ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nexport const NoColorSpace = '';\nexport const SRGBColorSpace = 'srgb';\nexport const LinearSRGBColorSpace = 'srgb-linear';\nexport const DisplayP3ColorSpace = 'display-p3';\n\nexport const ZeroStencilOp = 0;\nexport const KeepStencilOp = 7680;\nexport const ReplaceStencilOp = 7681;\nexport const IncrementStencilOp = 7682;\nexport const DecrementStencilOp = 7683;\nexport const IncrementWrapStencilOp = 34055;\nexport const DecrementWrapStencilOp = 34056;\nexport const InvertStencilOp = 5386;\n\nexport const NeverStencilFunc = 512;\nexport const LessStencilFunc = 513;\nexport const EqualStencilFunc = 514;\nexport const LessEqualStencilFunc = 515;\nexport const GreaterStencilFunc = 516;\nexport const NotEqualStencilFunc = 517;\nexport const GreaterEqualStencilFunc = 518;\nexport const AlwaysStencilFunc = 519;\n\nexport const StaticDrawUsage = 35044;\nexport const DynamicDrawUsage = 35048;\nexport const StreamDrawUsage = 35040;\nexport const StaticReadUsage = 35045;\nexport const DynamicReadUsage = 35049;\nexport const StreamReadUsage = 35041;\nexport const StaticCopyUsage = 35046;\nexport const DynamicCopyUsage = 35050;\nexport const StreamCopyUsage = 35042;\n\nexport const GLSL1 = '100';\nexport const GLSL3 = '300 es';\n\nexport const _SRGBAFormat = 1035; // fallback for WebGL 1\n", "import { clamp } from '../math/MathUtils.js';\n\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst _tables = /*@__PURE__*/ _generateTables();\n\nfunction _generateTables() {\n\n\t// float32 to float16 helpers\n\n\tconst buffer = new ArrayBuffer( 4 );\n\tconst floatView = new Float32Array( buffer );\n\tconst uint32View = new Uint32Array( buffer );\n\n\tconst baseTable = new Uint32Array( 512 );\n\tconst shiftTable = new Uint32Array( 512 );\n\n\tfor ( let i = 0; i < 256; ++ i ) {\n\n\t\tconst e = i - 127;\n\n\t\t// very small number (0, -0)\n\n\t\tif ( e < - 27 ) {\n\n\t\t\tbaseTable[ i ] = 0x0000;\n\t\t\tbaseTable[ i | 0x100 ] = 0x8000;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// small number (denorm)\n\n\t\t} else if ( e < - 14 ) {\n\n\t\t\tbaseTable[ i ] = 0x0400 >> ( - e - 14 );\n\t\t\tbaseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;\n\t\t\tshiftTable[ i ] = - e - 1;\n\t\t\tshiftTable[ i | 0x100 ] = - e - 1;\n\n\t\t\t// normal number\n\n\t\t} else if ( e <= 15 ) {\n\n\t\t\tbaseTable[ i ] = ( e + 15 ) << 10;\n\t\t\tbaseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t\t// large number (Infinity, -Infinity)\n\n\t\t} else if ( e < 128 ) {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// stay (NaN, Infinity, -Infinity)\n\n\t\t} else {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t}\n\n\t}\n\n\t// float16 to float32 helpers\n\n\tconst mantissaTable = new Uint32Array( 2048 );\n\tconst exponentTable = new Uint32Array( 64 );\n\tconst offsetTable = new Uint32Array( 64 );\n\n\tfor ( let i = 1; i < 1024; ++ i ) {\n\n\t\tlet m = i << 13; // zero pad mantissa bits\n\t\tlet e = 0; // zero exponent\n\n\t\t// normalized\n\t\twhile ( ( m & 0x00800000 ) === 0 ) {\n\n\t\t\tm <<= 1;\n\t\t\te -= 0x00800000; // decrement exponent\n\n\t\t}\n\n\t\tm &= ~ 0x00800000; // clear leading 1 bit\n\t\te += 0x38800000; // adjust bias\n\n\t\tmantissaTable[ i ] = m | e;\n\n\t}\n\n\tfor ( let i = 1024; i < 2048; ++ i ) {\n\n\t\tmantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );\n\n\t}\n\n\tfor ( let i = 1; i < 31; ++ i ) {\n\n\t\texponentTable[ i ] = i << 23;\n\n\t}\n\n\texponentTable[ 31 ] = 0x47800000;\n\texponentTable[ 32 ] = 0x80000000;\n\n\tfor ( let i = 33; i < 63; ++ i ) {\n\n\t\texponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );\n\n\t}\n\n\texponentTable[ 63 ] = 0xc7800000;\n\n\tfor ( let i = 1; i < 64; ++ i ) {\n\n\t\tif ( i !== 32 ) {\n\n\t\t\toffsetTable[ i ] = 1024;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tfloatView: floatView,\n\t\tuint32View: uint32View,\n\t\tbaseTable: baseTable,\n\t\tshiftTable: shiftTable,\n\t\tmantissaTable: mantissaTable,\n\t\texponentTable: exponentTable,\n\t\toffsetTable: offsetTable\n\t};\n\n}\n\n// float32 to float16\n\nfunction toHalfFloat( val ) {\n\n\tif ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );\n\n\tval = clamp( val, - 65504, 65504 );\n\n\t_tables.floatView[ 0 ] = val;\n\tconst f = _tables.uint32View[ 0 ];\n\tconst e = ( f >> 23 ) & 0x1ff;\n\treturn _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );\n\n}\n\n// float16 to float32\n\nfunction fromHalfFloat( val ) {\n\n\tconst m = val >> 10;\n\t_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];\n\treturn _tables.floatView[ 0 ];\n\n}\n\nconst DataUtils = {\n\ttoHalfFloat: toHalfFloat,\n\tfromHalfFloat: fromHalfFloat,\n};\n\nexport {\n\ttoHalfFloat,\n\tfromHalfFloat,\n\tDataUtils\n};\n", "import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { denormalize, normalize } from '../math/MathUtils.js';\nimport { StaticDrawUsage } from '../constants.js';\nimport { fromHalfFloat, toHalfFloat } from '../extras/DataUtils.js';\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector2();\n\nclass BufferAttribute {\n\n\tconstructor( array, itemSize, normalized = false ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.isBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyArray( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2.fromBufferAttribute( this, i );\n\t\t\t\t_vector2.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2.x, _vector2.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( this, i );\n\t\t\t\t_vector.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( this, i );\n\n\t\t\t_vector.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( this, i );\n\n\t\t\t_vector.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( this, i );\n\n\t\t\t_vector.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\t// Matching BufferAttribute constructor, do not normalize the array.\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.array[ index * this.itemSize ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.array[ index * this.itemSize + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.array[ index * this.itemSize + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.array[ index * this.itemSize + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.from( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\t\tif ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;\n\n\t\treturn data;\n\n\t}\n\n\tcopyColorsArray() { // @deprecated, r144\n\n\t\tconsole.error( 'THREE.BufferAttribute: copyColorsArray() was removed in r144.' );\n\n\t}\n\n\tcopyVector2sArray() { // @deprecated, r144\n\n\t\tconsole.error( 'THREE.BufferAttribute: copyVector2sArray() was removed in r144.' );\n\n\t}\n\n\tcopyVector3sArray() { // @deprecated, r144\n\n\t\tconsole.error( 'THREE.BufferAttribute: copyVector3sArray() was removed in r144.' );\n\n\t}\n\n\tcopyVector4sArray() { // @deprecated, r144\n\n\t\tconsole.error( 'THREE.BufferAttribute: copyVector4sArray() was removed in r144.' );\n\n\t}\n\n}\n\n//\n\nclass Int8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t\tthis.isFloat16BufferAttribute = true;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = fromHalfFloat( this.array[ index * this.itemSize ] );\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = toHalfFloat( x );\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\t\tthis.array[ index + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass Float32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float64BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float64Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\n//\n\nexport {\n\tFloat64BufferAttribute,\n\tFloat32BufferAttribute,\n\tFloat16BufferAttribute,\n\tUint32BufferAttribute,\n\tInt32BufferAttribute,\n\tUint16BufferAttribute,\n\tInt16BufferAttribute,\n\tUint8ClampedBufferAttribute,\n\tUint8BufferAttribute,\n\tInt8BufferAttribute,\n\tBufferAttribute\n};\n", null, null, "// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n", "export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t}\n\n}\n", "export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n", "import { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport {\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\n} from './Constants.js';\n\nfunction ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tlet index;\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\tfor ( const group of geo.groups ) {\n\n\t\trangeBoundaries.add( group.start );\n\t\trangeBoundaries.add( group.start + group.count );\n\n\t}\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\n\n\t}\n\n\treturn ranges;\n\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\n\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds( geo, fullBounds ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index.array;\n\tconst triCount = index.length / 3;\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai, bi, ci;\n\n\t\tif ( normalized ) {\n\n\t\t\tai = index[ tri3 + 0 ];\n\t\t\tbi = index[ tri3 + 1 ];\n\t\t\tci = index[ tri3 + 2 ];\n\n\t\t} else {\n\n\t\t\tai = index[ tri3 + 0 ] * stride + bufferOffset;\n\t\t\tbi = index[ tri3 + 1 ] * stride + bufferOffset;\n\t\t\tci = index[ tri3 + 2 ] * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n\nexport function buildTree( geo, options ) {\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tensureIndex( geo, options );\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\n\tconst indexArray = geo.index.array;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = geo.index.count / 3;\n\tlet reachedMaxDepth = false;\n\n\tconst roots = [];\n\tconst ranges = getRootIndexRanges( geo );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n}\n\nexport function buildPackedTree( geo, options ) {\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( geo, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\treturn packedRoots;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n", "import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n", "import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n", "import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst DIST_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < DIST_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst points1 = this.points;\n\t\t\tlet found1 = false;\n\t\t\tlet count1 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points1[ i ];\n\t\t\t\tconst pNext = points1[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir1 );\n\n\t\t\t\tconst targetPoint = found1 ? edge1.start : edge1.end;\n\t\t\t\tconst startIntersects = isNearZero( plane2.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge1.copy( edge );\n\t\t\t\t\tcount1 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount1 ++;\n\t\t\t\t\tif ( found1 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound1 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst points2 = other.points;\n\t\t\tlet found2 = false;\n\t\t\tlet count2 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points2[ i ];\n\t\t\t\tconst pNext = points2[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir2 );\n\n\t\t\t\tconst targetPoint = found2 ? edge2.start : edge2.end;\n\t\t\t\tconst startIntersects = isNearZero( plane1.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge2.copy( edge );\n\t\t\t\t\tcount2 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount2 ++;\n\t\t\t\t\tif ( found2 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound2 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n", "import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n", "import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tconst a = geo.index.getX( triOffset );\n\tconst b = geo.index.getX( triOffset + 1 );\n\tconst c = geo.index.getX( triOffset + 2 );\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n", "import { intersectTri } from './ThreeRayIntersectUtilities.js';\n\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\n\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tintersectTri( geo, side, ray, i, intersections );\n\n\t}\n\n}\n\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\n\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tconst intersection = intersectTri( geo, side, ray, i );\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n", "\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i );\n\t\ti1 = index.getX( i + 1 );\n\t\ti2 = index.getX( i + 2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nexport function iterateOverTriangles(\n\toffset,\n\tcount,\n\tgeometry,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst index = geometry.index;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tsetTriangle( triangle, i * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n", "export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n", "export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n", "import { Box3, Vector3, Matrix4 } from 'three';\nimport { CONTAINED } from './Constants.js';\n\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\n\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = [ 'x', 'y', 'z' ];\n\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport const shapecast = ( function () {\n\n\tlet _box1, _box2;\n\tconst boxStack = [];\n\tconst boxPool = new PrimitivePool( () => new Box3() );\n\n\treturn function shapecast( ...args ) {\n\n\t\t_box1 = boxPool.getPrimitive();\n\t\t_box2 = boxPool.getPrimitive();\n\t\tboxStack.push( _box1, _box2 );\n\n\t\tconst result = shapecastTraverse( ...args );\n\n\t\tboxPool.releasePrimitive( _box1 );\n\t\tboxPool.releasePrimitive( _box2 );\n\t\tboxStack.pop();\n\t\tboxStack.pop();\n\n\t\tconst length = boxStack.length;\n\t\tif ( length > 0 ) {\n\n\t\t\t_box2 = boxStack[ length - 1 ];\n\t\t\t_box1 = boxStack[ length - 2 ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tfunction shapecastTraverse(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tbox2 = _box2;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n} )();\n\nexport const intersectsGeometry = ( function () {\n\n\tconst triangle = new ExtendedTriangle();\n\tconst triangle2 = new ExtendedTriangle();\n\tconst invertedMat = new Matrix4();\n\n\tconst obb = new OrientedBox();\n\tconst obb2 = new OrientedBox();\n\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n} )();\n\nfunction intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, boundingBox );\n\treturn ray.intersectBox( boundingBox, target );\n\n}\n\nconst bufferStack = [];\nlet _prevBuffer;\nlet _float32Array;\nlet _uint16Array;\nlet _uint32Array;\nexport function setBuffer( buffer ) {\n\n\tif ( _prevBuffer ) {\n\n\t\tbufferStack.push( _prevBuffer );\n\n\t}\n\n\t_prevBuffer = buffer;\n\t_float32Array = new Float32Array( buffer );\n\t_uint16Array = new Uint16Array( buffer );\n\t_uint32Array = new Uint32Array( buffer );\n\n}\n\nexport function clearBuffer() {\n\n\t_prevBuffer = null;\n\t_float32Array = null;\n\t_uint16Array = null;\n\t_uint32Array = null;\n\n\tif ( bufferStack.length ) {\n\n\t\tsetBuffer( bufferStack.pop() );\n\n\t}\n\n}\n", "import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport {\n\traycast,\n\traycastFirst,\n\tshapecast,\n\tintersectsGeometry,\n\tsetBuffer,\n\tclearBuffer,\n} from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\n\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\n\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\nconst tempBox = /* @__PURE__ */ new Box3();\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\tif ( options.isBufferGeometry ) {\n\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.serialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\t{\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\tif ( typeof options === 'boolean' ) {\n\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.deserialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\targuments[ 1 ],\n\t\t\t\t{\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tthis._roots = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis._roots = buildPackedTree( geometry, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = this.geometry;\n\t\tconst indexArr = geometry.index.array;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tconst index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\n\t\t\tclearBuffer();\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tconst geometry = this.geometry;\n\t\tlet result = false;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\n\n\t\tconst geometry = this.geometry;\n\t\tif ( callbacks instanceof Function ) {\n\n\t\t\tif ( _intersectsTriangleFunc ) {\n\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\n\t\t\t\t// indices here.\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\n\n\t\t\t\t\tconst i3 = index * 3;\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\n\n\t\t\t\t};\n\n\n\t\t\t}\n\n\t\t\tcallbacks = {\n\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\n\t\t\t\tintersectsBounds: callbacks,\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\n\t\t\t\tintersectsRange: null,\n\n\t\t\t};\n\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\n\n\t\t}\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst indexAttr = this.geometry.index;\n\t\tconst positionAttr = this.geometry.attributes.position;\n\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\t\ttempMatrix.copy( matrixToLocal ).invert();\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\totherBvh.getBoundingBox( aabb2 );\n\t\taabb2.applyMatrix4( matrixToLocal );\n\t\tconst result = this.shapecast( {\n\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\t\taabb.copy( box );\n\t\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\t\treturn result;\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb.needsUpdate = true;\n\n\t\tconst geometry = this.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tthis.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) return null;\n\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\n\t\telse target1.point.copy( tempTargetDest1 );\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tthis.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1.clone();\n\t\telse target.point.copy( temp1 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n", "import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootVisualizer extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( mesh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootVisualizer';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.mesh = mesh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHVisualizer extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh, depth = 10 ) {\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHVisualizer';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.depth = this.depth;\n\t\t\troot.mesh = this.mesh;\n\t\t\troot.displayParents = this.displayParents;\n\t\t\troot.displayEdges = this.displayEdges;\n\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tthis.position.copy( this.mesh.position );\n\t\tthis.rotation.copy( this.mesh.rotation );\n\t\tthis.scale.copy( this.mesh.scale );\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { MeshBVHVisualizer };\n", "import { Box3, Vector3 } from 'three';\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\n\nconst _box1 = /* @__PURE__ */ new Box3();\nconst _box2 = /* @__PURE__ */ new Box3();\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\nfunction getPrimitiveSize( el ) {\n\n\tswitch ( typeof el ) {\n\n\t\tcase 'number':\n\t\t\treturn 8;\n\t\tcase 'string':\n\t\t\treturn el.length * 2;\n\t\tcase 'boolean':\n\t\t\treturn 4;\n\t\tdefault:\n\t\t\treturn 0;\n\n\t}\n\n}\n\nfunction isTypedArray( arr ) {\n\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\treturn regex.test( arr.constructor.name );\n\n}\n\nfunction getRootExtremes( bvh, group ) {\n\n\tconst result = {\n\t\tnodeCount: 0,\n\t\tleafNodeCount: 0,\n\n\t\tdepth: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\ttris: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\tsplits: [ 0, 0, 0 ],\n\t\tsurfaceAreaScore: 0,\n\t};\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\tresult.nodeCount ++;\n\t\tif ( isLeaf ) {\n\n\t\t\tresult.leafNodeCount ++;\n\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t} else {\n\n\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t}\n\n\t}, group );\n\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\tif ( result.tris.min === Infinity ) {\n\n\t\tresult.tris.min = 0;\n\t\tresult.tris.max = 0;\n\n\t}\n\n\tif ( result.depth.min === Infinity ) {\n\n\t\tresult.depth.min = 0;\n\t\tresult.depth.max = 0;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getBVHExtremes( bvh ) {\n\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n}\n\nfunction estimateMemoryInBytes( obj ) {\n\n\tconst traversed = new Set();\n\tconst stack = [ obj ];\n\tlet bytes = 0;\n\n\twhile ( stack.length ) {\n\n\t\tconst curr = stack.pop();\n\t\tif ( traversed.has( curr ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\ttraversed.add( curr );\n\n\t\tfor ( let key in curr ) {\n\n\t\t\tif ( ! curr.hasOwnProperty( key ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\tconst value = curr[ key ];\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\treturn bytes;\n\n}\n\nfunction validateBounds( bvh ) {\n\n\tconst geometry = bvh.geometry;\n\tconst depthStack = [];\n\tconst index = geometry.index;\n\tconst position = geometry.getAttribute( 'position' );\n\tlet passes = true;\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tdepth,\n\t\t\tisLeaf,\n\t\t\tboundingData,\n\t\t\toffset,\n\t\t\tcount,\n\t\t};\n\t\tdepthStack[ depth ] = info;\n\n\t\tarrayToBox( 0, boundingData, _box1 );\n\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\tif ( isLeaf ) {\n\n\t\t\t// check triangles\n\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\tconst i0 = index.getX( i );\n\t\t\t\tconst i1 = index.getX( i + 1 );\n\t\t\t\tconst i2 = index.getX( i + 2 );\n\n\t\t\t\tlet isContained;\n\n\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parent ) {\n\n\t\t\t// check if my bounds fit in my parents\n\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\tpasses = passes && isContained;\n\n\t\t}\n\n\t} );\n\n\treturn passes;\n\n}\n\n// Returns a simple, human readable object that represents the BVH.\nfunction getJSONStructure( bvh ) {\n\n\tconst depthStack = [];\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\n\t\t};\n\n\t\tif ( isLeaf ) {\n\n\t\t\tinfo.count = count;\n\t\t\tinfo.offset = offset;\n\n\t\t} else {\n\n\t\t\tinfo.left = null;\n\t\t\tinfo.right = null;\n\n\t\t}\n\n\t\tdepthStack[ depth ] = info;\n\n\t\t// traversal hits the left then right node\n\t\tconst parent = depthStack[ depth - 1 ];\n\t\tif ( parent ) {\n\n\t\t\tif ( parent.left === null ) {\n\n\t\t\t\tparent.left = info;\n\n\t\t\t} else {\n\n\t\t\t\tparent.right = info;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn depthStack[ 0 ];\n\n}\n\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\n", "import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n", "import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst attributes = {};\n\n\tlet offset = 0;\n\n\ttargetGeometry.clearGroups();\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\tattributes[ name ] = [];\n\n\t\t\t}\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\tif ( isIndexed ) {\n\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\tlet indexCount = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// merge attributes\n\tfor ( const name in attributes ) {\n\n\t\tconst attrList = attributes[ name ];\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\tlet count = 0;\n\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t}\n\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\tconst attr = attrList[ i ];\n\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n\treturn targetGeometry;\n\n}\n\nfunction checkTypedArrayEquality( a, b ) {\n\n\tif ( a === null || b === null ) {\n\n\t\treturn a === b;\n\n\t}\n\n\tif ( a.length !== b.length ) {\n\n\t\treturn false;\n\n\t}\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n\n\tconstructor( mesh ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.boneMatrices = null;\n\t\tthis.primitiveCount = - 1;\n\t\tthis.mesh = mesh;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\tthis.primitiveCount = primitiveCount;\n\n\t\tif ( skeleton ) {\n\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t}\n\n\t\t\tskeleton.update();\n\n\t\t\t// copy data if possible otherwise clone it\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = null;\n\n\t\t}\n\n\t}\n\n\tdidChange() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( meshes ) {\n\n\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\tmeshes = [ meshes ];\n\n\t\t}\n\n\t\tconst finalMeshes = [];\n\t\tmeshes.forEach( object => {\n\n\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tthis.meshes = finalMeshes;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\n\t\tthis._diffMap = new WeakMap();\n\n\t}\n\n\tgetMaterials() {\n\n\t\tconst materials = [];\n\t\tthis.meshes.forEach( mesh => {\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn materials;\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tlet skipAttributes = [];\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdiff.update();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tskipAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\tconst attributes = geometry.attributes;\n\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t// initialize the attributes if they don't exist\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\ttargetGeometry.index = geometry.index;\n\n\t\t}\n\n\t\tif ( ! targetAttributes.position ) {\n\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t}\n\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t}\n\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t}\n\n\t\t// ensure the attributes are consistent\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\tif ( includeNormal ) {\n\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t}\n\n\t\tif ( includeTangent ) {\n\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t}\n\n\t\t// generate transformed vertex attribute data\n\t\tconst position = attributes.position;\n\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\tconst normalMatrix = new Matrix3();\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t}\n\n\t\t\t// apply morph target transform\n\t\t\tif ( morphInfluences ) {\n\n\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// apply bone transform\n\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the vectors of the attributes\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// copy other attributes over\n\t\tfor ( const i in this.attributes ) {\n\n\t\t\tconst key = this.attributes[ i ];\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t}\n\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n}\n", null, null, "export const SIZEOF_SHORT = 2;\nexport const SIZEOF_INT = 4;\nexport const FILE_IDENTIFIER_LENGTH = 4;\nexport const SIZE_PREFIX_LENGTH = 4;\n", "export const int32 = new Int32Array(2);\nexport const float32 = new Float32Array(int32.buffer);\nexport const float64 = new Float64Array(int32.buffer);\nexport const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n", "export var Encoding;\n(function (Encoding) {\n    Encoding[Encoding[\"UTF8_BYTES\"] = 1] = \"UTF8_BYTES\";\n    Encoding[Encoding[\"UTF16_STRING\"] = 2] = \"UTF16_STRING\";\n})(Encoding || (Encoding = {}));\n", "import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from \"./constants.js\";\nimport { int32, isLittleEndian, float32, float64 } from \"./utils.js\";\nimport { Encoding } from \"./encoding.js\";\nexport class ByteBuffer {\n    /**\n     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n     */\n    constructor(bytes_) {\n        this.bytes_ = bytes_;\n        this.position_ = 0;\n        this.text_decoder_ = new TextDecoder();\n    }\n    /**\n     * Create and allocate a new ByteBuffer with a given size.\n     */\n    static allocate(byte_size) {\n        return new ByteBuffer(new Uint8Array(byte_size));\n    }\n    clear() {\n        this.position_ = 0;\n    }\n    /**\n     * Get the underlying `Uint8Array`.\n     */\n    bytes() {\n        return this.bytes_;\n    }\n    /**\n     * Get the buffer's position.\n     */\n    position() {\n        return this.position_;\n    }\n    /**\n     * Set the buffer's position.\n     */\n    setPosition(position) {\n        this.position_ = position;\n    }\n    /**\n     * Get the buffer's capacity.\n     */\n    capacity() {\n        return this.bytes_.length;\n    }\n    readInt8(offset) {\n        return this.readUint8(offset) << 24 >> 24;\n    }\n    readUint8(offset) {\n        return this.bytes_[offset];\n    }\n    readInt16(offset) {\n        return this.readUint16(offset) << 16 >> 16;\n    }\n    readUint16(offset) {\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n    }\n    readInt32(offset) {\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n    }\n    readUint32(offset) {\n        return this.readInt32(offset) >>> 0;\n    }\n    readInt64(offset) {\n        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readUint64(offset) {\n        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readFloat32(offset) {\n        int32[0] = this.readInt32(offset);\n        return float32[0];\n    }\n    readFloat64(offset) {\n        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\n        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n        return float64[0];\n    }\n    writeInt8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeUint8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeInt16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeUint16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeInt32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeUint32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeInt64(offset, value) {\n        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));\n        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));\n    }\n    writeUint64(offset, value) {\n        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));\n        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));\n    }\n    writeFloat32(offset, value) {\n        float32[0] = value;\n        this.writeInt32(offset, int32[0]);\n    }\n    writeFloat64(offset, value) {\n        float64[0] = value;\n        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\n        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\n    }\n    /**\n     * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n     * schema does not include a file_identifier (likely points at padding or the\n     * start of a the root vtable).\n     */\n    getBufferIdentifier() {\n        if (this.bytes_.length < this.position_ + SIZEOF_INT +\n            FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n        }\n        let result = \"\";\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n        }\n        return result;\n    }\n    /**\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\n     * field is not present.\n     */\n    __offset(bb_pos, vtable_offset) {\n        const vtable = bb_pos - this.readInt32(bb_pos);\n        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n    }\n    /**\n     * Initialize any Table-derived type to point to the union at the given offset.\n     */\n    __union(t, offset) {\n        t.bb_pos = offset + this.readInt32(offset);\n        t.bb = this;\n        return t;\n    }\n    /**\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n     * This allocates a new string and converts to wide chars upon each access.\n     *\n     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the\n     * \"optionalEncoding\" argument. This is useful for avoiding conversion when\n     * the data will just be packaged back up in another FlatBuffer later on.\n     *\n     * @param offset\n     * @param opt_encoding Defaults to UTF16_STRING\n     */\n    __string(offset, opt_encoding) {\n        offset += this.readInt32(offset);\n        const length = this.readInt32(offset);\n        offset += SIZEOF_INT;\n        const utf8bytes = this.bytes_.subarray(offset, offset + length);\n        if (opt_encoding === Encoding.UTF8_BYTES)\n            return utf8bytes;\n        else\n            return this.text_decoder_.decode(utf8bytes);\n    }\n    /**\n     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n     * if a string then return a new one\n     *\n     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n     * makes the behaviour of __union_with_string different compared to __union\n     */\n    __union_with_string(o, offset) {\n        if (typeof o === 'string') {\n            return this.__string(offset);\n        }\n        return this.__union(o, offset);\n    }\n    /**\n     * Retrieve the relative offset stored at \"offset\"\n     */\n    __indirect(offset) {\n        return offset + this.readInt32(offset);\n    }\n    /**\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector(offset) {\n        return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\n    }\n    /**\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector_len(offset) {\n        return this.readInt32(offset + this.readInt32(offset));\n    }\n    __has_identifier(ident) {\n        if (ident.length != FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: file identifier must be length ' +\n                FILE_IDENTIFIER_LENGTH);\n        }\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * A helper function for generating list for obj api\n     */\n    createScalarList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val);\n            }\n        }\n        return ret;\n    }\n    /**\n     * A helper function for generating list for obj api\n     * @param listAccessor function that accepts an index and return data at that index\n     * @param listLength listLength\n     * @param res result list\n     */\n    createObjList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val.unpack());\n            }\n        }\n        return ret;\n    }\n}\n", "import { ByteBuffer } from \"./byte-buffer.js\";\nimport { SIZEOF_SHORT, SIZE_PREFIX_LENGTH, SIZEOF_INT, FILE_IDENTIFIER_LENGTH } from \"./constants.js\";\nexport class Builder {\n    /**\n     * Create a FlatBufferBuilder.\n     */\n    constructor(opt_initial_size) {\n        /** Minimum alignment encountered so far. */\n        this.minalign = 1;\n        /** The vtable for the current table. */\n        this.vtable = null;\n        /** The amount of fields we're actually using. */\n        this.vtable_in_use = 0;\n        /** Whether we are currently serializing a table. */\n        this.isNested = false;\n        /** Starting offset of the current struct/table. */\n        this.object_start = 0;\n        /** List of offsets of all vtables. */\n        this.vtables = [];\n        /** For the current vector being built. */\n        this.vector_num_elems = 0;\n        /** False omits default values from the serialized data */\n        this.force_defaults = false;\n        this.string_maps = null;\n        this.text_encoder = new TextEncoder();\n        let initial_size;\n        if (!opt_initial_size) {\n            initial_size = 1024;\n        }\n        else {\n            initial_size = opt_initial_size;\n        }\n        /**\n         * @type {ByteBuffer}\n         * @private\n         */\n        this.bb = ByteBuffer.allocate(initial_size);\n        this.space = initial_size;\n    }\n    clear() {\n        this.bb.clear();\n        this.space = this.bb.capacity();\n        this.minalign = 1;\n        this.vtable = null;\n        this.vtable_in_use = 0;\n        this.isNested = false;\n        this.object_start = 0;\n        this.vtables = [];\n        this.vector_num_elems = 0;\n        this.force_defaults = false;\n        this.string_maps = null;\n    }\n    /**\n     * In order to save space, fields that are set to their default value\n     * don't get serialized into the buffer. Forcing defaults provides a\n     * way to manually disable this optimization.\n     *\n     * @param forceDefaults true always serializes default values\n     */\n    forceDefaults(forceDefaults) {\n        this.force_defaults = forceDefaults;\n    }\n    /**\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n     * called finish(). The actual data starts at the ByteBuffer's current position,\n     * not necessarily at 0.\n     */\n    dataBuffer() {\n        return this.bb;\n    }\n    /**\n     * Get the bytes representing the FlatBuffer. Only call this after you've\n     * called finish().\n     */\n    asUint8Array() {\n        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n    }\n    /**\n     * Prepare to write an element of `size` after `additional_bytes` have been\n     * written, e.g. if you write a string, you need to align such the int length\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\n     * you need to do is alignment, `additional_bytes` will be 0.\n     *\n     * @param size This is the of the new element to write\n     * @param additional_bytes The padding size\n     */\n    prep(size, additional_bytes) {\n        // Track the biggest thing we've ever aligned to.\n        if (size > this.minalign) {\n            this.minalign = size;\n        }\n        // Find the amount of alignment needed such that `size` is properly\n        // aligned after `additional_bytes`\n        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n        // Reallocate the buffer if needed.\n        while (this.space < align_size + size + additional_bytes) {\n            const old_buf_size = this.bb.capacity();\n            this.bb = Builder.growByteBuffer(this.bb);\n            this.space += this.bb.capacity() - old_buf_size;\n        }\n        this.pad(align_size);\n    }\n    pad(byte_size) {\n        for (let i = 0; i < byte_size; i++) {\n            this.bb.writeInt8(--this.space, 0);\n        }\n    }\n    writeInt8(value) {\n        this.bb.writeInt8(this.space -= 1, value);\n    }\n    writeInt16(value) {\n        this.bb.writeInt16(this.space -= 2, value);\n    }\n    writeInt32(value) {\n        this.bb.writeInt32(this.space -= 4, value);\n    }\n    writeInt64(value) {\n        this.bb.writeInt64(this.space -= 8, value);\n    }\n    writeFloat32(value) {\n        this.bb.writeFloat32(this.space -= 4, value);\n    }\n    writeFloat64(value) {\n        this.bb.writeFloat64(this.space -= 8, value);\n    }\n    /**\n     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int8` to add the buffer.\n     */\n    addInt8(value) {\n        this.prep(1, 0);\n        this.writeInt8(value);\n    }\n    /**\n     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int16` to add the buffer.\n     */\n    addInt16(value) {\n        this.prep(2, 0);\n        this.writeInt16(value);\n    }\n    /**\n     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int32` to add the buffer.\n     */\n    addInt32(value) {\n        this.prep(4, 0);\n        this.writeInt32(value);\n    }\n    /**\n     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int64` to add the buffer.\n     */\n    addInt64(value) {\n        this.prep(8, 0);\n        this.writeInt64(value);\n    }\n    /**\n     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float32` to add the buffer.\n     */\n    addFloat32(value) {\n        this.prep(4, 0);\n        this.writeFloat32(value);\n    }\n    /**\n     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float64` to add the buffer.\n     */\n    addFloat64(value) {\n        this.prep(8, 0);\n        this.writeFloat64(value);\n    }\n    addFieldInt8(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt8(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt16(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt16(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt64(voffset, value, defaultValue) {\n        if (this.force_defaults || value !== defaultValue) {\n            this.addInt64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat64(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldOffset(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addOffset(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n     */\n    addFieldStruct(voffset, value, defaultValue) {\n        if (value != defaultValue) {\n            this.nested(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structures are always stored inline, they need to be created right\n     * where they're used.  You'll get this assertion failure if you\n     * created it elsewhere.\n     */\n    nested(obj) {\n        if (obj != this.offset()) {\n            throw new TypeError('FlatBuffers: struct must be serialized inline.');\n        }\n    }\n    /**\n     * Should not be creating any other object, string or vector\n     * while an object is being constructed\n     */\n    notNested() {\n        if (this.isNested) {\n            throw new TypeError('FlatBuffers: object serialization must not be nested.');\n        }\n    }\n    /**\n     * Set the current vtable at `voffset` to the current location in the buffer.\n     */\n    slot(voffset) {\n        if (this.vtable !== null)\n            this.vtable[voffset] = this.offset();\n    }\n    /**\n     * @returns Offset relative to the end of the buffer.\n     */\n    offset() {\n        return this.bb.capacity() - this.space;\n    }\n    /**\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\n     * the end of the new buffer (since we build the buffer backwards).\n     *\n     * @param bb The current buffer with the existing data\n     * @returns A new byte buffer with the old data copied\n     * to it. The data is located at the end of the buffer.\n     *\n     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n     * it a uint8Array we need to suppress the type check:\n     * @suppress {checkTypes}\n     */\n    static growByteBuffer(bb) {\n        const old_buf_size = bb.capacity();\n        // Ensure we don't grow beyond what fits in an int.\n        if (old_buf_size & 0xC0000000) {\n            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n        }\n        const new_buf_size = old_buf_size << 1;\n        const nbb = ByteBuffer.allocate(new_buf_size);\n        nbb.setPosition(new_buf_size - old_buf_size);\n        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n        return nbb;\n    }\n    /**\n     * Adds on offset, relative to where it will be written.\n     *\n     * @param offset The offset to add.\n     */\n    addOffset(offset) {\n        this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.\n        this.writeInt32(this.offset() - offset + SIZEOF_INT);\n    }\n    /**\n     * Start encoding a new object in the buffer.  Users will not usually need to\n     * call this directly. The FlatBuffers compiler will generate helper methods\n     * that call this method internally.\n     */\n    startObject(numfields) {\n        this.notNested();\n        if (this.vtable == null) {\n            this.vtable = [];\n        }\n        this.vtable_in_use = numfields;\n        for (let i = 0; i < numfields; i++) {\n            this.vtable[i] = 0; // This will push additional elements as needed\n        }\n        this.isNested = true;\n        this.object_start = this.offset();\n    }\n    /**\n     * Finish off writing the object that is under construction.\n     *\n     * @returns The offset to the object inside `dataBuffer`\n     */\n    endObject() {\n        if (this.vtable == null || !this.isNested) {\n            throw new Error('FlatBuffers: endObject called without startObject');\n        }\n        this.addInt32(0);\n        const vtableloc = this.offset();\n        // Trim trailing zeroes.\n        let i = this.vtable_in_use - 1;\n        // eslint-disable-next-line no-empty\n        for (; i >= 0 && this.vtable[i] == 0; i--) { }\n        const trimmed_size = i + 1;\n        // Write out the current vtable.\n        for (; i >= 0; i--) {\n            // Offset relative to the start of the table.\n            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n        }\n        const standard_fields = 2; // The fields below:\n        this.addInt16(vtableloc - this.object_start);\n        const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n        this.addInt16(len);\n        // Search for an existing vtable that matches the current one.\n        let existing_vtable = 0;\n        const vt1 = this.space;\n        outer_loop: for (i = 0; i < this.vtables.length; i++) {\n            const vt2 = this.bb.capacity() - this.vtables[i];\n            if (len == this.bb.readInt16(vt2)) {\n                for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n                        continue outer_loop;\n                    }\n                }\n                existing_vtable = this.vtables[i];\n                break;\n            }\n        }\n        if (existing_vtable) {\n            // Found a match:\n            // Remove the current vtable.\n            this.space = this.bb.capacity() - vtableloc;\n            // Point table to existing vtable.\n            this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n        }\n        else {\n            // No match:\n            // Add the location of the current vtable to the list of vtables.\n            this.vtables.push(this.offset());\n            // Point table to current vtable.\n            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n        }\n        this.isNested = false;\n        return vtableloc;\n    }\n    /**\n     * Finalize a buffer, poiting to the given `root_table`.\n     */\n    finish(root_table, opt_file_identifier, opt_size_prefix) {\n        const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n        if (opt_file_identifier) {\n            const file_identifier = opt_file_identifier;\n            this.prep(this.minalign, SIZEOF_INT +\n                FILE_IDENTIFIER_LENGTH + size_prefix);\n            if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n                throw new TypeError('FlatBuffers: file identifier must be length ' +\n                    FILE_IDENTIFIER_LENGTH);\n            }\n            for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n                this.writeInt8(file_identifier.charCodeAt(i));\n            }\n        }\n        this.prep(this.minalign, SIZEOF_INT + size_prefix);\n        this.addOffset(root_table);\n        if (size_prefix) {\n            this.addInt32(this.bb.capacity() - this.space);\n        }\n        this.bb.setPosition(this.space);\n    }\n    /**\n     * Finalize a size prefixed buffer, pointing to the given `root_table`.\n     */\n    finishSizePrefixed(root_table, opt_file_identifier) {\n        this.finish(root_table, opt_file_identifier, true);\n    }\n    /**\n     * This checks a required field has been set in a given table that has\n     * just been constructed.\n     */\n    requiredField(table, field) {\n        const table_start = this.bb.capacity() - table;\n        const vtable_start = table_start - this.bb.readInt32(table_start);\n        const ok = field < this.bb.readInt16(vtable_start) &&\n            this.bb.readInt16(vtable_start + field) != 0;\n        // If this fails, the caller will show what field needs to be set.\n        if (!ok) {\n            throw new TypeError('FlatBuffers: field ' + field + ' must be set');\n        }\n    }\n    /**\n     * Start a new array/vector of objects.  Users usually will not call\n     * this directly. The FlatBuffers compiler will create a start/end\n     * method for vector types in generated code.\n     *\n     * @param elem_size The size of each element in the array\n     * @param num_elems The number of elements in the array\n     * @param alignment The alignment of the array\n     */\n    startVector(elem_size, num_elems, alignment) {\n        this.notNested();\n        this.vector_num_elems = num_elems;\n        this.prep(SIZEOF_INT, elem_size * num_elems);\n        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n    }\n    /**\n     * Finish off the creation of an array and all its elements. The array must be\n     * created with `startVector`.\n     *\n     * @returns The offset at which the newly created array\n     * starts.\n     */\n    endVector() {\n        this.writeInt32(this.vector_num_elems);\n        return this.offset();\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If the string passed has\n     * already been seen, we return the offset of the already written string\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createSharedString(s) {\n        if (!s) {\n            return 0;\n        }\n        if (!this.string_maps) {\n            this.string_maps = new Map();\n        }\n        if (this.string_maps.has(s)) {\n            return this.string_maps.get(s);\n        }\n        const offset = this.createString(s);\n        this.string_maps.set(s, offset);\n        return offset;\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createString(s) {\n        if (s === null || s === undefined) {\n            return 0;\n        }\n        let utf8;\n        if (s instanceof Uint8Array) {\n            utf8 = s;\n        }\n        else {\n            utf8 = this.text_encoder.encode(s);\n        }\n        this.addInt8(0);\n        this.startVector(1, utf8.length, 1);\n        this.bb.setPosition(this.space -= utf8.length);\n        for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n            bytes[offset++] = utf8[i];\n        }\n        return this.endVector();\n    }\n    /**\n     * A helper function to pack an object\n     *\n     * @returns offset of obj\n     */\n    createObjectOffset(obj) {\n        if (obj === null) {\n            return 0;\n        }\n        if (typeof obj === 'string') {\n            return this.createString(obj);\n        }\n        else {\n            return obj.pack(this);\n        }\n    }\n    /**\n     * A helper function to pack a list of object\n     *\n     * @returns list of offsets of each non null object\n     */\n    createObjectOffsetList(list) {\n        const ret = [];\n        for (let i = 0; i < list.length; ++i) {\n            const val = list[i];\n            if (val !== null) {\n                ret.push(this.createObjectOffset(val));\n            }\n            else {\n                throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');\n            }\n        }\n        return ret;\n    }\n    createStructOffsetList(list, startFunc) {\n        startFunc(this, list.length);\n        this.createObjectOffsetList(list.slice().reverse());\n        return this.endVector();\n    }\n}\n", null, null, null, null],
  "mappings": "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",
  "names": ["uids", "nodeIndex", "Vector3", "Vector2", "_vector", "Vector3", "_vector2", "Vector2", "BufferAttribute", "index", "BufferAttribute", "leftBounds", "areIntersecting", "closestPointLineToLine", "temp1", "temp2", "closestPointsSegmentToSegment", "sphereIntersectTriangle", "xyzFields", "ray", "ray", "ray", "_box1", "_box2", "shapecast", "nodeIndex32", "nodeIndex16", "uint16Array", "uint32Array", "temp", "obb", "obb2", "intersectsGeometry", "byteOffset", "ray", "box", "contained", "boundingBox", "tempMatrix", "Encoding", "Fragment", "Fragment", "FragmentsGroup", "Fragment", "result", "instances", "id", "FragmentsGroup"]
}
