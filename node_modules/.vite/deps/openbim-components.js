import {
  ExtendedTriangle,
  Fragment,
  FragmentMesh,
  FragmentsGroup,
  GeometryUtils,
  MeshBVH,
  Serializer,
  acceleratedRaycast,
  computeBoundsTree,
  disposeBoundsTree,
  generateUUID,
  mergeGeometries
} from "./chunk-T6I67UKM.js";
import {
  Handle,
  IFCBUILDING,
  IFCBUILDINGSTOREY,
  IFCELEMENTQUANTITY,
  IFCMATERIALLAYERSETUSAGE,
  IFCOWNERHISTORY,
  IFCPROJECT,
  IFCPROPERTYSET,
  IFCRELAGGREGATES,
  IFCRELASSIGNSTOGROUP,
  IFCRELASSOCIATESCLASSIFICATION,
  IFCRELASSOCIATESMATERIAL,
  IFCRELCONTAINEDINSPATIALSTRUCTURE,
  IFCRELDEFINESBYPROPERTIES,
  IFCRELDEFINESBYTYPE,
  IFCSITE,
  IFCSPACE,
  IFCUNITASSIGNMENT,
  IfcAPI2,
  web_ifc_api_exports
} from "./chunk-SKJXX5VK.js";
import {
  AmbientLight,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Camera,
  Clock,
  Color,
  ColorManagement,
  CylinderGeometry,
  DataTexture,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DynamicDrawUsage,
  Euler,
  EventDispatcher,
  Float32BufferAttribute,
  FloatType,
  Group,
  HalfFloatType,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  InterleavedBufferAttribute,
  Line,
  Line3,
  LineBasicMaterial,
  LineDashedMaterial,
  LineSegments,
  LinearFilter,
  MOUSE,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  NearestFilter,
  NoColorSpace,
  NoToneMapping,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Points,
  PointsMaterial,
  Quaternion,
  REVISION,
  RGBAFormat,
  Ray,
  Raycaster,
  RedFormat,
  RepeatWrapping,
  Scene,
  ShaderLib,
  ShaderMaterial,
  ShapeUtils,
  Sphere,
  SphereGeometry,
  Spherical,
  TOUCH,
  TorusGeometry,
  Triangle,
  UniformsLib,
  UniformsUtils,
  UnsignedInt248Type,
  UnsignedIntType,
  Vector2,
  Vector3,
  Vector4,
  WebGLMultipleRenderTargets,
  WebGLRenderTarget,
  WebGLRenderer,
  WireframeGeometry,
  three_module_exports
} from "./chunk-CVOXZEEP.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-UV5CTPV7.js";

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut3;
    module.exports.default = earcut3;
    function earcut3(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start2, end2, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start2, end2, dim) > 0) {
        for (i = start2; i < end2; i += dim)
          last = insertNode(i, data[i], data[i + 1], last);
      } else {
        for (i = end2 - dim; i >= start2; i -= dim)
          last = insertNode(i, data[i], data[i + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start2, end2) {
      if (!start2)
        return start2;
      if (!end2)
        end2 = start2;
      var p2 = start2, again;
      do {
        again = false;
        if (!p2.steiner && (equals(p2, p2.next) || area2(p2.prev, p2, p2.next) === 0)) {
          removeNode(p2);
          p2 = end2 = p2.prev;
          if (p2 === p2.next)
            break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end2);
      return end2;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b2 = ear, c3 = ear.next;
      if (area2(a, b2, c3) >= 0)
        return false;
      var ax = a.x, bx = b2.x, cx = c3.x, ay = a.y, by = b2.y, cy = c3.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p2 = c3.next;
      while (p2 !== a) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b2 = ear, c3 = ear.next;
      if (area2(a, b2, c3) >= 0)
        return false;
      var ax = a.x, bx = b2.x, cx = c3.x, ay = a.y, by = b2.y, cy = c3.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a && p2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a && n2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area2(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a && p2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a && n2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area2(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start2, triangles, dim) {
      var p2 = start2;
      do {
        var a = p2.prev, b2 = p2.next.next;
        if (!equals(a, b2) && intersects(a, p2, p2.next, b2) && locallyInside(a, b2) && locallyInside(b2, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p2.i / dim | 0);
          triangles.push(b2.i / dim | 0);
          removeNode(p2);
          removeNode(p2.next);
          p2 = start2 = b2;
        }
        p2 = p2.next;
      } while (p2 !== start2);
      return filterPoints(p2);
    }
    function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
      var a = start2;
      do {
        var b2 = a.next.next;
        while (b2 !== a.prev) {
          if (a.i !== b2.i && isValidDiagonal(a, b2)) {
            var c3 = splitPolygon(a, b2);
            a = filterPoints(a, a.next);
            c3 = filterPoints(c3, c3.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c3, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b2 = b2.next;
        }
        a = a.next;
      } while (a !== start2);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start2, end2, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start2 = holeIndices[i] * dim;
        end2 = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start2, end2, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b2) {
      return a.x - b2.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x <= hx && x > qx) {
            qx = x;
            m2 = p2.x < p2.next.x ? p2 : p2.next;
            if (x === hx)
              return m2;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m2)
        return null;
      var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
      p2 = m2;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
            m2 = p2;
            tanMin = tan;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m2;
    }
    function sectorContainsSector(m2, p2) {
      return area2(m2.prev, m2, p2.prev) < 0 && area2(p2.next, m2, m2.next) < 0;
    }
    function indexCurve(start2, minX, minY, invSize) {
      var p2 = start2;
      do {
        if (p2.z === 0)
          p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start2);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked(p2);
    }
    function sortLinked(list) {
      var i, p2, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q = p2;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
              e = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p2 = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = (x - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start2) {
      var p2 = start2, leftmost = start2;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
          leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start2);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b2) {
      return a.next.i !== b2.i && a.prev.i !== b2.i && !intersectsPolygon(a, b2) && // dones't intersect other edges
      (locallyInside(a, b2) && locallyInside(b2, a) && middleInside(a, b2) && // locally visible
      (area2(a.prev, a, b2.prev) || area2(a, b2.prev, b2)) || // does not create opposite-facing sectors
      equals(a, b2) && area2(a.prev, a, a.next) > 0 && area2(b2.prev, b2, b2.next) > 0);
    }
    function area2(p2, q, r) {
      return (q.y - p2.y) * (r.x - q.x) - (q.x - p2.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area2(p1, q1, p2));
      var o2 = sign(area2(p1, q1, q2));
      var o3 = sign(area2(p2, q2, p1));
      var o4 = sign(area2(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p2, q, r) {
      return q.x <= Math.max(p2.x, r.x) && q.x >= Math.min(p2.x, r.x) && q.y <= Math.max(p2.y, r.y) && q.y >= Math.min(p2.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b2) {
      var p2 = a;
      do {
        if (p2.i !== a.i && p2.next.i !== a.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a, b2))
          return true;
        p2 = p2.next;
      } while (p2 !== a);
      return false;
    }
    function locallyInside(a, b2) {
      return area2(a.prev, a, a.next) < 0 ? area2(a, b2, a.next) >= 0 && area2(a, a.prev, b2) >= 0 : area2(a, b2, a.prev) < 0 || area2(a, a.next, b2) < 0;
    }
    function middleInside(a, b2) {
      var p2 = a, inside = false, px = (a.x + b2.x) / 2, py = (a.y + b2.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a);
      return inside;
    }
    function splitPolygon(a, b2) {
      var a2 = new Node(a.i, a.x, a.y), b22 = new Node(b2.i, b2.x, b2.y), an = a.next, bp = b2.prev;
      a.next = b2;
      b2.prev = a;
      a2.next = an;
      an.prev = a2;
      b22.next = a2;
      a2.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode(i, x, y, last) {
      var p2 = new Node(i, x, y);
      if (!last) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last.next;
        p2.prev = last;
        last.next.prev = p2;
        last.next = p2;
      }
      return p2;
    }
    function removeNode(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ)
        p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ)
        p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut3.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start2 = holeIndices[i] * dim;
          var end2 = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start2, end2, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b2 = triangles[i + 1] * dim;
        var c3 = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c3]) * (data[b2 + 1] - data[a + 1]) - (data[a] - data[b2]) * (data[c3 + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start2, end2, dim) {
      var sum = 0;
      for (var i = start2, j = end2 - dim; i < end2; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut3.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d2 = 0; d2 < dim; d2++)
            result.vertices.push(data[i][j][d2]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/mapbox-gl/dist/mapbox-gl.js
var require_mapbox_gl = __commonJS({
  "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.mapboxgl = factory());
    })(exports, function() {
      "use strict";
      var shared, worker, mapboxgl;
      function define2(_, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
          var sharedChunk = {};
          shared(sharedChunk);
          mapboxgl = chunk(sharedChunk);
          if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
            mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t) {
        "use strict";
        var e = "undefined" != typeof self ? self : {}, r = "2.15.0";
        let n2;
        const i = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
          if (null == n2) {
            const t2 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            try {
              n2 = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t2;
            } catch (e2) {
              n2 = t2;
            }
          }
          return n2;
        }, get API_TILEJSON_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
        }, get API_SPRITE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
        }, get API_FONTS_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
        }, get API_STYLE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
        }, get API_CDN_URL_REGEX() {
          return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
        }, get EVENTS_URL() {
          if (!i.API_URL)
            return null;
          try {
            const t2 = new URL(i.API_URL);
            return "api.mapbox.cn" === t2.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t2.hostname ? "https://events.mapbox.com/events/v2" : null;
          } catch (t2) {
            return null;
          }
        }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, s3 = { supported: false, testSupport: function(t2) {
          !l2 && o && (u2 ? c3(t2) : a = t2);
        } };
        let a, o, l2 = false, u2 = false;
        function c3(t2) {
          const e2 = t2.createTexture();
          t2.bindTexture(t2.TEXTURE_2D, e2);
          try {
            if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, o), t2.isContextLost())
              return;
            s3.supported = true;
          } catch (t3) {
          }
          t2.deleteTexture(e2), l2 = true;
        }
        e.document && (o = e.document.createElement("img"), o.onload = function() {
          a && c3(a), a = null, u2 = true;
        }, o.onerror = function() {
          l2 = true, a = null;
        }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const h2 = "01";
        function p2(t2) {
          return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
        }
        var d2 = f;
        function f(t2, e2, r2, n3) {
          this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n3 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n3;
        }
        f.prototype = { sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        }, sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        }, sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        }, solveCurveX: function(t2, e2) {
          if (void 0 === e2 && (e2 = 1e-6), t2 < 0)
            return 0;
          if (t2 > 1)
            return 1;
          for (var r2 = t2, n3 = 0; n3 < 8; n3++) {
            var i2 = this.sampleCurveX(r2) - t2;
            if (Math.abs(i2) < e2)
              return r2;
            var s4 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s4) < 1e-6)
              break;
            r2 -= i2 / s4;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t2, n3 = 0; n3 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n3++)
            t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        }, solve: function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        } };
        var y = p2(d2), m2 = g;
        function g(t2, e2) {
          this.x = t2, this.y = e2;
        }
        g.prototype = { clone: function() {
          return new g(this.x, this.y);
        }, add: function(t2) {
          return this.clone()._add(t2);
        }, sub: function(t2) {
          return this.clone()._sub(t2);
        }, multByPoint: function(t2) {
          return this.clone()._multByPoint(t2);
        }, divByPoint: function(t2) {
          return this.clone()._divByPoint(t2);
        }, mult: function(t2) {
          return this.clone()._mult(t2);
        }, div: function(t2) {
          return this.clone()._div(t2);
        }, rotate: function(t2) {
          return this.clone()._rotate(t2);
        }, rotateAround: function(t2, e2) {
          return this.clone()._rotateAround(t2, e2);
        }, matMult: function(t2) {
          return this.clone()._matMult(t2);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t2) {
          return this.x === t2.x && this.y === t2.y;
        }, dist: function(t2) {
          return Math.sqrt(this.distSqr(t2));
        }, distSqr: function(t2) {
          var e2 = t2.x - this.x, r2 = t2.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        }, angleWith: function(t2) {
          return this.angleWithSep(t2.x, t2.y);
        }, angleWithSep: function(t2, e2) {
          return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
        }, _matMult: function(t2) {
          var e2 = t2[2] * this.x + t2[3] * this.y;
          return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
        }, _add: function(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        }, _sub: function(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        }, _mult: function(t2) {
          return this.x *= t2, this.y *= t2, this;
        }, _div: function(t2) {
          return this.x /= t2, this.y /= t2, this;
        }, _multByPoint: function(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }, _divByPoint: function(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        }, _rotate: function(t2) {
          var e2 = Math.cos(t2), r2 = Math.sin(t2), n3 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n3, this;
        }, _rotateAround: function(t2, e2) {
          var r2 = Math.cos(t2), n3 = Math.sin(t2), i2 = e2.y + n3 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n3 * (this.y - e2.y), this.y = i2, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, g.convert = function(t2) {
          return t2 instanceof g ? t2 : Array.isArray(t2) ? new g(t2[0], t2[1]) : t2;
        };
        var x = p2(m2);
        const v3 = Math.PI / 180, b2 = 180 / Math.PI;
        function w(t2) {
          return t2 * v3;
        }
        function _(t2) {
          return t2 * b2;
        }
        const A = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function S(t2) {
          if (t2 <= 0)
            return 0;
          if (t2 >= 1)
            return 1;
          const e2 = t2 * t2, r2 = e2 * t2;
          return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
        }
        function k(t2, e2, r2, n3) {
          const i2 = new y(t2, e2, r2, n3);
          return function(t3) {
            return i2.solve(t3);
          };
        }
        const I = k(0.25, 0.1, 0.25, 1);
        function M(t2, e2, r2) {
          return Math.min(r2, Math.max(e2, t2));
        }
        function T2(t2, e2, r2) {
          return (r2 = M((r2 - t2) / (e2 - t2), 0, 1)) * r2 * (3 - 2 * r2);
        }
        function z(t2, e2, r2) {
          const n3 = r2 - e2, i2 = ((t2 - e2) % n3 + n3) % n3 + e2;
          return i2 === e2 ? r2 : i2;
        }
        function B(t2, e2, r2) {
          if (!t2.length)
            return r2(null, []);
          let n3 = t2.length;
          const i2 = new Array(t2.length);
          let s4 = null;
          t2.forEach((t3, a2) => {
            e2(t3, (t4, e3) => {
              t4 && (s4 = t4), i2[a2] = e3, 0 == --n3 && r2(s4, i2);
            });
          });
        }
        function E(t2) {
          const e2 = [];
          for (const r2 in t2)
            e2.push(t2[r2]);
          return e2;
        }
        function C2(t2, ...e2) {
          for (const r2 of e2)
            for (const e3 in r2)
              t2[e3] = r2[e3];
          return t2;
        }
        let P2 = 1;
        function D() {
          return P2++;
        }
        function V() {
          return function t2(e2) {
            return e2 ? (e2 ^ Math.random() * (16 >> e2 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
          }();
        }
        function L(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
        }
        function F(t2) {
          return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
        }
        function R(t2, e2) {
          t2.forEach((t3) => {
            e2[t3] && (e2[t3] = e2[t3].bind(e2));
          });
        }
        function U(t2, e2) {
          return -1 !== t2.indexOf(e2, t2.length - e2.length);
        }
        function $(t2, e2, r2) {
          const n3 = {};
          for (const i2 in t2)
            n3[i2] = e2.call(r2 || this, t2[i2], i2, t2);
          return n3;
        }
        function j(t2, e2, r2) {
          const n3 = {};
          for (const i2 in t2)
            e2.call(r2 || this, t2[i2], i2, t2) && (n3[i2] = t2[i2]);
          return n3;
        }
        function O(t2) {
          return Array.isArray(t2) ? t2.map(O) : "object" == typeof t2 && t2 ? $(t2, O) : t2;
        }
        const q = {};
        function N(t2) {
          q[t2] || ("undefined" != typeof console && console.warn(t2), q[t2] = true);
        }
        function G(t2, e2, r2) {
          return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
        }
        function Z(t2) {
          let e2 = 0;
          for (let r2, n3, i2 = 0, s4 = t2.length, a2 = s4 - 1; i2 < s4; a2 = i2++)
            r2 = t2[i2], n3 = t2[a2], e2 += (n3.x - r2.x) * (r2.y + n3.y);
          return e2;
        }
        function K() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function X(t2) {
          const e2 = {};
          if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n3, i2) => {
            const s4 = n3 || i2;
            return e2[r2] = !s4 || s4.toLowerCase(), "";
          }), e2["max-age"]) {
            const t3 = parseInt(e2["max-age"], 10);
            isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
          }
          return e2;
        }
        let J = null;
        function H(t2) {
          if (null == J) {
            const e2 = t2.navigator ? t2.navigator.userAgent : null;
            J = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return J;
        }
        function Y(t2) {
          try {
            const r2 = e[t2];
            return r2.setItem("_mapbox_test_", 1), r2.removeItem("_mapbox_test_"), true;
          } catch (t3) {
            return false;
          }
        }
        function W(t2, e2) {
          return [t2[4 * e2], t2[4 * e2 + 1], t2[4 * e2 + 2], t2[4 * e2 + 3]];
        }
        const Q = "mapbox-tiles";
        let tt = 500, et = 50;
        let rt, nt;
        function it() {
          try {
            return e.caches;
          } catch (t2) {
          }
        }
        function st() {
          it() && !rt && (rt = e.caches.open(Q));
        }
        function at(t2) {
          const e2 = t2.indexOf("?");
          if (e2 < 0)
            return t2;
          const r2 = function(t3) {
            const e3 = t3.indexOf("?");
            return e3 > 0 ? t3.slice(e3 + 1).split("&") : [];
          }(t2), n3 = r2.filter((t3) => {
            const e3 = t3.split("=");
            return "language" === e3[0] || "worldview" === e3[0];
          });
          return n3.length ? `${t2.slice(0, e2)}?${n3.join("&")}` : t2.slice(0, e2);
        }
        let ot = 1 / 0;
        const lt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
        "function" == typeof Object.freeze && Object.freeze(lt);
        class ut extends Error {
          constructor(t2, e2, r2) {
            401 === e2 && bt(r2) && (t2 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t2), this.status = e2, this.url = r2;
          }
          toString() {
            return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
          }
        }
        const ct = K() ? () => self.worker && self.worker.referrer : () => ("blob:" === e.location.protocol ? e.parent : e).location.href;
        const ht = function(t2, r2) {
          if (!(/^file:/.test(n3 = t2.url) || /^file:/.test(ct()) && !/^\w+:/.test(n3))) {
            if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal"))
              return function(t3, r3) {
                const n4 = new e.AbortController(), i2 = new e.Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: ct(), referrerPolicy: t3.referrerPolicy, signal: n4.signal });
                let s4 = false, a2 = false;
                const o2 = (l3 = i2.url).indexOf("sku=") > 0 && bt(l3);
                var l3;
                "json" === t3.type && i2.headers.set("Accept", "application/json");
                const u3 = (n5, s5, l4) => {
                  if (a2)
                    return;
                  if (n5 && "SecurityError" !== n5.message && N(n5.toString()), s5 && l4)
                    return c4(s5);
                  const u4 = Date.now();
                  e.fetch(i2).then((e2) => {
                    if (e2.ok) {
                      const t4 = o2 ? e2.clone() : null;
                      return c4(e2, t4, u4);
                    }
                    return r3(new ut(e2.statusText, e2.status, t3.url));
                  }).catch((e2) => {
                    "AbortError" !== e2.name && r3(new Error(`${e2.message} ${t3.url}`));
                  });
                }, c4 = (n5, o3, l4) => {
                  ("arrayBuffer" === t3.type ? n5.arrayBuffer() : "json" === t3.type ? n5.json() : n5.text()).then((t4) => {
                    a2 || (o3 && l4 && function(t5, r4, n6) {
                      if (st(), !rt)
                        return;
                      const i3 = { status: r4.status, statusText: r4.statusText, headers: new e.Headers() };
                      r4.headers.forEach((t6, e2) => i3.headers.set(e2, t6));
                      const s5 = X(r4.headers.get("Cache-Control") || "");
                      if (s5["no-store"])
                        return;
                      s5["max-age"] && i3.headers.set("Expires", new Date(n6 + 1e3 * s5["max-age"]).toUTCString());
                      const a3 = i3.headers.get("Expires");
                      a3 && (new Date(a3).getTime() - n6 < 42e4 || function(t6, e2) {
                        if (void 0 === nt)
                          try {
                            new Response(new ReadableStream()), nt = true;
                          } catch (t7) {
                            nt = false;
                          }
                        nt ? e2(t6.body) : t6.blob().then(e2);
                      }(r4, (r5) => {
                        const n7 = new e.Response(r5, i3);
                        st(), rt && rt.then((e2) => e2.put(at(t5.url), n7)).catch((t6) => N(t6.message));
                      }));
                    }(i2, o3, l4), s4 = true, r3(null, t4, n5.headers.get("Cache-Control"), n5.headers.get("Expires")));
                  }).catch((t4) => {
                    a2 || r3(new Error(t4.message));
                  });
                };
                return o2 ? function(t4, e2) {
                  if (st(), !rt)
                    return e2(null);
                  const r4 = at(t4.url);
                  rt.then((t5) => {
                    t5.match(r4).then((n5) => {
                      const i3 = function(t6) {
                        if (!t6)
                          return false;
                        const e3 = new Date(t6.headers.get("Expires") || 0), r5 = X(t6.headers.get("Cache-Control") || "");
                        return e3 > Date.now() && !r5["no-cache"];
                      }(n5);
                      t5.delete(r4), i3 && t5.put(r4, n5.clone()), e2(null, n5, i3);
                    }).catch(e2);
                  }).catch(e2);
                }(i2, u3) : u3(null, null), { cancel: () => {
                  a2 = true, s4 || n4.abort();
                } };
              }(t2, r2);
            if (K() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t2, r2, void 0, true);
          }
          var n3;
          return function(t3, r3) {
            const n4 = new e.XMLHttpRequest();
            n4.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (n4.responseType = "arraybuffer");
            for (const e2 in t3.headers)
              n4.setRequestHeader(e2, t3.headers[e2]);
            return "json" === t3.type && (n4.responseType = "text", n4.setRequestHeader("Accept", "application/json")), n4.withCredentials = "include" === t3.credentials, n4.onerror = () => {
              r3(new Error(n4.statusText));
            }, n4.onload = () => {
              if ((n4.status >= 200 && n4.status < 300 || 0 === n4.status) && null !== n4.response) {
                let e2 = n4.response;
                if ("json" === t3.type)
                  try {
                    e2 = JSON.parse(n4.response);
                  } catch (t4) {
                    return r3(t4);
                  }
                r3(null, e2, n4.getResponseHeader("Cache-Control"), n4.getResponseHeader("Expires"));
              } else
                r3(new ut(n4.statusText, n4.status, t3.url));
            }, n4.send(t3.body), { cancel: () => n4.abort() };
          }(t2, r2);
        }, pt = function(t2, e2) {
          return ht(C2(t2, { type: "arrayBuffer" }), e2);
        };
        function dt(t2) {
          const r2 = e.document.createElement("a");
          return r2.href = t2, r2.protocol === e.document.location.protocol && r2.host === e.document.location.host;
        }
        const ft = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let yt, mt;
        yt = [], mt = 0;
        const gt = function(t2, r2) {
          if (s3.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), mt >= i.MAX_PARALLEL_IMAGE_REQUESTS) {
            const e2 = { requestParameters: t2, callback: r2, cancelled: false, cancel() {
              this.cancelled = true;
            } };
            return yt.push(e2), e2;
          }
          mt++;
          let n3 = false;
          const a2 = () => {
            if (!n3)
              for (n3 = true, mt--; yt.length && mt < i.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                const t3 = yt.shift(), { requestParameters: e2, callback: r3, cancelled: n4 } = t3;
                n4 || (t3.cancel = gt(e2, r3).cancel);
              }
          }, o2 = pt(t2, (t3, n4, i2, s4) => {
            a2(), t3 ? r2(t3) : n4 && (e.createImageBitmap ? function(t4, r3) {
              const n5 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
              e.createImageBitmap(n5).then((t5) => {
                r3(null, t5);
              }).catch((t5) => {
                r3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(n4, (t4, e2) => r2(t4, e2, i2, s4)) : function(t4, r3) {
              const n5 = new e.Image(), i3 = e.URL;
              n5.onload = () => {
                r3(null, n5), i3.revokeObjectURL(n5.src), n5.onload = null, e.requestAnimationFrame(() => {
                  n5.src = ft;
                });
              }, n5.onerror = () => r3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const s5 = new e.Blob([new Uint8Array(t4)], { type: "image/png" });
              n5.src = t4.byteLength ? i3.createObjectURL(s5) : ft;
            }(n4, (t4, e2) => r2(t4, e2, i2, s4)));
          });
          return { cancel: () => {
            o2.cancel(), a2();
          } };
        }, xt = "NO_ACCESS_TOKEN";
        function vt(t2) {
          return 0 === t2.indexOf("mapbox:");
        }
        function bt(t2) {
          return i.API_URL_REGEX.test(t2);
        }
        function wt(t2) {
          return i.API_CDN_URL_REGEX.test(t2);
        }
        function _t(t2) {
          return i.API_STYLE_REGEX.test(t2) && !At(t2);
        }
        function At(t2) {
          return i.API_SPRITE_REGEX.test(t2);
        }
        const St = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function kt(t2) {
          const e2 = t2.match(St);
          if (!e2)
            throw new Error("Unable to parse URL object");
          return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
        }
        function It(t2) {
          const e2 = t2.params.length ? `?${t2.params.join("&")}` : "";
          return `${t2.protocol}://${t2.authority}${t2.path}${e2}`;
        }
        const Mt = "mapbox.eventData";
        function Tt(t2) {
          if (!t2)
            return null;
          const r2 = t2.split(".");
          if (!r2 || 3 !== r2.length)
            return null;
          try {
            return JSON.parse(decodeURIComponent(e.atob(r2[1]).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join("")));
          } catch (t3) {
            return null;
          }
        }
        class zt {
          constructor(t2) {
            this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          }
          getStorageKey(t2) {
            const r2 = Tt(i.ACCESS_TOKEN);
            let n3 = "";
            return n3 = r2 && r2.u ? e.btoa(encodeURIComponent(r2.u).replace(/%([0-9A-F]{2})/g, (t3, e2) => String.fromCharCode(Number("0x" + e2)))) : i.ACCESS_TOKEN || "", t2 ? `${Mt}.${t2}:${n3}` : `${Mt}:${n3}`;
          }
          fetchEventData() {
            const t2 = Y("localStorage"), r2 = this.getStorageKey(), n3 = this.getStorageKey("uuid");
            if (t2)
              try {
                const t3 = e.localStorage.getItem(r2);
                t3 && (this.eventData = JSON.parse(t3));
                const i2 = e.localStorage.getItem(n3);
                i2 && (this.anonId = i2);
              } catch (t3) {
                N("Unable to read from LocalStorage");
              }
          }
          saveEventData() {
            const t2 = Y("localStorage"), r2 = this.getStorageKey(), n3 = this.getStorageKey("uuid");
            if (t2)
              try {
                e.localStorage.setItem(n3, this.anonId), Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(r2, JSON.stringify(this.eventData));
              } catch (t3) {
                N("Unable to write to LocalStorage");
              }
          }
          processRequests(t2) {
          }
          postEvent(t2, e2, r2, n3) {
            if (!i.EVENTS_URL)
              return;
            const s4 = kt(i.EVENTS_URL);
            s4.params.push(`access_token=${n3 || i.ACCESS_TOKEN || ""}`);
            const a2 = { event: this.type, created: new Date(t2).toISOString() }, o2 = e2 ? C2(a2, e2) : a2, l3 = { url: It(s4), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o2]) };
            this.pendingRequest = function(t3, e3) {
              return ht(C2(t3, { method: "POST" }), e3);
            }(l3, (t3) => {
              this.pendingRequest = null, r2(t3), this.saveEventData(), this.processRequests(n3);
            });
          }
          queueRequest(t2, e2) {
            this.queue.push(t2), this.processRequests(e2);
          }
        }
        const Bt = new class extends zt {
          constructor(t2) {
            super("appUserTurnstile"), this._customAccessToken = t2;
          }
          postTurnstileEvent(t2, e2) {
            i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => vt(t3) || bt(t3)) && this.queueRequest(Date.now(), e2);
          }
          processRequests(t2) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            const e2 = Tt(i.ACCESS_TOKEN), n3 = e2 ? e2.u : i.ACCESS_TOKEN;
            let s4 = n3 !== this.eventData.tokenU;
            F(this.anonId) || (this.anonId = V(), s4 = true);
            const a2 = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const t3 = new Date(this.eventData.lastSuccess), e3 = new Date(a2), r2 = (a2 - this.eventData.lastSuccess) / 864e5;
              s4 = s4 || r2 >= 1 || r2 < -1 || t3.getDate() !== e3.getDate();
            } else
              s4 = true;
            s4 ? this.postEvent(a2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h2, "enabled.telemetry": false, userId: this.anonId }, (t3) => {
              t3 || (this.eventData.lastSuccess = a2, this.eventData.tokenU = n3);
            }, t2) : this.processRequests();
          }
        }(), Et = Bt.postTurnstileEvent.bind(Bt), Ct = new class extends zt {
          constructor() {
            super("map.load"), this.success = {}, this.skuToken = "";
          }
          postMapLoadEvent(t2, e2, r2, n3) {
            this.skuToken = e2, this.errorCb = n3, i.EVENTS_URL && (r2 || i.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(xt)));
          }
          processRequests(t2) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { id: e2, timestamp: n3 } = this.queue.shift();
            e2 && this.success[e2] || (this.anonId || this.fetchEventData(), F(this.anonId) || (this.anonId = V()), this.postEvent(n3, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h2, skuToken: this.skuToken, userId: this.anonId }, (t3) => {
              t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
            }, t2));
          }
        }(), Pt = Ct.postMapLoadEvent.bind(Ct), Dt = new class extends zt {
          constructor() {
            super("gljs.performance");
          }
          postPerformanceEvent(t2, e2) {
            i.EVENTS_URL && (t2 || i.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e2 }, t2);
          }
          processRequests(t2) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { timestamp: n3, performanceData: i2 } = this.queue.shift(), s4 = function(t3) {
              const n4 = e.performance.getEntriesByType("resource"), i3 = e.performance.getEntriesByType("mark"), s5 = function(t4) {
                const e2 = {};
                if (t4) {
                  for (const r2 in t4)
                    if ("other" !== r2)
                      for (const n5 of t4[r2]) {
                        const t5 = `${r2}ResolveRangeMin`, i4 = `${r2}ResolveRangeMax`, s6 = `${r2}RequestCount`, a3 = `${r2}RequestCachedCount`;
                        e2[t5] = Math.min(e2[t5] || 1 / 0, n5.startTime), e2[i4] = Math.max(e2[i4] || -1 / 0, n5.responseEnd);
                        const o3 = (t6) => {
                          void 0 === e2[t6] && (e2[t6] = 0), ++e2[t6];
                        };
                        void 0 !== n5.transferSize && 0 === n5.transferSize && o3(a3), o3(s6);
                      }
                }
                return e2;
              }(function(t4, e2) {
                const r2 = {};
                if (t4)
                  for (const n5 of t4) {
                    const t5 = e2(n5);
                    void 0 === r2[t5] && (r2[t5] = []), r2[t5].push(n5);
                  }
                return r2;
              }(n4, jt)), a2 = e.devicePixelRatio, o2 = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection, l3 = { counters: [], metadata: [], attributes: [] }, u3 = (t4, e2, r2) => {
                null != r2 && t4.push({ name: e2, value: r2.toString() });
              };
              for (const t4 in s5)
                u3(l3.counters, t4, s5[t4]);
              if (t3.interactionRange[0] !== 1 / 0 && t3.interactionRange[1] !== -1 / 0 && (u3(l3.counters, "interactionRangeMin", t3.interactionRange[0]), u3(l3.counters, "interactionRangeMax", t3.interactionRange[1])), i3)
                for (const t4 of Object.keys(Ut)) {
                  const e2 = Ut[t4], r2 = i3.find((t5) => t5.name === e2);
                  r2 && u3(l3.counters, e2, r2.startTime);
                }
              return u3(l3.counters, "visibilityHidden", t3.visibilityHidden), u3(l3.attributes, "style", function(t4) {
                if (t4)
                  for (const e2 of t4) {
                    const t5 = e2.name.split("?")[0];
                    if (_t(t5)) {
                      const e3 = t5.split("/").slice(-2);
                      if (2 === e3.length)
                        return `mapbox://styles/${e3[0]}/${e3[1]}`;
                    }
                  }
              }(n4)), u3(l3.attributes, "terrainEnabled", t3.terrainEnabled ? "true" : "false"), u3(l3.attributes, "fogEnabled", t3.fogEnabled ? "true" : "false"), u3(l3.attributes, "projection", t3.projection), u3(l3.attributes, "zoom", t3.zoom), u3(l3.metadata, "devicePixelRatio", a2), u3(l3.metadata, "connectionEffectiveType", o2 ? o2.effectiveType : void 0), u3(l3.metadata, "navigatorUserAgent", e.navigator.userAgent), u3(l3.metadata, "screenWidth", e.screen.width), u3(l3.metadata, "screenHeight", e.screen.height), u3(l3.metadata, "windowWidth", e.innerWidth), u3(l3.metadata, "windowHeight", e.innerHeight), u3(l3.metadata, "mapWidth", t3.width / a2), u3(l3.metadata, "mapHeight", t3.height / a2), u3(l3.metadata, "webglRenderer", t3.renderer), u3(l3.metadata, "webglVendor", t3.vendor), u3(l3.metadata, "sdkVersion", r), u3(l3.metadata, "sdkIdentifier", "mapbox-gl-js"), l3;
            }(i2);
            for (const t3 of s4.metadata)
              ;
            for (const t3 of s4.counters)
              ;
            for (const t3 of s4.attributes)
              ;
            this.postEvent(n3, s4, () => {
            }, t2);
          }
        }(), Vt = Dt.postPerformanceEvent.bind(Dt), Lt = new class extends zt {
          constructor() {
            super("map.auth"), this.success = {}, this.skuToken = "";
          }
          getSession(t2, e2, r2, n3) {
            if (!i.API_URL || !i.SESSION_PATH)
              return;
            const s4 = kt(i.API_URL + i.SESSION_PATH);
            s4.params.push(`sku=${e2 || ""}`), s4.params.push(`access_token=${n3 || i.ACCESS_TOKEN || ""}`);
            const a2 = { url: It(s4), headers: { "Content-Type": "text/plain" } };
            this.pendingRequest = function(t3, e3) {
              return ht(C2(t3, { method: "GET" }), e3);
            }(a2, (t3) => {
              this.pendingRequest = null, r2(t3), this.saveEventData(), this.processRequests(n3);
            });
          }
          getSessionAPI(t2, e2, r2, n3) {
            this.skuToken = e2, this.errorCb = n3, i.SESSION_PATH && i.API_URL && (r2 || i.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(xt)));
          }
          processRequests(t2) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { id: e2, timestamp: r2 } = this.queue.shift();
            e2 && this.success[e2] || this.getSession(r2, this.skuToken, (t3) => {
              t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
            }, t2);
          }
        }(), Ft = Lt.getSessionAPI.bind(Lt), Rt = /* @__PURE__ */ new Set(), Ut = { create: "create", load: "load", fullLoad: "fullLoad" }, $t = { mark(t2) {
          e.performance.mark(t2);
        }, measure(t2, r2, n3) {
          e.performance.measure(t2, r2, n3);
        } };
        function jt(t2) {
          const e2 = t2.name.split("?")[0];
          return wt(e2) && e2.includes("mapbox-gl.js") ? "javascript" : wt(e2) && e2.includes("mapbox-gl.css") ? "css" : function(t3) {
            return i.API_FONTS_REGEX.test(t3);
          }(e2) ? "fontRange" : At(e2) ? "sprite" : _t(e2) ? "style" : function(t3) {
            return i.API_TILEJSON_REGEX.test(t3);
          }(e2) ? "tilejson" : "other";
        }
        const Ot = e.performance;
        function qt(t2) {
          const e2 = t2 ? t2.url.toString() : void 0;
          return Ot.getEntriesByName(e2);
        }
        let Nt, Gt, Zt, Kt;
        const Xt = { now: () => void 0 !== Zt ? Zt : e.performance.now(), setNow(t2) {
          Zt = t2;
        }, restoreNow() {
          Zt = void 0;
        }, frame(t2) {
          const r2 = e.requestAnimationFrame(t2);
          return { cancel: () => e.cancelAnimationFrame(r2) };
        }, getImageData(t2, r2 = 0) {
          const { width: n3, height: i2 } = t2;
          Kt || (Kt = e.document.createElement("canvas"));
          const s4 = Kt.getContext("2d", { willReadFrequently: true });
          if (!s4)
            throw new Error("failed to create canvas 2d context");
          return (n3 > Kt.width || i2 > Kt.height) && (Kt.width = n3, Kt.height = i2), s4.clearRect(-r2, -r2, n3 + 2 * r2, i2 + 2 * r2), s4.drawImage(t2, 0, 0, n3, i2), s4.getImageData(-r2, -r2, n3 + 2 * r2, i2 + 2 * r2);
        }, resolveURL: (t2) => (Nt || (Nt = e.document.createElement("a")), Nt.href = t2, Nt.href), get devicePixelRatio() {
          return e.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!e.matchMedia && (null == Gt && (Gt = e.matchMedia("(prefers-reduced-motion: reduce)")), Gt.matches);
        } };
        function Jt(t2, e2, r2) {
          r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
        }
        function Ht(t2, e2, r2) {
          if (r2 && r2[t2]) {
            const n3 = r2[t2].indexOf(e2);
            -1 !== n3 && r2[t2].splice(n3, 1);
          }
        }
        class Yt {
          constructor(t2, e2 = {}) {
            C2(this, e2), this.type = t2;
          }
        }
        class Wt extends Yt {
          constructor(t2, e2 = {}) {
            super("error", C2({ error: t2 }, e2));
          }
        }
        class Qt {
          on(t2, e2) {
            return this._listeners = this._listeners || {}, Jt(t2, e2, this._listeners), this;
          }
          off(t2, e2) {
            return Ht(t2, e2, this._listeners), Ht(t2, e2, this._oneTimeListeners), this;
          }
          once(t2, e2) {
            return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Jt(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
          }
          fire(t2, e2) {
            "string" == typeof t2 && (t2 = new Yt(t2, e2 || {}));
            const r2 = t2.type;
            if (this.listens(r2)) {
              t2.target = this;
              const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
              for (const r3 of e3)
                r3.call(this, t2);
              const n3 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
              for (const e4 of n3)
                Ht(r2, e4, this._oneTimeListeners), e4.call(this, t2);
              const i2 = this._eventedParent;
              i2 && (C2(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
            } else
              t2 instanceof Wt && console.error(t2.error);
            return this;
          }
          listens(t2) {
            return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
          }
          setEventedParent(t2, e2) {
            return this._eventedParent = t2, this._eventedParentData = e2, this;
          }
        }
        var te = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"requires":["fill-extrusion-edge-radius"],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function ee(t2, ...e2) {
          for (const r2 of e2)
            for (const e3 in r2)
              t2[e3] = r2[e3];
          return t2;
        }
        function re(t2) {
          return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
        }
        function ne(t2) {
          if (Array.isArray(t2))
            return t2.map(ne);
          if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
            const e2 = {};
            for (const r2 in t2)
              e2[r2] = ne(t2[r2]);
            return e2;
          }
          return re(t2);
        }
        class ie extends Error {
          constructor(t2, e2) {
            super(e2), this.message = e2, this.key = t2;
          }
        }
        var se = ie;
        class ae {
          constructor(t2, e2 = []) {
            this.parent = t2, this.bindings = {};
            for (const [t3, r2] of e2)
              this.bindings[t3] = r2;
          }
          concat(t2) {
            return new ae(this, t2);
          }
          get(t2) {
            if (this.bindings[t2])
              return this.bindings[t2];
            if (this.parent)
              return this.parent.get(t2);
            throw new Error(`${t2} not found in scope.`);
          }
          has(t2) {
            return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
          }
        }
        var oe = ae;
        const le = { kind: "null" }, ue = { kind: "number" }, ce = { kind: "string" }, he = { kind: "boolean" }, pe = { kind: "color" }, de = { kind: "object" }, fe = { kind: "value" }, ye = { kind: "collator" }, me = { kind: "formatted" }, ge = { kind: "resolvedImage" };
        function xe(t2, e2) {
          return { kind: "array", itemType: t2, N: e2 };
        }
        function ve(t2) {
          if ("array" === t2.kind) {
            const e2 = ve(t2.itemType);
            return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
          }
          return t2.kind;
        }
        const be = [le, ue, ce, he, pe, me, de, xe(fe), ge];
        function we(t2, e2) {
          if ("error" === e2.kind)
            return null;
          if ("array" === t2.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !we(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N))
              return null;
          } else {
            if (t2.kind === e2.kind)
              return null;
            if ("value" === t2.kind) {
              for (const t3 of be)
                if (!we(t3, e2))
                  return null;
            }
          }
          return `Expected ${ve(t2)} but found ${ve(e2)} instead.`;
        }
        function _e(t2, e2) {
          return e2.some((e3) => e3.kind === t2.kind);
        }
        function Ae(t2, e2) {
          return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
        }
        var Se, ke = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function Ie(t2) {
          return (t2 = Math.round(t2)) < 0 ? 0 : t2 > 255 ? 255 : t2;
        }
        function Me(t2) {
          return Ie("%" === t2[t2.length - 1] ? parseFloat(t2) / 100 * 255 : parseInt(t2));
        }
        function Te(t2) {
          return (e2 = "%" === t2[t2.length - 1] ? parseFloat(t2) / 100 : parseFloat(t2)) < 0 ? 0 : e2 > 1 ? 1 : e2;
          var e2;
        }
        function ze(t2, e2, r2) {
          return r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1), 6 * r2 < 1 ? t2 + (e2 - t2) * r2 * 6 : 2 * r2 < 1 ? e2 : 3 * r2 < 2 ? t2 + (e2 - t2) * (2 / 3 - r2) * 6 : t2;
        }
        try {
          Se = {}.parseCSSColor = function(t2) {
            var e2, r2 = t2.replace(/ /g, "").toLowerCase();
            if (r2 in ke)
              return ke[r2].slice();
            if ("#" === r2[0])
              return 4 === r2.length ? (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 4095 ? [(3840 & e2) >> 4 | (3840 & e2) >> 8, 240 & e2 | (240 & e2) >> 4, 15 & e2 | (15 & e2) << 4, 1] : null : 7 === r2.length && (e2 = parseInt(r2.substr(1), 16)) >= 0 && e2 <= 16777215 ? [(16711680 & e2) >> 16, (65280 & e2) >> 8, 255 & e2, 1] : null;
            var n3 = r2.indexOf("("), i2 = r2.indexOf(")");
            if (-1 !== n3 && i2 + 1 === r2.length) {
              var s4 = r2.substr(0, n3), a2 = r2.substr(n3 + 1, i2 - (n3 + 1)).split(","), o2 = 1;
              switch (s4) {
                case "rgba":
                  if (4 !== a2.length)
                    return null;
                  o2 = Te(a2.pop());
                case "rgb":
                  return 3 !== a2.length ? null : [Me(a2[0]), Me(a2[1]), Me(a2[2]), o2];
                case "hsla":
                  if (4 !== a2.length)
                    return null;
                  o2 = Te(a2.pop());
                case "hsl":
                  if (3 !== a2.length)
                    return null;
                  var l3 = (parseFloat(a2[0]) % 360 + 360) % 360 / 360, u3 = Te(a2[1]), c4 = Te(a2[2]), h3 = c4 <= 0.5 ? c4 * (u3 + 1) : c4 + u3 - c4 * u3, p3 = 2 * c4 - h3;
                  return [Ie(255 * ze(p3, h3, l3 + 1 / 3)), Ie(255 * ze(p3, h3, l3)), Ie(255 * ze(p3, h3, l3 - 1 / 3)), o2];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t2) {
        }
        class Be {
          constructor(t2, e2, r2, n3 = 1) {
            this.r = t2, this.g = e2, this.b = r2, this.a = n3;
          }
          static parse(t2) {
            if (!t2)
              return;
            if (t2 instanceof Be)
              return t2;
            if ("string" != typeof t2)
              return;
            const e2 = Se(t2);
            return e2 ? new Be(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
          }
          toString() {
            const [t2, e2, r2, n3] = this.toArray();
            return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r2)},${n3})`;
          }
          toArray() {
            const { r: t2, g: e2, b: r2, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [255 * t2 / n3, 255 * e2 / n3, 255 * r2 / n3, n3];
          }
          toArray01() {
            const { r: t2, g: e2, b: r2, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [t2 / n3, e2 / n3, r2 / n3, n3];
          }
          toArray01PremultipliedAlpha() {
            const { r: t2, g: e2, b: r2, a: n3 } = this;
            return [t2, e2, r2, n3];
          }
        }
        Be.black = new Be(0, 0, 0, 1), Be.white = new Be(1, 1, 1, 1), Be.transparent = new Be(0, 0, 0, 0), Be.red = new Be(1, 0, 0, 1), Be.blue = new Be(0, 0, 1, 1);
        var Ee = Be;
        class Ce {
          constructor(t2, e2, r2) {
            this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t2, e2) {
            return this.collator.compare(t2, e2);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Pe {
          constructor(t2, e2, r2, n3, i2) {
            this.text = t2.normalize ? t2.normalize() : t2, this.image = e2, this.scale = r2, this.fontStack = n3, this.textColor = i2;
          }
        }
        class De {
          constructor(t2) {
            this.sections = t2;
          }
          static fromString(t2) {
            return new De([new Pe(t2, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length);
          }
          static factory(t2) {
            return t2 instanceof De ? t2 : De.fromString(t2);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
          }
          serialize() {
            const t2 = ["format"];
            for (const e2 of this.sections) {
              if (e2.image) {
                t2.push(["image", e2.image.name]);
                continue;
              }
              t2.push(e2.text);
              const r2 = {};
              e2.fontStack && (r2["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r2["font-scale"] = e2.scale), e2.textColor && (r2["text-color"] = ["rgba"].concat(e2.textColor.toArray())), t2.push(r2);
            }
            return t2;
          }
        }
        class Ve {
          constructor(t2) {
            this.name = t2.name, this.available = t2.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t2) {
            return t2 ? new Ve({ name: t2, available: false }) : null;
          }
          serialize() {
            return ["image", this.name];
          }
        }
        function Le(t2, e2, r2, n3) {
          return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n3 ? [t2, e2, r2, n3] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Fe(t2) {
          if (null === t2)
            return true;
          if ("string" == typeof t2)
            return true;
          if ("boolean" == typeof t2)
            return true;
          if ("number" == typeof t2)
            return true;
          if (t2 instanceof Ee)
            return true;
          if (t2 instanceof Ce)
            return true;
          if (t2 instanceof De)
            return true;
          if (t2 instanceof Ve)
            return true;
          if (Array.isArray(t2)) {
            for (const e2 of t2)
              if (!Fe(e2))
                return false;
            return true;
          }
          if ("object" == typeof t2) {
            for (const e2 in t2)
              if (!Fe(t2[e2]))
                return false;
            return true;
          }
          return false;
        }
        function Re(t2) {
          if (null === t2)
            return le;
          if ("string" == typeof t2)
            return ce;
          if ("boolean" == typeof t2)
            return he;
          if ("number" == typeof t2)
            return ue;
          if (t2 instanceof Ee)
            return pe;
          if (t2 instanceof Ce)
            return ye;
          if (t2 instanceof De)
            return me;
          if (t2 instanceof Ve)
            return ge;
          if (Array.isArray(t2)) {
            const e2 = t2.length;
            let r2;
            for (const e3 of t2) {
              const t3 = Re(e3);
              if (r2) {
                if (r2 === t3)
                  continue;
                r2 = fe;
                break;
              }
              r2 = t3;
            }
            return xe(r2 || fe, e2);
          }
          return de;
        }
        function Ue(t2) {
          const e2 = typeof t2;
          return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof Ee || t2 instanceof De || t2 instanceof Ve ? t2.toString() : JSON.stringify(t2);
        }
        class $e {
          constructor(t2, e2) {
            this.type = t2, this.value = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (!Fe(t2[1]))
              return e2.error("invalid value");
            const r2 = t2[1];
            let n3 = Re(r2);
            const i2 = e2.expectedType;
            return "array" !== n3.kind || 0 !== n3.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n3 = i2), new $e(n3, r2);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Ee ? ["rgba"].concat(this.value.toArray()) : this.value instanceof De ? this.value.serialize() : this.value;
          }
        }
        var je = $e, Oe = class {
          constructor(t2) {
            this.name = "ExpressionEvaluationError", this.message = t2;
          }
          toJSON() {
            return this.message;
          }
        };
        const qe = { string: ce, number: ue, boolean: he, object: de };
        class Ne {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            let r2, n3 = 1;
            const i2 = t2[0];
            if ("array" === i2) {
              let i3, s5;
              if (t2.length > 2) {
                const r3 = t2[1];
                if ("string" != typeof r3 || !(r3 in qe) || "object" === r3)
                  return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i3 = qe[r3], n3++;
              } else
                i3 = fe;
              if (t2.length > 3) {
                if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                  return e2.error('The length argument to "array" must be a positive integer literal', 2);
                s5 = t2[2], n3++;
              }
              r2 = xe(i3, s5);
            } else
              r2 = qe[i2];
            const s4 = [];
            for (; n3 < t2.length; n3++) {
              const r3 = e2.parse(t2[n3], n3, fe);
              if (!r3)
                return null;
              s4.push(r3);
            }
            return new Ne(r2, s4);
          }
          evaluate(t2) {
            for (let e2 = 0; e2 < this.args.length; e2++) {
              const r2 = this.args[e2].evaluate(t2);
              if (!we(this.type, Re(r2)))
                return r2;
              if (e2 === this.args.length - 1)
                throw new Oe(`Expected value to be of type ${ve(this.type)}, but found ${ve(Re(r2))} instead.`);
            }
            return null;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = this.type, e2 = [t2.kind];
            if ("array" === t2.kind) {
              const r2 = t2.itemType;
              if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
                e2.push(r2.kind);
                const n3 = t2.N;
                ("number" == typeof n3 || this.args.length > 1) && e2.push(n3);
              }
            }
            return e2.concat(this.args.map((t3) => t3.serialize()));
          }
        }
        var Ge = Ne;
        class Ze {
          constructor(t2) {
            this.type = me, this.sections = t2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            const r2 = t2[1];
            if (!Array.isArray(r2) && "object" == typeof r2)
              return e2.error("First argument must be an image or text section.");
            const n3 = [];
            let i2 = false;
            for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
              const s4 = t2[r3];
              if (i2 && "object" == typeof s4 && !Array.isArray(s4)) {
                i2 = false;
                let t3 = null;
                if (s4["font-scale"] && (t3 = e2.parse(s4["font-scale"], 1, ue), !t3))
                  return null;
                let r4 = null;
                if (s4["text-font"] && (r4 = e2.parse(s4["text-font"], 1, xe(ce)), !r4))
                  return null;
                let a2 = null;
                if (s4["text-color"] && (a2 = e2.parse(s4["text-color"], 1, pe), !a2))
                  return null;
                const o2 = n3[n3.length - 1];
                o2.scale = t3, o2.font = r4, o2.textColor = a2;
              } else {
                const s5 = e2.parse(t2[r3], 1, fe);
                if (!s5)
                  return null;
                const a2 = s5.type.kind;
                if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2)
                  return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i2 = true, n3.push({ content: s5, scale: null, font: null, textColor: null });
              }
            }
            return new Ze(n3);
          }
          evaluate(t2) {
            return new De(this.sections.map((e2) => {
              const r2 = e2.content.evaluate(t2);
              return Re(r2) === ge ? new Pe("", r2, null, null, null) : new Pe(Ue(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
            }));
          }
          eachChild(t2) {
            for (const e2 of this.sections)
              t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = ["format"];
            for (const e2 of this.sections) {
              t2.push(e2.content.serialize());
              const r2 = {};
              e2.scale && (r2["font-scale"] = e2.scale.serialize()), e2.font && (r2["text-font"] = e2.font.serialize()), e2.textColor && (r2["text-color"] = e2.textColor.serialize()), t2.push(r2);
            }
            return t2;
          }
        }
        class Ke {
          constructor(t2) {
            this.type = ge, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error("Expected two arguments.");
            const r2 = e2.parse(t2[1], 1, ce);
            return r2 ? new Ke(r2) : e2.error("No image name provided.");
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r2 = Ve.fromString(e2);
            return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["image", this.input.serialize()];
          }
        }
        const Xe = { "to-boolean": he, "to-color": pe, "to-number": ue, "to-string": ce };
        class Je {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            const r2 = t2[0];
            if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
              return e2.error("Expected one argument.");
            const n3 = Xe[r2], i2 = [];
            for (let r3 = 1; r3 < t2.length; r3++) {
              const n4 = e2.parse(t2[r3], r3, fe);
              if (!n4)
                return null;
              i2.push(n4);
            }
            return new Je(n3, i2);
          }
          evaluate(t2) {
            if ("boolean" === this.type.kind)
              return Boolean(this.args[0].evaluate(t2));
            if ("color" === this.type.kind) {
              let e2, r2;
              for (const n3 of this.args) {
                if (e2 = n3.evaluate(t2), r2 = null, e2 instanceof Ee)
                  return e2;
                if ("string" == typeof e2) {
                  const r3 = t2.parseColor(e2);
                  if (r3)
                    return r3;
                } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Le(e2[0], e2[1], e2[2], e2[3]), !r2))
                  return new Ee(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
              }
              throw new Oe(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : String(JSON.stringify(e2))}'`);
            }
            if ("number" === this.type.kind) {
              let e2 = null;
              for (const r2 of this.args) {
                if (e2 = r2.evaluate(t2), null === e2)
                  return 0;
                const n3 = Number(e2);
                if (!isNaN(n3))
                  return n3;
              }
              throw new Oe(`Could not convert ${JSON.stringify(e2)} to number.`);
            }
            return "formatted" === this.type.kind ? De.fromString(Ue(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? Ve.fromString(Ue(this.args[0].evaluate(t2))) : Ue(this.args[0].evaluate(t2));
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            if ("formatted" === this.type.kind)
              return new Ze([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if ("resolvedImage" === this.type.kind)
              return new Ke(this.args[0]).serialize();
            const t2 = [`to-${this.type.kind}`];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        var He = Je;
        const Ye = ["Unknown", "Point", "LineString", "Polygon"];
        var We = class {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
          }
          id() {
            return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? Ye[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
              const t2 = this.featureDistanceData.center, e2 = this.featureDistanceData.scale, { x: r2, y: n3 } = this.featureTileCoord;
              return this.featureDistanceData.bearing[0] * (r2 * e2 - t2[0]) + this.featureDistanceData.bearing[1] * (n3 * e2 - t2[1]);
            }
            return 0;
          }
          parseColor(t2) {
            let e2 = this._parseColorCache[t2];
            return e2 || (e2 = this._parseColorCache[t2] = Ee.parse(t2)), e2;
          }
        };
        class Qe {
          constructor(t2, e2, r2, n3) {
            this.name = t2, this.type = e2, this._evaluate = r2, this.args = n3;
          }
          evaluate(t2) {
            return this._evaluate(t2, this.args);
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return [this.name].concat(this.args.map((t2) => t2.serialize()));
          }
          static parse(t2, e2) {
            const r2 = t2[0], n3 = Qe.definitions[r2];
            if (!n3)
              return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i2 = Array.isArray(n3) ? n3[0] : n3.type, s4 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, a2 = s4.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
            let o2 = null;
            for (const [n4, s5] of a2) {
              o2 = new Ir(e2.registry, e2.path, null, e2.scope);
              const a3 = [];
              let l3 = false;
              for (let e3 = 1; e3 < t2.length; e3++) {
                const r3 = t2[e3], i3 = Array.isArray(n4) ? n4[e3 - 1] : n4.type, s6 = o2.parse(r3, 1 + a3.length, i3);
                if (!s6) {
                  l3 = true;
                  break;
                }
                a3.push(s6);
              }
              if (!l3)
                if (Array.isArray(n4) && n4.length !== a3.length)
                  o2.error(`Expected ${n4.length} arguments, but found ${a3.length} instead.`);
                else {
                  for (let t3 = 0; t3 < a3.length; t3++) {
                    const e3 = Array.isArray(n4) ? n4[t3] : n4.type, r3 = a3[t3];
                    o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                  }
                  if (0 === o2.errors.length)
                    return new Qe(r2, i2, s5, a3);
                }
            }
            if (1 === a2.length)
              e2.errors.push(...o2.errors);
            else {
              const r3 = (a2.length ? a2 : s4).map(([t3]) => {
                return e3 = t3, Array.isArray(e3) ? `(${e3.map(ve).join(", ")})` : `(${ve(e3.type)}...)`;
                var e3;
              }).join(" | "), n4 = [];
              for (let r4 = 1; r4 < t2.length; r4++) {
                const i3 = e2.parse(t2[r4], 1 + n4.length);
                if (!i3)
                  return null;
                n4.push(ve(i3.type));
              }
              e2.error(`Expected arguments of type ${r3}, but found (${n4.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t2, e2) {
            Qe.definitions = e2;
            for (const r2 in e2)
              t2[r2] = Qe;
          }
        }
        var tr = Qe;
        class er {
          constructor(t2, e2, r2) {
            this.type = ye, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error("Expected one argument.");
            const r2 = t2[1];
            if ("object" != typeof r2 || Array.isArray(r2))
              return e2.error("Collator options argument must be an object.");
            const n3 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, he);
            if (!n3)
              return null;
            const i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, he);
            if (!i2)
              return null;
            let s4 = null;
            return r2.locale && (s4 = e2.parse(r2.locale, 1, ce), !s4) ? null : new er(n3, i2, s4);
          }
          evaluate(t2) {
            return new Ce(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
          }
          eachChild(t2) {
            t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = {};
            return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
          }
        }
        const rr = 8192;
        function nr(t2, e2) {
          t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
        }
        function ir(t2, e2) {
          return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
        }
        function sr(t2, e2) {
          const r2 = (180 + t2[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
          return [Math.round(r2 * i2 * rr), Math.round(n3 * i2 * rr)];
        }
        function ar(t2, e2, r2) {
          const n3 = t2[0] - e2[0], i2 = t2[1] - e2[1], s4 = t2[0] - r2[0], a2 = t2[1] - r2[1];
          return n3 * a2 - s4 * i2 == 0 && n3 * s4 <= 0 && i2 * a2 <= 0;
        }
        function or(t2, e2) {
          let r2 = false;
          for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
            const o3 = e2[a2];
            for (let e3 = 0, a3 = o3.length; e3 < a3 - 1; e3++) {
              if (ar(t2, o3[e3], o3[e3 + 1]))
                return false;
              (i2 = o3[e3])[1] > (n3 = t2)[1] != (s4 = o3[e3 + 1])[1] > n3[1] && n3[0] < (s4[0] - i2[0]) * (n3[1] - i2[1]) / (s4[1] - i2[1]) + i2[0] && (r2 = !r2);
            }
          }
          var n3, i2, s4;
          return r2;
        }
        function lr(t2, e2) {
          for (let r2 = 0; r2 < e2.length; r2++)
            if (or(t2, e2[r2]))
              return true;
          return false;
        }
        function ur(t2, e2, r2, n3) {
          const i2 = n3[0] - r2[0], s4 = n3[1] - r2[1], a2 = (t2[0] - r2[0]) * s4 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s4 - i2 * (e2[1] - r2[1]);
          return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
        }
        function cr(t2, e2, r2) {
          for (const u3 of r2)
            for (let r3 = 0; r3 < u3.length - 1; ++r3)
              if (0 != (o2 = [(a2 = u3[r3 + 1])[0] - (s4 = u3[r3])[0], a2[1] - s4[1]])[0] * (l3 = [(i2 = e2)[0] - (n3 = t2)[0], i2[1] - n3[1]])[1] - o2[1] * l3[0] && ur(n3, i2, s4, a2) && ur(s4, a2, n3, i2))
                return true;
          var n3, i2, s4, a2, o2, l3;
          return false;
        }
        function hr(t2, e2) {
          for (let r2 = 0; r2 < t2.length; ++r2)
            if (!or(t2[r2], e2))
              return false;
          for (let r2 = 0; r2 < t2.length - 1; ++r2)
            if (cr(t2[r2], t2[r2 + 1], e2))
              return false;
          return true;
        }
        function pr(t2, e2) {
          for (let r2 = 0; r2 < e2.length; r2++)
            if (hr(t2, e2[r2]))
              return true;
          return false;
        }
        function dr(t2, e2, r2) {
          const n3 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s4 = [];
            for (let n4 = 0; n4 < t2[i2].length; n4++) {
              const a2 = sr(t2[i2][n4], r2);
              nr(e2, a2), s4.push(a2);
            }
            n3.push(s4);
          }
          return n3;
        }
        function fr(t2, e2, r2) {
          const n3 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s4 = dr(t2[i2], e2, r2);
            n3.push(s4);
          }
          return n3;
        }
        function yr(t2, e2, r2, n3) {
          if (t2[0] < r2[0] || t2[0] > r2[2]) {
            const e3 = 0.5 * n3;
            let i2 = t2[0] - r2[0] > e3 ? -n3 : r2[0] - t2[0] > e3 ? n3 : 0;
            0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n3 : r2[2] - t2[0] > e3 ? n3 : 0), t2[0] += i2;
          }
          nr(e2, t2);
        }
        function mr(t2, e2, r2, n3) {
          const i2 = Math.pow(2, n3.z) * rr, s4 = [n3.x * rr, n3.y * rr], a2 = [];
          if (!t2)
            return a2;
          for (const n4 of t2)
            for (const t3 of n4) {
              const n5 = [t3.x + s4[0], t3.y + s4[1]];
              yr(n5, e2, r2, i2), a2.push(n5);
            }
          return a2;
        }
        function gr(t2, e2, r2, n3) {
          const i2 = Math.pow(2, n3.z) * rr, s4 = [n3.x * rr, n3.y * rr], a2 = [];
          if (!t2)
            return a2;
          for (const r3 of t2) {
            const t3 = [];
            for (const n4 of r3) {
              const r4 = [n4.x + s4[0], n4.y + s4[1]];
              nr(e2, r4), t3.push(r4);
            }
            a2.push(t3);
          }
          if (e2[2] - e2[0] <= i2 / 2) {
            (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (const t3 of a2)
              for (const n4 of t3)
                yr(n4, e2, r2, i2);
          }
          var o2;
          return a2;
        }
        class xr {
          constructor(t2, e2) {
            this.type = he, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (Fe(t2[1])) {
              const e3 = t2[1];
              if ("FeatureCollection" === e3.type)
                for (let t3 = 0; t3 < e3.features.length; ++t3) {
                  const r2 = e3.features[t3].geometry.type;
                  if ("Polygon" === r2 || "MultiPolygon" === r2)
                    return new xr(e3, e3.features[t3].geometry);
                }
              else if ("Feature" === e3.type) {
                const t3 = e3.geometry.type;
                if ("Polygon" === t3 || "MultiPolygon" === t3)
                  return new xr(e3, e3.geometry);
              } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type)
                return new xr(e3, e3);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType())
                return function(t3, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if (!i2)
                    return false;
                  if ("Polygon" === e2.type) {
                    const s4 = dr(e2.coordinates, n3, i2), a2 = mr(t3.geometry(), r2, n3, i2);
                    if (!ir(r2, n3))
                      return false;
                    for (const t4 of a2)
                      if (!or(t4, s4))
                        return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const s4 = fr(e2.coordinates, n3, i2), a2 = mr(t3.geometry(), r2, n3, i2);
                    if (!ir(r2, n3))
                      return false;
                    for (const t4 of a2)
                      if (!lr(t4, s4))
                        return false;
                  }
                  return true;
                }(t2, this.geometries);
              if ("LineString" === t2.geometryType())
                return function(t3, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if (!i2)
                    return false;
                  if ("Polygon" === e2.type) {
                    const s4 = dr(e2.coordinates, n3, i2), a2 = gr(t3.geometry(), r2, n3, i2);
                    if (!ir(r2, n3))
                      return false;
                    for (const t4 of a2)
                      if (!hr(t4, s4))
                        return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const s4 = fr(e2.coordinates, n3, i2), a2 = gr(t3.geometry(), r2, n3, i2);
                    if (!ir(r2, n3))
                      return false;
                    for (const t4 of a2)
                      if (!pr(t4, s4))
                        return false;
                  }
                  return true;
                }(t2, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        var vr = xr;
        function br(t2) {
          if (t2 instanceof tr) {
            if ("get" === t2.name && 1 === t2.args.length)
              return false;
            if ("feature-state" === t2.name)
              return false;
            if ("has" === t2.name && 1 === t2.args.length)
              return false;
            if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
              return false;
            if (/^filter-/.test(t2.name))
              return false;
          }
          if (t2 instanceof vr)
            return false;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !br(t3) && (e2 = false);
          }), e2;
        }
        function wr(t2) {
          if (t2 instanceof tr && "feature-state" === t2.name)
            return false;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !wr(t3) && (e2 = false);
          }), e2;
        }
        function _r(t2, e2) {
          if (t2 instanceof tr && e2.indexOf(t2.name) >= 0)
            return false;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 && !_r(t3, e2) && (r2 = false);
          }), r2;
        }
        class Ar {
          constructor(t2, e2) {
            this.type = e2.type, this.name = t2, this.boundExpression = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length || "string" != typeof t2[1])
              return e2.error("'var' expression requires exactly one string literal argument.");
            const r2 = t2[1];
            return e2.scope.has(r2) ? new Ar(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t2) {
            return this.boundExpression.evaluate(t2);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        var Sr = Ar;
        class kr {
          constructor(t2, e2 = [], r2, n3 = new oe(), i2 = []) {
            this.registry = t2, this.path = e2, this.key = e2.map((t3) => `[${t3}]`).join(""), this.scope = n3, this.errors = i2, this.expectedType = r2;
          }
          parse(t2, e2, r2, n3, i2 = {}) {
            return e2 ? this.concat(e2, r2, n3)._parse(t2, i2) : this._parse(t2, i2);
          }
          _parse(t2, e2) {
            function r2(t3, e3, r3) {
              return "assert" === r3 ? new Ge(e3, [t3]) : "coerce" === r3 ? new He(e3, [t3]) : t3;
            }
            if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
              if (0 === t2.length)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n3 = t2[0];
              if ("string" != typeof n3)
                return this.error(`Expression name must be a string, but found ${typeof n3} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i2 = this.registry[n3];
              if (i2) {
                let n4 = i2.parse(t2, this);
                if (!n4)
                  return null;
                if (this.expectedType) {
                  const t3 = this.expectedType, i3 = n4.type;
                  if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind)
                    if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== i3.kind && "string" !== i3.kind) {
                      if (this.checkSubtype(t3, i3))
                        return null;
                    } else
                      n4 = r2(n4, t3, e2.typeAnnotation || "coerce");
                  else
                    n4 = r2(n4, t3, e2.typeAnnotation || "assert");
                }
                if (!(n4 instanceof je) && "resolvedImage" !== n4.type.kind && Mr(n4)) {
                  const t3 = new We();
                  try {
                    n4 = new je(n4.type, n4.evaluate(t3));
                  } catch (t4) {
                    return this.error(t4.message), null;
                  }
                }
                return n4;
              }
              return this.error(`Unknown expression "${n3}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
          }
          concat(t2, e2, r2) {
            const n3 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
            return new kr(this.registry, n3, e2 || null, i2, this.errors);
          }
          error(t2, ...e2) {
            const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
            this.errors.push(new se(r2, t2));
          }
          checkSubtype(t2, e2) {
            const r2 = we(t2, e2);
            return r2 && this.error(r2), r2;
          }
        }
        var Ir = kr;
        function Mr(t2) {
          if (t2 instanceof Sr)
            return Mr(t2.boundExpression);
          if (t2 instanceof tr && "error" === t2.name)
            return false;
          if (t2 instanceof er)
            return false;
          if (t2 instanceof vr)
            return false;
          const e2 = t2 instanceof He || t2 instanceof Ge;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 = e2 ? r2 && Mr(t3) : r2 && t3 instanceof je;
          }), !!r2 && br(t2) && _r(t2, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
        }
        function Tr(t2, e2) {
          const r2 = t2.length - 1;
          let n3, i2, s4 = 0, a2 = r2, o2 = 0;
          for (; s4 <= a2; )
            if (o2 = Math.floor((s4 + a2) / 2), n3 = t2[o2], i2 = t2[o2 + 1], n3 <= e2) {
              if (o2 === r2 || e2 < i2)
                return o2;
              s4 = o2 + 1;
            } else {
              if (!(n3 > e2))
                throw new Oe("Input is not a number.");
              a2 = o2 - 1;
            }
          return 0;
        }
        class zr {
          constructor(t2, e2, r2) {
            this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of r2)
              this.labels.push(t3), this.outputs.push(e3);
          }
          static parse(t2, e2) {
            if (t2.length - 1 < 4)
              return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            const r2 = e2.parse(t2[1], 1, ue);
            if (!r2)
              return null;
            const n3 = [];
            let i2 = null;
            e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
            for (let r3 = 1; r3 < t2.length; r3 += 2) {
              const s4 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l3 = r3 + 1;
              if ("number" != typeof s4)
                return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n3.length && n3[n3.length - 1][0] >= s4)
                return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              const u3 = e2.parse(a2, l3, i2);
              if (!u3)
                return null;
              i2 = i2 || u3.type, n3.push([s4, u3]);
            }
            return new zr(i2, r2, n3);
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length)
              return r2[0].evaluate(t2);
            const n3 = this.input.evaluate(t2);
            if (n3 <= e2[0])
              return r2[0].evaluate(t2);
            const i2 = e2.length;
            return n3 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[Tr(e2, n3)].evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs)
              t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = ["step", this.input.serialize()];
            for (let e2 = 0; e2 < this.labels.length; e2++)
              e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
            return t2;
          }
        }
        var Br = zr;
        function Er(t2, e2, r2) {
          return t2 * (1 - r2) + e2 * r2;
        }
        var Cr = Object.freeze({ __proto__: null, array: function(t2, e2, r2) {
          return t2.map((t3, n3) => Er(t3, e2[n3], r2));
        }, color: function(t2, e2, r2) {
          return new Ee(Er(t2.r, e2.r, r2), Er(t2.g, e2.g, r2), Er(t2.b, e2.b, r2), Er(t2.a, e2.a, r2));
        }, number: Er });
        const Pr = 0.95047, Dr = 1.08883, Vr = 4 / 29, Lr = 6 / 29, Fr = 3 * Lr * Lr, Rr = Lr * Lr * Lr, Ur = Math.PI / 180, $r = 180 / Math.PI;
        function jr(t2) {
          return t2 > Rr ? Math.pow(t2, 1 / 3) : t2 / Fr + Vr;
        }
        function Or(t2) {
          return t2 > Lr ? t2 * t2 * t2 : Fr * (t2 - Vr);
        }
        function qr(t2) {
          return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
        }
        function Nr(t2) {
          return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function Gr(t2) {
          const e2 = Nr(t2.r), r2 = Nr(t2.g), n3 = Nr(t2.b), i2 = jr((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n3) / Pr), s4 = jr((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n3) / 1);
          return { l: 116 * s4 - 16, a: 500 * (i2 - s4), b: 200 * (s4 - jr((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n3) / Dr)), alpha: t2.a };
        }
        function Zr(t2) {
          let e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n3 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
          return e2 = 1 * Or(e2), r2 = Pr * Or(r2), n3 = Dr * Or(n3), new Ee(qr(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n3), qr(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n3), qr(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n3), t2.alpha);
        }
        function Kr(t2, e2, r2) {
          const n3 = e2 - t2;
          return t2 + r2 * (n3 > 180 || n3 < -180 ? n3 - 360 * Math.round(n3 / 360) : n3);
        }
        const Xr = { forward: Gr, reverse: Zr, interpolate: function(t2, e2, r2) {
          return { l: Er(t2.l, e2.l, r2), a: Er(t2.a, e2.a, r2), b: Er(t2.b, e2.b, r2), alpha: Er(t2.alpha, e2.alpha, r2) };
        } }, Jr = { forward: function(t2) {
          const { l: e2, a: r2, b: n3 } = Gr(t2), i2 = Math.atan2(n3, r2) * $r;
          return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n3 * n3), l: e2, alpha: t2.a };
        }, reverse: function(t2) {
          const e2 = t2.h * Ur, r2 = t2.c;
          return Zr({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
        }, interpolate: function(t2, e2, r2) {
          return { h: Kr(t2.h, e2.h, r2), c: Er(t2.c, e2.c, r2), l: Er(t2.l, e2.l, r2), alpha: Er(t2.alpha, e2.alpha, r2) };
        } };
        var Hr = Object.freeze({ __proto__: null, hcl: Jr, lab: Xr });
        class Yr {
          constructor(t2, e2, r2, n3, i2) {
            this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n3, this.labels = [], this.outputs = [];
            for (const [t3, e3] of i2)
              this.labels.push(t3), this.outputs.push(e3);
          }
          static interpolationFactor(t2, e2, r2, n3) {
            let i2 = 0;
            if ("exponential" === t2.name)
              i2 = Wr(e2, t2.base, r2, n3);
            else if ("linear" === t2.name)
              i2 = Wr(e2, 1, r2, n3);
            else if ("cubic-bezier" === t2.name) {
              const s4 = t2.controlPoints;
              i2 = new y(s4[0], s4[1], s4[2], s4[3]).solve(Wr(e2, 1, r2, n3));
            }
            return i2;
          }
          static parse(t2, e2) {
            let [r2, n3, i2, ...s4] = t2;
            if (!Array.isArray(n3) || 0 === n3.length)
              return e2.error("Expected an interpolation type expression.", 1);
            if ("linear" === n3[0])
              n3 = { name: "linear" };
            else if ("exponential" === n3[0]) {
              const t3 = n3[1];
              if ("number" != typeof t3)
                return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n3 = { name: "exponential", base: t3 };
            } else {
              if ("cubic-bezier" !== n3[0])
                return e2.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
              {
                const t3 = n3.slice(1);
                if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))
                  return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n3 = { name: "cubic-bezier", controlPoints: t3 };
              }
            }
            if (t2.length - 1 < 4)
              return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            if (i2 = e2.parse(i2, 2, ue), !i2)
              return null;
            const a2 = [];
            let o2 = null;
            "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = pe : e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType);
            for (let t3 = 0; t3 < s4.length; t3 += 2) {
              const r3 = s4[t3], n4 = s4[t3 + 1], i3 = t3 + 3, l3 = t3 + 4;
              if ("number" != typeof r3)
                return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
              if (a2.length && a2[a2.length - 1][0] >= r3)
                return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
              const u3 = e2.parse(n4, l3, o2);
              if (!u3)
                return null;
              o2 = o2 || u3.type, a2.push([r3, u3]);
            }
            return "number" === o2.kind || "color" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new Yr(o2, r2, n3, i2, a2) : e2.error(`Type ${ve(o2)} is not interpolatable.`);
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length)
              return r2[0].evaluate(t2);
            const n3 = this.input.evaluate(t2);
            if (n3 <= e2[0])
              return r2[0].evaluate(t2);
            const i2 = e2.length;
            if (n3 >= e2[i2 - 1])
              return r2[i2 - 1].evaluate(t2);
            const s4 = Tr(e2, n3), a2 = Yr.interpolationFactor(this.interpolation, n3, e2[s4], e2[s4 + 1]), o2 = r2[s4].evaluate(t2), l3 = r2[s4 + 1].evaluate(t2);
            return "interpolate" === this.operator ? Cr[this.type.kind.toLowerCase()](o2, l3, a2) : "interpolate-hcl" === this.operator ? Jr.reverse(Jr.interpolate(Jr.forward(o2), Jr.forward(l3), a2)) : Xr.reverse(Xr.interpolate(Xr.forward(o2), Xr.forward(l3), a2));
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs)
              t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
          serialize() {
            let t2;
            t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            const e2 = [this.operator, t2, this.input.serialize()];
            for (let t3 = 0; t3 < this.labels.length; t3++)
              e2.push(this.labels[t3], this.outputs[t3].serialize());
            return e2;
          }
        }
        function Wr(t2, e2, r2, n3) {
          const i2 = n3 - r2, s4 = t2 - r2;
          return 0 === i2 ? 0 : 1 === e2 ? s4 / i2 : (Math.pow(e2, s4) - 1) / (Math.pow(e2, i2) - 1);
        }
        var Qr = Yr;
        class tn {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expectected at least one argument.");
            let r2 = null;
            const n3 = e2.expectedType;
            n3 && "value" !== n3.kind && (r2 = n3);
            const i2 = [];
            for (const n4 of t2.slice(1)) {
              const t3 = e2.parse(n4, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
              if (!t3)
                return null;
              r2 = r2 || t3.type, i2.push(t3);
            }
            const s4 = n3 && i2.some((t3) => we(n3, t3.type));
            return new tn(s4 ? fe : r2, i2);
          }
          evaluate(t2) {
            let e2, r2 = null, n3 = 0;
            for (const i2 of this.args) {
              if (n3++, r2 = i2.evaluate(t2), r2 && r2 instanceof Ve && !r2.available && (e2 || (e2 = r2), r2 = null, n3 === this.args.length))
                return e2;
              if (null !== r2)
                break;
            }
            return r2;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
          serialize() {
            const t2 = ["coalesce"];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        var en = tn;
        class rn {
          constructor(t2, e2) {
            this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
          }
          evaluate(t2) {
            return this.result.evaluate(t2);
          }
          eachChild(t2) {
            for (const e2 of this.bindings)
              t2(e2[1]);
            t2(this.result);
          }
          static parse(t2, e2) {
            if (t2.length < 4)
              return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
            const r2 = [];
            for (let n4 = 1; n4 < t2.length - 1; n4 += 2) {
              const i2 = t2[n4];
              if ("string" != typeof i2)
                return e2.error(`Expected string, but found ${typeof i2} instead.`, n4);
              if (/[^a-zA-Z0-9_]/.test(i2))
                return e2.error("Variable names must contain only alphanumeric characters or '_'.", n4);
              const s4 = e2.parse(t2[n4 + 1], n4 + 1);
              if (!s4)
                return null;
              r2.push([i2, s4]);
            }
            const n3 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
            return n3 ? new rn(r2, n3) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const t2 = ["let"];
            for (const [e2, r2] of this.bindings)
              t2.push(e2, r2.serialize());
            return t2.push(this.result.serialize()), t2;
          }
        }
        var nn = rn;
        class sn {
          constructor(t2, e2, r2) {
            this.type = t2, this.index = e2, this.input = r2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length)
              return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, ue), n3 = e2.parse(t2[2], 2, xe(e2.expectedType || fe));
            return r2 && n3 ? new sn(n3.type.itemType, r2, n3) : null;
          }
          evaluate(t2) {
            const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
            if (e2 < 0)
              throw new Oe(`Array index out of bounds: ${e2} < 0.`);
            if (e2 >= r2.length)
              throw new Oe(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
            if (e2 !== Math.floor(e2))
              throw new Oe(`Array index must be an integer, but found ${e2} instead.`);
            return r2[e2];
          }
          eachChild(t2) {
            t2(this.index), t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        var an = sn;
        class on {
          constructor(t2, e2) {
            this.type = he, this.needle = t2, this.haystack = e2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length)
              return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, fe), n3 = e2.parse(t2[2], 2, fe);
            return r2 && n3 ? _e(r2.type, [he, ce, ue, le, fe]) ? new on(r2, n3) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r2.type)} instead`) : null;
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (null == r2)
              return false;
            if (!Ae(e2, ["boolean", "string", "number", "null"]))
              throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e2))} instead.`);
            if (!Ae(r2, ["string", "array"]))
              throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r2))} instead.`);
            return r2.indexOf(e2) >= 0;
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        var ln = on;
        class un {
          constructor(t2, e2, r2) {
            this.type = ue, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5)
              return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, fe), n3 = e2.parse(t2[2], 2, fe);
            if (!r2 || !n3)
              return null;
            if (!_e(r2.type, [he, ce, ue, le, fe]))
              return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, ue);
              return i2 ? new un(r2, n3, i2) : null;
            }
            return new un(r2, n3);
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!Ae(e2, ["boolean", "string", "number", "null"]))
              throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e2))} instead.`);
            if (!Ae(r2, ["string", "array"]))
              throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r2))} instead.`);
            if (this.fromIndex) {
              const n3 = this.fromIndex.evaluate(t2);
              return r2.indexOf(e2, n3);
            }
            return r2.indexOf(e2);
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.fromIndex && void 0 !== this.fromIndex) {
              const t2 = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        var cn = un;
        class hn {
          constructor(t2, e2, r2, n3, i2, s4) {
            this.inputType = t2, this.type = e2, this.input = r2, this.cases = n3, this.outputs = i2, this.otherwise = s4;
          }
          static parse(t2, e2) {
            if (t2.length < 5)
              return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 1)
              return e2.error("Expected an even number of arguments.");
            let r2, n3;
            e2.expectedType && "value" !== e2.expectedType.kind && (n3 = e2.expectedType);
            const i2 = {}, s4 = [];
            for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
              let o3 = t2[a3];
              const l3 = t2[a3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              const u3 = e2.concat(a3);
              if (0 === o3.length)
                return u3.error("Expected at least one branch label.");
              for (const t3 of o3) {
                if ("number" != typeof t3 && "string" != typeof t3)
                  return u3.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                  return u3.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t3 && Math.floor(t3) !== t3)
                  return u3.error("Numeric branch labels must be integer values.");
                if (r2) {
                  if (u3.checkSubtype(r2, Re(t3)))
                    return null;
                } else
                  r2 = Re(t3);
                if (void 0 !== i2[String(t3)])
                  return u3.error("Branch labels must be unique.");
                i2[String(t3)] = s4.length;
              }
              const c4 = e2.parse(l3, a3, n3);
              if (!c4)
                return null;
              n3 = n3 || c4.type, s4.push(c4);
            }
            const a2 = e2.parse(t2[1], 1, fe);
            if (!a2)
              return null;
            const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n3);
            return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r2, a2.type) ? null : new hn(r2, n3, a2, i2, s4, o2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            return (Re(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r2 = [], n3 = {};
            for (const t3 of e2) {
              const e3 = n3[this.cases[t3]];
              void 0 === e3 ? (n3[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e3][1].push(t3);
            }
            const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
            for (const [e3, n4] of r2)
              t2.push(1 === n4.length ? i2(n4[0]) : n4.map(i2)), t2.push(this.outputs[e3].serialize());
            return t2.push(this.otherwise.serialize()), t2;
          }
        }
        var pn = hn;
        class dn {
          constructor(t2, e2, r2) {
            this.type = t2, this.branches = e2, this.otherwise = r2;
          }
          static parse(t2, e2) {
            if (t2.length < 4)
              return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 0)
              return e2.error("Expected an odd number of arguments.");
            let r2;
            e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
            const n3 = [];
            for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
              const s4 = e2.parse(t2[i3], i3, he);
              if (!s4)
                return null;
              const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
              if (!a2)
                return null;
              n3.push([s4, a2]), r2 = r2 || a2.type;
            }
            const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
            return i2 ? new dn(r2, n3, i2) : null;
          }
          evaluate(t2) {
            for (const [e2, r2] of this.branches)
              if (e2.evaluate(t2))
                return r2.evaluate(t2);
            return this.otherwise.evaluate(t2);
          }
          eachChild(t2) {
            for (const [e2, r2] of this.branches)
              t2(e2), t2(r2);
            t2(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t2 = ["case"];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        var fn2 = dn;
        class yn {
          constructor(t2, e2, r2, n3) {
            this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n3;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5)
              return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, fe), n3 = e2.parse(t2[2], 2, ue);
            if (!r2 || !n3)
              return null;
            if (!_e(r2.type, [xe(fe), ce, fe]))
              return e2.error(`Expected first argument to be of type array or string, but found ${ve(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, ue);
              return i2 ? new yn(r2.type, r2, n3, i2) : null;
            }
            return new yn(r2.type, r2, n3);
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
            if (!Ae(e2, ["string", "array"]))
              throw new Oe(`Expected first argument to be of type array or string, but found ${ve(Re(e2))} instead.`);
            if (this.endIndex) {
              const n3 = this.endIndex.evaluate(t2);
              return e2.slice(r2, n3);
            }
            return e2.slice(r2);
          }
          eachChild(t2) {
            t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.endIndex && void 0 !== this.endIndex) {
              const t2 = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        var mn = yn;
        function gn(t2, e2) {
          return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function xn(t2, e2, r2, n3) {
          return 0 === n3.compare(e2, r2);
        }
        function vn(t2, e2, r2) {
          const n3 = "==" !== t2 && "!=" !== t2;
          return class i2 {
            constructor(t3, e3, r3) {
              this.type = he, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
            }
            static parse(t3, e3) {
              if (3 !== t3.length && 4 !== t3.length)
                return e3.error("Expected two or three arguments.");
              const r3 = t3[0];
              let s4 = e3.parse(t3[1], 1, fe);
              if (!s4)
                return null;
              if (!gn(r3, s4.type))
                return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${ve(s4.type)}'.`);
              let a2 = e3.parse(t3[2], 2, fe);
              if (!a2)
                return null;
              if (!gn(r3, a2.type))
                return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${ve(a2.type)}'.`);
              if (s4.type.kind !== a2.type.kind && "value" !== s4.type.kind && "value" !== a2.type.kind)
                return e3.error(`Cannot compare types '${ve(s4.type)}' and '${ve(a2.type)}'.`);
              n3 && ("value" === s4.type.kind && "value" !== a2.type.kind ? s4 = new Ge(a2.type, [s4]) : "value" !== s4.type.kind && "value" === a2.type.kind && (a2 = new Ge(s4.type, [a2])));
              let o2 = null;
              if (4 === t3.length) {
                if ("string" !== s4.type.kind && "string" !== a2.type.kind && "value" !== s4.type.kind && "value" !== a2.type.kind)
                  return e3.error("Cannot use collator to compare non-string types.");
                if (o2 = e3.parse(t3[3], 3, ye), !o2)
                  return null;
              }
              return new i2(s4, a2, o2);
            }
            evaluate(i3) {
              const s4 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
              if (n3 && this.hasUntypedArgument) {
                const e3 = Re(s4), r3 = Re(a2);
                if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind)
                  throw new Oe(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
              }
              if (this.collator && !n3 && this.hasUntypedArgument) {
                const t3 = Re(s4), r3 = Re(a2);
                if ("string" !== t3.kind || "string" !== r3.kind)
                  return e2(i3, s4, a2);
              }
              return this.collator ? r2(i3, s4, a2, this.collator.evaluate(i3)) : e2(i3, s4, a2);
            }
            eachChild(t3) {
              t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              const e3 = [t2];
              return this.eachChild((t3) => {
                e3.push(t3.serialize());
              }), e3;
            }
          };
        }
        const bn = vn("==", function(t2, e2, r2) {
          return e2 === r2;
        }, xn), wn = vn("!=", function(t2, e2, r2) {
          return e2 !== r2;
        }, function(t2, e2, r2, n3) {
          return !xn(0, e2, r2, n3);
        }), _n = vn("<", function(t2, e2, r2) {
          return e2 < r2;
        }, function(t2, e2, r2, n3) {
          return n3.compare(e2, r2) < 0;
        }), An = vn(">", function(t2, e2, r2) {
          return e2 > r2;
        }, function(t2, e2, r2, n3) {
          return n3.compare(e2, r2) > 0;
        }), Sn = vn("<=", function(t2, e2, r2) {
          return e2 <= r2;
        }, function(t2, e2, r2, n3) {
          return n3.compare(e2, r2) <= 0;
        }), kn = vn(">=", function(t2, e2, r2) {
          return e2 >= r2;
        }, function(t2, e2, r2, n3) {
          return n3.compare(e2, r2) >= 0;
        });
        class In {
          constructor(t2, e2, r2, n3, i2, s4) {
            this.type = ce, this.number = t2, this.locale = e2, this.currency = r2, this.unit = n3, this.minFractionDigits = i2, this.maxFractionDigits = s4;
          }
          static parse(t2, e2) {
            if (3 !== t2.length)
              return e2.error("Expected two arguments.");
            const r2 = e2.parse(t2[1], 1, ue);
            if (!r2)
              return null;
            const n3 = t2[2];
            if ("object" != typeof n3 || Array.isArray(n3))
              return e2.error("NumberFormat options argument must be an object.");
            let i2 = null;
            if (n3.locale && (i2 = e2.parse(n3.locale, 1, ce), !i2))
              return null;
            let s4 = null;
            if (n3.currency && (s4 = e2.parse(n3.currency, 1, ce), !s4))
              return null;
            let a2 = null;
            if (n3.unit && (a2 = e2.parse(n3.unit, 1, ce), !a2))
              return null;
            let o2 = null;
            if (n3["min-fraction-digits"] && (o2 = e2.parse(n3["min-fraction-digits"], 1, ue), !o2))
              return null;
            let l3 = null;
            return n3["max-fraction-digits"] && (l3 = e2.parse(n3["max-fraction-digits"], 1, ue), !l3) ? null : new In(r2, i2, s4, a2, o2, l3);
          }
          evaluate(t2) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, unit: this.unit ? this.unit.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
          }
          eachChild(t2) {
            t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.unit && t2(this.unit), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = {};
            return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.unit && (t2.unit = this.unit.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
          }
        }
        class Mn {
          constructor(t2) {
            this.type = ue, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1);
            return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${ve(r2.type)} instead.`) : new Mn(r2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            if ("string" == typeof e2)
              return e2.length;
            if (Array.isArray(e2))
              return e2.length;
            throw new Oe(`Expected value to be of type string or array, but found ${ve(Re(e2))} instead.`);
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t2 = ["length"];
            return this.eachChild((e2) => {
              t2.push(e2.serialize());
            }), t2;
          }
        }
        const Tn = { "==": bn, "!=": wn, ">": An, "<": _n, ">=": kn, "<=": Sn, array: Ge, at: an, boolean: Ge, case: fn2, coalesce: en, collator: er, format: Ze, image: Ke, in: ln, "index-of": cn, interpolate: Qr, "interpolate-hcl": Qr, "interpolate-lab": Qr, length: Mn, let: nn, literal: je, match: pn, number: Ge, "number-format": In, object: Ge, slice: mn, step: Br, string: Ge, "to-boolean": He, "to-color": He, "to-number": He, "to-string": He, var: Sr, within: vr };
        function zn(t2, [e2, r2, n3, i2]) {
          e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n3 = n3.evaluate(t2);
          const s4 = i2 ? i2.evaluate(t2) : 1, a2 = Le(e2, r2, n3, s4);
          if (a2)
            throw new Oe(a2);
          return new Ee(e2 / 255 * s4, r2 / 255 * s4, n3 / 255 * s4, s4);
        }
        function Bn(t2, e2) {
          return t2 in e2;
        }
        function En(t2, e2) {
          const r2 = e2[t2];
          return void 0 === r2 ? null : r2;
        }
        function Cn(t2) {
          return { type: t2 };
        }
        tr.register(Tn, { error: [{ kind: "error" }, [ce], (t2, [e2]) => {
          throw new Oe(e2.evaluate(t2));
        }], typeof: [ce, [fe], (t2, [e2]) => ve(Re(e2.evaluate(t2)))], "to-rgba": [xe(ue, 4), [pe], (t2, [e2]) => e2.evaluate(t2).toArray()], rgb: [pe, [ue, ue, ue], zn], rgba: [pe, [ue, ue, ue, ue], zn], has: { type: he, overloads: [[[ce], (t2, [e2]) => Bn(e2.evaluate(t2), t2.properties())], [[ce, de], (t2, [e2, r2]) => Bn(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: fe, overloads: [[[ce], (t2, [e2]) => En(e2.evaluate(t2), t2.properties())], [[ce, de], (t2, [e2, r2]) => En(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [fe, [ce], (t2, [e2]) => En(e2.evaluate(t2), t2.featureState || {})], properties: [de, [], (t2) => t2.properties()], "geometry-type": [ce, [], (t2) => t2.geometryType()], id: [fe, [], (t2) => t2.id()], zoom: [ue, [], (t2) => t2.globals.zoom], pitch: [ue, [], (t2) => t2.globals.pitch || 0], "distance-from-center": [ue, [], (t2) => t2.distanceFromCenter()], "heatmap-density": [ue, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [ue, [], (t2) => t2.globals.lineProgress || 0], "sky-radial-progress": [ue, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [fe, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [ue, Cn(ue), (t2, e2) => {
          let r2 = 0;
          for (const n3 of e2)
            r2 += n3.evaluate(t2);
          return r2;
        }], "*": [ue, Cn(ue), (t2, e2) => {
          let r2 = 1;
          for (const n3 of e2)
            r2 *= n3.evaluate(t2);
          return r2;
        }], "-": { type: ue, overloads: [[[ue, ue], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[ue], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [ue, [ue, ue], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [ue, [ue, ue], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [ue, [], () => Math.LN2], pi: [ue, [], () => Math.PI], e: [ue, [], () => Math.E], "^": [ue, [ue, ue], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [ue, [ue], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [ue, [ue], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [ue, [ue], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [ue, [ue], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [ue, [ue], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [ue, [ue], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [ue, [ue], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [ue, [ue], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [ue, [ue], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [ue, [ue], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [ue, Cn(ue), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [ue, Cn(ue), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [ue, [ue], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [ue, [ue], (t2, [e2]) => {
          const r2 = e2.evaluate(t2);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [ue, [ue], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [ue, [ue], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [he, [ce, fe], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [he, [fe], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [he, [ce], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [he, [ce, fe], (t2, [e2, r2]) => {
          const n3 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n3 == typeof i2 && n3 < i2;
        }], "filter-id-<": [he, [fe], (t2, [e2]) => {
          const r2 = t2.id(), n3 = e2.value;
          return typeof r2 == typeof n3 && r2 < n3;
        }], "filter->": [he, [ce, fe], (t2, [e2, r2]) => {
          const n3 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n3 == typeof i2 && n3 > i2;
        }], "filter-id->": [he, [fe], (t2, [e2]) => {
          const r2 = t2.id(), n3 = e2.value;
          return typeof r2 == typeof n3 && r2 > n3;
        }], "filter-<=": [he, [ce, fe], (t2, [e2, r2]) => {
          const n3 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n3 == typeof i2 && n3 <= i2;
        }], "filter-id-<=": [he, [fe], (t2, [e2]) => {
          const r2 = t2.id(), n3 = e2.value;
          return typeof r2 == typeof n3 && r2 <= n3;
        }], "filter->=": [he, [ce, fe], (t2, [e2, r2]) => {
          const n3 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n3 == typeof i2 && n3 >= i2;
        }], "filter-id->=": [he, [fe], (t2, [e2]) => {
          const r2 = t2.id(), n3 = e2.value;
          return typeof r2 == typeof n3 && r2 >= n3;
        }], "filter-has": [he, [fe], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [he, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [he, [xe(ce)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [he, [xe(fe)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [he, [ce, xe(fe)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [he, [ce, xe(fe)], (t2, [e2, r2]) => function(t3, e3, r3, n3) {
          for (; r3 <= n3; ) {
            const i2 = r3 + n3 >> 1;
            if (e3[i2] === t3)
              return true;
            e3[i2] > t3 ? n3 = i2 - 1 : r3 = i2 + 1;
          }
          return false;
        }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: he, overloads: [[[he, he], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Cn(he), (t2, e2) => {
          for (const r2 of e2)
            if (!r2.evaluate(t2))
              return false;
          return true;
        }]] }, any: { type: he, overloads: [[[he, he], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Cn(he), (t2, e2) => {
          for (const r2 of e2)
            if (r2.evaluate(t2))
              return true;
          return false;
        }]] }, "!": [he, [he], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [he, [ce], (t2, [e2]) => {
          const r2 = t2.globals && t2.globals.isSupportedScript;
          return !r2 || r2(e2.evaluate(t2));
        }], upcase: [ce, [ce], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [ce, [ce], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [ce, Cn(fe), (t2, e2) => e2.map((e3) => Ue(e3.evaluate(t2))).join("")], "resolved-locale": [ce, [ye], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
        var Pn = Tn;
        function Dn(t2) {
          return { result: "success", value: t2 };
        }
        function Vn(t2) {
          return { result: "error", value: t2 };
        }
        function Ln(t2) {
          return "data-driven" === t2["property-type"];
        }
        function Fn(t2) {
          return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
        }
        function Rn(t2) {
          return !!t2.expression && t2.expression.interpolated;
        }
        function Un(t2) {
          return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
        }
        function $n(t2) {
          return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
        }
        function jn(t2) {
          return t2;
        }
        function On(t2, e2) {
          const r2 = "color" === e2.type, n3 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n3 || !(n3 || void 0 !== t2.property), s4 = t2.type || (Rn(e2) ? "exponential" : "interval");
          if (r2 && ((t2 = ee({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], Ee.parse(t3[1])])), t2.default = Ee.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && "rgb" !== t2.colorSpace && !Hr[t2.colorSpace])
            throw new Error(`Unknown color space: ${t2.colorSpace}`);
          let a2, o2, l3;
          if ("exponential" === s4)
            a2 = Zn;
          else if ("interval" === s4)
            a2 = Gn;
          else if ("categorical" === s4) {
            a2 = Nn, o2 = /* @__PURE__ */ Object.create(null);
            for (const e3 of t2.stops)
              o2[e3[0]] = e3[1];
            l3 = typeof t2.stops[0][0];
          } else {
            if ("identity" !== s4)
              throw new Error(`Unknown function type "${s4}"`);
            a2 = Kn;
          }
          if (n3) {
            const r3 = {}, n4 = [];
            for (let e3 = 0; e3 < t2.stops.length; e3++) {
              const i4 = t2.stops[e3], s6 = i4[0].zoom;
              void 0 === r3[s6] && (r3[s6] = { zoom: s6, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n4.push(s6)), r3[s6].stops.push([i4[0].value, i4[1]]);
            }
            const i3 = [];
            for (const t3 of n4)
              i3.push([r3[t3].zoom, On(r3[t3], e2)]);
            const s5 = { name: "linear" };
            return { kind: "composite", interpolationType: s5, interpolationFactor: Qr.interpolationFactor.bind(void 0, s5), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n5) => Zn({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n5) };
          }
          if (i2) {
            const r3 = "exponential" === s4 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
            return { kind: "camera", interpolationType: r3, interpolationFactor: Qr.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t2, e2, r4, o2, l3) };
          }
          return { kind: "source", evaluate(r3, n4) {
            const i3 = n4 && n4.properties ? n4.properties[t2.property] : void 0;
            return void 0 === i3 ? qn(t2.default, e2.default) : a2(t2, e2, i3, o2, l3);
          } };
        }
        function qn(t2, e2, r2) {
          return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
        }
        function Nn(t2, e2, r2, n3, i2) {
          return qn(typeof r2 === i2 ? n3[r2] : void 0, t2.default, e2.default);
        }
        function Gn(t2, e2, r2) {
          if ("number" !== Un(r2))
            return qn(t2.default, e2.default);
          const n3 = t2.stops.length;
          if (1 === n3)
            return t2.stops[0][1];
          if (r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[n3 - 1][0])
            return t2.stops[n3 - 1][1];
          const i2 = Tr(t2.stops.map((t3) => t3[0]), r2);
          return t2.stops[i2][1];
        }
        function Zn(t2, e2, r2) {
          const n3 = void 0 !== t2.base ? t2.base : 1;
          if ("number" !== Un(r2))
            return qn(t2.default, e2.default);
          const i2 = t2.stops.length;
          if (1 === i2)
            return t2.stops[0][1];
          if (r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[i2 - 1][0])
            return t2.stops[i2 - 1][1];
          const s4 = Tr(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n4) {
            const i3 = n4 - r3, s5 = t3 - r3;
            return 0 === i3 ? 0 : 1 === e3 ? s5 / i3 : (Math.pow(e3, s5) - 1) / (Math.pow(e3, i3) - 1);
          }(r2, n3, t2.stops[s4][0], t2.stops[s4 + 1][0]), o2 = t2.stops[s4][1], l3 = t2.stops[s4 + 1][1];
          let u3 = Cr[e2.type] || jn;
          if (t2.colorSpace && "rgb" !== t2.colorSpace) {
            const e3 = Hr[t2.colorSpace];
            u3 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), a2));
          }
          return "function" == typeof o2.evaluate ? { evaluate(...t3) {
            const e3 = o2.evaluate.apply(void 0, t3), r3 = l3.evaluate.apply(void 0, t3);
            if (void 0 !== e3 && void 0 !== r3)
              return u3(e3, r3, a2);
          } } : u3(o2, l3, a2);
        }
        function Kn(t2, e2, r2) {
          return "color" === e2.type ? r2 = Ee.parse(r2) : "formatted" === e2.type ? r2 = De.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = Ve.fromString(r2.toString()) : Un(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), qn(r2, t2.default, e2.default);
        }
        class Xn {
          constructor(t2, e2) {
            this.expression = t2, this._warningHistory = {}, this._evaluator = new We(), this._defaultValue = e2 ? function(t3) {
              return "color" === t3.type && ($n(t3.default) || Array.isArray(t3.default)) ? new Ee(0, 0, 0, 0) : "color" === t3.type ? Ee.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
            }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n3, i2, s4, a2, o2) {
            return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s4, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
          }
          evaluate(t2, e2, r2, n3, i2, s4, a2, o2) {
            this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s4 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null;
            try {
              const t3 = this.expression.evaluate(this._evaluator);
              if (null == t3 || "number" == typeof t3 && t3 != t3)
                return this._defaultValue;
              if (this._enumValues && !(t3 in this._enumValues))
                throw new Oe(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
              return t3;
            } catch (t3) {
              return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
            }
          }
        }
        function Jn(t2) {
          return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in Pn;
        }
        function Hn(t2, e2) {
          const r2 = new Ir(Pn, [], e2 ? function(t3) {
            const e3 = { color: pe, string: ce, number: ue, enum: ce, boolean: he, formatted: me, resolvedImage: ge };
            return "array" === t3.type ? xe(e3[t3.value] || fe, t3.length) : e3[t3.type];
          }(e2) : void 0), n3 = r2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return n3 ? Dn(new Xn(n3, e2)) : Vn(r2.errors);
        }
        class Yn {
          constructor(t2, e2) {
            this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !wr(e2.expression);
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n3, i2, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n3, i2, s4);
          }
          evaluate(t2, e2, r2, n3, i2, s4) {
            return this._styleExpression.evaluate(t2, e2, r2, n3, i2, s4);
          }
        }
        class Wn {
          constructor(t2, e2, r2, n3) {
            this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !wr(e2.expression), this.interpolationType = n3;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n3, i2, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n3, i2, s4);
          }
          evaluate(t2, e2, r2, n3, i2, s4) {
            return this._styleExpression.evaluate(t2, e2, r2, n3, i2, s4);
          }
          interpolationFactor(t2, e2, r2) {
            return this.interpolationType ? Qr.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
          }
        }
        function Qn(t2, e2) {
          if ("error" === (t2 = Hn(t2, e2)).result)
            return t2;
          const r2 = t2.value.expression, n3 = br(r2);
          if (!n3 && !Ln(e2))
            return Vn([new se("", "data expressions not supported")]);
          const i2 = _r(r2, ["zoom", "pitch", "distance-from-center"]);
          if (!i2 && !Fn(e2))
            return Vn([new se("", "zoom expressions not supported")]);
          const s4 = ei(r2);
          return s4 || i2 ? s4 instanceof se ? Vn([s4]) : s4 instanceof Qr && !Rn(e2) ? Vn([new se("", '"interpolate" expressions cannot be used with this property')]) : Dn(s4 ? new Wn(n3 ? "camera" : "composite", t2.value, s4.labels, s4 instanceof Qr ? s4.interpolation : void 0) : new Yn(n3 ? "constant" : "source", t2.value)) : Vn([new se("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class ti {
          constructor(t2, e2) {
            this._parameters = t2, this._specification = e2, ee(this, On(this._parameters, this._specification));
          }
          static deserialize(t2) {
            return new ti(t2._parameters, t2._specification);
          }
          static serialize(t2) {
            return { _parameters: t2._parameters, _specification: t2._specification };
          }
        }
        function ei(t2) {
          let e2 = null;
          if (t2 instanceof nn)
            e2 = ei(t2.result);
          else if (t2 instanceof en) {
            for (const r2 of t2.args)
              if (e2 = ei(r2), e2)
                break;
          } else
            (t2 instanceof Br || t2 instanceof Qr) && t2.input instanceof tr && "zoom" === t2.input.name && (e2 = t2);
          return e2 instanceof se || t2.eachChild((t3) => {
            const r2 = ei(t3);
            r2 instanceof se ? e2 = r2 : !e2 && r2 ? e2 = new se("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new se("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e2;
        }
        class ri {
          constructor(t2, e2, r2, n3) {
            this.message = (t2 ? `${t2}: ` : "") + r2, n3 && (this.identifier = n3), null != e2 && e2.__line__ && (this.line = e2.__line__);
          }
        }
        function ni(t2) {
          const e2 = t2.key, r2 = t2.value, n3 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s4 = t2.style, a2 = t2.styleSpec;
          let o2 = [];
          const l3 = Un(r2);
          if ("object" !== l3)
            return [new ri(e2, r2, `object expected, ${l3} found`)];
          for (const t3 in r2) {
            const l4 = t3.split(".")[0];
            let u3;
            i2[l4] ? u3 = i2[l4] : n3[l4] ? u3 = Fi : i2["*"] ? u3 = i2["*"] : n3["*"] && (u3 = Fi), u3 ? o2 = o2.concat(u3({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: n3[l4] || n3["*"], style: s4, styleSpec: a2, object: r2, objectKey: t3 }, r2)) : o2.push(new ri(e2, r2[t3], `unknown property "${t3}"`));
          }
          for (const t3 in n3)
            i2[t3] || n3[t3].required && void 0 === n3[t3].default && void 0 === r2[t3] && o2.push(new ri(e2, r2, `missing required property "${t3}"`));
          return o2;
        }
        function ii(t2) {
          const e2 = t2.value, r2 = t2.valueSpec, n3 = t2.style, i2 = t2.styleSpec, s4 = t2.key, a2 = t2.arrayElementValidator || Fi;
          if ("array" !== Un(e2))
            return [new ri(s4, e2, `array expected, ${Un(e2)} found`)];
          if (r2.length && e2.length !== r2.length)
            return [new ri(s4, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
          if (r2["min-length"] && e2.length < r2["min-length"])
            return [new ri(s4, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
          let o2 = { type: r2.value, values: r2.values, minimum: r2.minimum, maximum: r2.maximum, function: void 0 };
          i2.$version < 7 && (o2.function = r2.function), "object" === Un(r2.value) && (o2 = r2.value);
          let l3 = [];
          for (let t3 = 0; t3 < e2.length; t3++)
            l3 = l3.concat(a2({ array: e2, arrayIndex: t3, value: e2[t3], valueSpec: o2, style: n3, styleSpec: i2, key: `${s4}[${t3}]` }));
          return l3;
        }
        function si(t2) {
          const e2 = t2.key, r2 = t2.value, n3 = t2.valueSpec;
          let i2 = Un(r2);
          if ("number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2)
            return [new ri(e2, r2, `number expected, ${i2} found`)];
          if ("minimum" in n3) {
            let i3 = n3.minimum;
            if ("array" === Un(n3.minimum) && (i3 = n3.minimum[t2.arrayIndex]), r2 < i3)
              return [new ri(e2, r2, `${r2} is less than the minimum value ${i3}`)];
          }
          if ("maximum" in n3) {
            let i3 = n3.maximum;
            if ("array" === Un(n3.maximum) && (i3 = n3.maximum[t2.arrayIndex]), r2 > i3)
              return [new ri(e2, r2, `${r2} is greater than the maximum value ${i3}`)];
          }
          return [];
        }
        function ai(t2) {
          const e2 = t2.valueSpec, r2 = re(t2.value.type);
          let n3, i2, s4, a2 = {};
          const o2 = "categorical" !== r2 && void 0 === t2.value.property, l3 = !o2, u3 = "array" === Un(t2.value.stops) && "array" === Un(t2.value.stops[0]) && "object" === Un(t2.value.stops[0][0]), c4 = ni({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
            if ("identity" === r2)
              return [new ri(t3.key, t3.value, 'identity function may not have a "stops" property')];
            let e3 = [];
            const n4 = t3.value;
            return e3 = e3.concat(ii({ key: t3.key, value: n4, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h3 })), "array" === Un(n4) && 0 === n4.length && e3.push(new ri(t3.key, n4, "array must have at least one stop")), e3;
          }, default: function(t3) {
            return Fi({ key: t3.key, value: t3.value, valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec });
          } } });
          return "identity" === r2 && o2 && c4.push(new ri(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c4.push(new ri(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !Rn(t2.valueSpec) && c4.push(new ri(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l3 && !Ln(t2.valueSpec) ? c4.push(new ri(t2.key, t2.value, "property functions not supported")) : o2 && !Fn(t2.valueSpec) && c4.push(new ri(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u3 || void 0 !== t2.value.property || c4.push(new ri(t2.key, t2.value, '"property" property is required')), c4;
          function h3(t3) {
            let r3 = [];
            const n4 = t3.value, o3 = t3.key;
            if ("array" !== Un(n4))
              return [new ri(o3, n4, `array expected, ${Un(n4)} found`)];
            if (2 !== n4.length)
              return [new ri(o3, n4, `array length 2 expected, length ${n4.length} found`)];
            if (u3) {
              if ("object" !== Un(n4[0]))
                return [new ri(o3, n4, `object expected, ${Un(n4[0])} found`)];
              if (void 0 === n4[0].zoom)
                return [new ri(o3, n4, "object stop key must have zoom")];
              if (void 0 === n4[0].value)
                return [new ri(o3, n4, "object stop key must have value")];
              const e3 = re(n4[0].zoom);
              if ("number" != typeof e3)
                return [new ri(o3, n4[0].zoom, "stop zoom values must be numbers")];
              if (s4 && s4 > e3)
                return [new ri(o3, n4[0].zoom, "stop zoom values must appear in ascending order")];
              e3 !== s4 && (s4 = e3, i2 = void 0, a2 = {}), r3 = r3.concat(ni({ key: `${o3}[0]`, value: n4[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: si, value: p3 } }));
            } else
              r3 = r3.concat(p3({ key: `${o3}[0]`, value: n4[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n4));
            return Jn(ne(n4[1])) ? r3.concat([new ri(`${o3}[1]`, n4[1], "expressions are not allowed in function stops.")]) : r3.concat(Fi({ key: `${o3}[1]`, value: n4[1], valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec }));
          }
          function p3(t3, s5) {
            const o3 = Un(t3.value), l4 = re(t3.value), u4 = null !== t3.value ? t3.value : s5;
            if (n3) {
              if (o3 !== n3)
                return [new ri(t3.key, u4, `${o3} stop domain type must match previous stop domain type ${n3}`)];
            } else
              n3 = o3;
            if ("number" !== o3 && "string" !== o3 && "boolean" !== o3 && "number" != typeof l4 && "string" != typeof l4 && "boolean" != typeof l4)
              return [new ri(t3.key, u4, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o3 && "categorical" !== r2) {
              let n4 = `number expected, ${o3} found`;
              return Ln(e2) && void 0 === r2 && (n4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ri(t3.key, u4, n4)];
            }
            return "categorical" !== r2 || "number" !== o3 || "number" == typeof l4 && isFinite(l4) && Math.floor(l4) === l4 ? "categorical" !== r2 && "number" === o3 && "number" == typeof l4 && "number" == typeof i2 && void 0 !== i2 && l4 < i2 ? [new ri(t3.key, u4, "stop domain values must appear in ascending order")] : (i2 = l4, "categorical" === r2 && l4 in a2 ? [new ri(t3.key, u4, "stop domain values must be unique")] : (a2[l4] = true, [])) : [new ri(t3.key, u4, `integer expected, found ${String(l4)}`)];
          }
        }
        function oi(t2) {
          const e2 = ("property" === t2.expressionContext ? Qn : Hn)(ne(t2.value), t2.valueSpec);
          if ("error" === e2.result)
            return e2.value.map((e3) => new ri(`${t2.key}${e3.key}`, t2.value, e3.message));
          const r2 = e2.value.expression || e2.value._styleExpression.expression;
          if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined())
            return [new ri(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t2.expressionContext && "layout" === t2.propertyType && !wr(r2))
            return [new ri(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t2.expressionContext)
            return li(r2, t2);
          if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
            if (!_r(r2, ["zoom", "feature-state"]))
              return [new ri(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t2.expressionContext && !br(r2))
              return [new ri(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function li(t2, e2) {
          const r2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
          if (e2.valueSpec && e2.valueSpec.expression)
            for (const t3 of e2.valueSpec.expression.parameters)
              r2.delete(t3);
          if (0 === r2.size)
            return [];
          const n3 = [];
          return t2 instanceof tr && r2.has(t2.name) ? [new ri(e2.key, e2.value, `["${t2.name}"] expression is not supported in a filter for a ${e2.object.type} layer with id: ${e2.object.id}`)] : (t2.eachChild((t3) => {
            n3.push(...li(t3, e2));
          }), n3);
        }
        function ui(t2) {
          const e2 = t2.key, r2 = t2.value, n3 = t2.valueSpec, i2 = [];
          return Array.isArray(n3.values) ? -1 === n3.values.indexOf(re(r2)) && i2.push(new ri(e2, r2, `expected one of [${n3.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n3.values).indexOf(re(r2)) && i2.push(new ri(e2, r2, `expected one of [${Object.keys(n3.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
        }
        function ci(t2) {
          if (true === t2 || false === t2)
            return true;
          if (!Array.isArray(t2) || 0 === t2.length)
            return false;
          switch (t2[0]) {
            case "has":
              return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
            case "in":
              return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
            case "any":
            case "all":
              for (const e2 of t2.slice(1))
                if (!ci(e2) && "boolean" != typeof e2)
                  return false;
              return true;
            default:
              return true;
          }
        }
        function hi(t2, e2 = "fill") {
          if (null == t2)
            return { filter: () => true, needGeometry: false, needFeature: false };
          ci(t2) || (t2 = xi(t2));
          const r2 = t2;
          let n3 = true;
          try {
            n3 = function(t3) {
              if (!fi(t3))
                return t3;
              let e3 = ne(t3);
              return di(e3), e3 = pi(e3), e3;
            }(r2);
          } catch (t3) {
            console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r2, null, 2)}
        `);
          }
          const i2 = te[`filter_${e2}`], s4 = Hn(n3, i2);
          let a2 = null;
          if ("error" === s4.result)
            throw new Error(s4.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
          a2 = (t3, e3, r3) => s4.value.evaluate(t3, e3, {}, r3);
          let o2 = null, l3 = null;
          if (n3 !== r2) {
            const t3 = Hn(r2, i2);
            if ("error" === t3.result)
              throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
            o2 = (e3, r3, n4, i3, s5) => t3.value.evaluate(e3, r3, {}, n4, void 0, void 0, i3, s5), l3 = !br(t3.value.expression);
          }
          return { filter: a2, dynamicFilter: o2 || void 0, needGeometry: gi(n3), needFeature: !!l3 };
        }
        function pi(t2) {
          if (!Array.isArray(t2))
            return t2;
          const e2 = function(t3) {
            if (yi.has(t3[0])) {
              for (let e3 = 1; e3 < t3.length; e3++)
                if (fi(t3[e3]))
                  return true;
            }
            return t3;
          }(t2);
          return true === e2 ? e2 : e2.map((t3) => pi(t3));
        }
        function di(t2) {
          let e2 = false;
          const r2 = [];
          if ("case" === t2[0]) {
            for (let n3 = 1; n3 < t2.length - 1; n3 += 2)
              e2 = e2 || fi(t2[n3]), r2.push(t2[n3 + 1]);
            r2.push(t2[t2.length - 1]);
          } else if ("match" === t2[0]) {
            e2 = e2 || fi(t2[1]);
            for (let e3 = 2; e3 < t2.length - 1; e3 += 2)
              r2.push(t2[e3 + 1]);
            r2.push(t2[t2.length - 1]);
          } else if ("step" === t2[0]) {
            e2 = e2 || fi(t2[1]);
            for (let e3 = 1; e3 < t2.length - 1; e3 += 2)
              r2.push(t2[e3 + 1]);
          }
          e2 && (t2.length = 0, t2.push("any", ...r2));
          for (let e3 = 1; e3 < t2.length; e3++)
            di(t2[e3]);
        }
        function fi(t2) {
          if (!Array.isArray(t2))
            return false;
          if ("pitch" === (e2 = t2[0]) || "distance-from-center" === e2)
            return true;
          var e2;
          for (let e3 = 1; e3 < t2.length; e3++)
            if (fi(t2[e3]))
              return true;
          return false;
        }
        const yi = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function mi(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function gi(t2) {
          if (!Array.isArray(t2))
            return false;
          if ("within" === t2[0])
            return true;
          for (let e2 = 1; e2 < t2.length; e2++)
            if (gi(t2[e2]))
              return true;
          return false;
        }
        function xi(t2) {
          if (!t2)
            return true;
          const e2 = t2[0];
          return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? vi(t2[1], t2[2], "==") : "!=" === e2 ? _i(vi(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? vi(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(xi))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(xi)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(xi).map(_i)) : "in" === e2 ? bi(t2[1], t2.slice(2)) : "!in" === e2 ? _i(bi(t2[1], t2.slice(2))) : "has" === e2 ? wi(t2[1]) : "!has" === e2 ? _i(wi(t2[1])) : "within" !== e2 || t2;
          var r2;
        }
        function vi(t2, e2, r2) {
          switch (t2) {
            case "$type":
              return [`filter-type-${r2}`, e2];
            case "$id":
              return [`filter-id-${r2}`, e2];
            default:
              return [`filter-${r2}`, t2, e2];
          }
        }
        function bi(t2, e2) {
          if (0 === e2.length)
            return false;
          switch (t2) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(mi)]] : ["filter-in-small", t2, ["literal", e2]];
          }
        }
        function wi(t2) {
          switch (t2) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t2];
          }
        }
        function _i(t2) {
          return ["!", t2];
        }
        function Ai(t2) {
          return ci(ne(t2.value)) ? oi(ee({}, t2, { expressionContext: "filter", valueSpec: t2.styleSpec[`filter_${t2.layerType || "fill"}`] })) : Si(t2);
        }
        function Si(t2) {
          const e2 = t2.value, r2 = t2.key;
          if ("array" !== Un(e2))
            return [new ri(r2, e2, `array expected, ${Un(e2)} found`)];
          const n3 = t2.styleSpec;
          let i2, s4 = [];
          if (e2.length < 1)
            return [new ri(r2, e2, "filter array must have at least 1 element")];
          switch (s4 = s4.concat(ui({ key: `${r2}[0]`, value: e2[0], valueSpec: n3.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), re(e2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e2.length >= 2 && "$type" === re(e2[1]) && s4.push(new ri(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
            case "==":
            case "!=":
              3 !== e2.length && s4.push(new ri(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e2.length >= 2 && (i2 = Un(e2[1]), "string" !== i2 && s4.push(new ri(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
              for (let a2 = 2; a2 < e2.length; a2++)
                i2 = Un(e2[a2]), "$type" === re(e2[1]) ? s4 = s4.concat(ui({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n3.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s4.push(new ri(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n4 = 1; n4 < e2.length; n4++)
                s4 = s4.concat(Si({ key: `${r2}[${n4}]`, value: e2[n4], style: t2.style, styleSpec: t2.styleSpec }));
              break;
            case "has":
            case "!has":
              i2 = Un(e2[1]), 2 !== e2.length ? s4.push(new ri(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i2 && s4.push(new ri(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
              break;
            case "within":
              i2 = Un(e2[1]), 2 !== e2.length ? s4.push(new ri(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "object" !== i2 && s4.push(new ri(`${r2}[1]`, e2[1], `object expected, ${i2} found`));
          }
          return s4;
        }
        function ki(t2, e2) {
          const r2 = t2.key, n3 = t2.style, i2 = t2.styleSpec, s4 = t2.value, a2 = t2.objectKey, o2 = i2[`${e2}_${t2.layerType}`];
          if (!o2)
            return [];
          const l3 = a2.match(/^(.*)-transition$/);
          if ("paint" === e2 && l3 && o2[l3[1]] && o2[l3[1]].transition)
            return Fi({ key: r2, value: s4, valueSpec: i2.transition, style: n3, styleSpec: i2 });
          const u3 = t2.valueSpec || o2[a2];
          if (!u3)
            return [new ri(r2, s4, `unknown property "${a2}"`)];
          let c4;
          if ("string" === Un(s4) && Ln(u3) && !u3.tokens && (c4 = /^{([^}]+)}$/.exec(s4))) {
            const t3 = `\`{ "type": "identity", "property": ${c4 ? JSON.stringify(c4[1]) : '"_"'} }\``;
            return [new ri(r2, s4, `"${a2}" does not support interpolation syntax
Use an identity property function instead: ${t3}.`)];
          }
          const h3 = [];
          return "symbol" === t2.layerType && ("text-field" === a2 && n3 && !n3.glyphs && h3.push(new ri(r2, s4, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a2 && $n(ne(s4)) && "identity" === re(s4.type) && h3.push(new ri(r2, s4, '"text-font" does not support identity functions'))), h3.concat(Fi({ key: t2.key, value: s4, valueSpec: u3, style: n3, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: a2 }));
        }
        function Ii(t2) {
          return ki(t2, "paint");
        }
        function Mi(t2) {
          return ki(t2, "layout");
        }
        function Ti(t2) {
          let e2 = [];
          const r2 = t2.value, n3 = t2.key, i2 = t2.style, s4 = t2.styleSpec;
          r2.type || r2.ref || e2.push(new ri(n3, r2, 'either "type" or "ref" is required'));
          let a2 = re(r2.type);
          const o2 = re(r2.ref);
          if (r2.id) {
            const s5 = re(r2.id);
            for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
              const t3 = i2.layers[a3];
              re(t3.id) === s5 && e2.push(new ri(n3, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
            }
          }
          if ("ref" in r2) {
            let t3;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
              t4 in r2 && e2.push(new ri(n3, r2[t4], `"${t4}" is prohibited for ref layers`));
            }), i2.layers.forEach((e3) => {
              re(e3.id) === o2 && (t3 = e3);
            }), t3 ? t3.ref ? e2.push(new ri(n3, r2.ref, "ref cannot reference another ref layer")) : a2 = re(t3.type) : "string" == typeof o2 && e2.push(new ri(n3, r2.ref, `ref layer "${o2}" not found`));
          } else if ("background" !== a2 && "sky" !== a2)
            if (r2.source) {
              const t3 = i2.sources && i2.sources[r2.source], s5 = t3 && re(t3.type);
              t3 ? "vector" === s5 && "raster" === a2 ? e2.push(new ri(n3, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster" === s5 && "raster" !== a2 ? e2.push(new ri(n3, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== s5 || r2["source-layer"] ? "raster-dem" === s5 && "hillshade" !== a2 ? e2.push(new ri(n3, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a2 || !r2.paint || !r2.paint["line-gradient"] && !r2.paint["line-trim-offset"] || "geojson" === s5 && t3.lineMetrics || e2.push(new ri(n3, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new ri(n3, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new ri(n3, r2.source, `source "${r2.source}" not found`));
            } else
              e2.push(new ri(n3, r2, 'missing required property "source"'));
          return e2 = e2.concat(ni({ key: n3, value: r2, valueSpec: s4.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => Fi({ key: `${n3}.type`, value: r2.type, valueSpec: s4.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" }), filter: (t3) => Ai(ee({ layerType: a2 }, t3)), layout: (t3) => ni({ layer: r2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => Mi(ee({ layerType: a2 }, t4)) } }), paint: (t3) => ni({ layer: r2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => Ii(ee({ layerType: a2 }, t4)) } }) } })), e2;
        }
        function zi(t2) {
          const e2 = t2.value, r2 = t2.key, n3 = Un(e2);
          return "string" !== n3 ? [new ri(r2, e2, `string expected, ${n3} found`)] : [];
        }
        const Bi = { promoteId: function({ key: t2, value: e2 }) {
          if ("string" === Un(e2))
            return zi({ key: t2, value: e2 });
          {
            const r2 = [];
            for (const n3 in e2)
              r2.push(...zi({ key: `${t2}.${n3}`, value: e2[n3] }));
            return r2;
          }
        } };
        function Ei(t2) {
          const e2 = t2.value, r2 = t2.key, n3 = t2.styleSpec, i2 = t2.style;
          if (!e2.type)
            return [new ri(r2, e2, '"type" is required')];
          const s4 = re(e2.type);
          let a2;
          switch (s4) {
            case "vector":
            case "raster":
            case "raster-dem":
              return a2 = ni({ key: r2, value: e2, valueSpec: n3[`source_${s4.replace("-", "_")}`], style: t2.style, styleSpec: n3, objectElementValidators: Bi }), a2;
            case "geojson":
              if (a2 = ni({ key: r2, value: e2, valueSpec: n3.source_geojson, style: i2, styleSpec: n3, objectElementValidators: Bi }), e2.cluster)
                for (const t3 in e2.clusterProperties) {
                  const [n4, i3] = e2.clusterProperties[t3], s5 = "string" == typeof n4 ? [n4, ["accumulated"], ["get", t3]] : n4;
                  a2.push(...oi({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...oi({ key: `${r2}.${t3}.reduce`, value: s5, expressionContext: "cluster-reduce" }));
                }
              return a2;
            case "video":
              return ni({ key: r2, value: e2, valueSpec: n3.source_video, style: i2, styleSpec: n3 });
            case "image":
              return ni({ key: r2, value: e2, valueSpec: n3.source_image, style: i2, styleSpec: n3 });
            case "canvas":
              return [new ri(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return ui({ key: `${r2}.type`, value: e2.type, valueSpec: { values: Ci(n3) }, style: i2, styleSpec: n3 });
          }
        }
        function Ci(t2) {
          return t2.source.reduce((e2, r2) => {
            const n3 = t2[r2];
            return "enum" === n3.type.type && (e2 = e2.concat(Object.keys(n3.type.values))), e2;
          }, []);
        }
        function Pi(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n3 = r2.light, i2 = t2.style;
          let s4 = [];
          const a2 = Un(e2);
          if (void 0 === e2)
            return s4;
          if ("object" !== a2)
            return s4 = s4.concat([new ri("light", e2, `object expected, ${a2} found`)]), s4;
          for (const t3 in e2) {
            const a3 = t3.match(/^(.*)-transition$/);
            s4 = s4.concat(a3 && n3[a3[1]] && n3[a3[1]].transition ? Fi({ key: t3, value: e2[t3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n3[t3] ? Fi({ key: t3, value: e2[t3], valueSpec: n3[t3], style: i2, styleSpec: r2 }) : [new ri(t3, e2[t3], `unknown property "${t3}"`)]);
          }
          return s4;
        }
        function Di(t2) {
          const e2 = t2.value, r2 = t2.key, n3 = t2.style, i2 = t2.styleSpec, s4 = i2.terrain;
          let a2 = [];
          const o2 = Un(e2);
          if (void 0 === e2)
            return a2;
          if ("object" !== o2)
            return a2 = a2.concat([new ri("terrain", e2, `object expected, ${o2} found`)]), a2;
          for (const t3 in e2) {
            const r3 = t3.match(/^(.*)-transition$/);
            a2 = a2.concat(r3 && s4[r3[1]] && s4[r3[1]].transition ? Fi({ key: t3, value: e2[t3], valueSpec: i2.transition, style: n3, styleSpec: i2 }) : s4[t3] ? Fi({ key: t3, value: e2[t3], valueSpec: s4[t3], style: n3, styleSpec: i2 }) : [new ri(t3, e2[t3], `unknown property "${t3}"`)]);
          }
          if (e2.source) {
            const t3 = n3.sources && n3.sources[e2.source], i3 = t3 && re(t3.type);
            t3 ? "raster-dem" !== i3 && a2.push(new ri(r2, e2.source, `terrain cannot be used with a source of type ${String(i3)}, it only be used with a "raster-dem" source type`)) : a2.push(new ri(r2, e2.source, `source "${e2.source}" not found`));
          } else
            a2.push(new ri(r2, e2, 'terrain is missing required property "source"'));
          return a2;
        }
        function Vi(t2) {
          const e2 = t2.value, r2 = t2.style, n3 = t2.styleSpec, i2 = n3.fog;
          let s4 = [];
          const a2 = Un(e2);
          if (void 0 === e2)
            return s4;
          if ("object" !== a2)
            return s4 = s4.concat([new ri("fog", e2, `object expected, ${a2} found`)]), s4;
          for (const t3 in e2) {
            const a3 = t3.match(/^(.*)-transition$/);
            s4 = s4.concat(a3 && i2[a3[1]] && i2[a3[1]].transition ? Fi({ key: t3, value: e2[t3], valueSpec: n3.transition, style: r2, styleSpec: n3 }) : i2[t3] ? Fi({ key: t3, value: e2[t3], valueSpec: i2[t3], style: r2, styleSpec: n3 }) : [new ri(t3, e2[t3], `unknown property "${t3}"`)]);
          }
          return s4;
        }
        const Li = { "*": () => [], array: ii, boolean: function(t2) {
          const e2 = t2.value, r2 = t2.key, n3 = Un(e2);
          return "boolean" !== n3 ? [new ri(r2, e2, `boolean expected, ${n3} found`)] : [];
        }, number: si, color: function(t2) {
          const e2 = t2.key, r2 = t2.value, n3 = Un(r2);
          return "string" !== n3 ? [new ri(e2, r2, `color expected, ${n3} found`)] : null === Se(r2) ? [new ri(e2, r2, `color expected, "${r2}" found`)] : [];
        }, enum: ui, filter: Ai, function: ai, layer: Ti, object: ni, source: Ei, light: Pi, terrain: Di, fog: Vi, string: zi, formatted: function(t2) {
          return 0 === zi(t2).length ? [] : oi(t2);
        }, resolvedImage: function(t2) {
          return 0 === zi(t2).length ? [] : oi(t2);
        }, projection: function(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n3 = r2.projection, i2 = t2.style;
          let s4 = [];
          const a2 = Un(e2);
          if ("object" === a2)
            for (const t3 in e2)
              s4 = s4.concat(Fi({ key: t3, value: e2[t3], valueSpec: n3[t3], style: i2, styleSpec: r2 }));
          else
            "string" !== a2 && (s4 = s4.concat([new ri("projection", e2, `object or string expected, ${a2} found`)]));
          return s4;
        } };
        function Fi(t2) {
          const e2 = t2.value, r2 = t2.valueSpec, n3 = t2.styleSpec;
          return r2.expression && $n(re(e2)) ? ai(t2) : r2.expression && Jn(ne(e2)) ? oi(t2) : r2.type && Li[r2.type] ? Li[r2.type](t2) : ni(ee({}, t2, { valueSpec: r2.type ? n3[r2.type] : r2 }));
        }
        function Ri(t2) {
          const e2 = t2.value, r2 = t2.key, n3 = zi(t2);
          return n3.length || (-1 === e2.indexOf("{fontstack}") && n3.push(new ri(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n3.push(new ri(r2, e2, '"glyphs" url must include a "{range}" token'))), n3;
        }
        function Ui(t2, e2 = te) {
          return Oi(Fi({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: Ri, "*": () => [] } }));
        }
        const $i = (t2) => Oi(Ii(t2)), ji = (t2) => Oi(Mi(t2));
        function Oi(t2) {
          return t2.slice().sort((t3, e2) => t3.line && e2.line ? t3.line - e2.line : 0);
        }
        function qi(t2, e2) {
          let r2 = false;
          if (e2 && e2.length)
            for (const n3 of e2)
              t2.fire(new Wt(new Error(n3.message))), r2 = true;
          return r2;
        }
        var Ni = Zi, Gi = 3;
        function Zi(t2, e2, r2) {
          var n3 = this.cells = [];
          if (t2 instanceof ArrayBuffer) {
            this.arrayBuffer = t2;
            var i2 = new Int32Array(this.arrayBuffer);
            t2 = i2[0], this.d = (e2 = i2[1]) + 2 * (r2 = i2[2]);
            for (var s4 = 0; s4 < this.d * this.d; s4++) {
              var a2 = i2[Gi + s4], o2 = i2[Gi + s4 + 1];
              n3.push(a2 === o2 ? null : i2.subarray(a2, o2));
            }
            var l3 = i2[Gi + n3.length + 1];
            this.keys = i2.subarray(i2[Gi + n3.length], l3), this.bboxes = i2.subarray(l3), this.insert = this._insertReadonly;
          } else {
            this.d = e2 + 2 * r2;
            for (var u3 = 0; u3 < this.d * this.d; u3++)
              n3.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
          var c4 = r2 / e2 * t2;
          this.min = -c4, this.max = t2 + c4;
        }
        Zi.prototype.insert = function(t2, e2, r2, n3, i2) {
          this._forEachCell(e2, r2, n3, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n3), this.bboxes.push(i2);
        }, Zi.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, Zi.prototype._insertCell = function(t2, e2, r2, n3, i2, s4) {
          this.cells[i2].push(s4);
        }, Zi.prototype.query = function(t2, e2, r2, n3, i2) {
          var s4 = this.min, a2 = this.max;
          if (t2 <= s4 && e2 <= s4 && a2 <= r2 && a2 <= n3 && !i2)
            return Array.prototype.slice.call(this.keys);
          var o2 = [];
          return this._forEachCell(t2, e2, r2, n3, this._queryCell, o2, {}, i2), o2;
        }, Zi.prototype._queryCell = function(t2, e2, r2, n3, i2, s4, a2, o2) {
          var l3 = this.cells[i2];
          if (null !== l3)
            for (var u3 = this.keys, c4 = this.bboxes, h3 = 0; h3 < l3.length; h3++) {
              var p3 = l3[h3];
              if (void 0 === a2[p3]) {
                var d3 = 4 * p3;
                (o2 ? o2(c4[d3 + 0], c4[d3 + 1], c4[d3 + 2], c4[d3 + 3]) : t2 <= c4[d3 + 2] && e2 <= c4[d3 + 3] && r2 >= c4[d3 + 0] && n3 >= c4[d3 + 1]) ? (a2[p3] = true, s4.push(u3[p3])) : a2[p3] = false;
              }
            }
        }, Zi.prototype._forEachCell = function(t2, e2, r2, n3, i2, s4, a2, o2) {
          for (var l3 = this._convertToCellCoord(t2), u3 = this._convertToCellCoord(e2), c4 = this._convertToCellCoord(r2), h3 = this._convertToCellCoord(n3), p3 = l3; p3 <= c4; p3++)
            for (var d3 = u3; d3 <= h3; d3++) {
              var f2 = this.d * d3 + p3;
              if ((!o2 || o2(this._convertFromCellCoord(p3), this._convertFromCellCoord(d3), this._convertFromCellCoord(p3 + 1), this._convertFromCellCoord(d3 + 1))) && i2.call(this, t2, e2, r2, n3, f2, s4, a2, o2))
                return;
            }
        }, Zi.prototype._convertFromCellCoord = function(t2) {
          return (t2 - this.padding) / this.scale;
        }, Zi.prototype._convertToCellCoord = function(t2) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
        }, Zi.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          for (var t2 = this.cells, e2 = Gi + this.cells.length + 1 + 1, r2 = 0, n3 = 0; n3 < this.cells.length; n3++)
            r2 += this.cells[n3].length;
          var i2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
          i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
          for (var s4 = e2, a2 = 0; a2 < t2.length; a2++) {
            var o2 = t2[a2];
            i2[Gi + a2] = s4, i2.set(o2, s4), s4 += o2.length;
          }
          return i2[Gi + t2.length] = s4, i2.set(this.keys, s4), i2[Gi + t2.length + 1] = s4 += this.keys.length, i2.set(this.bboxes, s4), s4 += this.bboxes.length, i2.buffer;
        };
        var Ki = p2(Ni);
        const Xi = {};
        function Ji(t2, e2, r2 = {}) {
          Object.defineProperty(t2, "_classRegistryKey", { value: e2, writeable: false }), Xi[e2] = { klass: t2, omit: r2.omit || [] };
        }
        Ji(Object, "Object"), Ki.serialize = function(t2, e2) {
          const r2 = t2.toArrayBuffer();
          return e2 && e2.push(r2), { buffer: r2 };
        }, Ki.deserialize = function(t2) {
          return new Ki(t2.buffer);
        }, Object.defineProperty(Ki, "name", { value: "Grid" }), Ji(Ki, "Grid"), Ji(Ee, "Color"), Ji(Error, "Error"), Ji(ut, "AJAXError"), Ji(Ve, "ResolvedImage"), Ji(ti, "StylePropertyFunction"), Ji(Xn, "StyleExpression", { omit: ["_evaluator"] }), Ji(Wn, "ZoomDependentExpression"), Ji(Yn, "ZoomConstantExpression"), Ji(tr, "CompoundExpression", { omit: ["_evaluate"] });
        for (const t2 in Pn)
          Xi[Pn[t2]._classRegistryKey] || Ji(Pn[t2], `Expression${t2}`);
        function Hi(t2) {
          return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
        }
        function Yi(t2) {
          return e.ImageBitmap && t2 instanceof e.ImageBitmap;
        }
        function Wi(t2, r2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
            return t2;
          if (Hi(t2) || Yi(t2))
            return r2 && r2.push(t2), t2;
          if (ArrayBuffer.isView(t2)) {
            const e2 = t2;
            return r2 && r2.push(e2.buffer), e2;
          }
          if (t2 instanceof e.ImageData)
            return r2 && r2.push(t2.data.buffer), t2;
          if (Array.isArray(t2)) {
            const e2 = [];
            for (const n3 of t2)
              e2.push(Wi(n3, r2));
            return e2;
          }
          if ("object" == typeof t2) {
            const e2 = t2.constructor, n3 = e2._classRegistryKey;
            if (!n3)
              throw new Error(`can't serialize object of unregistered class ${n3}`);
            const i2 = e2.serialize ? e2.serialize(t2, r2) : {};
            if (!e2.serialize) {
              for (const e3 in t2)
                t2.hasOwnProperty(e3) && (Xi[n3].omit.indexOf(e3) >= 0 || (i2[e3] = Wi(t2[e3], r2)));
              t2 instanceof Error && (i2.message = t2.message);
            }
            if (i2.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n3 && (i2.$name = n3), i2;
          }
          throw new Error("can't serialize object of type " + typeof t2);
        }
        function Qi(t2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || Hi(t2) || Yi(t2) || ArrayBuffer.isView(t2) || t2 instanceof e.ImageData)
            return t2;
          if (Array.isArray(t2))
            return t2.map(Qi);
          if ("object" == typeof t2) {
            const e2 = t2.$name || "Object", { klass: r2 } = Xi[e2];
            if (!r2)
              throw new Error(`can't deserialize unregistered class ${e2}`);
            if (r2.deserialize)
              return r2.deserialize(t2);
            const n3 = Object.create(r2.prototype);
            for (const e3 of Object.keys(t2))
              "$name" !== e3 && (n3[e3] = Qi(t2[e3]));
            return n3;
          }
          throw new Error("can't deserialize object of type " + typeof t2);
        }
        const ts = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, Arabic: (t2) => t2 >= 1536 && t2 <= 1791, "Arabic Supplement": (t2) => t2 >= 1872 && t2 <= 1919, "Arabic Extended-A": (t2) => t2 >= 2208 && t2 <= 2303, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, "Unified Canadian Aboriginal Syllabics": (t2) => t2 >= 5120 && t2 <= 5759, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t2) => t2 >= 6320 && t2 <= 6399, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "CJK Radicals Supplement": (t2) => t2 >= 11904 && t2 <= 12031, "Kangxi Radicals": (t2) => t2 >= 12032 && t2 <= 12255, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Bopomofo: (t2) => t2 >= 12544 && t2 <= 12591, "Hangul Compatibility Jamo": (t2) => t2 >= 12592 && t2 <= 12687, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "Bopomofo Extended": (t2) => t2 >= 12704 && t2 <= 12735, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Katakana Phonetic Extensions": (t2) => t2 >= 12784 && t2 <= 12799, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "CJK Unified Ideographs Extension A": (t2) => t2 >= 13312 && t2 <= 19903, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Yi Syllables": (t2) => t2 >= 40960 && t2 <= 42127, "Yi Radicals": (t2) => t2 >= 42128 && t2 <= 42191, "Hangul Jamo Extended-A": (t2) => t2 >= 43360 && t2 <= 43391, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Hangul Jamo Extended-B": (t2) => t2 >= 55216 && t2 <= 55295, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "CJK Compatibility Ideographs": (t2) => t2 >= 63744 && t2 <= 64255, "Arabic Presentation Forms-A": (t2) => t2 >= 64336 && t2 <= 65023, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Arabic Presentation Forms-B": (t2) => t2 >= 65136 && t2 <= 65279, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
        function es(t2) {
          for (const e2 of t2)
            if (is(e2.charCodeAt(0)))
              return true;
          return false;
        }
        function rs(t2) {
          for (const e2 of t2)
            if (!ns(e2.charCodeAt(0)))
              return false;
          return true;
        }
        function ns(t2) {
          return !(ts.Arabic(t2) || ts["Arabic Supplement"](t2) || ts["Arabic Extended-A"](t2) || ts["Arabic Presentation Forms-A"](t2) || ts["Arabic Presentation Forms-B"](t2));
        }
        function is(t2) {
          return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(ts["Bopomofo Extended"](t2) || ts.Bopomofo(t2) || ts["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || ts["CJK Compatibility Ideographs"](t2) || ts["CJK Compatibility"](t2) || ts["CJK Radicals Supplement"](t2) || ts["CJK Strokes"](t2) || !(!ts["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || ts["CJK Unified Ideographs Extension A"](t2) || ts["CJK Unified Ideographs"](t2) || ts["Enclosed CJK Letters and Months"](t2) || ts["Hangul Compatibility Jamo"](t2) || ts["Hangul Jamo Extended-A"](t2) || ts["Hangul Jamo Extended-B"](t2) || ts["Hangul Jamo"](t2) || ts["Hangul Syllables"](t2) || ts.Hiragana(t2) || ts["Ideographic Description Characters"](t2) || ts.Kanbun(t2) || ts["Kangxi Radicals"](t2) || ts["Katakana Phonetic Extensions"](t2) || ts.Katakana(t2) && 12540 !== t2 || !(!ts["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!ts["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || ts["Unified Canadian Aboriginal Syllabics"](t2) || ts["Unified Canadian Aboriginal Syllabics Extended"](t2) || ts["Vertical Forms"](t2) || ts["Yijing Hexagram Symbols"](t2) || ts["Yi Syllables"](t2) || ts["Yi Radicals"](t2))));
        }
        function ss(t2) {
          return !(is(t2) || function(t3) {
            return !!(ts["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || ts["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || ts["Letterlike Symbols"](t3) || ts["Number Forms"](t3) || ts["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ts["Control Pictures"](t3) && 9251 !== t3 || ts["Optical Character Recognition"](t3) || ts["Enclosed Alphanumerics"](t3) || ts["Geometric Shapes"](t3) || ts["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || ts["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || ts["CJK Symbols and Punctuation"](t3) || ts.Katakana(t3) || ts["Private Use Area"](t3) || ts["CJK Compatibility Forms"](t3) || ts["Small Form Variants"](t3) || ts["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
          }(t2));
        }
        function as(t2) {
          return t2 >= 1424 && t2 <= 2303 || ts["Arabic Presentation Forms-A"](t2) || ts["Arabic Presentation Forms-B"](t2);
        }
        function os(t2, e2) {
          return !(!e2 && as(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || ts.Khmer(t2));
        }
        function ls(t2) {
          for (const e2 of t2)
            if (as(e2.charCodeAt(0)))
              return true;
          return false;
        }
        const us = "deferred", cs = "loading", hs = "loaded";
        let ps = null, ds = "unavailable", fs = null;
        const ys = function(t2) {
          t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (ds = "error"), ps && ps(t2);
        };
        function ms() {
          gs.fire(new Yt("pluginStateChange", { pluginStatus: ds, pluginURL: fs }));
        }
        const gs = new Qt(), xs = function() {
          return ds;
        }, vs = function() {
          if (ds !== us || !fs)
            throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          ds = cs, ms(), fs && pt({ url: fs }, (t2) => {
            t2 ? ys(t2) : (ds = hs, ms());
          });
        }, bs = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ds === hs || null != bs.applyArabicShaping, isLoading: () => ds === cs, setState(t2) {
          ds = t2.pluginStatus, fs = t2.pluginURL;
        }, isParsed: () => null != bs.applyArabicShaping && null != bs.processBidirectionalText && null != bs.processStyledBidirectionalText, getPluginURL: () => fs };
        class ws {
          constructor(t2, e2) {
            this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.transition = e2.transition, this.pitch = e2.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
          }
          isSupportedScript(t2) {
            return function(t3, e2) {
              for (const r2 of t3)
                if (!os(r2.charCodeAt(0), e2))
                  return false;
              return true;
            }(t2, bs.isLoaded());
          }
        }
        class _s {
          constructor(t2, e2) {
            this.property = t2, this.value = e2, this.expression = function(t3, e3) {
              if ($n(t3))
                return new ti(t3, e3);
              if (Jn(t3)) {
                const r2 = Qn(t3, e3);
                if ("error" === r2.result)
                  throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                return r2.value;
              }
              {
                let r2 = t3;
                return "string" == typeof t3 && "color" === e3.type && (r2 = Ee.parse(t3)), { kind: "constant", evaluate: () => r2 };
              }
            }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t2, e2, r2) {
            return this.property.possiblyEvaluate(this, t2, e2, r2);
          }
        }
        class As {
          constructor(t2) {
            this.property = t2, this.value = new _s(t2, void 0);
          }
          transitioned(t2, e2) {
            return new ks(this.property, this.value, e2, C2({}, t2.transition, this.transition), t2.now);
          }
          untransitioned() {
            return new ks(this.property, this.value, null, {}, 0);
          }
        }
        class Ss {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
          }
          getValue(t2) {
            return O(this._values[t2].value.value);
          }
          setValue(t2, e2) {
            this._values.hasOwnProperty(t2) || (this._values[t2] = new As(this._values[t2].property)), this._values[t2].value = new _s(this._values[t2].property, null === e2 ? void 0 : O(e2));
          }
          getTransition(t2) {
            return O(this._values[t2].transition);
          }
          setTransition(t2, e2) {
            this._values.hasOwnProperty(t2) || (this._values[t2] = new As(this._values[t2].property)), this._values[t2].transition = O(e2) || void 0;
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
              const n3 = this.getTransition(e2);
              void 0 !== n3 && (t2[`${e2}-transition`] = n3);
            }
            return t2;
          }
          transitioned(t2, e2) {
            const r2 = new Is(this._properties);
            for (const n3 of Object.keys(this._values))
              r2._values[n3] = this._values[n3].transitioned(t2, e2._values[n3]);
            return r2;
          }
          untransitioned() {
            const t2 = new Is(this._properties);
            for (const e2 of Object.keys(this._values))
              t2._values[e2] = this._values[e2].untransitioned();
            return t2;
          }
        }
        class ks {
          constructor(t2, e2, r2, n3, i2) {
            const s4 = n3.delay || 0, a2 = n3.duration || 0;
            i2 = i2 || 0, this.property = t2, this.value = e2, this.begin = i2 + s4, this.end = this.begin + a2, t2.specification.transition && (n3.delay || n3.duration) && (this.prior = r2);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n3 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s4 = this.prior;
            if (s4) {
              if (n3 > this.end)
                return this.prior = null, i2;
              if (this.value.isDataDriven())
                return this.prior = null, i2;
              if (n3 < this.begin)
                return s4.possiblyEvaluate(t2, e2, r2);
              {
                const a2 = (n3 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s4.possiblyEvaluate(t2, e2, r2), i2, S(a2));
              }
            }
            return i2;
          }
        }
        class Is {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n3 = new zs(this._properties);
            for (const i2 of Object.keys(this._values))
              n3._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n3;
          }
          hasTransition() {
            for (const t2 of Object.keys(this._values))
              if (this._values[t2].prior)
                return true;
            return false;
          }
        }
        class Ms {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
          }
          getValue(t2) {
            return O(this._values[t2].value);
          }
          setValue(t2, e2) {
            this._values[t2] = new _s(this._values[t2].property, null === e2 ? void 0 : O(e2));
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
            }
            return t2;
          }
          possiblyEvaluate(t2, e2, r2) {
            const n3 = new zs(this._properties);
            for (const i2 of Object.keys(this._values))
              n3._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n3;
          }
        }
        class Ts {
          constructor(t2, e2, r2) {
            this.property = t2, this.value = e2, this.parameters = r2;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t2) {
            return "constant" === this.value.kind ? this.value.value : t2;
          }
          evaluate(t2, e2, r2, n3) {
            return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n3);
          }
        }
        class zs {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
          }
          get(t2) {
            return this._values[t2];
          }
        }
        class Bs {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2) {
            return t2.expression.evaluate(e2);
          }
          interpolate(t2, e2, r2) {
            const n3 = Cr[this.specification.type];
            return n3 ? n3(t2, e2, r2) : t2;
          }
        }
        class Es {
          constructor(t2, e2) {
            this.specification = t2, this.overrides = e2;
          }
          possiblyEvaluate(t2, e2, r2, n3) {
            return new Ts(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n3) } : t2.expression, e2);
          }
          interpolate(t2, e2, r2) {
            if ("constant" !== t2.value.kind || "constant" !== e2.value.kind)
              return t2;
            if (void 0 === t2.value.value || void 0 === e2.value.value)
              return new Ts(this, { kind: "constant", value: void 0 }, t2.parameters);
            const n3 = Cr[this.specification.type];
            return n3 ? new Ts(this, { kind: "constant", value: n3(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
          }
          evaluate(t2, e2, r2, n3, i2, s4) {
            return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n3, i2, s4);
          }
        }
        class Cs {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n3) {
            return !!t2.expression.evaluate(e2, null, {}, r2, n3);
          }
          interpolate() {
            return false;
          }
        }
        class Ps {
          constructor(t2) {
            this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            const e2 = new ws(0, {});
            for (const r2 in t2) {
              const n3 = t2[r2];
              n3.specification.overridable && this.overridableProperties.push(r2);
              const i2 = this.defaultPropertyValues[r2] = new _s(n3, void 0), s4 = this.defaultTransitionablePropertyValues[r2] = new As(n3);
              this.defaultTransitioningPropertyValues[r2] = s4.untransitioned(), this.defaultPossiblyEvaluatedValues[r2] = i2.possiblyEvaluate(e2);
            }
          }
        }
        function Ds(t2, e2) {
          return 256 * (t2 = M(Math.floor(t2), 0, 255)) + M(Math.floor(e2), 0, 255);
        }
        Ji(Es, "DataDrivenProperty"), Ji(Bs, "DataConstantProperty"), Ji(Cs, "ColorRampProperty");
        const Vs = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Ls {
          constructor(t2, e2) {
            this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class Fs {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t2, e2) {
            return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
          }
          static deserialize(t2) {
            const e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t2) {
            this.reserve(t2), this.length = t2;
          }
          reserve(t2) {
            if (t2 > this.capacity) {
              this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
          destroy() {
            this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
          }
        }
        function Rs(t2, e2 = 1) {
          let r2 = 0, n3 = 0;
          return { members: t2.map((t3) => {
            const i2 = Vs[t3.type].BYTES_PER_ELEMENT, s4 = r2 = Us(r2, Math.max(e2, i2)), a2 = t3.components || 1;
            return n3 = Math.max(n3, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s4 };
          }), size: Us(r2, Math.max(n3, e2)), alignment: e2 };
        }
        function Us(t2, e2) {
          return Math.ceil(t2 / e2) * e2;
        }
        class $s extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n3 = 2 * t2;
            return this.int16[n3 + 0] = e2, this.int16[n3 + 1] = r2, t2;
          }
        }
        $s.prototype.bytesPerElement = 4, Ji($s, "StructArrayLayout2i4");
        class js extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t2, e2, r2);
          }
          emplace(t2, e2, r2, n3) {
            const i2 = 3 * t2;
            return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n3, t2;
          }
        }
        js.prototype.bytesPerElement = 6, Ji(js, "StructArrayLayout3i6");
        class Os extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n3);
          }
          emplace(t2, e2, r2, n3, i2) {
            const s4 = 4 * t2;
            return this.int16[s4 + 0] = e2, this.int16[s4 + 1] = r2, this.int16[s4 + 2] = n3, this.int16[s4 + 3] = i2, t2;
          }
        }
        Os.prototype.bytesPerElement = 8, Ji(Os, "StructArrayLayout4i8");
        class qs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2, s4, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n3, i2, s4, a2);
          }
          emplace(t2, e2, r2, n3, i2, s4, a2, o2) {
            const l3 = 6 * t2, u3 = 12 * t2, c4 = 3 * t2;
            return this.int16[l3 + 0] = e2, this.int16[l3 + 1] = r2, this.uint8[u3 + 4] = n3, this.uint8[u3 + 5] = i2, this.uint8[u3 + 6] = s4, this.uint8[u3 + 7] = a2, this.float32[c4 + 2] = o2, t2;
          }
        }
        qs.prototype.bytesPerElement = 12, Ji(qs, "StructArrayLayout2i4ub1f12");
        class Ns extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n3);
          }
          emplace(t2, e2, r2, n3, i2) {
            const s4 = 4 * t2;
            return this.float32[s4 + 0] = e2, this.float32[s4 + 1] = r2, this.float32[s4 + 2] = n3, this.float32[s4 + 3] = i2, t2;
          }
        }
        Ns.prototype.bytesPerElement = 16, Ji(Ns, "StructArrayLayout4f16");
        class Gs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t2, e2, r2, n3, i2);
          }
          emplace(t2, e2, r2, n3, i2, s4) {
            const a2 = 6 * t2, o2 = 3 * t2;
            return this.uint16[a2 + 0] = e2, this.uint16[a2 + 1] = r2, this.uint16[a2 + 2] = n3, this.uint16[a2 + 3] = i2, this.float32[o2 + 2] = s4, t2;
          }
        }
        Gs.prototype.bytesPerElement = 12, Ji(Gs, "StructArrayLayout4ui1f12");
        class Zs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n3);
          }
          emplace(t2, e2, r2, n3, i2) {
            const s4 = 4 * t2;
            return this.uint16[s4 + 0] = e2, this.uint16[s4 + 1] = r2, this.uint16[s4 + 2] = n3, this.uint16[s4 + 3] = i2, t2;
          }
        }
        Zs.prototype.bytesPerElement = 8, Ji(Zs, "StructArrayLayout4ui8");
        class Ks extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2, s4) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n3, i2, s4);
          }
          emplace(t2, e2, r2, n3, i2, s4, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n3, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s4, this.int16[o2 + 5] = a2, t2;
          }
        }
        Ks.prototype.bytesPerElement = 12, Ji(Ks, "StructArrayLayout6i12");
        class Xs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3) {
            const p3 = this.length;
            return this.resize(p3 + 1), this.emplace(p3, t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3);
          }
          emplace(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3) {
            const d3 = 12 * t2;
            return this.int16[d3 + 0] = e2, this.int16[d3 + 1] = r2, this.int16[d3 + 2] = n3, this.int16[d3 + 3] = i2, this.uint16[d3 + 4] = s4, this.uint16[d3 + 5] = a2, this.uint16[d3 + 6] = o2, this.uint16[d3 + 7] = l3, this.int16[d3 + 8] = u3, this.int16[d3 + 9] = c4, this.int16[d3 + 10] = h3, this.int16[d3 + 11] = p3, t2;
          }
        }
        Xs.prototype.bytesPerElement = 24, Ji(Xs, "StructArrayLayout4i4ui4i24");
        class Js extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2, s4) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n3, i2, s4);
          }
          emplace(t2, e2, r2, n3, i2, s4, a2) {
            const o2 = 10 * t2, l3 = 5 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n3, this.float32[l3 + 2] = i2, this.float32[l3 + 3] = s4, this.float32[l3 + 4] = a2, t2;
          }
        }
        Js.prototype.bytesPerElement = 20, Ji(Js, "StructArrayLayout3i3f20");
        class Hs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint32[1 * t2 + 0] = e2, t2;
          }
        }
        Hs.prototype.bytesPerElement = 4, Ji(Hs, "StructArrayLayout1ul4");
        class Ys extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3) {
            const d3 = this.length;
            return this.resize(d3 + 1), this.emplace(d3, t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3);
          }
          emplace(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3) {
            const f2 = 20 * t2, y2 = 10 * t2;
            return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n3, this.int16[f2 + 3] = i2, this.int16[f2 + 4] = s4, this.float32[y2 + 3] = a2, this.float32[y2 + 4] = o2, this.float32[y2 + 5] = l3, this.float32[y2 + 6] = u3, this.int16[f2 + 14] = c4, this.uint32[y2 + 8] = h3, this.uint16[f2 + 18] = p3, this.uint16[f2 + 19] = d3, t2;
          }
        }
        Ys.prototype.bytesPerElement = 40, Ji(Ys, "StructArrayLayout5i4f1i1ul2ui40");
        class Ws extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2, s4, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n3, i2, s4, a2);
          }
          emplace(t2, e2, r2, n3, i2, s4, a2, o2) {
            const l3 = 8 * t2;
            return this.int16[l3 + 0] = e2, this.int16[l3 + 1] = r2, this.int16[l3 + 2] = n3, this.int16[l3 + 4] = i2, this.int16[l3 + 5] = s4, this.int16[l3 + 6] = a2, this.int16[l3 + 7] = o2, t2;
          }
        }
        Ws.prototype.bytesPerElement = 16, Ji(Ws, "StructArrayLayout3i2i2i16");
        class Qs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t2, e2, r2, n3, i2);
          }
          emplace(t2, e2, r2, n3, i2, s4) {
            const a2 = 4 * t2, o2 = 8 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n3, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s4, t2;
          }
        }
        Qs.prototype.bytesPerElement = 16, Ji(Qs, "StructArrayLayout2f1f2i16");
        class ta extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n3);
          }
          emplace(t2, e2, r2, n3, i2) {
            const s4 = 12 * t2, a2 = 3 * t2;
            return this.uint8[s4 + 0] = e2, this.uint8[s4 + 1] = r2, this.float32[a2 + 1] = n3, this.float32[a2 + 2] = i2, t2;
          }
        }
        ta.prototype.bytesPerElement = 12, Ji(ta, "StructArrayLayout2ub2f12");
        class ea extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t2, e2, r2);
          }
          emplace(t2, e2, r2, n3) {
            const i2 = 3 * t2;
            return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n3, t2;
          }
        }
        ea.prototype.bytesPerElement = 12, Ji(ea, "StructArrayLayout3f12");
        class ra extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t2, e2, r2);
          }
          emplace(t2, e2, r2, n3) {
            const i2 = 3 * t2;
            return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n3, t2;
          }
        }
        ra.prototype.bytesPerElement = 6, Ji(ra, "StructArrayLayout3ui6");
        class na extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3, f2, y2, m3, g2, x2, v4, b3) {
            const w2 = this.length;
            return this.resize(w2 + 1), this.emplace(w2, t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3, f2, y2, m3, g2, x2, v4, b3);
          }
          emplace(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3, f2, y2, m3, g2, x2, v4, b3, w2) {
            const _2 = 30 * t2, A2 = 15 * t2, S2 = 60 * t2;
            return this.int16[_2 + 0] = e2, this.int16[_2 + 1] = r2, this.int16[_2 + 2] = n3, this.float32[A2 + 2] = i2, this.float32[A2 + 3] = s4, this.uint16[_2 + 8] = a2, this.uint16[_2 + 9] = o2, this.uint32[A2 + 5] = l3, this.uint32[A2 + 6] = u3, this.uint32[A2 + 7] = c4, this.uint16[_2 + 16] = h3, this.uint16[_2 + 17] = p3, this.uint16[_2 + 18] = d3, this.float32[A2 + 10] = f2, this.float32[A2 + 11] = y2, this.uint8[S2 + 48] = m3, this.uint8[S2 + 49] = g2, this.uint8[S2 + 50] = x2, this.uint32[A2 + 13] = v4, this.int16[_2 + 28] = b3, this.uint8[S2 + 58] = w2, t2;
          }
        }
        na.prototype.bytesPerElement = 60, Ji(na, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class ia extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3, f2, y2, m3, g2, x2, v4, b3, w2, _2, A2, S2, k2, I2, M2, T3, z2) {
            const B2 = this.length;
            return this.resize(B2 + 1), this.emplace(B2, t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3, f2, y2, m3, g2, x2, v4, b3, w2, _2, A2, S2, k2, I2, M2, T3, z2);
          }
          emplace(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3, f2, y2, m3, g2, x2, v4, b3, w2, _2, A2, S2, k2, I2, M2, T3, z2, B2) {
            const E2 = 38 * t2, C3 = 19 * t2;
            return this.int16[E2 + 0] = e2, this.int16[E2 + 1] = r2, this.int16[E2 + 2] = n3, this.float32[C3 + 2] = i2, this.float32[C3 + 3] = s4, this.int16[E2 + 8] = a2, this.int16[E2 + 9] = o2, this.int16[E2 + 10] = l3, this.int16[E2 + 11] = u3, this.int16[E2 + 12] = c4, this.int16[E2 + 13] = h3, this.uint16[E2 + 14] = p3, this.uint16[E2 + 15] = d3, this.uint16[E2 + 16] = f2, this.uint16[E2 + 17] = y2, this.uint16[E2 + 18] = m3, this.uint16[E2 + 19] = g2, this.uint16[E2 + 20] = x2, this.uint16[E2 + 21] = v4, this.uint16[E2 + 22] = b3, this.uint16[E2 + 23] = w2, this.uint16[E2 + 24] = _2, this.uint16[E2 + 25] = A2, this.uint16[E2 + 26] = S2, this.uint16[E2 + 27] = k2, this.uint16[E2 + 28] = I2, this.uint32[C3 + 15] = M2, this.float32[C3 + 16] = T3, this.float32[C3 + 17] = z2, this.float32[C3 + 18] = B2, t2;
          }
        }
        ia.prototype.bytesPerElement = 76, Ji(ia, "StructArrayLayout3i2f6i15ui1ul3f76");
        class sa extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.float32[1 * t2 + 0] = e2, t2;
          }
        }
        sa.prototype.bytesPerElement = 4, Ji(sa, "StructArrayLayout1f4");
        class aa extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3, i2) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t2, e2, r2, n3, i2);
          }
          emplace(t2, e2, r2, n3, i2, s4) {
            const a2 = 5 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n3, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s4, t2;
          }
        }
        aa.prototype.bytesPerElement = 20, Ji(aa, "StructArrayLayout5f20");
        class oa extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n3) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n3);
          }
          emplace(t2, e2, r2, n3, i2) {
            const s4 = 6 * t2;
            return this.uint32[3 * t2 + 0] = e2, this.uint16[s4 + 2] = r2, this.uint16[s4 + 3] = n3, this.uint16[s4 + 4] = i2, t2;
          }
        }
        oa.prototype.bytesPerElement = 12, Ji(oa, "StructArrayLayout1ul3ui12");
        class la extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n3 = 2 * t2;
            return this.uint16[n3 + 0] = e2, this.uint16[n3 + 1] = r2, t2;
          }
        }
        la.prototype.bytesPerElement = 4, Ji(la, "StructArrayLayout2ui4");
        class ua extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint16[1 * t2 + 0] = e2, t2;
          }
        }
        ua.prototype.bytesPerElement = 2, Ji(ua, "StructArrayLayout1ui2");
        class ca extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n3 = 2 * t2;
            return this.float32[n3 + 0] = e2, this.float32[n3 + 1] = r2, t2;
          }
        }
        ca.prototype.bytesPerElement = 8, Ji(ca, "StructArrayLayout2f8");
        class ha extends Ls {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get tileAnchorY() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get x1() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get y1() {
            return this._structArray.float32[this._pos4 + 4];
          }
          get x2() {
            return this._structArray.float32[this._pos4 + 5];
          }
          get y2() {
            return this._structArray.float32[this._pos4 + 6];
          }
          get padding() {
            return this._structArray.int16[this._pos2 + 14];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 8];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
        }
        ha.prototype.size = 40;
        class pa extends Ys {
          get(t2) {
            return new ha(this, t2);
          }
        }
        Ji(pa, "CollisionBoxArray");
        class da extends Ls {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 5];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 6];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 7];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 10];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 11];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 48];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 49];
          }
          set placedOrientation(t2) {
            this._structArray.uint8[this._pos1 + 49] = t2;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 50];
          }
          set hidden(t2) {
            this._structArray.uint8[this._pos1 + 50] = t2;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 13];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 13] = t2;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 28];
          }
          get flipState() {
            return this._structArray.uint8[this._pos1 + 58];
          }
          set flipState(t2) {
            this._structArray.uint8[this._pos1 + 58] = t2;
          }
        }
        da.prototype.size = 60;
        class fa extends na {
          get(t2) {
            return new da(this, t2);
          }
        }
        Ji(fa, "PlacedSymbolArray");
        class ya extends Ls {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 8];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 9];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 10];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 11];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 12];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 13];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 23];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 24];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 25];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 26];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 27];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 28];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 15];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 15] = t2;
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 16];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 17];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 18];
          }
        }
        ya.prototype.size = 76;
        class ma extends ia {
          get(t2) {
            return new ya(this, t2);
          }
        }
        Ji(ma, "SymbolInstanceArray");
        class ga extends sa {
          getoffsetX(t2) {
            return this.float32[1 * t2 + 0];
          }
        }
        Ji(ga, "GlyphOffsetArray");
        class xa extends $s {
          getx(t2) {
            return this.int16[2 * t2 + 0];
          }
          gety(t2) {
            return this.int16[2 * t2 + 1];
          }
        }
        Ji(xa, "SymbolLineVertexArray");
        class va extends Ls {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get layoutVertexArrayOffset() {
            return this._structArray.uint16[this._pos2 + 4];
          }
        }
        va.prototype.size = 12;
        class ba extends oa {
          get(t2) {
            return new va(this, t2);
          }
        }
        Ji(ba, "FeatureIndexArray");
        class wa extends la {
          geta_centroid_pos0(t2) {
            return this.uint16[2 * t2 + 0];
          }
          geta_centroid_pos1(t2) {
            return this.uint16[2 * t2 + 1];
          }
        }
        Ji(wa, "FillExtrusionCentroidArray");
        const _a2 = Rs([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), Aa = Rs([{ name: "a_dash", components: 4, type: "Uint16" }]);
        var Sa = { exports: {} }, ka = { exports: {} };
        ka.exports = function(t2, e2) {
          var r2, n3, i2, s4, a2, o2, l3, u3;
          for (n3 = t2.length - (r2 = 3 & t2.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u3 = 0; u3 < n3; )
            l3 = 255 & t2.charCodeAt(u3) | (255 & t2.charCodeAt(++u3)) << 8 | (255 & t2.charCodeAt(++u3)) << 16 | (255 & t2.charCodeAt(++u3)) << 24, ++u3, i2 = 27492 + (65535 & (s4 = 5 * (65535 & (i2 = (i2 ^= l3 = (65535 & (l3 = (l3 = (65535 & l3) * a2 + (((l3 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o2 + (((l3 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s4 >>> 16) & 65535) << 16);
          switch (l3 = 0, r2) {
            case 3:
              l3 ^= (255 & t2.charCodeAt(u3 + 2)) << 16;
            case 2:
              l3 ^= (255 & t2.charCodeAt(u3 + 1)) << 8;
            case 1:
              i2 ^= l3 = (65535 & (l3 = (l3 = (65535 & (l3 ^= 255 & t2.charCodeAt(u3))) * a2 + (((l3 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * o2 + (((l3 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
        var Ia = ka.exports, Ma = { exports: {} };
        Ma.exports = function(t2, e2) {
          for (var r2, n3 = t2.length, i2 = e2 ^ n3, s4 = 0; n3 >= 4; )
            r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(s4) | (255 & t2.charCodeAt(++s4)) << 8 | (255 & t2.charCodeAt(++s4)) << 16 | (255 & t2.charCodeAt(++s4)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n3 -= 4, ++s4;
          switch (n3) {
            case 3:
              i2 ^= (255 & t2.charCodeAt(s4 + 2)) << 16;
            case 2:
              i2 ^= (255 & t2.charCodeAt(s4 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s4))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
        var Ta = Ia, za = Ma.exports;
        Sa.exports = Ta, Sa.exports.murmur3 = Ta, Sa.exports.murmur2 = za;
        var Ba = p2(Sa.exports);
        class Ea {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t2, e2, r2, n3) {
            this.ids.push(Ca(t2)), this.positions.push(e2, r2, n3);
          }
          getPositions(t2) {
            const e2 = Ca(t2);
            let r2 = 0, n3 = this.ids.length - 1;
            for (; r2 < n3; ) {
              const t3 = r2 + n3 >> 1;
              this.ids[t3] >= e2 ? n3 = t3 : r2 = t3 + 1;
            }
            const i2 = [];
            for (; this.ids[r2] === e2; )
              i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
            return i2;
          }
          static serialize(t2, e2) {
            const r2 = new Float64Array(t2.ids), n3 = new Uint32Array(t2.positions);
            return Pa(r2, n3, 0, r2.length - 1), e2 && e2.push(r2.buffer, n3.buffer), { ids: r2, positions: n3 };
          }
          static deserialize(t2) {
            const e2 = new Ea();
            return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
          }
        }
        function Ca(t2) {
          const e2 = +t2;
          return !isNaN(e2) && Number.MIN_SAFE_INTEGER <= e2 && e2 <= Number.MAX_SAFE_INTEGER ? e2 : Ba(String(t2));
        }
        function Pa(t2, e2, r2, n3) {
          for (; r2 < n3; ) {
            const i2 = t2[r2 + n3 >> 1];
            let s4 = r2 - 1, a2 = n3 + 1;
            for (; ; ) {
              do {
                s4++;
              } while (t2[s4] < i2);
              do {
                a2--;
              } while (t2[a2] > i2);
              if (s4 >= a2)
                break;
              Da(t2, s4, a2), Da(e2, 3 * s4, 3 * a2), Da(e2, 3 * s4 + 1, 3 * a2 + 1), Da(e2, 3 * s4 + 2, 3 * a2 + 2);
            }
            a2 - r2 < n3 - a2 ? (Pa(t2, e2, r2, a2), r2 = a2 + 1) : (Pa(t2, e2, a2 + 1, n3), n3 = a2);
          }
        }
        function Da(t2, e2, r2) {
          const n3 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n3;
        }
        Ji(Ea, "FeaturePositionMap");
        class Va {
          constructor(t2) {
            this.gl = t2.gl, this.initialized = false;
          }
          fetchUniformLocation(t2, e2) {
            return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t2, e2), this.initialized = true), !!this.location;
          }
        }
        class La extends Va {
          constructor(t2) {
            super(t2), this.current = 0;
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1f(this.location, r2));
          }
        }
        class Fa extends Va {
          constructor(t2) {
            super(t2), this.current = [0, 0, 0, 0];
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] && r2[3] === this.current[3] || (this.current = r2, this.gl.uniform4f(this.location, r2[0], r2[1], r2[2], r2[3])));
          }
        }
        class Ra extends Va {
          constructor(t2) {
            super(t2), this.current = Ee.transparent;
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && (r2.r === this.current.r && r2.g === this.current.g && r2.b === this.current.b && r2.a === this.current.a || (this.current = r2, this.gl.uniform4f(this.location, r2.r, r2.g, r2.b, r2.a)));
          }
        }
        const Ua = new Float32Array(16), $a = new Float32Array(9), ja = new Float32Array(4);
        function Oa(t2) {
          return [Ds(255 * t2.r, 255 * t2.g), Ds(255 * t2.b, 255 * t2.a)];
        }
        class qa {
          constructor(t2, e2, r2) {
            this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
          }
          setUniform(t2, e2, r2, n3, i2) {
            e2.set(t2, i2, n3.constantOr(this.value));
          }
          getBinding(t2, e2) {
            return "color" === this.type ? new Ra(t2) : new La(t2);
          }
        }
        class Na {
          constructor(t2, e2) {
            this.uniformNames = e2.map((t3) => `u_${t3}`), this.pattern = null, this.pixelRatio = 1;
          }
          setConstantPatternPositions(t2) {
            this.pixelRatio = t2.pixelRatio || 1, this.pattern = t2.tl.concat(t2.br);
          }
          setUniform(t2, e2, r2, n3, i2) {
            const s4 = "u_pattern" === i2 || "u_dash" === i2 ? this.pattern : "u_pixel_ratio" === i2 ? this.pixelRatio : null;
            s4 && e2.set(t2, i2, s4);
          }
          getBinding(t2, e2) {
            return "u_pattern" === e2 || "u_dash" === e2 ? new Fa(t2) : new La(t2);
          }
        }
        class Ga {
          constructor(t2, e2, r2, n3) {
            this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
          }
          populatePaintArray(t2, e2, r2, n3, i2, s4) {
            const a2 = this.paintVertexArray.length, o2 = this.expression.evaluate(new ws(0), e2, {}, i2, n3, s4);
            this.paintVertexArray.resize(t2), this._setPaintValue(a2, t2, o2);
          }
          updatePaintArray(t2, e2, r2, n3, i2) {
            const s4 = this.expression.evaluate({ zoom: 0 }, r2, n3, void 0, i2);
            this._setPaintValue(t2, e2, s4);
          }
          _setPaintValue(t2, e2, r2) {
            if ("color" === this.type) {
              const n3 = Oa(r2);
              for (let r3 = t2; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, n3[0], n3[1]);
            } else {
              for (let n3 = t2; n3 < e2; n3++)
                this.paintVertexArray.emplace(n3, r2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Za {
          constructor(t2, e2, r2, n3, i2, s4) {
            this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n3, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s4();
          }
          populatePaintArray(t2, e2, r2, n3, i2, s4) {
            const a2 = this.expression.evaluate(new ws(this.zoom), e2, {}, i2, n3, s4), o2 = this.expression.evaluate(new ws(this.zoom + 1), e2, {}, i2, n3, s4), l3 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValue(l3, t2, a2, o2);
          }
          updatePaintArray(t2, e2, r2, n3, i2) {
            const s4 = this.expression.evaluate({ zoom: this.zoom }, r2, n3, void 0, i2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n3, void 0, i2);
            this._setPaintValue(t2, e2, s4, a2);
          }
          _setPaintValue(t2, e2, r2, n3) {
            if ("color" === this.type) {
              const i2 = Oa(r2), s4 = Oa(n3);
              for (let r3 = t2; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, i2[0], i2[1], s4[0], s4[1]);
            } else {
              for (let i2 = t2; i2 < e2; i2++)
                this.paintVertexArray.emplace(i2, r2, n3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n3));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t2, e2, r2, n3, i2) {
            const s4 = this.useIntegerZoom ? Math.floor(r2.zoom) : r2.zoom, a2 = M(this.expression.interpolationFactor(s4, this.zoom, this.zoom + 1), 0, 1);
            e2.set(t2, i2, a2);
          }
          getBinding(t2, e2) {
            return new La(t2);
          }
        }
        class Ka {
          constructor(t2, e2, r2, n3, i2) {
            this.expression = t2, this.layerId = i2, this.paintVertexAttributes = ("array" === r2 ? Aa : _a2).members;
            for (let t3 = 0; t3 < e2.length; ++t3)
              ;
            this.paintVertexArray = new n3();
          }
          populatePaintArray(t2, e2, r2) {
            const n3 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValues(n3, t2, e2.patterns && e2.patterns[this.layerId], r2);
          }
          updatePaintArray(t2, e2, r2, n3, i2, s4) {
            this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], s4);
          }
          _setPaintValues(t2, e2, r2, n3) {
            if (!n3 || !r2)
              return;
            const i2 = n3[r2];
            if (!i2)
              return;
            const { tl: s4, br: a2, pixelRatio: o2 } = i2;
            for (let r3 = t2; r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, s4[0], s4[1], a2[0], a2[1], o2);
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Xa {
          constructor(t2, e2, r2 = () => true) {
            this.binders = {}, this._buffers = [];
            const n3 = [];
            for (const i2 in t2.paint._values) {
              if (!r2(i2))
                continue;
              const s4 = t2.paint.get(i2);
              if (!(s4 instanceof Ts && Ln(s4.property.specification)))
                continue;
              const a2 = Ya(i2, t2.type), o2 = s4.value, l3 = s4.property.specification.type, u3 = !!s4.property.useIntegerZoom, c4 = "line-dasharray" === i2 || i2.endsWith("pattern"), h3 = "line-dasharray" === i2 && "constant" !== t2.layout.get("line-cap").value.kind;
              if ("constant" !== o2.kind || h3)
                if ("source" === o2.kind || h3 || c4) {
                  const e3 = to(i2, l3, "source");
                  this.binders[i2] = c4 ? new Ka(o2, a2, l3, e3, t2.id) : new Ga(o2, a2, l3, e3), n3.push(`/a_${i2}`);
                } else {
                  const t3 = to(i2, l3, "composite");
                  this.binders[i2] = new Za(o2, a2, l3, u3, e2, t3), n3.push(`/z_${i2}`);
                }
              else
                this.binders[i2] = c4 ? new Na(o2.value, a2) : new qa(o2.value, a2, l3), n3.push(`/u_${i2}`);
            }
            this.cacheKey = n3.sort().join("");
          }
          getMaxValue(t2) {
            const e2 = this.binders[t2];
            return e2 instanceof Ga || e2 instanceof Za ? e2.maxValue : 0;
          }
          populatePaintArrays(t2, e2, r2, n3, i2, s4) {
            for (const a2 in this.binders) {
              const o2 = this.binders[a2];
              (o2 instanceof Ga || o2 instanceof Za || o2 instanceof Ka) && o2.populatePaintArray(t2, e2, r2, n3, i2, s4);
            }
          }
          setConstantPatternPositions(t2) {
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              r2 instanceof Na && r2.setConstantPatternPositions(t2);
            }
          }
          updatePaintArrays(t2, e2, r2, n3, i2, s4) {
            let a2 = false;
            for (const o2 in t2) {
              const l3 = e2.getPositions(o2);
              for (const e3 of l3) {
                const l4 = r2.feature(e3.index);
                for (const r3 in this.binders) {
                  const u3 = this.binders[r3];
                  if ((u3 instanceof Ga || u3 instanceof Za || u3 instanceof Ka) && true === u3.expression.isStateDependent) {
                    const c4 = n3.paint.get(r3);
                    u3.expression = c4.value, u3.updatePaintArray(e3.start, e3.end, l4, t2[o2], i2, s4), a2 = true;
                  }
                }
              }
            }
            return a2;
          }
          defines() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof qa || r2 instanceof Na) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
            }
            return t2;
          }
          getBinderAttributes() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof Ga || r2 instanceof Za || r2 instanceof Ka)
                for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                  t2.push(r2.paintVertexAttributes[e3].name);
            }
            return t2;
          }
          getBinderUniforms() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof qa || r2 instanceof Na || r2 instanceof Za)
                for (const e3 of r2.uniformNames)
                  t2.push(e3);
            }
            return t2;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t2) {
            const e2 = [];
            for (const r2 in this.binders) {
              const n3 = this.binders[r2];
              if (n3 instanceof qa || n3 instanceof Na || n3 instanceof Za)
                for (const i2 of n3.uniformNames)
                  e2.push({ name: i2, property: r2, binding: n3.getBinding(t2, i2) });
            }
            return e2;
          }
          setUniforms(t2, e2, r2, n3, i2) {
            for (const { name: e3, property: s4, binding: a2 } of r2)
              this.binders[s4].setUniform(t2, a2, i2, n3.get(s4), e3);
          }
          updatePaintBuffers() {
            this._buffers = [];
            for (const t2 in this.binders) {
              const e2 = this.binders[t2];
              (e2 instanceof Ga || e2 instanceof Za || e2 instanceof Ka) && e2.paintVertexBuffer && this._buffers.push(e2.paintVertexBuffer);
            }
          }
          upload(t2) {
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof Ga || r2 instanceof Za || r2 instanceof Ka) && r2.upload(t2);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t2 in this.binders) {
              const e2 = this.binders[t2];
              (e2 instanceof Ga || e2 instanceof Za || e2 instanceof Ka) && e2.destroy();
            }
          }
        }
        class Ja {
          constructor(t2, e2, r2 = () => true) {
            this.programConfigurations = {};
            for (const n3 of t2)
              this.programConfigurations[n3.id] = new Xa(n3, e2, r2);
            this.needsUpload = false, this._featureMap = new Ea(), this._bufferOffset = 0;
          }
          populatePaintArrays(t2, e2, r2, n3, i2, s4, a2) {
            for (const r3 in this.programConfigurations)
              this.programConfigurations[r3].populatePaintArrays(t2, e2, n3, i2, s4, a2);
            void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
          }
          updatePaintArrays(t2, e2, r2, n3, i2) {
            for (const s4 of r2)
              this.needsUpload = this.programConfigurations[s4.id].updatePaintArrays(t2, this._featureMap, e2, s4, n3, i2) || this.needsUpload;
          }
          get(t2) {
            return this.programConfigurations[t2];
          }
          upload(t2) {
            if (this.needsUpload) {
              for (const e2 in this.programConfigurations)
                this.programConfigurations[e2].upload(t2);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t2 in this.programConfigurations)
              this.programConfigurations[t2].destroy();
          }
        }
        const Ha = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
        function Ya(t2, e2) {
          return Ha[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
        }
        const Wa = { "line-pattern": { source: Gs, composite: Gs }, "fill-pattern": { source: Gs, composite: Gs }, "fill-extrusion-pattern": { source: Gs, composite: Gs }, "line-dasharray": { source: Zs, composite: Zs } }, Qa = { color: { source: ca, composite: Ns }, number: { source: sa, composite: ca } };
        function to(t2, e2, r2) {
          const n3 = Wa[t2];
          return n3 && n3[r2] || Qa[e2][r2];
        }
        Ji(qa, "ConstantBinder"), Ji(Na, "PatternConstantBinder"), Ji(Ga, "SourceExpressionBinder"), Ji(Ka, "PatternCompositeBinder"), Ji(Za, "CompositeExpressionBinder"), Ji(Xa, "ProgramConfiguration", { omit: ["_buffers"] }), Ji(Ja, "ProgramConfigurationSet");
        const eo = "-transition";
        class ro extends Qt {
          constructor(t2, e2) {
            if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && "sky" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new Ms(e2.layout)), e2.paint)) {
              this._transitionablePaint = new Ss(e2.paint);
              for (const e3 in t2.paint)
                this.setPaintProperty(e3, t2.paint[e3], { validate: false });
              for (const e3 in t2.layout)
                this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new zs(e2.paint);
            }
          }
          getLayoutProperty(t2) {
            return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
          }
          setLayoutProperty(t2, e2, r2 = {}) {
            null != e2 && this._validate(ji, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || ("visibility" !== t2 ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
          }
          getPaintProperty(t2) {
            return U(t2, eo) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
          }
          setPaintProperty(t2, e2, r2 = {}) {
            if (null != e2 && this._validate($i, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
              return false;
            if (U(t2, eo))
              return this._transitionablePaint.setTransition(t2.slice(0, -11), e2 || void 0), false;
            {
              const r3 = this._transitionablePaint._values[t2], n3 = r3.value.isDataDriven(), i2 = r3.value;
              this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
              const s4 = this._transitionablePaint._values[t2].value, a2 = s4.isDataDriven(), o2 = U(t2, "pattern") || "line-dasharray" === t2;
              return a2 || n3 || o2 || this._handleOverridablePaintPropertyUpdate(t2, i2, s4);
            }
          }
          _handleSpecialPaintPropertyUpdate(t2) {
          }
          getProgramIds() {
            return null;
          }
          getProgramConfiguration(t2) {
            return null;
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return false;
          }
          isHidden(t2) {
            return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t2) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t2, e2) {
            this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
          }
          serialize() {
            const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), j(t2, (t3, e2) => !(void 0 === t3 || "layout" === e2 && !Object.keys(t3).length || "paint" === e2 && !Object.keys(t3).length));
          }
          _validate(t2, e2, r2, n3, i2 = {}) {
            return (!i2 || false !== i2.validate) && qi(this, t2.call(Ui, { key: e2, layerType: this.type, objectKey: r2, value: n3, styleSpec: te, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isSky() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t2 in this.paint._values) {
              const e2 = this.paint.get(t2);
              if (e2 instanceof Ts && Ln(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent)
                return true;
            }
            return false;
          }
          compileFilter() {
            this._filterCompiled || (this._featureFilter = hi(this.filter), this._filterCompiled = true);
          }
          invalidateCompiledFilter() {
            this._filterCompiled = false;
          }
          dynamicFilter() {
            return this._featureFilter.dynamicFilter;
          }
          dynamicFilterNeedsFeature() {
            return this._featureFilter.needFeature;
          }
        }
        const no = Rs([{ name: "a_pos", components: 2, type: "Int16" }], 4), io = Rs([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
        class so {
          constructor(t2 = []) {
            this.segments = t2;
          }
          prepareSegment(t2, e2, r2, n3) {
            let i2 = this.segments[this.segments.length - 1];
            return t2 > so.MAX_VERTEX_ARRAY_LENGTH && N(`Max vertices per segment is ${so.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > so.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n3) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n3 && (i2.sortKey = n3), this.segments.push(i2)), i2;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t2 of this.segments)
              for (const e2 in t2.vaos)
                t2.vaos[e2].destroy();
          }
          static simpleSegment(t2, e2, r2, n3) {
            return new so([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
          }
        }
        so.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ji(so, "SegmentVector");
        var ao = 8192;
        class oo {
          constructor(t2, e2) {
            t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
          }
          setNorthEast(t2) {
            return this._ne = t2 instanceof Ol ? new Ol(t2.lng, t2.lat) : Ol.convert(t2), this;
          }
          setSouthWest(t2) {
            return this._sw = t2 instanceof Ol ? new Ol(t2.lng, t2.lat) : Ol.convert(t2), this;
          }
          extend(t2) {
            const e2 = this._sw, r2 = this._ne;
            let n3, i2;
            if (t2 instanceof Ol)
              n3 = t2, i2 = t2;
            else {
              if (!(t2 instanceof oo))
                return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(oo.convert(t2)) : this.extend(Ol.convert(t2)) : "object" == typeof t2 && null !== t2 && t2.hasOwnProperty("lat") && (t2.hasOwnProperty("lon") || t2.hasOwnProperty("lng")) ? this.extend(Ol.convert(t2)) : this;
              if (n3 = t2._sw, i2 = t2._ne, !n3 || !i2)
                return this;
            }
            return e2 || r2 ? (e2.lng = Math.min(n3.lng, e2.lng), e2.lat = Math.min(n3.lat, e2.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new Ol(n3.lng, n3.lat), this._ne = new Ol(i2.lng, i2.lat)), this;
          }
          getCenter() {
            return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new Ol(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new Ol(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t2) {
            const { lng: e2, lat: r2 } = Ol.convert(t2);
            let n3 = this._sw.lng <= e2 && e2 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (n3 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n3;
          }
          static convert(t2) {
            return !t2 || t2 instanceof oo ? t2 : new oo(t2);
          }
        }
        var lo = 1e-6, uo = "undefined" != typeof Float32Array ? Float32Array : Array;
        function co() {
          var t2 = new uo(9);
          return uo != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
        }
        function ho(t2, e2, r2) {
          var n3 = e2[0], i2 = e2[1], s4 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u3 = e2[6], c4 = e2[7], h3 = e2[8], p3 = r2[0], d3 = r2[1], f2 = r2[2], y2 = r2[3], m3 = r2[4], g2 = r2[5], x2 = r2[6], v4 = r2[7], b3 = r2[8];
          return t2[0] = p3 * n3 + d3 * a2 + f2 * u3, t2[1] = p3 * i2 + d3 * o2 + f2 * c4, t2[2] = p3 * s4 + d3 * l3 + f2 * h3, t2[3] = y2 * n3 + m3 * a2 + g2 * u3, t2[4] = y2 * i2 + m3 * o2 + g2 * c4, t2[5] = y2 * s4 + m3 * l3 + g2 * h3, t2[6] = x2 * n3 + v4 * a2 + b3 * u3, t2[7] = x2 * i2 + v4 * o2 + b3 * c4, t2[8] = x2 * s4 + v4 * l3 + b3 * h3, t2;
        }
        function po(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function fo(t2, e2) {
          var r2 = e2[0], n3 = e2[1], i2 = e2[2], s4 = e2[3], a2 = e2[4], o2 = e2[5], l3 = e2[6], u3 = e2[7], c4 = e2[8], h3 = e2[9], p3 = e2[10], d3 = e2[11], f2 = e2[12], y2 = e2[13], m3 = e2[14], g2 = e2[15], x2 = r2 * o2 - n3 * a2, v4 = r2 * l3 - i2 * a2, b3 = r2 * u3 - s4 * a2, w2 = n3 * l3 - i2 * o2, _2 = n3 * u3 - s4 * o2, A2 = i2 * u3 - s4 * l3, S2 = c4 * y2 - h3 * f2, k2 = c4 * m3 - p3 * f2, I2 = c4 * g2 - d3 * f2, M2 = h3 * m3 - p3 * y2, T3 = h3 * g2 - d3 * y2, z2 = p3 * g2 - d3 * m3, B2 = x2 * z2 - v4 * T3 + b3 * M2 + w2 * I2 - _2 * k2 + A2 * S2;
          return B2 ? (t2[0] = (o2 * z2 - l3 * T3 + u3 * M2) * (B2 = 1 / B2), t2[1] = (i2 * T3 - n3 * z2 - s4 * M2) * B2, t2[2] = (y2 * A2 - m3 * _2 + g2 * w2) * B2, t2[3] = (p3 * _2 - h3 * A2 - d3 * w2) * B2, t2[4] = (l3 * I2 - a2 * z2 - u3 * k2) * B2, t2[5] = (r2 * z2 - i2 * I2 + s4 * k2) * B2, t2[6] = (m3 * b3 - f2 * A2 - g2 * v4) * B2, t2[7] = (c4 * A2 - p3 * b3 + d3 * v4) * B2, t2[8] = (a2 * T3 - o2 * I2 + u3 * S2) * B2, t2[9] = (n3 * I2 - r2 * T3 - s4 * S2) * B2, t2[10] = (f2 * _2 - y2 * b3 + g2 * x2) * B2, t2[11] = (h3 * b3 - c4 * _2 - d3 * x2) * B2, t2[12] = (o2 * k2 - a2 * M2 - l3 * S2) * B2, t2[13] = (r2 * M2 - n3 * k2 + i2 * S2) * B2, t2[14] = (y2 * v4 - f2 * w2 - m3 * x2) * B2, t2[15] = (c4 * w2 - h3 * v4 + p3 * x2) * B2, t2) : null;
        }
        function yo(t2, e2, r2) {
          var n3 = e2[0], i2 = e2[1], s4 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u3 = e2[6], c4 = e2[7], h3 = e2[8], p3 = e2[9], d3 = e2[10], f2 = e2[11], y2 = e2[12], m3 = e2[13], g2 = e2[14], x2 = e2[15], v4 = r2[0], b3 = r2[1], w2 = r2[2], _2 = r2[3];
          return t2[0] = v4 * n3 + b3 * o2 + w2 * h3 + _2 * y2, t2[1] = v4 * i2 + b3 * l3 + w2 * p3 + _2 * m3, t2[2] = v4 * s4 + b3 * u3 + w2 * d3 + _2 * g2, t2[3] = v4 * a2 + b3 * c4 + w2 * f2 + _2 * x2, t2[4] = (v4 = r2[4]) * n3 + (b3 = r2[5]) * o2 + (w2 = r2[6]) * h3 + (_2 = r2[7]) * y2, t2[5] = v4 * i2 + b3 * l3 + w2 * p3 + _2 * m3, t2[6] = v4 * s4 + b3 * u3 + w2 * d3 + _2 * g2, t2[7] = v4 * a2 + b3 * c4 + w2 * f2 + _2 * x2, t2[8] = (v4 = r2[8]) * n3 + (b3 = r2[9]) * o2 + (w2 = r2[10]) * h3 + (_2 = r2[11]) * y2, t2[9] = v4 * i2 + b3 * l3 + w2 * p3 + _2 * m3, t2[10] = v4 * s4 + b3 * u3 + w2 * d3 + _2 * g2, t2[11] = v4 * a2 + b3 * c4 + w2 * f2 + _2 * x2, t2[12] = (v4 = r2[12]) * n3 + (b3 = r2[13]) * o2 + (w2 = r2[14]) * h3 + (_2 = r2[15]) * y2, t2[13] = v4 * i2 + b3 * l3 + w2 * p3 + _2 * m3, t2[14] = v4 * s4 + b3 * u3 + w2 * d3 + _2 * g2, t2[15] = v4 * a2 + b3 * c4 + w2 * f2 + _2 * x2, t2;
        }
        function mo(t2, e2, r2) {
          var n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3, f2, y2 = r2[0], m3 = r2[1], g2 = r2[2];
          return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m3 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m3 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m3 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m3 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s4 = e2[2], a2 = e2[3], o2 = e2[4], l3 = e2[5], u3 = e2[6], c4 = e2[7], h3 = e2[8], p3 = e2[9], d3 = e2[10], f2 = e2[11], t2[0] = n3 = e2[0], t2[1] = i2, t2[2] = s4, t2[3] = a2, t2[4] = o2, t2[5] = l3, t2[6] = u3, t2[7] = c4, t2[8] = h3, t2[9] = p3, t2[10] = d3, t2[11] = f2, t2[12] = n3 * y2 + o2 * m3 + h3 * g2 + e2[12], t2[13] = i2 * y2 + l3 * m3 + p3 * g2 + e2[13], t2[14] = s4 * y2 + u3 * m3 + d3 * g2 + e2[14], t2[15] = a2 * y2 + c4 * m3 + f2 * g2 + e2[15]), t2;
        }
        function go(t2, e2, r2) {
          var n3 = r2[0], i2 = r2[1], s4 = r2[2];
          return t2[0] = e2[0] * n3, t2[1] = e2[1] * n3, t2[2] = e2[2] * n3, t2[3] = e2[3] * n3, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s4, t2[9] = e2[9] * s4, t2[10] = e2[10] * s4, t2[11] = e2[11] * s4, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }
        function xo(t2, e2, r2) {
          var n3 = Math.sin(r2), i2 = Math.cos(r2), s4 = e2[4], a2 = e2[5], o2 = e2[6], l3 = e2[7], u3 = e2[8], c4 = e2[9], h3 = e2[10], p3 = e2[11];
          return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s4 * i2 + u3 * n3, t2[5] = a2 * i2 + c4 * n3, t2[6] = o2 * i2 + h3 * n3, t2[7] = l3 * i2 + p3 * n3, t2[8] = u3 * i2 - s4 * n3, t2[9] = c4 * i2 - a2 * n3, t2[10] = h3 * i2 - o2 * n3, t2[11] = p3 * i2 - l3 * n3, t2;
        }
        function vo(t2, e2, r2) {
          var n3 = Math.sin(r2), i2 = Math.cos(r2), s4 = e2[0], a2 = e2[1], o2 = e2[2], l3 = e2[3], u3 = e2[8], c4 = e2[9], h3 = e2[10], p3 = e2[11];
          return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s4 * i2 - u3 * n3, t2[1] = a2 * i2 - c4 * n3, t2[2] = o2 * i2 - h3 * n3, t2[3] = l3 * i2 - p3 * n3, t2[8] = s4 * n3 + u3 * i2, t2[9] = a2 * n3 + c4 * i2, t2[10] = o2 * n3 + h3 * i2, t2[11] = l3 * n3 + p3 * i2, t2;
        }
        function bo(t2, e2) {
          return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function wo(t2, e2, r2) {
          var n3, i2, s4, a2 = r2[0], o2 = r2[1], l3 = r2[2], u3 = Math.hypot(a2, o2, l3);
          return u3 < lo ? null : (a2 *= u3 = 1 / u3, o2 *= u3, l3 *= u3, n3 = Math.sin(e2), i2 = Math.cos(e2), t2[0] = a2 * a2 * (s4 = 1 - i2) + i2, t2[1] = o2 * a2 * s4 + l3 * n3, t2[2] = l3 * a2 * s4 - o2 * n3, t2[3] = 0, t2[4] = a2 * o2 * s4 - l3 * n3, t2[5] = o2 * o2 * s4 + i2, t2[6] = l3 * o2 * s4 + a2 * n3, t2[7] = 0, t2[8] = a2 * l3 * s4 + o2 * n3, t2[9] = o2 * l3 * s4 - a2 * n3, t2[10] = l3 * l3 * s4 + i2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
        }
        Math.hypot || (Math.hypot = function() {
          for (var t2 = 0, e2 = arguments.length; e2--; )
            t2 += arguments[e2] * arguments[e2];
          return Math.sqrt(t2);
        });
        var _o = yo;
        function Ao() {
          var t2 = new uo(3);
          return uo != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
        }
        function So(t2) {
          var e2 = new uo(3);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
        }
        function ko(t2) {
          return Math.hypot(t2[0], t2[1], t2[2]);
        }
        function Io(t2, e2, r2) {
          var n3 = new uo(3);
          return n3[0] = t2, n3[1] = e2, n3[2] = r2, n3;
        }
        function Mo(t2, e2, r2) {
          return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
        }
        function To(t2, e2, r2) {
          return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
        }
        function zo(t2, e2, r2) {
          return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2;
        }
        function Bo(t2, e2, r2) {
          return t2[0] = Math.min(e2[0], r2[0]), t2[1] = Math.min(e2[1], r2[1]), t2[2] = Math.min(e2[2], r2[2]), t2;
        }
        function Eo(t2, e2, r2) {
          return t2[0] = Math.max(e2[0], r2[0]), t2[1] = Math.max(e2[1], r2[1]), t2[2] = Math.max(e2[2], r2[2]), t2;
        }
        function Co(t2, e2, r2) {
          return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
        }
        function Po(t2, e2, r2, n3) {
          return t2[0] = e2[0] + r2[0] * n3, t2[1] = e2[1] + r2[1] * n3, t2[2] = e2[2] + r2[2] * n3, t2;
        }
        function Do(t2, e2) {
          var r2 = e2[0], n3 = e2[1], i2 = e2[2], s4 = r2 * r2 + n3 * n3 + i2 * i2;
          return s4 > 0 && (s4 = 1 / Math.sqrt(s4)), t2[0] = e2[0] * s4, t2[1] = e2[1] * s4, t2[2] = e2[2] * s4, t2;
        }
        function Vo(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
        }
        function Lo(t2, e2, r2) {
          var n3 = e2[0], i2 = e2[1], s4 = e2[2], a2 = r2[0], o2 = r2[1], l3 = r2[2];
          return t2[0] = i2 * l3 - s4 * o2, t2[1] = s4 * a2 - n3 * l3, t2[2] = n3 * o2 - i2 * a2, t2;
        }
        function Fo(t2, e2, r2) {
          var n3 = e2[0], i2 = e2[1], s4 = e2[2], a2 = r2[3] * n3 + r2[7] * i2 + r2[11] * s4 + r2[15];
          return t2[0] = (r2[0] * n3 + r2[4] * i2 + r2[8] * s4 + r2[12]) / (a2 = a2 || 1), t2[1] = (r2[1] * n3 + r2[5] * i2 + r2[9] * s4 + r2[13]) / a2, t2[2] = (r2[2] * n3 + r2[6] * i2 + r2[10] * s4 + r2[14]) / a2, t2;
        }
        function Ro(t2, e2, r2) {
          var n3 = r2[0], i2 = r2[1], s4 = r2[2], a2 = e2[0], o2 = e2[1], l3 = e2[2], u3 = i2 * l3 - s4 * o2, c4 = s4 * a2 - n3 * l3, h3 = n3 * o2 - i2 * a2, p3 = i2 * h3 - s4 * c4, d3 = s4 * u3 - n3 * h3, f2 = n3 * c4 - i2 * u3, y2 = 2 * r2[3];
          return c4 *= y2, h3 *= y2, d3 *= 2, f2 *= 2, t2[0] = a2 + (u3 *= y2) + (p3 *= 2), t2[1] = o2 + c4 + d3, t2[2] = l3 + h3 + f2, t2;
        }
        var Uo, $o = To, jo = zo, Oo = ko;
        function qo(t2, e2, r2) {
          return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2[3] = e2[3] * r2, t2;
        }
        function No(t2, e2) {
          var r2 = e2[0], n3 = e2[1], i2 = e2[2], s4 = e2[3], a2 = r2 * r2 + n3 * n3 + i2 * i2 + s4 * s4;
          return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = r2 * a2, t2[1] = n3 * a2, t2[2] = i2 * a2, t2[3] = s4 * a2, t2;
        }
        function Go(t2, e2, r2) {
          var n3 = e2[0], i2 = e2[1], s4 = e2[2], a2 = e2[3];
          return t2[0] = r2[0] * n3 + r2[4] * i2 + r2[8] * s4 + r2[12] * a2, t2[1] = r2[1] * n3 + r2[5] * i2 + r2[9] * s4 + r2[13] * a2, t2[2] = r2[2] * n3 + r2[6] * i2 + r2[10] * s4 + r2[14] * a2, t2[3] = r2[3] * n3 + r2[7] * i2 + r2[11] * s4 + r2[15] * a2, t2;
        }
        function Zo() {
          var t2 = new uo(4);
          return uo != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
        }
        function Ko(t2) {
          return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
        }
        function Xo(t2, e2, r2) {
          r2 *= 0.5;
          var n3 = e2[0], i2 = e2[1], s4 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l3 = Math.cos(r2);
          return t2[0] = n3 * l3 + a2 * o2, t2[1] = i2 * l3 + s4 * o2, t2[2] = s4 * l3 - i2 * o2, t2[3] = a2 * l3 - n3 * o2, t2;
        }
        function Jo(t2, e2, r2) {
          r2 *= 0.5;
          var n3 = e2[0], i2 = e2[1], s4 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l3 = Math.cos(r2);
          return t2[0] = n3 * l3 - s4 * o2, t2[1] = i2 * l3 + a2 * o2, t2[2] = s4 * l3 + n3 * o2, t2[3] = a2 * l3 - i2 * o2, t2;
        }
        Ao(), Uo = new uo(4), uo != Float32Array && (Uo[0] = 0, Uo[1] = 0, Uo[2] = 0, Uo[3] = 0);
        var Ho = No;
        Ao(), Io(1, 0, 0), Io(0, 1, 0), Zo(), Zo(), co();
        const Yo = Rs([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: Wo } = Yo, Qo = Rs([{ name: "a_pos_3", components: 3, type: "Int16" }]);
        var tl = Rs([{ name: "a_pos", type: "Int16", components: 2 }]);
        class el {
          constructor(t2, e2) {
            this.pos = t2, this.dir = e2;
          }
          intersectsPlane(t2, e2, r2) {
            const n3 = Vo(e2, this.dir);
            if (Math.abs(n3) < 1e-6)
              return false;
            const i2 = ((t2[0] - this.pos[0]) * e2[0] + (t2[1] - this.pos[1]) * e2[1] + (t2[2] - this.pos[2]) * e2[2]) / n3;
            return r2[0] = this.pos[0] + this.dir[0] * i2, r2[1] = this.pos[1] + this.dir[1] * i2, r2[2] = this.pos[2] + this.dir[2] * i2, true;
          }
          closestPointOnSphere(t2, e2, r2) {
            if (function(t3, e3) {
              var r3 = t3[0], n4 = t3[1], i3 = t3[2], s5 = e3[0], a3 = e3[1], o3 = e3[2];
              return Math.abs(r3 - s5) <= lo * Math.max(1, Math.abs(r3), Math.abs(s5)) && Math.abs(n4 - a3) <= lo * Math.max(1, Math.abs(n4), Math.abs(a3)) && Math.abs(i3 - o3) <= lo * Math.max(1, Math.abs(i3), Math.abs(o3));
            }(this.pos, t2) || 0 === e2)
              return r2[0] = r2[1] = r2[2] = 0, false;
            const [n3, i2, s4] = this.dir, a2 = this.pos[0] - t2[0], o2 = this.pos[1] - t2[1], l3 = this.pos[2] - t2[2], u3 = n3 * n3 + i2 * i2 + s4 * s4, c4 = 2 * (a2 * n3 + o2 * i2 + l3 * s4), h3 = c4 * c4 - 4 * u3 * (a2 * a2 + o2 * o2 + l3 * l3 - e2 * e2);
            if (h3 < 0) {
              const t3 = Math.max(-c4 / 2, 0), u4 = a2 + n3 * t3, h4 = o2 + i2 * t3, p3 = l3 + s4 * t3, d3 = Math.hypot(u4, h4, p3);
              return r2[0] = u4 * e2 / d3, r2[1] = h4 * e2 / d3, r2[2] = p3 * e2 / d3, false;
            }
            {
              const t3 = (-c4 - Math.sqrt(h3)) / (2 * u3);
              if (t3 < 0) {
                const t4 = Math.hypot(a2, o2, l3);
                return r2[0] = a2 * e2 / t4, r2[1] = o2 * e2 / t4, r2[2] = l3 * e2 / t4, false;
              }
              return r2[0] = a2 + n3 * t3, r2[1] = o2 + i2 * t3, r2[2] = l3 + s4 * t3, true;
            }
          }
        }
        class rl {
          constructor(t2, e2, r2, n3, i2) {
            this.TL = t2, this.TR = e2, this.BR = r2, this.BL = n3, this.horizon = i2;
          }
          static fromInvProjectionMatrix(t2, e2, r2) {
            const n3 = [-1, 1, 1], i2 = [1, 1, 1], s4 = [1, -1, 1], a2 = [-1, -1, 1], o2 = Fo(n3, n3, t2), l3 = Fo(i2, i2, t2), u3 = Fo(s4, s4, t2), c4 = Fo(a2, a2, t2);
            return new rl(o2, l3, u3, c4, e2 / r2);
          }
        }
        class nl {
          constructor(t2, e2) {
            this.points = t2, this.planes = e2;
          }
          static fromInvProjectionMatrix(t2, e2, r2, n3) {
            const i2 = Math.pow(2, r2), s4 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
              const s5 = Go([], r3, t2), a3 = 1 / s5[3] / e2 * i2;
              return function(t3, e3, r4) {
                return t3[0] = e3[0] * r4[0], t3[1] = e3[1] * r4[1], t3[2] = e3[2] * r4[2], t3[3] = e3[3] * r4[3], t3;
              }(s5, s5, [a3, a3, n3 ? 1 / s5[3] : a3, a3]);
            }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
              const e3 = Do([], Lo([], $o([], s4[t3[0]], s4[t3[1]]), $o([], s4[t3[2]], s4[t3[1]]))), r3 = -Vo(e3, s4[t3[1]]);
              return e3.concat(r3);
            });
            return new nl(s4, a2);
          }
        }
        class il {
          static fromPoints(t2) {
            const e2 = [1 / 0, 1 / 0, 1 / 0], r2 = [-1 / 0, -1 / 0, -1 / 0];
            for (const n3 of t2)
              Bo(e2, e2, n3), Eo(r2, r2, n3);
            return new il(e2, r2);
          }
          static applyTransform(t2, e2) {
            const r2 = t2.getCorners();
            for (let t3 = 0; t3 < r2.length; ++t3)
              Fo(r2[t3], r2[t3], e2);
            return il.fromPoints(r2);
          }
          constructor(t2, e2) {
            this.min = t2, this.max = e2, this.center = Co([], Mo([], this.min, this.max), 0.5);
          }
          quadrant(t2) {
            const e2 = [t2 % 2 == 0, t2 < 2], r2 = So(this.min), n3 = So(this.max);
            for (let t3 = 0; t3 < e2.length; t3++)
              r2[t3] = e2[t3] ? this.min[t3] : this.center[t3], n3[t3] = e2[t3] ? this.center[t3] : this.max[t3];
            return n3[2] = this.max[2], new il(r2, n3);
          }
          distanceX(t2) {
            return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
          }
          distanceY(t2) {
            return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
          }
          distanceZ(t2) {
            return Math.max(Math.min(this.max[2], t2[2]), this.min[2]) - t2[2];
          }
          getCorners() {
            const t2 = this.min, e2 = this.max;
            return [[t2[0], t2[1], t2[2]], [e2[0], t2[1], t2[2]], [e2[0], e2[1], t2[2]], [t2[0], e2[1], t2[2]], [t2[0], t2[1], e2[2]], [e2[0], t2[1], e2[2]], [e2[0], e2[1], e2[2]], [t2[0], e2[1], e2[2]]];
          }
          intersects(t2) {
            const e2 = this.getCorners();
            let r2 = true;
            for (let n3 = 0; n3 < t2.planes.length; n3++) {
              const i2 = t2.planes[n3];
              let s4 = 0;
              for (let t3 = 0; t3 < e2.length; t3++)
                s4 += Vo(i2, e2[t3]) + i2[3] >= 0;
              if (0 === s4)
                return 0;
              s4 !== e2.length && (r2 = false);
            }
            if (r2)
              return 2;
            for (let e3 = 0; e3 < 3; e3++) {
              let r3 = Number.MAX_VALUE, n3 = -Number.MAX_VALUE;
              for (let i2 = 0; i2 < t2.points.length; i2++) {
                const s4 = t2.points[i2][e3] - this.min[e3];
                r3 = Math.min(r3, s4), n3 = Math.max(n3, s4);
              }
              if (n3 < 0 || r3 > this.max[e3] - this.min[e3])
                return 0;
            }
            return 1;
          }
        }
        const sl = 5, al = 6, ol = ao / Math.PI / 2, ll = 16383, ul = 64, cl = [ul, 32, 16], hl = -ol, pl = ol, dl = [new il([hl, hl, hl], [pl, pl, pl]), new il([hl, hl, hl], [0, 0, pl]), new il([0, hl, hl], [pl, 0, pl]), new il([hl, 0, hl], [0, pl, pl]), new il([0, 0, hl], [pl, pl, pl])];
        function fl(t2) {
          return t2 * ol / Ul;
        }
        function yl(t2, e2, r2, n3 = true) {
          const i2 = Co([], t2._camera.position, t2.worldSize), s4 = [e2, r2, 1, 1];
          Go(s4, s4, t2.pixelMatrixInverse), qo(s4, s4, 1 / s4[3]);
          const a2 = Do([], $o([], s4, i2)), o2 = t2.globeMatrix, l3 = [o2[12], o2[13], o2[14]], u3 = $o([], l3, i2), c4 = ko(u3), h3 = Do([], u3), p3 = t2.worldSize / (2 * Math.PI), d3 = Vo(h3, a2), f2 = Math.asin(p3 / c4);
          if (f2 < Math.acos(d3)) {
            if (!n3)
              return null;
            const t3 = [], e3 = [];
            Co(t3, a2, c4 / d3), Do(e3, $o(e3, t3, u3)), Do(a2, Mo(a2, u3, Co(a2, e3, Math.tan(f2) * c4)));
          }
          const y2 = [];
          new el(i2, a2).closestPointOnSphere(l3, p3, y2);
          const m3 = Do([], W(o2, 0)), g2 = Do([], W(o2, 1)), x2 = Do([], W(o2, 2)), v4 = Vo(m3, y2), b3 = Vo(g2, y2), w2 = Vo(x2, y2), A2 = _(Math.asin(-b3 / p3));
          let S2 = _(Math.atan2(v4, w2));
          S2 = t2.center.lng + function(t3, e3) {
            const r3 = (e3 - t3 + 180) % 360 - 180;
            return r3 < -180 ? r3 + 360 : r3;
          }(t2.center.lng, S2);
          const k2 = Nl(S2), I2 = M(Gl(A2), 0, 1);
          return new Wl(k2, I2);
        }
        class ml {
          constructor(t2, e2, r2) {
            this.a = $o([], t2, r2), this.b = $o([], e2, r2), this.center = r2;
            const n3 = Do([], this.a), i2 = Do([], this.b);
            this.angle = Math.acos(Vo(n3, i2));
          }
        }
        function gl(t2, e2) {
          if (0 === t2.angle)
            return null;
          let r2;
          return r2 = 0 === t2.a[e2] ? 1 / t2.angle * 0.5 * Math.PI : 1 / t2.angle * Math.atan(t2.b[e2] / t2.a[e2] / Math.sin(t2.angle) - 1 / Math.tan(t2.angle)), r2 < 0 || r2 > 1 ? null : function(t3, e3, r3, n3) {
            const i2 = Math.sin(r3);
            return t3 * (Math.sin((1 - n3) * r3) / i2) + e3 * (Math.sin(n3 * r3) / i2);
          }(t2.a[e2], t2.b[e2], t2.angle, M(r2, 0, 1)) + t2.center[e2];
        }
        function xl(t2) {
          if (t2.z <= 1)
            return dl[t2.z + 2 * t2.y + t2.x];
          const e2 = Sl(Al(t2));
          return il.fromPoints(e2);
        }
        function vl(t2, e2, r2) {
          return Co(t2, t2, 1 - r2), Po(t2, t2, e2, r2);
        }
        function bl(t2, e2) {
          const r2 = Pl(e2.zoom);
          if (0 === r2)
            return xl(t2);
          const n3 = Al(t2), i2 = Sl(n3), s4 = Nl(n3.getWest()) * e2.worldSize, a2 = Nl(n3.getEast()) * e2.worldSize, o2 = Gl(n3.getNorth()) * e2.worldSize, l3 = Gl(n3.getSouth()) * e2.worldSize, u3 = [s4, o2, 0], c4 = [a2, o2, 0], h3 = [s4, l3, 0], p3 = [a2, l3, 0], d3 = fo([], e2.globeMatrix);
          return Fo(u3, u3, d3), Fo(c4, c4, d3), Fo(h3, h3, d3), Fo(p3, p3, d3), i2[0] = vl(i2[0], h3, r2), i2[1] = vl(i2[1], p3, r2), i2[2] = vl(i2[2], c4, r2), i2[3] = vl(i2[3], u3, r2), il.fromPoints(i2);
        }
        function wl(t2, e2, r2) {
          for (const n3 of t2)
            Fo(n3, n3, e2), Co(n3, n3, r2);
        }
        function _l(t2, e2, r2) {
          const n3 = e2 / t2.worldSize, i2 = t2.globeMatrix;
          if (r2.z <= 1) {
            const t3 = xl(r2).getCorners();
            return wl(t3, i2, n3), il.fromPoints(t3);
          }
          const s4 = Al(r2), a2 = Sl(s4);
          wl(a2, i2, n3);
          const o2 = Number.MAX_VALUE, l3 = [-o2, -o2, -o2], u3 = [o2, o2, o2];
          if (s4.contains(t2.center)) {
            for (const t3 of a2)
              Bo(u3, u3, t3), Eo(l3, l3, t3);
            l3[2] = 0;
            const e3 = t2.point, r3 = [e3.x * n3, e3.y * n3, 0];
            return Bo(u3, u3, r3), Eo(l3, l3, r3), new il(u3, l3);
          }
          const c4 = [i2[12] * n3, i2[13] * n3, i2[14] * n3], h3 = s4.getCenter(), p3 = M(t2.center.lat, -Hl, Hl), d3 = M(h3.lat, -Hl, Hl), f2 = Nl(t2.center.lng), y2 = Gl(p3);
          let m3 = f2 - Nl(h3.lng);
          const g2 = y2 - Gl(d3);
          m3 > 0.5 ? m3 -= 1 : m3 < -0.5 && (m3 += 1);
          let x2 = 0;
          Math.abs(m3) > Math.abs(g2) ? x2 = m3 >= 0 ? 1 : 3 : (x2 = g2 >= 0 ? 0 : 2, Po(c4, c4, [i2[4] * n3, i2[5] * n3, i2[6] * n3], -Math.sin(w(g2 >= 0 ? s4.getSouth() : s4.getNorth())) * ol));
          const v4 = a2[x2], b3 = a2[(x2 + 1) % 4], _2 = new ml(v4, b3, c4), A2 = [gl(_2, 0) || v4[0], gl(_2, 1) || v4[1], gl(_2, 2) || v4[2]], S2 = Pl(t2.zoom);
          if (S2 > 0) {
            const n4 = function({ x: t3, y: e3, z: r3 }, n5, i4, s5, a3) {
              const o3 = 1 / (1 << r3);
              let l4 = t3 * o3, u4 = l4 + o3, c5 = e3 * o3, h4 = c5 + o3, p4 = 0;
              const d4 = (l4 + u4) / 2 - s5;
              return d4 > 0.5 ? p4 = -1 : d4 < -0.5 && (p4 = 1), l4 = ((l4 + p4) * n5 - (s5 *= n5)) * i4 + s5, u4 = ((u4 + p4) * n5 - s5) * i4 + s5, c5 = (c5 * n5 - (a3 *= n5)) * i4 + a3, h4 = (h4 * n5 - a3) * i4 + a3, [[l4, h4, 0], [u4, h4, 0], [u4, c5, 0], [l4, c5, 0]];
            }(r2, e2, t2._pixelsPerMercatorPixel, f2, y2);
            for (let t3 = 0; t3 < a2.length; t3++)
              vl(a2[t3], n4[t3], S2);
            const i3 = Mo([], n4[x2], n4[(x2 + 1) % 4]);
            Co(i3, i3, 0.5), vl(A2, i3, S2);
          }
          for (const t3 of a2)
            Bo(u3, u3, t3), Eo(l3, l3, t3);
          return u3[2] = Math.min(v4[2], b3[2]), Bo(u3, u3, A2), Eo(l3, l3, A2), new il(u3, l3);
        }
        function Al({ x: t2, y: e2, z: r2 }) {
          const n3 = 1 / (1 << r2), i2 = new Ol(Kl(t2 * n3), Xl((e2 + 1) * n3)), s4 = new Ol(Kl((t2 + 1) * n3), Xl(e2 * n3));
          return new oo(i2, s4);
        }
        function Sl(t2) {
          const e2 = w(t2.getNorth()), r2 = w(t2.getSouth()), n3 = Math.cos(e2), i2 = Math.cos(r2), s4 = Math.sin(e2), a2 = Math.sin(r2), o2 = t2.getWest(), l3 = t2.getEast();
          return [kl(i2, a2, o2), kl(i2, a2, l3), kl(n3, s4, l3), kl(n3, s4, o2)];
        }
        function kl(t2, e2, r2, n3 = ol) {
          return r2 = w(r2), [t2 * Math.sin(r2) * n3, -e2 * n3, t2 * Math.cos(r2) * n3];
        }
        function Il(t2, e2, r2) {
          return kl(Math.cos(w(t2)), Math.sin(w(t2)), e2, r2);
        }
        function Ml(t2, e2, r2, n3) {
          const i2 = 1 << r2.z, s4 = (t2 / ao + r2.x) / i2;
          return Il(Xl((e2 / ao + r2.y) / i2), Kl(s4), n3);
        }
        function Tl({ min: t2, max: e2 }) {
          return ll / Math.max(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
        }
        const zl = new Float64Array(16);
        function Bl(t2) {
          const e2 = Tl(t2), r2 = bo(zl, [e2, e2, e2]);
          return mo(r2, r2, ((n3 = [])[0] = -(i2 = t2.min)[0], n3[1] = -i2[1], n3[2] = -i2[2], n3));
          var n3, i2;
        }
        function El(t2) {
          const e2 = (n3 = t2.min, (r2 = zl)[0] = 1, r2[1] = 0, r2[2] = 0, r2[3] = 0, r2[4] = 0, r2[5] = 1, r2[6] = 0, r2[7] = 0, r2[8] = 0, r2[9] = 0, r2[10] = 1, r2[11] = 0, r2[12] = n3[0], r2[13] = n3[1], r2[14] = n3[2], r2[15] = 1, r2);
          var r2, n3;
          const i2 = 1 / Tl(t2);
          return go(e2, e2, [i2, i2, i2]);
        }
        function Cl(t2, e2, r2, n3, i2) {
          const s4 = function(t3) {
            const e3 = ao / (2 * Math.PI);
            return t3 / (2 * Math.PI) / e3;
          }(r2), a2 = [t2, e2, -r2 / (2 * Math.PI)], o2 = po(new Float64Array(16));
          return mo(o2, o2, a2), go(o2, o2, [s4, s4, s4]), xo(o2, o2, w(-i2)), vo(o2, o2, w(-n3)), o2;
        }
        function Pl(t2) {
          return T2(sl, al, t2);
        }
        function Dl(t2, e2) {
          const r2 = Il(e2.lat, e2.lng), n3 = function(t3) {
            const e3 = Il(t3._center.lat, t3._center.lng);
            let r3 = Lo([], Io(0, 1, 0), e3);
            const n4 = wo([], -t3.angle, e3);
            r3 = Fo(r3, r3, n4), wo(n4, -t3._pitch, r3);
            const i3 = Do([], e3);
            return Co(i3, i3, fl(t3.cameraToCenterDistance / t3.pixelsPerMeter)), Fo(i3, i3, n4), Mo([], e3, i3);
          }(t2);
          return a2 = (i2 = To([], n3, r2))[0], o2 = i2[1], l3 = i2[2], u3 = (s4 = r2)[0], c4 = s4[1], h3 = s4[2], d3 = (p3 = Math.sqrt(a2 * a2 + o2 * o2 + l3 * l3) * Math.sqrt(u3 * u3 + c4 * c4 + h3 * h3)) && Vo(i2, s4) / p3, Math.acos(Math.min(Math.max(d3, -1), 1));
          var i2, s4, a2, o2, l3, u3, c4, h3, p3, d3;
        }
        function Vl(t2, e2) {
          return Dl(t2, e2) > Math.PI / 2 * 1.01;
        }
        const Ll = w(85), Fl = Math.cos(Ll), Rl = Math.sin(Ll), Ul = 63710088e-1, $l = 2 * Math.PI * Ul;
        class jl {
          constructor(t2, e2) {
            if (isNaN(t2) || isNaN(e2))
              throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
            if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new jl(z(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t2) {
            const e2 = Math.PI / 180, r2 = this.lat * e2, n3 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n3) + Math.cos(r2) * Math.cos(n3) * Math.cos((t2.lng - this.lng) * e2);
            return Ul * Math.acos(Math.min(i2, 1));
          }
          toBounds(t2 = 0) {
            const e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
            return new oo(new jl(this.lng - r2, this.lat - e2), new jl(this.lng + r2, this.lat + e2));
          }
          toEcef(t2) {
            const e2 = fl(t2);
            return Il(this.lat, this.lng, ol + e2);
          }
          static convert(t2) {
            if (t2 instanceof jl)
              return t2;
            if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
              return new jl(Number(t2[0]), Number(t2[1]));
            if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
              return new jl(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        var Ol = jl;
        function ql(t2) {
          return $l * Math.cos(t2 * Math.PI / 180);
        }
        function Nl(t2) {
          return (180 + t2) / 360;
        }
        function Gl(t2) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
        }
        function Zl(t2, e2) {
          return t2 / ql(e2);
        }
        function Kl(t2) {
          return 360 * t2 - 180;
        }
        function Xl(t2) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
        }
        function Jl(t2, e2) {
          return t2 * ql(Xl(e2));
        }
        const Hl = 85.051129;
        function Yl(t2) {
          return 1 / Math.cos(t2 * Math.PI / 180);
        }
        class Wl {
          constructor(t2, e2, r2 = 0) {
            this.x = +t2, this.y = +e2, this.z = +r2;
          }
          static fromLngLat(t2, e2 = 0) {
            const r2 = Ol.convert(t2);
            return new Wl(Nl(r2.lng), Gl(r2.lat), Zl(e2, r2.lat));
          }
          toLngLat() {
            return new Ol(Kl(this.x), Xl(this.y));
          }
          toAltitude() {
            return Jl(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / $l * Yl(Xl(this.y));
          }
        }
        function Ql(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
          const u3 = (e2 + n3) / 2, c4 = (r2 + i2) / 2, h3 = new x(u3, c4);
          o2(h3), function(t3, e3, r3, n4, i3, s5) {
            const a3 = r3 - i3, o3 = n4 - s5;
            return Math.abs((n4 - e3) * a3 - (r3 - t3) * o3) / Math.hypot(a3, o3);
          }(h3.x, h3.y, s4.x, s4.y, a2.x, a2.y) >= l3 ? (Ql(t2, e2, r2, u3, c4, s4, h3, o2, l3), Ql(t2, u3, c4, n3, i2, h3, a2, o2, l3)) : t2.push(a2);
        }
        function tu(t2, e2, r2) {
          let n3 = t2[0], i2 = n3.x, s4 = n3.y;
          e2(n3);
          const a2 = [n3];
          for (let o2 = 1; o2 < t2.length; o2++) {
            const l3 = t2[o2], { x: u3, y: c4 } = l3;
            e2(l3), Ql(a2, i2, s4, u3, c4, n3, l3, e2, r2), i2 = u3, s4 = c4, n3 = l3;
          }
          return a2;
        }
        function eu(t2, e2, r2, n3) {
          if (n3(e2, r2)) {
            const i2 = e2.add(r2)._mult(0.5);
            eu(t2, e2, i2, n3), eu(t2, i2, r2, n3);
          } else
            t2.push(r2);
        }
        function ru(t2, e2) {
          let r2 = t2[0];
          const n3 = [r2];
          for (let i2 = 1; i2 < t2.length; i2++) {
            const s4 = t2[i2];
            eu(n3, r2, s4, e2), r2 = s4;
          }
          return n3;
        }
        const nu = Math.pow(2, 14) - 1, iu = -nu - 1;
        function su(t2, e2) {
          const r2 = Math.round(t2.x * e2), n3 = Math.round(t2.y * e2);
          return t2.x = M(r2, iu, nu), t2.y = M(n3, iu, nu), (r2 < t2.x || r2 > t2.x + 1 || n3 < t2.y || n3 > t2.y + 1) && N("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t2;
        }
        function au(t2, e2, r2) {
          const n3 = t2.loadGeometry(), i2 = t2.extent, s4 = ao / i2;
          if (e2 && r2 && r2.projection.isReprojectedInTileSpace) {
            const s5 = 1 << e2.z, { scale: a2, x: o2, y: l3, projection: u3 } = r2, c4 = (t3) => {
              const r3 = Kl((e2.x + t3.x / i2) / s5), n4 = Xl((e2.y + t3.y / i2) / s5), c5 = u3.project(r3, n4);
              t3.x = (c5.x * a2 - o2) * i2, t3.y = (c5.y * a2 - l3) * i2;
            };
            for (let e3 = 0; e3 < n3.length; e3++)
              if (1 !== t2.type)
                n3[e3] = tu(n3[e3], c4, 1);
              else {
                const t3 = [];
                for (const r3 of n3[e3])
                  r3.x < 0 || r3.x >= i2 || r3.y < 0 || r3.y >= i2 || (c4(r3), t3.push(r3));
                n3[e3] = t3;
              }
          }
          for (const t3 of n3)
            for (const e3 of t3)
              su(e3, s4);
          return n3;
        }
        function ou(t2, e2) {
          return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? au(t2) : [] };
        }
        function lu(t2, e2, r2, n3, i2) {
          t2.emplaceBack(2 * e2 + (n3 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
        }
        function uu(t2, e2, r2) {
          const n3 = 16384;
          t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n3, r2[1] * n3, r2[2] * n3);
        }
        class cu {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.projection = t2.projection, this.layoutVertexArray = new $s(), this.indexArray = new ra(), this.segments = new so(), this.programConfigurations = new Ja(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2, n3) {
            const i2 = this.layers[0], s4 = [];
            let a2 = null;
            "circle" === i2.type && (a2 = i2.layout.get("circle-sort-key"));
            for (const { feature: e3, id: i3, index: o3, sourceLayerIndex: l3 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u3 = ou(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), u3, r2))
                continue;
              const c4 = a2 ? a2.evaluate(u3, {}, r2) : void 0, h3 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u3.geometry : au(e3, r2, n3), patterns: {}, sortKey: c4 };
              s4.push(h3);
            }
            a2 && s4.sort((t3, e3) => t3.sortKey - e3.sortKey);
            let o2 = null;
            "globe" === n3.projection.name && (this.globeExtVertexArray = new Ks(), o2 = n3.projection);
            for (const n4 of s4) {
              const { geometry: i3, index: s5, sourceLayerIndex: a3 } = n4, l3 = t2[s5].feature;
              this.addFeature(n4, i3, s5, e2.availableImages, r2, o2), e2.featureIndex.insert(l3, i3, s5, a3, this.index);
            }
          }
          update(t2, e2, r2, n3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, no.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, io.members))), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
          addFeature(t2, e2, r2, n3, i2, s4) {
            for (const r3 of e2)
              for (const e3 of r3) {
                const r4 = e3.x, n4 = e3.y;
                if (r4 < 0 || r4 >= ao || n4 < 0 || n4 >= ao)
                  continue;
                if (s4) {
                  const t3 = s4.projectTilePoint(r4, n4, i2), e4 = s4.upVector(i2, r4, n4), a3 = this.globeExtVertexArray;
                  uu(a3, t3, e4), uu(a3, t3, e4), uu(a3, t3, e4), uu(a3, t3, e4);
                }
                const a2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), o2 = a2.vertexLength;
                lu(this.layoutVertexArray, r4, n4, -1, -1), lu(this.layoutVertexArray, r4, n4, 1, -1), lu(this.layoutVertexArray, r4, n4, 1, 1), lu(this.layoutVertexArray, r4, n4, -1, 1), this.indexArray.emplaceBack(o2, o2 + 1, o2 + 2), this.indexArray.emplaceBack(o2, o2 + 2, o2 + 3), a2.vertexLength += 4, a2.primitiveLength += 2;
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n3, i2);
          }
        }
        function hu(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++)
            if (bu(e2, t2[r2]))
              return true;
          for (let r2 = 0; r2 < e2.length; r2++)
            if (bu(t2, e2[r2]))
              return true;
          return !!yu(t2, e2);
        }
        function pu(t2, e2, r2) {
          return !!bu(t2, e2) || !!gu(e2, t2, r2);
        }
        function du(t2, e2) {
          if (1 === t2.length)
            return vu(e2, t2[0]);
          for (let r2 = 0; r2 < e2.length; r2++) {
            const n3 = e2[r2];
            for (let e3 = 0; e3 < n3.length; e3++)
              if (bu(t2, n3[e3]))
                return true;
          }
          for (let r2 = 0; r2 < t2.length; r2++)
            if (vu(e2, t2[r2]))
              return true;
          for (let r2 = 0; r2 < e2.length; r2++)
            if (yu(t2, e2[r2]))
              return true;
          return false;
        }
        function fu(t2, e2, r2) {
          if (t2.length > 1) {
            if (yu(t2, e2))
              return true;
            for (let n3 = 0; n3 < e2.length; n3++)
              if (gu(e2[n3], t2, r2))
                return true;
          }
          for (let n3 = 0; n3 < t2.length; n3++)
            if (gu(t2[n3], e2, r2))
              return true;
          return false;
        }
        function yu(t2, e2) {
          if (0 === t2.length || 0 === e2.length)
            return false;
          for (let r2 = 0; r2 < t2.length - 1; r2++) {
            const n3 = t2[r2], i2 = t2[r2 + 1];
            for (let t3 = 0; t3 < e2.length - 1; t3++)
              if (mu(n3, i2, e2[t3], e2[t3 + 1]))
                return true;
          }
          return false;
        }
        function mu(t2, e2, r2, n3) {
          return G(t2, r2, n3) !== G(e2, r2, n3) && G(t2, e2, r2) !== G(t2, e2, n3);
        }
        function gu(t2, e2, r2) {
          const n3 = r2 * r2;
          if (1 === e2.length)
            return t2.distSqr(e2[0]) < n3;
          for (let r3 = 1; r3 < e2.length; r3++)
            if (xu(t2, e2[r3 - 1], e2[r3]) < n3)
              return true;
          return false;
        }
        function xu(t2, e2, r2) {
          const n3 = e2.distSqr(r2);
          if (0 === n3)
            return t2.distSqr(e2);
          const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n3;
          return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
        }
        function vu(t2, e2) {
          let r2, n3, i2, s4 = false;
          for (let a2 = 0; a2 < t2.length; a2++) {
            r2 = t2[a2];
            for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++)
              n3 = r2[t3], i2 = r2[a3], n3.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n3.x) * (e2.y - n3.y) / (i2.y - n3.y) + n3.x && (s4 = !s4);
          }
          return s4;
        }
        function bu(t2, e2) {
          let r2 = false;
          for (let n3 = 0, i2 = t2.length - 1; n3 < t2.length; i2 = n3++) {
            const s4 = t2[n3], a2 = t2[i2];
            s4.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s4.x) * (e2.y - s4.y) / (a2.y - s4.y) + s4.x && (r2 = !r2);
          }
          return r2;
        }
        function wu(t2, e2, r2, n3, i2) {
          for (const s5 of t2)
            if (e2 <= s5.x && r2 <= s5.y && n3 >= s5.x && i2 >= s5.y)
              return true;
          const s4 = [new x(e2, r2), new x(e2, i2), new x(n3, i2), new x(n3, r2)];
          if (t2.length > 2) {
            for (const e3 of s4)
              if (bu(t2, e3))
                return true;
          }
          for (let e3 = 0; e3 < t2.length - 1; e3++)
            if (_u(t2[e3], t2[e3 + 1], s4))
              return true;
          return false;
        }
        function _u(t2, e2, r2) {
          const n3 = r2[0], i2 = r2[2];
          if (t2.x < n3.x && e2.x < n3.x || t2.x > i2.x && e2.x > i2.x || t2.y < n3.y && e2.y < n3.y || t2.y > i2.y && e2.y > i2.y)
            return false;
          const s4 = G(t2, e2, r2[0]);
          return s4 !== G(t2, e2, r2[1]) || s4 !== G(t2, e2, r2[2]) || s4 !== G(t2, e2, r2[3]);
        }
        function Au(t2, e2, r2) {
          const n3 = e2.paint.get(t2).value;
          return "constant" === n3.kind ? n3.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
        }
        function Su(t2) {
          return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
        }
        function ku(t2, e2, r2, n3, i2) {
          if (!e2[0] && !e2[1])
            return t2;
          const s4 = x.convert(e2)._mult(i2);
          "viewport" === r2 && s4._rotate(-n3);
          const a2 = [];
          for (let e3 = 0; e3 < t2.length; e3++)
            a2.push(t2[e3].sub(s4));
          return a2;
        }
        function Iu(t2, e2, r2, n3) {
          const i2 = x.convert(t2)._mult(n3);
          return "viewport" === e2 && i2._rotate(-r2), i2;
        }
        Ji(cu, "CircleBucket", { omit: ["layers"] });
        const Mu = new Ps({ "circle-sort-key": new Es(te.layout_circle["circle-sort-key"]) });
        var Tu = { paint: new Ps({ "circle-radius": new Es(te.paint_circle["circle-radius"]), "circle-color": new Es(te.paint_circle["circle-color"]), "circle-blur": new Es(te.paint_circle["circle-blur"]), "circle-opacity": new Es(te.paint_circle["circle-opacity"]), "circle-translate": new Bs(te.paint_circle["circle-translate"]), "circle-translate-anchor": new Bs(te.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Bs(te.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Bs(te.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Es(te.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Es(te.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Es(te.paint_circle["circle-stroke-opacity"]) }), layout: Mu };
        function zu(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
          if (s4 && t2.queryGeometry.isAboveHorizon)
            return false;
          s4 && (l3 *= t2.pixelToTileUnitsFactor);
          const u3 = t2.tileID.canonical, c4 = r2.projection.upVectorScale(u3, r2.center.lat, r2.worldSize).metersToTile;
          for (const h3 of e2)
            for (const e3 of h3) {
              const h4 = e3.add(o2), p3 = i2 && r2.elevation ? r2.elevation.exaggeration() * i2.getElevationAt(h4.x, h4.y, true) : 0, d3 = r2.projection.projectTilePoint(h4.x, h4.y, u3);
              if (p3 > 0) {
                const t3 = r2.projection.upVector(u3, h4.x, h4.y);
                d3.x += t3[0] * c4 * p3, d3.y += t3[1] * c4 * p3, d3.z += t3[2] * c4 * p3;
              }
              const f2 = s4 ? h4 : Bu(d3.x, d3.y, d3.z, n3), y2 = s4 ? t2.tilespaceRays.map((t3) => Pu(t3, p3)) : t2.queryGeometry.screenGeometry, m3 = Go([], [d3.x, d3.y, d3.z, 1], n3);
              if (!a2 && s4 ? l3 *= m3[3] / r2.cameraToCenterDistance : a2 && !s4 && (l3 *= r2.cameraToCenterDistance / m3[3]), s4) {
                const t3 = Xl((e3.y / ao + u3.y) / (1 << u3.z));
                l3 /= r2.projection.pixelsPerMeter(t3, 1) / Zl(1, t3);
              }
              if (pu(y2, f2, l3))
                return true;
            }
          return false;
        }
        function Bu(t2, e2, r2, n3) {
          const i2 = Go([], [t2, e2, r2, 1], n3);
          return new x(i2[0] / i2[3], i2[1] / i2[3]);
        }
        const Eu = Io(0, 0, 0), Cu = Io(0, 0, 1);
        function Pu(t2, e2) {
          const r2 = Ao();
          return Eu[2] = e2, t2.intersectsPlane(Eu, Cu, r2), new x(r2[0], r2[1]);
        }
        class Du extends cu {
        }
        function Vu(t2, { width: e2, height: r2 }, n3, i2) {
          if (i2) {
            if (i2 instanceof Uint8ClampedArray)
              i2 = new Uint8Array(i2.buffer);
            else if (i2.length !== e2 * r2 * n3)
              throw new RangeError("mismatched image size");
          } else
            i2 = new Uint8Array(e2 * r2 * n3);
          return t2.width = e2, t2.height = r2, t2.data = i2, t2;
        }
        function Lu(t2, e2, r2) {
          const { width: n3, height: i2 } = e2;
          n3 === t2.width && i2 === t2.height || (Fu(t2, e2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n3), height: Math.min(t2.height, i2) }, r2), t2.width = n3, t2.height = i2, t2.data = e2.data);
        }
        function Fu(t2, e2, r2, n3, i2, s4) {
          if (0 === i2.width || 0 === i2.height)
            return e2;
          if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i2.width > e2.width || i2.height > e2.height || n3.x > e2.width - i2.width || n3.y > e2.height - i2.height)
            throw new RangeError("out of range destination coordinates for image copy");
          const a2 = t2.data, o2 = e2.data;
          for (let l3 = 0; l3 < i2.height; l3++) {
            const u3 = ((r2.y + l3) * t2.width + r2.x) * s4, c4 = ((n3.y + l3) * e2.width + n3.x) * s4;
            for (let t3 = 0; t3 < i2.width * s4; t3++)
              o2[c4 + t3] = a2[u3 + t3];
          }
          return e2;
        }
        Ji(Du, "HeatmapBucket", { omit: ["layers"] });
        class Ru {
          constructor(t2, e2) {
            Vu(this, t2, 1, e2);
          }
          resize(t2) {
            Lu(this, new Ru(t2), 1);
          }
          clone() {
            return new Ru({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n3, i2) {
            Fu(t2, e2, r2, n3, i2, 1);
          }
        }
        class Uu {
          constructor(t2, e2) {
            Vu(this, t2, 4, e2);
          }
          resize(t2) {
            Lu(this, new Uu(t2), 4);
          }
          replace(t2, e2) {
            e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
          }
          clone() {
            return new Uu({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n3, i2) {
            Fu(t2, e2, r2, n3, i2, 4);
          }
        }
        Ji(Ru, "AlphaImage"), Ji(Uu, "RGBAImage");
        var $u = { paint: new Ps({ "heatmap-radius": new Es(te.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Es(te.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Bs(te.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Cs(te.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Bs(te.paint_heatmap["heatmap-opacity"]) }) };
        function ju(t2) {
          const e2 = {}, r2 = t2.resolution || 256, n3 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Uu({ width: r2, height: n3 }), s4 = (r3, n4, s5) => {
            e2[t2.evaluationKey] = s5;
            const a2 = t2.expression.evaluate(e2);
            i2.data[r3 + n4 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n4 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n4 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n4 + 3] = Math.floor(255 * a2.a);
          };
          if (t2.clips)
            for (let e3 = 0, i3 = 0; e3 < n3; ++e3, i3 += 4 * r2)
              for (let n4 = 0, a2 = 0; n4 < r2; n4++, a2 += 4) {
                const o2 = n4 / (r2 - 1), { start: l3, end: u3 } = t2.clips[e3];
                s4(i3, a2, l3 * (1 - o2) + u3 * o2);
              }
          else
            for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4)
              s4(0, e3, t3 / (r2 - 1));
          return i2;
        }
        var Ou = { paint: new Ps({ "hillshade-illumination-direction": new Bs(te.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Bs(te.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Bs(te.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Bs(te.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Bs(te.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Bs(te.paint_hillshade["hillshade-accent-color"]) }) };
        const qu = Rs([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Nu } = qu;
        var Gu = { exports: {} };
        function Zu(t2, e2, r2) {
          r2 = r2 || 2;
          var n3, i2, s4, a2, o2, l3, u3, c4 = e2 && e2.length, h3 = c4 ? e2[0] * r2 : t2.length, p3 = Ku(t2, 0, h3, r2, true), d3 = [];
          if (!p3 || p3.next === p3.prev)
            return d3;
          if (c4 && (p3 = function(t3, e3, r3, n4) {
            var i3, s5, a3, o3 = [];
            for (i3 = 0, s5 = e3.length; i3 < s5; i3++)
              (a3 = Ku(t3, e3[i3] * n4, i3 < s5 - 1 ? e3[i3 + 1] * n4 : t3.length, n4, false)) === a3.next && (a3.steiner = true), o3.push(ic(a3));
            for (o3.sort(tc), i3 = 0; i3 < o3.length; i3++)
              r3 = ec(o3[i3], r3);
            return r3;
          }(t2, e2, p3, r2)), t2.length > 80 * r2) {
            n3 = s4 = t2[0], i2 = a2 = t2[1];
            for (var f2 = r2; f2 < h3; f2 += r2)
              (o2 = t2[f2]) < n3 && (n3 = o2), (l3 = t2[f2 + 1]) < i2 && (i2 = l3), o2 > s4 && (s4 = o2), l3 > a2 && (a2 = l3);
            u3 = 0 !== (u3 = Math.max(s4 - n3, a2 - i2)) ? 32767 / u3 : 0;
          }
          return Ju(p3, d3, r2, n3, i2, u3, 0), d3;
        }
        function Ku(t2, e2, r2, n3, i2) {
          var s4, a2;
          if (i2 === gc(t2, e2, r2, n3) > 0)
            for (s4 = e2; s4 < r2; s4 += n3)
              a2 = fc(s4, t2[s4], t2[s4 + 1], a2);
          else
            for (s4 = r2 - n3; s4 >= e2; s4 -= n3)
              a2 = fc(s4, t2[s4], t2[s4 + 1], a2);
          return a2 && lc(a2, a2.next) && (yc(a2), a2 = a2.next), a2;
        }
        function Xu(t2, e2) {
          if (!t2)
            return t2;
          e2 || (e2 = t2);
          var r2, n3 = t2;
          do {
            if (r2 = false, n3.steiner || !lc(n3, n3.next) && 0 !== oc(n3.prev, n3, n3.next))
              n3 = n3.next;
            else {
              if (yc(n3), (n3 = e2 = n3.prev) === n3.next)
                break;
              r2 = true;
            }
          } while (r2 || n3 !== e2);
          return e2;
        }
        function Ju(t2, e2, r2, n3, i2, s4, a2) {
          if (t2) {
            !a2 && s4 && function(t3, e3, r3, n4) {
              var i3 = t3;
              do {
                0 === i3.z && (i3.z = nc(i3.x, i3.y, e3, r3, n4)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
              } while (i3 !== t3);
              i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                var e4, r4, n5, i4, s5, a3, o3, l4, u4 = 1;
                do {
                  for (r4 = t4, t4 = null, s5 = null, a3 = 0; r4; ) {
                    for (a3++, n5 = r4, o3 = 0, e4 = 0; e4 < u4 && (o3++, n5 = n5.nextZ); e4++)
                      ;
                    for (l4 = u4; o3 > 0 || l4 > 0 && n5; )
                      0 !== o3 && (0 === l4 || !n5 || r4.z <= n5.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n5, n5 = n5.nextZ, l4--), s5 ? s5.nextZ = i4 : t4 = i4, i4.prevZ = s5, s5 = i4;
                    r4 = n5;
                  }
                  s5.nextZ = null, u4 *= 2;
                } while (a3 > 1);
              }(i3);
            }(t2, n3, i2, s4);
            for (var o2, l3, u3 = t2; t2.prev !== t2.next; )
              if (o2 = t2.prev, l3 = t2.next, s4 ? Yu(t2, n3, i2, s4) : Hu(t2))
                e2.push(o2.i / r2 | 0), e2.push(t2.i / r2 | 0), e2.push(l3.i / r2 | 0), yc(t2), t2 = l3.next, u3 = l3.next;
              else if ((t2 = l3) === u3) {
                a2 ? 1 === a2 ? Ju(t2 = Wu(Xu(t2), e2, r2), e2, r2, n3, i2, s4, 2) : 2 === a2 && Qu(t2, e2, r2, n3, i2, s4) : Ju(Xu(t2), e2, r2, n3, i2, s4, 1);
                break;
              }
          }
        }
        function Hu(t2) {
          var e2 = t2.prev, r2 = t2, n3 = t2.next;
          if (oc(e2, r2, n3) >= 0)
            return false;
          for (var i2 = e2.x, s4 = r2.x, a2 = n3.x, o2 = e2.y, l3 = r2.y, u3 = n3.y, c4 = i2 < s4 ? i2 < a2 ? i2 : a2 : s4 < a2 ? s4 : a2, h3 = o2 < l3 ? o2 < u3 ? o2 : u3 : l3 < u3 ? l3 : u3, p3 = i2 > s4 ? i2 > a2 ? i2 : a2 : s4 > a2 ? s4 : a2, d3 = o2 > l3 ? o2 > u3 ? o2 : u3 : l3 > u3 ? l3 : u3, f2 = n3.next; f2 !== e2; ) {
            if (f2.x >= c4 && f2.x <= p3 && f2.y >= h3 && f2.y <= d3 && sc(i2, o2, s4, l3, a2, u3, f2.x, f2.y) && oc(f2.prev, f2, f2.next) >= 0)
              return false;
            f2 = f2.next;
          }
          return true;
        }
        function Yu(t2, e2, r2, n3) {
          var i2 = t2.prev, s4 = t2, a2 = t2.next;
          if (oc(i2, s4, a2) >= 0)
            return false;
          for (var o2 = i2.x, l3 = s4.x, u3 = a2.x, c4 = i2.y, h3 = s4.y, p3 = a2.y, d3 = o2 < l3 ? o2 < u3 ? o2 : u3 : l3 < u3 ? l3 : u3, f2 = c4 < h3 ? c4 < p3 ? c4 : p3 : h3 < p3 ? h3 : p3, y2 = o2 > l3 ? o2 > u3 ? o2 : u3 : l3 > u3 ? l3 : u3, m3 = c4 > h3 ? c4 > p3 ? c4 : p3 : h3 > p3 ? h3 : p3, g2 = nc(d3, f2, e2, r2, n3), x2 = nc(y2, m3, e2, r2, n3), v4 = t2.prevZ, b3 = t2.nextZ; v4 && v4.z >= g2 && b3 && b3.z <= x2; ) {
            if (v4.x >= d3 && v4.x <= y2 && v4.y >= f2 && v4.y <= m3 && v4 !== i2 && v4 !== a2 && sc(o2, c4, l3, h3, u3, p3, v4.x, v4.y) && oc(v4.prev, v4, v4.next) >= 0)
              return false;
            if (v4 = v4.prevZ, b3.x >= d3 && b3.x <= y2 && b3.y >= f2 && b3.y <= m3 && b3 !== i2 && b3 !== a2 && sc(o2, c4, l3, h3, u3, p3, b3.x, b3.y) && oc(b3.prev, b3, b3.next) >= 0)
              return false;
            b3 = b3.nextZ;
          }
          for (; v4 && v4.z >= g2; ) {
            if (v4.x >= d3 && v4.x <= y2 && v4.y >= f2 && v4.y <= m3 && v4 !== i2 && v4 !== a2 && sc(o2, c4, l3, h3, u3, p3, v4.x, v4.y) && oc(v4.prev, v4, v4.next) >= 0)
              return false;
            v4 = v4.prevZ;
          }
          for (; b3 && b3.z <= x2; ) {
            if (b3.x >= d3 && b3.x <= y2 && b3.y >= f2 && b3.y <= m3 && b3 !== i2 && b3 !== a2 && sc(o2, c4, l3, h3, u3, p3, b3.x, b3.y) && oc(b3.prev, b3, b3.next) >= 0)
              return false;
            b3 = b3.nextZ;
          }
          return true;
        }
        function Wu(t2, e2, r2) {
          var n3 = t2;
          do {
            var i2 = n3.prev, s4 = n3.next.next;
            !lc(i2, s4) && uc(i2, n3, n3.next, s4) && pc(i2, s4) && pc(s4, i2) && (e2.push(i2.i / r2 | 0), e2.push(n3.i / r2 | 0), e2.push(s4.i / r2 | 0), yc(n3), yc(n3.next), n3 = t2 = s4), n3 = n3.next;
          } while (n3 !== t2);
          return Xu(n3);
        }
        function Qu(t2, e2, r2, n3, i2, s4) {
          var a2 = t2;
          do {
            for (var o2 = a2.next.next; o2 !== a2.prev; ) {
              if (a2.i !== o2.i && ac(a2, o2)) {
                var l3 = dc(a2, o2);
                return a2 = Xu(a2, a2.next), l3 = Xu(l3, l3.next), Ju(a2, e2, r2, n3, i2, s4, 0), void Ju(l3, e2, r2, n3, i2, s4, 0);
              }
              o2 = o2.next;
            }
            a2 = a2.next;
          } while (a2 !== t2);
        }
        function tc(t2, e2) {
          return t2.x - e2.x;
        }
        function ec(t2, e2) {
          var r2 = function(t3, e3) {
            var r3, n4 = e3, i2 = t3.x, s4 = t3.y, a2 = -1 / 0;
            do {
              if (s4 <= n4.y && s4 >= n4.next.y && n4.next.y !== n4.y) {
                var o2 = n4.x + (s4 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
                if (o2 <= i2 && o2 > a2 && (a2 = o2, r3 = n4.x < n4.next.x ? n4 : n4.next, o2 === i2))
                  return r3;
              }
              n4 = n4.next;
            } while (n4 !== e3);
            if (!r3)
              return null;
            var l3, u3 = r3, c4 = r3.x, h3 = r3.y, p3 = 1 / 0;
            n4 = r3;
            do {
              i2 >= n4.x && n4.x >= c4 && i2 !== n4.x && sc(s4 < h3 ? i2 : a2, s4, c4, h3, s4 < h3 ? a2 : i2, s4, n4.x, n4.y) && (l3 = Math.abs(s4 - n4.y) / (i2 - n4.x), pc(n4, t3) && (l3 < p3 || l3 === p3 && (n4.x > r3.x || n4.x === r3.x && rc(r3, n4))) && (r3 = n4, p3 = l3)), n4 = n4.next;
            } while (n4 !== u3);
            return r3;
          }(t2, e2);
          if (!r2)
            return e2;
          var n3 = dc(r2, t2);
          return Xu(n3, n3.next), Xu(r2, r2.next);
        }
        function rc(t2, e2) {
          return oc(t2.prev, t2, e2.prev) < 0 && oc(e2.next, t2, t2.next) < 0;
        }
        function nc(t2, e2, r2, n3, i2) {
          return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n3) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function ic(t2) {
          var e2 = t2, r2 = t2;
          do {
            (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
          } while (e2 !== t2);
          return r2;
        }
        function sc(t2, e2, r2, n3, i2, s4, a2, o2) {
          return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s4 - o2) && (t2 - a2) * (n3 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s4 - o2) >= (i2 - a2) * (n3 - o2);
        }
        function ac(t2, e2) {
          return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
            var r2 = t3;
            do {
              if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && uc(r2, r2.next, t3, e3))
                return true;
              r2 = r2.next;
            } while (r2 !== t3);
            return false;
          }(t2, e2) && (pc(t2, e2) && pc(e2, t2) && function(t3, e3) {
            var r2 = t3, n3 = false, i2 = (t3.x + e3.x) / 2, s4 = (t3.y + e3.y) / 2;
            do {
              r2.y > s4 != r2.next.y > s4 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s4 - r2.y) / (r2.next.y - r2.y) + r2.x && (n3 = !n3), r2 = r2.next;
            } while (r2 !== t3);
            return n3;
          }(t2, e2) && (oc(t2.prev, t2, e2.prev) || oc(t2, e2.prev, e2)) || lc(t2, e2) && oc(t2.prev, t2, t2.next) > 0 && oc(e2.prev, e2, e2.next) > 0);
        }
        function oc(t2, e2, r2) {
          return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
        }
        function lc(t2, e2) {
          return t2.x === e2.x && t2.y === e2.y;
        }
        function uc(t2, e2, r2, n3) {
          var i2 = hc(oc(t2, e2, r2)), s4 = hc(oc(t2, e2, n3)), a2 = hc(oc(r2, n3, t2)), o2 = hc(oc(r2, n3, e2));
          return i2 !== s4 && a2 !== o2 || !(0 !== i2 || !cc(t2, r2, e2)) || !(0 !== s4 || !cc(t2, n3, e2)) || !(0 !== a2 || !cc(r2, t2, n3)) || !(0 !== o2 || !cc(r2, e2, n3));
        }
        function cc(t2, e2, r2) {
          return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
        }
        function hc(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }
        function pc(t2, e2) {
          return oc(t2.prev, t2, t2.next) < 0 ? oc(t2, e2, t2.next) >= 0 && oc(t2, t2.prev, e2) >= 0 : oc(t2, e2, t2.prev) < 0 || oc(t2, t2.next, e2) < 0;
        }
        function dc(t2, e2) {
          var r2 = new mc(t2.i, t2.x, t2.y), n3 = new mc(e2.i, e2.x, e2.y), i2 = t2.next, s4 = e2.prev;
          return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n3.next = r2, r2.prev = n3, s4.next = n3, n3.prev = s4, n3;
        }
        function fc(t2, e2, r2, n3) {
          var i2 = new mc(t2, e2, r2);
          return n3 ? (i2.next = n3.next, i2.prev = n3, n3.next.prev = i2, n3.next = i2) : (i2.prev = i2, i2.next = i2), i2;
        }
        function yc(t2) {
          t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
        }
        function mc(t2, e2, r2) {
          this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function gc(t2, e2, r2, n3) {
          for (var i2 = 0, s4 = e2, a2 = r2 - n3; s4 < r2; s4 += n3)
            i2 += (t2[a2] - t2[s4]) * (t2[s4 + 1] + t2[a2 + 1]), a2 = s4;
          return i2;
        }
        Gu.exports = Zu, Gu.exports.default = Zu, Zu.deviation = function(t2, e2, r2, n3) {
          var i2 = e2 && e2.length, s4 = Math.abs(gc(t2, 0, i2 ? e2[0] * r2 : t2.length, r2));
          if (i2)
            for (var a2 = 0, o2 = e2.length; a2 < o2; a2++)
              s4 -= Math.abs(gc(t2, e2[a2] * r2, a2 < o2 - 1 ? e2[a2 + 1] * r2 : t2.length, r2));
          var l3 = 0;
          for (a2 = 0; a2 < n3.length; a2 += 3) {
            var u3 = n3[a2] * r2, c4 = n3[a2 + 1] * r2, h3 = n3[a2 + 2] * r2;
            l3 += Math.abs((t2[u3] - t2[h3]) * (t2[c4 + 1] - t2[u3 + 1]) - (t2[u3] - t2[c4]) * (t2[h3 + 1] - t2[u3 + 1]));
          }
          return 0 === s4 && 0 === l3 ? 0 : Math.abs((l3 - s4) / s4);
        }, Zu.flatten = function(t2) {
          for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n3 = 0, i2 = 0; i2 < t2.length; i2++) {
            for (var s4 = 0; s4 < t2[i2].length; s4++)
              for (var a2 = 0; a2 < e2; a2++)
                r2.vertices.push(t2[i2][s4][a2]);
            i2 > 0 && r2.holes.push(n3 += t2[i2 - 1].length);
          }
          return r2;
        };
        var xc = p2(Gu.exports);
        function vc(t2, e2, r2, n3, i2) {
          bc(t2, e2, r2 || 0, n3 || t2.length - 1, i2 || _c);
        }
        function bc(t2, e2, r2, n3, i2) {
          for (; n3 > r2; ) {
            if (n3 - r2 > 600) {
              var s4 = n3 - r2 + 1, a2 = e2 - r2 + 1, o2 = Math.log(s4), l3 = 0.5 * Math.exp(2 * o2 / 3), u3 = 0.5 * Math.sqrt(o2 * l3 * (s4 - l3) / s4) * (a2 - s4 / 2 < 0 ? -1 : 1);
              bc(t2, e2, Math.max(r2, Math.floor(e2 - a2 * l3 / s4 + u3)), Math.min(n3, Math.floor(e2 + (s4 - a2) * l3 / s4 + u3)), i2);
            }
            var c4 = t2[e2], h3 = r2, p3 = n3;
            for (wc(t2, r2, e2), i2(t2[n3], c4) > 0 && wc(t2, r2, n3); h3 < p3; ) {
              for (wc(t2, h3, p3), h3++, p3--; i2(t2[h3], c4) < 0; )
                h3++;
              for (; i2(t2[p3], c4) > 0; )
                p3--;
            }
            0 === i2(t2[r2], c4) ? wc(t2, r2, p3) : wc(t2, ++p3, n3), p3 <= e2 && (r2 = p3 + 1), e2 <= p3 && (n3 = p3 - 1);
          }
        }
        function wc(t2, e2, r2) {
          var n3 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n3;
        }
        function _c(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function Ac(t2, e2) {
          const r2 = t2.length;
          if (r2 <= 1)
            return [t2];
          const n3 = [];
          let i2, s4;
          for (let e3 = 0; e3 < r2; e3++) {
            const r3 = Z(t2[e3]);
            0 !== r3 && (t2[e3].area = Math.abs(r3), void 0 === s4 && (s4 = r3 < 0), s4 === r3 < 0 ? (i2 && n3.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
          }
          if (i2 && n3.push(i2), e2 > 1)
            for (let t3 = 0; t3 < n3.length; t3++)
              n3[t3].length <= e2 || (vc(n3[t3], e2, 1, n3[t3].length - 1, Sc), n3[t3] = n3[t3].slice(0, e2));
          return n3;
        }
        function Sc(t2, e2) {
          return e2.area - t2.area;
        }
        function kc(t2, e2, r2) {
          const n3 = r2.patternDependencies;
          let i2 = false;
          for (const r3 of e2) {
            const e3 = r3.paint.get(`${t2}-pattern`);
            e3.isConstant() || (i2 = true);
            const s4 = e3.constantOr(null);
            s4 && (i2 = true, n3[s4] = true);
          }
          return i2;
        }
        function Ic(t2, e2, r2, n3, i2) {
          const s4 = i2.patternDependencies;
          for (const a2 of e2) {
            const e3 = a2.paint.get(`${t2}-pattern`).value;
            if ("constant" !== e3.kind) {
              let t3 = e3.evaluate({ zoom: n3 }, r2, {}, i2.availableImages);
              t3 = t3 && t3.name ? t3.name : t3, s4[t3] = true, r2.patterns[a2.id] = t3;
            }
          }
          return r2;
        }
        class Mc {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new $s(), this.indexArray = new ra(), this.indexArray2 = new la(), this.programConfigurations = new Ja(t2.layers, t2.zoom), this.segments = new so(), this.segments2 = new so(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t2.projection;
          }
          populate(t2, e2, r2, n3) {
            this.hasPattern = kc("fill", this.layers, e2);
            const i2 = this.layers[0].layout.get("fill-sort-key"), s4 = [];
            for (const { feature: a2, id: o2, index: l3, sourceLayerIndex: u3 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, c4 = ou(a2, t3);
              if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), c4, r2))
                continue;
              const h3 = i2 ? i2.evaluate(c4, {}, r2, e2.availableImages) : void 0, p3 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u3, index: l3, geometry: t3 ? c4.geometry : au(a2, r2, n3), patterns: {}, sortKey: h3 };
              s4.push(p3);
            }
            i2 && s4.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (const n4 of s4) {
              const { geometry: i3, index: s5, sourceLayerIndex: a2 } = n4;
              if (this.hasPattern) {
                const t3 = Ic("fill", this.layers, n4, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else
                this.addFeature(n4, i3, s5, r2, {}, e2.availableImages);
              e2.featureIndex.insert(t2[s5].feature, i3, s5, a2, this.index);
            }
          }
          update(t2, e2, r2, n3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n3);
          }
          addFeatures(t2, e2, r2, n3, i2) {
            for (const t3 of this.patternFeatures)
              this.addFeature(t3, t3.geometry, t3.index, e2, r2, n3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Nu), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t2, e2, r2, n3, i2, s4 = []) {
            for (const t3 of Ac(e2, 500)) {
              let e3 = 0;
              for (const r4 of t3)
                e3 += r4.length;
              const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n4 = r3.vertexLength, i3 = [], s5 = [];
              for (const e4 of t3) {
                if (0 === e4.length)
                  continue;
                e4 !== t3[0] && s5.push(i3.length / 2);
                const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n5 = r4.vertexLength;
                this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n5 + e4.length - 1, n5), i3.push(e4[0].x), i3.push(e4[0].y);
                for (let t4 = 1; t4 < e4.length; t4++)
                  this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n5 + t4 - 1, n5 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
                r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
              }
              const a2 = xc(i3, s5);
              for (let t4 = 0; t4 < a2.length; t4 += 3)
                this.indexArray.emplaceBack(n4 + a2[t4], n4 + a2[t4 + 1], n4 + a2[t4 + 2]);
              r3.vertexLength += e3, r3.primitiveLength += a2.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s4, n3);
          }
        }
        Ji(Mc, "FillBucket", { omit: ["layers", "patternFeatures"] });
        const Tc = new Ps({ "fill-sort-key": new Es(te.layout_fill["fill-sort-key"]) });
        var zc = { paint: new Ps({ "fill-antialias": new Bs(te.paint_fill["fill-antialias"]), "fill-opacity": new Es(te.paint_fill["fill-opacity"]), "fill-color": new Es(te.paint_fill["fill-color"]), "fill-outline-color": new Es(te.paint_fill["fill-outline-color"]), "fill-translate": new Bs(te.paint_fill["fill-translate"]), "fill-translate-anchor": new Bs(te.paint_fill["fill-translate-anchor"]), "fill-pattern": new Es(te.paint_fill["fill-pattern"]) }), layout: Tc };
        const Bc = Rs([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Ec = Rs([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Cc = Rs([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Pc } = Bc;
        var Dc = {}, Vc = m2, Lc = Fc;
        function Fc(t2, e2, r2, n3, i2) {
          this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n3, this._values = i2, t2.readFields(Rc, this, e2);
        }
        function Rc(t2, e2, r2) {
          1 == t2 ? e2.id = r2.readVarint() : 2 == t2 ? function(t3, e3) {
            for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n3 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
              e3.properties[n3] = i2;
            }
          }(r2, e2) : 3 == t2 ? e2.type = r2.readVarint() : 4 == t2 && (e2._geometry = r2.pos);
        }
        function Uc(t2) {
          for (var e2, r2, n3 = 0, i2 = 0, s4 = t2.length, a2 = s4 - 1; i2 < s4; a2 = i2++)
            n3 += ((r2 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
          return n3;
        }
        Fc.types = ["Unknown", "Point", "LineString", "Polygon"], Fc.prototype.loadGeometry = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2, r2 = t2.readVarint() + t2.pos, n3 = 1, i2 = 0, s4 = 0, a2 = 0, o2 = []; t2.pos < r2; ) {
            if (i2 <= 0) {
              var l3 = t2.readVarint();
              n3 = 7 & l3, i2 = l3 >> 3;
            }
            if (i2--, 1 === n3 || 2 === n3)
              s4 += t2.readSVarint(), a2 += t2.readSVarint(), 1 === n3 && (e2 && o2.push(e2), e2 = []), e2.push(new Vc(s4, a2));
            else {
              if (7 !== n3)
                throw new Error("unknown command " + n3);
              e2 && e2.push(e2[0].clone());
            }
          }
          return e2 && o2.push(e2), o2;
        }, Fc.prototype.bbox = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n3 = 0, i2 = 0, s4 = 0, a2 = 1 / 0, o2 = -1 / 0, l3 = 1 / 0, u3 = -1 / 0; t2.pos < e2; ) {
            if (n3 <= 0) {
              var c4 = t2.readVarint();
              r2 = 7 & c4, n3 = c4 >> 3;
            }
            if (n3--, 1 === r2 || 2 === r2)
              (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s4 += t2.readSVarint()) < l3 && (l3 = s4), s4 > u3 && (u3 = s4);
            else if (7 !== r2)
              throw new Error("unknown command " + r2);
          }
          return [a2, l3, o2, u3];
        }, Fc.prototype.toGeoJSON = function(t2, e2, r2) {
          var n3, i2, s4 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e2, l3 = this.loadGeometry(), u3 = Fc.types[this.type];
          function c4(t3) {
            for (var e3 = 0; e3 < t3.length; e3++) {
              var r3 = t3[e3];
              t3[e3] = [360 * (r3.x + a2) / s4 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s4) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h3 = [];
              for (n3 = 0; n3 < l3.length; n3++)
                h3[n3] = l3[n3][0];
              c4(l3 = h3);
              break;
            case 2:
              for (n3 = 0; n3 < l3.length; n3++)
                c4(l3[n3]);
              break;
            case 3:
              for (l3 = function(t3) {
                var e3 = t3.length;
                if (e3 <= 1)
                  return [t3];
                for (var r3, n4, i3 = [], s5 = 0; s5 < e3; s5++) {
                  var a3 = Uc(t3[s5]);
                  0 !== a3 && (void 0 === n4 && (n4 = a3 < 0), n4 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s5]]) : r3.push(t3[s5]));
                }
                return r3 && i3.push(r3), i3;
              }(l3), n3 = 0; n3 < l3.length; n3++)
                for (i2 = 0; i2 < l3[n3].length; i2++)
                  c4(l3[n3][i2]);
          }
          1 === l3.length ? l3 = l3[0] : u3 = "Multi" + u3;
          var p3 = { type: "Feature", geometry: { type: u3, coordinates: l3 }, properties: this.properties };
          return "id" in this && (p3.id = this.id), p3;
        };
        var $c = Lc, jc = Oc;
        function Oc(t2, e2) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(qc, this, e2), this.length = this._features.length;
        }
        function qc(t2, e2, r2) {
          15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push(function(t3) {
            for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n3 = t3.readVarint() >> 3;
              e3 = 1 === n3 ? t3.readString() : 2 === n3 ? t3.readFloat() : 3 === n3 ? t3.readDouble() : 4 === n3 ? t3.readVarint64() : 5 === n3 ? t3.readVarint() : 6 === n3 ? t3.readSVarint() : 7 === n3 ? t3.readBoolean() : null;
            }
            return e3;
          }(r2));
        }
        Oc.prototype.feature = function(t2) {
          if (t2 < 0 || t2 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t2];
          var e2 = this._pbf.readVarint() + this._pbf.pos;
          return new $c(this._pbf, e2, this.extent, this._keys, this._values);
        };
        var Nc = jc;
        function Gc(t2, e2, r2) {
          if (3 === t2) {
            var n3 = new Nc(r2, r2.readVarint() + r2.pos);
            n3.length && (e2[n3.name] = n3);
          }
        }
        var Zc = Dc.VectorTile = function(t2, e2) {
          this.layers = t2.readFields(Gc, {}, e2);
        }, Kc = Dc.VectorTileFeature = Lc;
        function Xc(t2, e2, r2, n3) {
          const i2 = [], s4 = 0 === n3 ? (t3, e3, r3, n4, i3, s5) => {
            t3.push(new x(s5, r3 + (s5 - e3) / (n4 - e3) * (i3 - r3)));
          } : (t3, e3, r3, n4, i3, s5) => {
            t3.push(new x(e3 + (s5 - r3) / (i3 - r3) * (n4 - e3), s5));
          };
          for (const a2 of t2) {
            const t3 = [];
            for (const i3 of a2) {
              if (i3.length <= 2)
                continue;
              const a3 = [];
              for (let t4 = 0; t4 < i3.length - 1; t4++) {
                const o3 = i3[t4].x, l4 = i3[t4].y, u3 = i3[t4 + 1].x, c4 = i3[t4 + 1].y, h3 = 0 === n3 ? o3 : l4, p3 = 0 === n3 ? u3 : c4;
                h3 < e2 ? p3 > e2 && s4(a3, o3, l4, u3, c4, e2) : h3 > r2 ? p3 < r2 && s4(a3, o3, l4, u3, c4, r2) : a3.push(i3[t4]), p3 < e2 && h3 >= e2 && s4(a3, o3, l4, u3, c4, e2), p3 > r2 && h3 <= r2 && s4(a3, o3, l4, u3, c4, r2);
              }
              let o2 = i3[i3.length - 1];
              const l3 = 0 === n3 ? o2.x : o2.y;
              l3 >= e2 && l3 <= r2 && a3.push(o2), a3.length && (o2 = a3[a3.length - 1], a3[0].x === o2.x && a3[0].y === o2.y || a3.push(a3[0]), t3.push(a3));
            }
            t3.length && i2.push(t3);
          }
          return i2;
        }
        Dc.VectorTileLayer = jc;
        const Jc = Kc.types, Hc = Math.pow(2, 13);
        function Yc(t2, e2, r2, n3, i2, s4, a2, o2) {
          t2.emplaceBack((e2 << 1) + a2, (r2 << 1) + s4, (Math.floor(n3 * Hc) << 1) + i2, Math.round(o2));
        }
        function Wc(t2, e2, r2) {
          const n3 = 16384;
          t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n3, r2[1] * n3, r2[2] * n3);
        }
        class Qc {
          constructor() {
            this.acc = new x(0, 0), this.polyCount = [];
          }
          startRing(t2) {
            this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new x(t2.x, t2.y), this.max = new x(t2.x, t2.y));
          }
          append(t2, e2) {
            this.currentPolyCount.edges++, this.acc._add(t2);
            const r2 = this.min, n3 = this.max;
            t2.x < r2.x ? r2.x = t2.x : t2.x > n3.x && (n3.x = t2.x), t2.y < r2.y ? r2.y = t2.y : t2.y > n3.y && (n3.y = t2.y), ((0 === t2.x || t2.x === ao) && t2.x === e2.x) != ((0 === t2.y || t2.y === ao) && t2.y === e2.y) && this.processBorderOverlap(t2, e2), e2.x < 0 != t2.x < 0 && this.addBorderIntersection(0, Er(e2.y, t2.y, (0 - e2.x) / (t2.x - e2.x))), e2.x > ao != t2.x > ao && this.addBorderIntersection(1, Er(e2.y, t2.y, (ao - e2.x) / (t2.x - e2.x))), e2.y < 0 != t2.y < 0 && this.addBorderIntersection(2, Er(e2.x, t2.x, (0 - e2.y) / (t2.y - e2.y))), e2.y > ao != t2.y > ao && this.addBorderIntersection(3, Er(e2.x, t2.x, (ao - e2.y) / (t2.y - e2.y)));
          }
          addBorderIntersection(t2, e2) {
            this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
            const r2 = this.borders[t2];
            e2 < r2[0] && (r2[0] = e2), e2 > r2[1] && (r2[1] = e2);
          }
          processBorderOverlap(t2, e2) {
            if (t2.x === e2.x) {
              if (t2.y === e2.y)
                return;
              const r2 = 0 === t2.x ? 0 : 1;
              this.addBorderIntersection(r2, e2.y), this.addBorderIntersection(r2, t2.y);
            } else {
              const r2 = 0 === t2.y ? 2 : 3;
              this.addBorderIntersection(r2, e2.x), this.addBorderIntersection(r2, t2.x);
            }
          }
          centroid() {
            const t2 = this.polyCount.reduce((t3, e2) => t3 + e2.edges, 0);
            return 0 !== t2 ? this.acc.div(t2)._round() : new x(0, 0);
          }
          span() {
            return new x(this.max.x - this.min.x, this.max.y - this.min.y);
          }
          intersectsCount() {
            return this.borders.reduce((t2, e2) => t2 + +(e2[0] !== Number.MAX_VALUE), 0);
          }
        }
        class th {
          constructor(t2) {
            this.zoom = t2.zoom, this.canonical = t2.canonical, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t2.projection, this.layoutVertexArray = new Os(), this.centroidVertexArray = new wa(), this.indexArray = new ra(), this.programConfigurations = new Ja(t2.layers, t2.zoom), this.segments = new so(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.enableTerrain = t2.enableTerrain;
          }
          populate(t2, e2, r2, n3) {
            this.features = [], this.hasPattern = kc("fill-extrusion", this.layers, e2), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function(t3) {
              const e3 = Math.exp(Math.PI * (1 - t3.y / (1 << t3.z) * 2));
              return 80150034 * e3 / (e3 * e3 + 1) / ao / (1 << t3.z);
            }(r2), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
            for (const { feature: i2, id: s4, index: a2, sourceLayerIndex: o2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, l3 = ou(i2, t3);
              if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), l3, r2))
                continue;
              const u3 = { id: s4, sourceLayerIndex: o2, index: a2, geometry: t3 ? l3.geometry : au(i2, r2, n3), properties: i2.properties, type: i2.type, patterns: {} }, c4 = this.layoutVertexArray.length;
              this.hasPattern ? this.features.push(Ic("fill-extrusion", this.layers, u3, this.zoom, e2)) : this.addFeature(u3, u3.geometry, a2, r2, {}, e2.availableImages, n3), e2.featureIndex.insert(i2, u3.geometry, a2, o2, this.index, c4);
            }
            this.sortBorders();
          }
          addFeatures(t2, e2, r2, n3, i2) {
            for (const t3 of this.features) {
              const { geometry: s4 } = t3;
              this.addFeature(t3, s4, t3.index, e2, r2, n3, i2);
            }
            this.sortBorders();
          }
          update(t2, e2, r2, n3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Pc), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t2.createVertexBuffer(this.layoutVertexExtArray, Cc.members, true))), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          uploadCentroid(t2) {
            0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Ec.members, true), this.needsCentroidUpdate = false);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t2, e2, r2, n3, i2, s4, a2) {
            const o2 = [new x(0, 0), new x(ao, ao)], l3 = a2.projection, u3 = "globe" === l3.name, c4 = this.enableTerrain && !u3 ? new Qc() : null, h3 = "Polygon" === Jc[t2.type];
            u3 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ks());
            const p3 = Ac(e2, 500);
            for (let t3 = p3.length - 1; t3 >= 0; t3--) {
              const e3 = p3[t3];
              (0 === e3.length || (d3 = e3[0]).every((t4) => t4.x <= 0) || d3.every((t4) => t4.x >= ao) || d3.every((t4) => t4.y <= 0) || d3.every((t4) => t4.y >= ao)) && p3.splice(t3, 1);
            }
            var d3;
            let f2;
            if (u3)
              f2 = lh(p3, o2, n3);
            else {
              f2 = [];
              for (const t3 of p3)
                f2.push({ polygon: t3, bounds: o2 });
            }
            const y2 = h3 ? this.edgeRadius : 0;
            for (const { polygon: t3, bounds: e3 } of f2) {
              let r3 = 0, i3 = 0;
              for (const e4 of t3)
                h3 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i3 += h3 ? e4.length - 1 : e4.length;
              const s5 = this.segments.prepareSegment((h3 ? 5 : 4) * i3, this.layoutVertexArray, this.indexArray);
              if (h3) {
                const e4 = [], i4 = [];
                r3 = s5.vertexLength;
                for (const r4 of t3) {
                  let a4, o3;
                  r4.length && r4 !== t3[0] && i4.push(e4.length / 2), a4 = r4[1].sub(r4[0])._perp()._unit();
                  for (let t4 = 1; t4 < r4.length; t4++) {
                    const i5 = r4[t4], c5 = r4[t4 === r4.length - 1 ? 1 : t4 + 1];
                    let { x: h4, y: p4 } = i5;
                    if (y2) {
                      o3 = c5.sub(i5)._perp()._unit();
                      const t5 = a4.add(o3)._unit(), e5 = y2 * Math.min(4, 1 / (a4.x * t5.x + a4.y * t5.y));
                      h4 += e5 * t5.x, p4 += e5 * t5.y, a4 = o3;
                    }
                    Yc(this.layoutVertexArray, h4, p4, 0, 0, 1, 1, 0), s5.vertexLength++, e4.push(i5.x, i5.y), u3 && Wc(this.layoutVertexExtArray, l3.projectTilePoint(h4, p4, n3), l3.upVector(n3, h4, p4));
                  }
                }
                const a3 = xc(e4, i4);
                for (let t4 = 0; t4 < a3.length; t4 += 3)
                  this.indexArray.emplaceBack(r3 + a3[t4], r3 + a3[t4 + 2], r3 + a3[t4 + 1]), s5.primitiveLength++;
              }
              for (const i4 of t3) {
                c4 && i4.length && c4.startRing(i4[0]);
                let t4, a3, o3, p4 = i4.length > 4 && sh(i4[i4.length - 2], i4[0], i4[1]), d4 = y2 ? rh(i4[i4.length - 2], i4[0], i4[1], y2) : 0;
                a3 = i4[1].sub(i4[0])._perp()._unit();
                let f3 = true;
                for (let m3 = 1, g2 = 0; m3 < i4.length; m3++) {
                  let x2 = i4[m3 - 1], v4 = i4[m3];
                  const b3 = i4[m3 === i4.length - 1 ? 1 : m3 + 1];
                  if (c4 && h3 && c4.currentPolyCount.top++, ih(v4, x2, e3)) {
                    y2 && (a3 = b3.sub(v4)._perp()._unit(), f3 = !f3);
                    continue;
                  }
                  c4 && c4.append(v4, x2);
                  const w2 = v4.sub(x2)._perp(), _2 = w2.x / (Math.abs(w2.x) + Math.abs(w2.y)), A2 = w2.y > 0 ? 1 : 0, S2 = x2.dist(v4);
                  if (g2 + S2 > 32768 && (g2 = 0), y2) {
                    o3 = b3.sub(v4)._perp()._unit();
                    let t5 = nh(x2, v4, b3, eh(a3, o3), y2);
                    isNaN(t5) && (t5 = 0);
                    const e4 = v4.sub(x2)._unit();
                    x2 = x2.add(e4.mult(d4))._round(), v4 = v4.add(e4.mult(-t5))._round(), d4 = t5, a3 = o3;
                  }
                  const k2 = s5.vertexLength, I2 = i4.length > 4 && sh(x2, v4, b3);
                  let M2 = ah(g2, p4, f3);
                  if (Yc(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 0, M2), Yc(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 1, M2), g2 += S2, M2 = ah(g2, I2, !f3), p4 = I2, Yc(this.layoutVertexArray, v4.x, v4.y, _2, A2, 0, 0, M2), Yc(this.layoutVertexArray, v4.x, v4.y, _2, A2, 0, 1, M2), s5.vertexLength += 4, this.indexArray.emplaceBack(k2 + 0, k2 + 1, k2 + 2), this.indexArray.emplaceBack(k2 + 1, k2 + 3, k2 + 2), s5.primitiveLength += 2, y2) {
                    const n4 = r3 + (1 === m3 ? i4.length - 2 : m3 - 2), a4 = 1 === m3 ? r3 : n4 + 1;
                    if (this.indexArray.emplaceBack(k2 + 1, n4, k2 + 3), this.indexArray.emplaceBack(n4, a4, k2 + 3), s5.primitiveLength += 2, void 0 === t4 && (t4 = k2), !ih(b3, i4[m3], e3)) {
                      const e4 = m3 === i4.length - 1 ? t4 : s5.vertexLength;
                      this.indexArray.emplaceBack(k2 + 2, k2 + 3, e4), this.indexArray.emplaceBack(k2 + 3, e4 + 1, e4), this.indexArray.emplaceBack(k2 + 3, a4, e4 + 1), s5.primitiveLength += 3;
                    }
                    f3 = !f3;
                  }
                  if (u3) {
                    const t5 = this.layoutVertexExtArray, e4 = l3.projectTilePoint(x2.x, x2.y, n3), r4 = l3.projectTilePoint(v4.x, v4.y, n3), i5 = l3.upVector(n3, x2.x, x2.y), s6 = l3.upVector(n3, v4.x, v4.y);
                    Wc(t5, e4, i5), Wc(t5, e4, i5), Wc(t5, r4, s6), Wc(t5, r4, s6);
                  }
                }
                h3 && (r3 += i4.length - 1);
              }
            }
            if (c4 && c4.polyCount.length > 0) {
              if (c4.borders) {
                c4.vertexArrayOffset = this.centroidVertexArray.length;
                const t3 = c4.borders, e3 = this.featuresOnBorder.push(c4) - 1;
                for (let r3 = 0; r3 < 4; r3++)
                  t3[r3][0] !== Number.MAX_VALUE && this.borders[r3].push(e3);
              }
              this.encodeCentroid(c4.borders ? void 0 : c4.centroid(), c4);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s4, n3);
          }
          sortBorders() {
            for (let t2 = 0; t2 < 4; t2++)
              this.borders[t2].sort((e2, r2) => this.featuresOnBorder[e2].borders[t2][0] - this.featuresOnBorder[r2].borders[t2][0]);
          }
          encodeCentroid(t2, e2, r2 = true) {
            let n3, i2;
            if (t2)
              if (0 !== t2.y) {
                const r3 = e2.span()._mult(this.tileToMeter);
                n3 = (Math.max(t2.x, 1) << 3) + Math.min(7, Math.round(r3.x / 10)), i2 = (Math.max(t2.y, 1) << 3) + Math.min(7, Math.round(r3.y / 10));
              } else
                n3 = Math.ceil(7 * (t2.x + 450)), i2 = 0;
            else
              n3 = 0, i2 = +r2;
            let s4 = r2 ? this.centroidVertexArray.length : e2.vertexArrayOffset;
            for (const t3 of e2.polyCount) {
              r2 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t3.edges + t3.top);
              for (let e3 = 0; e3 < t3.top; e3++)
                this.centroidVertexArray.emplace(s4++, n3, i2);
              for (let e3 = 0; e3 < 2 * t3.edges; e3++)
                this.centroidVertexArray.emplace(s4++, 0, i2), this.centroidVertexArray.emplace(s4++, n3, i2);
            }
          }
        }
        function eh(t2, e2) {
          const r2 = t2.add(e2)._unit();
          return t2.x * r2.x + t2.y * r2.y;
        }
        function rh(t2, e2, r2, n3) {
          const i2 = e2.sub(t2)._perp()._unit(), s4 = r2.sub(e2)._perp()._unit();
          return nh(t2, e2, r2, eh(i2, s4), n3);
        }
        function nh(t2, e2, r2, n3, i2) {
          const s4 = Math.sqrt(1 - n3 * n3);
          return Math.min(t2.dist(e2) / 3, e2.dist(r2) / 3, i2 * s4 / n3);
        }
        function ih(t2, e2, r2) {
          return t2.x < r2[0].x && e2.x < r2[0].x || t2.x > r2[1].x && e2.x > r2[1].x || t2.y < r2[0].y && e2.y < r2[0].y || t2.y > r2[1].y && e2.y > r2[1].y;
        }
        function sh(t2, e2, r2) {
          if (t2.x < 0 || t2.x >= ao || e2.x < 0 || e2.x >= ao || r2.x < 0 || r2.x >= ao)
            return false;
          const n3 = r2.sub(e2), i2 = n3.perp(), s4 = t2.sub(e2);
          return (n3.x * s4.x + n3.y * s4.y) / Math.sqrt((n3.x * n3.x + n3.y * n3.y) * (s4.x * s4.x + s4.y * s4.y)) > -0.866 && i2.x * s4.x + i2.y * s4.y < 0;
        }
        function ah(t2, e2, r2) {
          const n3 = e2 ? 2 | t2 : -3 & t2;
          return r2 ? 1 | n3 : -2 & n3;
        }
        function oh() {
          const t2 = Math.PI / 32, e2 = Math.tan(t2), r2 = Ul;
          return r2 * Math.sqrt(1 + 2 * e2 * e2) - r2;
        }
        function lh(t2, e2, r2) {
          const n3 = 1 << r2.z, i2 = Kl(r2.x / n3), s4 = Kl((r2.x + 1) / n3), a2 = Xl(r2.y / n3), o2 = Xl((r2.y + 1) / n3);
          return function(t3, e3, r3, n4, i3 = 0, s5) {
            const a3 = [];
            if (!t3.length || !r3 || !n4)
              return a3;
            const o3 = (t4, e4) => {
              for (const r4 of t4)
                a3.push({ polygon: r4, bounds: e4 });
            }, l3 = Math.ceil(Math.log2(r3)), u3 = Math.ceil(Math.log2(n4)), c4 = l3 - u3, h3 = [];
            for (let t4 = 0; t4 < Math.abs(c4); t4++)
              h3.push(c4 > 0 ? 0 : 1);
            for (let t4 = 0; t4 < Math.min(l3, u3); t4++)
              h3.push(0), h3.push(1);
            let p3 = t3;
            if (p3 = Xc(p3, e3[0].y - i3, e3[1].y + i3, 1), p3 = Xc(p3, e3[0].x - i3, e3[1].x + i3, 0), !p3.length)
              return a3;
            const d3 = [];
            for (h3.length ? d3.push({ polygons: p3, bounds: e3, depth: 0 }) : o3(p3, e3); d3.length; ) {
              const t4 = d3.pop(), e4 = t4.depth, r4 = h3[e4], n5 = t4.bounds[0], a4 = t4.bounds[1], l4 = 0 === r4 ? n5.x : n5.y, u4 = 0 === r4 ? a4.x : a4.y, c5 = s5 ? s5(r4, l4, u4) : 0.5 * (l4 + u4), p4 = Xc(t4.polygons, l4 - i3, c5 + i3, r4), f2 = Xc(t4.polygons, c5 - i3, u4 + i3, r4);
              if (p4.length) {
                const t5 = [n5, new x(0 === r4 ? c5 : a4.x, 1 === r4 ? c5 : a4.y)];
                h3.length > e4 + 1 ? d3.push({ polygons: p4, bounds: t5, depth: e4 + 1 }) : o3(p4, t5);
              }
              if (f2.length) {
                const t5 = [new x(0 === r4 ? c5 : n5.x, 1 === r4 ? c5 : n5.y), a4];
                h3.length > e4 + 1 ? d3.push({ polygons: f2, bounds: t5, depth: e4 + 1 }) : o3(f2, t5);
              }
            }
            return a3;
          }(t2, e2, Math.ceil((s4 - i2) / 11.25), Math.ceil((a2 - o2) / 11.25), 1, (t3, e3, i3) => {
            if (0 === t3)
              return 0.5 * (e3 + i3);
            {
              const t4 = Xl((r2.y + e3 / ao) / n3);
              return (Gl(0.5 * (Xl((r2.y + i3 / ao) / n3) + t4)) * n3 - r2.y) * ao;
            }
          });
        }
        Ji(th, "FillExtrusionBucket", { omit: ["layers", "features"] }), Ji(Qc, "PartMetadata");
        const uh = new Ps({ "fill-extrusion-edge-radius": new Bs(te["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
        var ch = { paint: new Ps({ "fill-extrusion-opacity": new Bs(te["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Es(te["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Bs(te["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Bs(te["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Es(te["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Es(te["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Es(te["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Bs(te["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Bs(te["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Bs(te["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-rounded-roof": new Bs(te["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]) }), layout: uh };
        function hh(t2, e2, r2) {
          var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t2 * n3 - 2 * Math.PI * 6378137 / 2, e2 * n3 - 2 * Math.PI * 6378137 / 2];
        }
        class ph {
          constructor(t2, e2, r2) {
            this.z = t2, this.x = e2, this.y = r2, this.key = yh(0, t2, t2, e2, r2);
          }
          equals(t2) {
            return this.z === t2.z && this.x === t2.x && this.y === t2.y;
          }
          url(t2, e2) {
            const r2 = function(t3, e3, r3) {
              var n4 = hh(256 * t3, 256 * (e3 = Math.pow(2, r3) - e3 - 1), r3), i2 = hh(256 * (t3 + 1), 256 * (e3 + 1), r3);
              return n4[0] + "," + n4[1] + "," + i2[0] + "," + i2[1];
            }(this.x, this.y, this.z), n3 = function(t3, e3, r3) {
              let n4, i2 = "";
              for (let s4 = t3; s4 > 0; s4--)
                n4 = 1 << s4 - 1, i2 += (e3 & n4 ? 1 : 0) + (r3 & n4 ? 2 : 0);
              return i2;
            }(this.z, this.x, this.y);
            return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n3).replace("{bbox-epsg-3857}", r2);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class dh {
          constructor(t2, e2) {
            this.wrap = t2, this.canonical = e2, this.key = yh(t2, e2.z, e2.z, e2.x, e2.y);
          }
        }
        class fh {
          constructor(t2, e2, r2, n3, i2) {
            this.overscaledZ = t2, this.wrap = e2, this.canonical = new ph(r2, +n3, +i2), this.key = 0 === e2 && t2 === r2 ? this.canonical.key : yh(e2, t2, r2, n3, i2);
          }
          equals(t2) {
            return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
          }
          scaledTo(t2) {
            const e2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? new fh(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new fh(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
          }
          calculateScaledKey(t2, e2 = true) {
            if (this.overscaledZ === t2 && e2)
              return this.key;
            if (t2 > this.canonical.z)
              return yh(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            {
              const r2 = this.canonical.z - t2;
              return yh(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
            }
          }
          isChildOf(t2) {
            if (t2.wrap !== this.wrap)
              return false;
            const e2 = this.canonical.z - t2.canonical.z;
            return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
          }
          children(t2) {
            if (this.overscaledZ >= t2)
              return [new fh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
            return [new fh(e2, this.wrap, e2, r2, n3), new fh(e2, this.wrap, e2, r2 + 1, n3), new fh(e2, this.wrap, e2, r2, n3 + 1), new fh(e2, this.wrap, e2, r2 + 1, n3 + 1)];
          }
          isLessThan(t2) {
            return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
          }
          wrapped() {
            return new fh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t2) {
            return new fh(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new dh(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
        }
        function yh(t2, e2, r2, n3, i2) {
          const s4 = 1 << Math.min(r2, 22);
          let a2 = s4 * (i2 % s4) + n3 % s4;
          return t2 && r2 < 22 && (a2 += s4 * s4 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r2)))), 16 * (32 * a2 + r2) + (e2 - r2);
        }
        Ji(ph, "CanonicalTileID"), Ji(fh, "OverscaledTileID", { omit: ["projMatrix"] });
        class mh extends x {
          constructor(t2, e2, r2) {
            super(t2, e2), this.z = r2;
          }
        }
        function gh(t2, e2) {
          return t2.x * e2.x + t2.y * e2.y;
        }
        function xh(t2, e2) {
          if (1 === t2.length) {
            let r2 = 0;
            const n3 = e2[r2++];
            let i2;
            for (; !i2 || n3.equals(i2); )
              if (i2 = e2[r2++], !i2)
                return 1 / 0;
            for (; r2 < e2.length; r2++) {
              const s4 = e2[r2], a2 = t2[0], o2 = i2.sub(n3), l3 = s4.sub(n3), u3 = a2.sub(n3), c4 = gh(o2, o2), h3 = gh(o2, l3), p3 = gh(l3, l3), d3 = gh(u3, o2), f2 = gh(u3, l3), y2 = c4 * p3 - h3 * h3, m3 = (p3 * d3 - h3 * f2) / y2, g2 = (c4 * f2 - h3 * d3) / y2, x2 = n3.z * (1 - m3 - g2) + i2.z * m3 + s4.z * g2;
              if (isFinite(x2))
                return x2;
            }
            return 1 / 0;
          }
          {
            let t3 = 1 / 0;
            for (const r2 of e2)
              t3 = Math.min(t3, r2.z);
            return t3;
          }
        }
        function vh(t2, e2, r2, n3, i2, s4, a2, o2) {
          const l3 = a2 * i2.getElevationAt(t2, e2, true, true), u3 = 0 !== s4[0], c4 = u3 ? 0 === s4[1] ? a2 * (s4[0] / 7 - 450) : a2 * function(t3, e3, r3) {
            const n4 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s5 = 10 * (e3[0] - 8 * n4), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n4, i3, true, true), l4 = t3.getMeterToDEM(r3), u4 = Math.floor(0.5 * (s5 * l4 - 1)), c5 = Math.floor(0.5 * (a3 * l4 - 1)), h3 = t3.tileCoordToPixel(n4, i3), p3 = 2 * u4 + 1, d3 = 2 * c5 + 1, f2 = function(t4, e4, r4, n5, i4) {
              return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n5, r4 + i4, true)];
            }(t3, h3.x - u4, h3.y - c5, p3, d3), y2 = Math.abs(f2[0] - f2[1]), m3 = Math.abs(f2[2] - f2[3]), g2 = Math.abs(f2[0] - f2[2]) + Math.abs(f2[1] - f2[3]), x2 = Math.min(0.25, 0.5 * l4 * (y2 + m3) / p3), v4 = Math.min(0.25, 0.5 * l4 * g2 / d3);
            return o3 + Math.max(x2 * s5, v4 * a3);
          }(i2, s4, o2) : l3;
          return { base: l3 + (0 === r2) ? -1 : r2, top: u3 ? Math.max(c4 + n3, l3 + r2 + 2) : l3 + n3 };
        }
        const bh = Rs([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: wh } = bh, _h = Rs([{ name: "a_packed", components: 4, type: "Float32" }]), { members: Ah } = _h, Sh = Kc.types, kh = Math.cos(Math.PI / 180 * 37.5);
        class Ih {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.projection = t2.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
              this.gradients[t3.id] = {};
            }), this.layoutVertexArray = new qs(), this.layoutVertexArray2 = new Ns(), this.indexArray = new ra(), this.programConfigurations = new Ja(t2.layers, t2.zoom), this.segments = new so(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2, n3) {
            this.hasPattern = kc("line", this.layers, e2);
            const i2 = this.layers[0].layout.get("line-sort-key"), s4 = [];
            for (const { feature: e3, id: a3, index: o3, sourceLayerIndex: l4 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u3 = ou(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), u3, r2))
                continue;
              const c4 = i2 ? i2.evaluate(u3, {}, r2) : void 0, h3 = { id: a3, properties: e3.properties, type: e3.type, sourceLayerIndex: l4, index: o3, geometry: t3 ? u3.geometry : au(e3, r2, n3), patterns: {}, sortKey: c4 };
              s4.push(h3);
            }
            i2 && s4.sort((t3, e3) => t3.sortKey - e3.sortKey);
            const { lineAtlas: a2, featureIndex: o2 } = e2, l3 = this.addConstantDashes(a2);
            for (const n4 of s4) {
              const { geometry: i3, index: s5, sourceLayerIndex: u3 } = n4;
              if (l3 && this.addFeatureDashes(n4, a2), this.hasPattern) {
                const t3 = Ic("line", this.layers, n4, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else
                this.addFeature(n4, i3, s5, r2, a2.positions, e2.availableImages);
              o2.insert(t2[s5].feature, i3, s5, u3, this.index);
            }
          }
          addConstantDashes(t2) {
            let e2 = false;
            for (const r2 of this.layers) {
              const n3 = r2.paint.get("line-dasharray").value, i2 = r2.layout.get("line-cap").value;
              if ("constant" !== n3.kind || "constant" !== i2.kind)
                e2 = true;
              else {
                const e3 = i2.value, r3 = n3.value;
                if (!r3)
                  continue;
                t2.addDash(r3, e3);
              }
            }
            return e2;
          }
          addFeatureDashes(t2, e2) {
            const r2 = this.zoom;
            for (const n3 of this.layers) {
              const i2 = n3.paint.get("line-dasharray").value, s4 = n3.layout.get("line-cap").value;
              if ("constant" === i2.kind && "constant" === s4.kind)
                continue;
              let a2, o2;
              if ("constant" === i2.kind) {
                if (a2 = i2.value, !a2)
                  continue;
              } else
                a2 = i2.evaluate({ zoom: r2 }, t2);
              o2 = "constant" === s4.kind ? s4.value : s4.evaluate({ zoom: r2 }, t2), e2.addDash(a2, o2), t2.patterns[n3.id] = e2.getKey(a2, o2);
            }
          }
          update(t2, e2, r2, n3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2, n3);
          }
          addFeatures(t2, e2, r2, n3, i2) {
            for (const t3 of this.patternFeatures)
              this.addFeature(t3, t3.geometry, t3.index, e2, r2, n3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Ah)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, wh), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t2) {
            if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end"))
              return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
          }
          addFeature(t2, e2, r2, n3, i2, s4) {
            const a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t2, {}), l3 = a2.get("line-cap").evaluate(t2, {}), u3 = a2.get("line-miter-limit"), c4 = a2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t2);
            for (const r3 of e2)
              this.addLine(r3, t2, o2, l3, u3, c4);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s4, n3);
          }
          addLine(t2, e2, r2, n3, i2, s4) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e3 = 0; e3 < t2.length - 1; e3++)
                this.totalDistance += t2[e3].dist(t2[e3 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const a2 = "Polygon" === Sh[e2.type];
            let o2 = t2.length;
            for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
              o2--;
            let l3 = 0;
            for (; l3 < o2 - 1 && t2[l3].equals(t2[l3 + 1]); )
              l3++;
            if (o2 < (a2 ? 3 : 2))
              return;
            "bevel" === r2 && (i2 = 1.05);
            const u3 = this.overscaling <= 16 ? 15 * ao / (512 * this.overscaling) : 0, c4 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
            let h3, p3, d3, f2, y2;
            this.e1 = this.e2 = -1, a2 && (h3 = t2[o2 - 2], y2 = t2[l3].sub(h3)._unit()._perp());
            for (let e3 = l3; e3 < o2; e3++) {
              if (d3 = e3 === o2 - 1 ? a2 ? t2[l3 + 1] : void 0 : t2[e3 + 1], d3 && t2[e3].equals(d3))
                continue;
              y2 && (f2 = y2), h3 && (p3 = h3), h3 = t2[e3], y2 = d3 ? d3.sub(h3)._unit()._perp() : f2, f2 = f2 || y2;
              let m3 = f2.add(y2);
              0 === m3.x && 0 === m3.y || m3._unit();
              const g2 = f2.x * y2.x + f2.y * y2.y, x2 = m3.x * y2.x + m3.y * y2.y, v4 = 0 !== x2 ? 1 / x2 : 1 / 0, b3 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < kh && p3 && d3, _2 = f2.x * y2.y - f2.y * y2.x > 0;
              if (w2 && e3 > l3) {
                const t3 = h3.dist(p3);
                if (t3 > 2 * u3) {
                  const e4 = h3.sub(h3.sub(p3)._mult(u3 / t3)._round());
                  this.updateDistance(p3, e4), this.addCurrentVertex(e4, f2, 0, 0, c4), p3 = e4;
                }
              }
              const A2 = p3 && d3;
              let S2 = A2 ? r2 : a2 ? "butt" : n3;
              if (A2 && "round" === S2 && (v4 < s4 ? S2 = "miter" : v4 <= 2 && (S2 = "fakeround")), "miter" === S2 && v4 > i2 && (S2 = "bevel"), "bevel" === S2 && (v4 > 2 && (S2 = "flipbevel"), v4 < i2 && (S2 = "miter")), p3 && this.updateDistance(p3, h3), "miter" === S2)
                m3._mult(v4), this.addCurrentVertex(h3, m3, 0, 0, c4);
              else if ("flipbevel" === S2) {
                if (v4 > 100)
                  m3 = y2.mult(-1);
                else {
                  const t3 = v4 * f2.add(y2).mag() / f2.sub(y2).mag();
                  m3._perp()._mult(t3 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h3, m3, 0, 0, c4), this.addCurrentVertex(h3, m3.mult(-1), 0, 0, c4);
              } else if ("bevel" === S2 || "fakeround" === S2) {
                const t3 = -Math.sqrt(v4 * v4 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
                if (p3 && this.addCurrentVertex(h3, f2, e4, r3, c4), "fakeround" === S2) {
                  const t4 = Math.round(180 * b3 / Math.PI / 20);
                  for (let e5 = 1; e5 < t4; e5++) {
                    let r4 = e5 / t4;
                    if (0.5 !== r4) {
                      const t5 = r4 - 0.5;
                      r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                    }
                    const n4 = y2.sub(f2)._mult(r4)._add(f2)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h3, n4.x, n4.y, false, _2, 0, c4);
                  }
                }
                d3 && this.addCurrentVertex(h3, y2, -e4, -r3, c4);
              } else if ("butt" === S2)
                this.addCurrentVertex(h3, m3, 0, 0, c4);
              else if ("square" === S2) {
                const t3 = p3 ? 1 : -1;
                p3 || this.addCurrentVertex(h3, m3, t3, t3, c4), this.addCurrentVertex(h3, m3, 0, 0, c4), p3 && this.addCurrentVertex(h3, m3, t3, t3, c4);
              } else
                "round" === S2 && (p3 && (this.addCurrentVertex(h3, f2, 0, 0, c4), this.addCurrentVertex(h3, f2, 1, 1, c4, true)), d3 && (this.addCurrentVertex(h3, y2, -1, -1, c4, true), this.addCurrentVertex(h3, y2, 0, 0, c4)));
              if (w2 && e3 < o2 - 1) {
                const t3 = h3.dist(d3);
                if (t3 > 2 * u3) {
                  const e4 = h3.add(d3.sub(h3)._mult(u3 / t3)._round());
                  this.updateDistance(h3, e4), this.addCurrentVertex(e4, y2, 0, 0, c4), h3 = e4;
                }
              }
            }
          }
          addCurrentVertex(t2, e2, r2, n3, i2, s4 = false) {
            const a2 = e2.y * n3 - e2.x, o2 = -e2.y - e2.x * n3;
            this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s4, false, r2, i2), this.addHalfVertex(t2, a2, o2, s4, true, -n3, i2);
          }
          addHalfVertex({ x: t2, y: e2 }, r2, n3, i2, s4, a2, o2) {
            this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s4 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n3) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
            const l3 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l3), o2.primitiveLength++), s4 ? this.e2 = l3 : this.e1 = l3;
          }
          updateScaledDistance() {
            if (this.lineClips) {
              const t2 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
              this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t2 * this.lineClips.start + this.distance;
            } else
              this.lineSoFar = this.distance;
          }
          updateDistance(t2, e2) {
            this.distance += t2.dist(e2), this.updateScaledDistance();
          }
        }
        Ji(Ih, "LineBucket", { omit: ["layers", "patternFeatures"] });
        const Mh = new Ps({ "line-cap": new Es(te.layout_line["line-cap"]), "line-join": new Es(te.layout_line["line-join"]), "line-miter-limit": new Bs(te.layout_line["line-miter-limit"]), "line-round-limit": new Bs(te.layout_line["line-round-limit"]), "line-sort-key": new Es(te.layout_line["line-sort-key"]) });
        var Th = { paint: new Ps({ "line-opacity": new Es(te.paint_line["line-opacity"]), "line-color": new Es(te.paint_line["line-color"]), "line-translate": new Bs(te.paint_line["line-translate"]), "line-translate-anchor": new Bs(te.paint_line["line-translate-anchor"]), "line-width": new Es(te.paint_line["line-width"]), "line-gap-width": new Es(te.paint_line["line-gap-width"]), "line-offset": new Es(te.paint_line["line-offset"]), "line-blur": new Es(te.paint_line["line-blur"]), "line-dasharray": new Es(te.paint_line["line-dasharray"]), "line-pattern": new Es(te.paint_line["line-pattern"]), "line-gradient": new Cs(te.paint_line["line-gradient"]), "line-trim-offset": new Bs(te.paint_line["line-trim-offset"]) }), layout: Mh };
        const zh = new class extends Es {
          possiblyEvaluate(t2, e2) {
            return e2 = new ws(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
          }
          evaluate(t2, e2, r2, n3) {
            return e2 = C2({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n3);
          }
        }(Th.paint.properties["line-width"].specification);
        function Bh(t2, e2) {
          return e2 > 0 ? e2 + 2 * t2 : t2;
        }
        zh.useIntegerZoom = true;
        const Eh = Rs([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Ch = Rs([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Ph = Rs([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
        Rs([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Dh = Rs([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), Vh = Rs([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
        Rs([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Lh = Rs([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Fh = Rs([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        Rs([{ name: "triangle", components: 3, type: "Uint16" }]), Rs([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Rs([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Rs([{ type: "Float32", name: "offsetX" }]), Rs([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
        var Rh = 24;
        const Uh = 128;
        function $h(t2, e2) {
          const { expression: r2 } = e2;
          if ("constant" === r2.kind)
            return { kind: "constant", layoutSize: r2.evaluate(new ws(t2 + 1)) };
          if ("source" === r2.kind)
            return { kind: "source" };
          {
            const { zoomStops: e3, interpolationType: n3 } = r2;
            let i2 = 0;
            for (; i2 < e3.length && e3[i2] <= t2; )
              i2++;
            i2 = Math.max(0, i2 - 1);
            let s4 = i2;
            for (; s4 < e3.length && e3[s4] < t2 + 1; )
              s4++;
            s4 = Math.min(e3.length - 1, s4);
            const a2 = e3[i2], o2 = e3[s4];
            return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n3 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new ws(a2)), maxSize: r2.evaluate(new ws(o2)), interpolationType: n3 };
          }
        }
        function jh(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n3, upperSize: i2 }) {
          return "source" === t2.kind ? n3 / Uh : "composite" === t2.kind ? Er(n3 / Uh, i2 / Uh, r2) : e2;
        }
        function Oh(t2, e2) {
          let r2 = 0, n3 = 0;
          if ("constant" === t2.kind)
            n3 = t2.layoutSize;
          else if ("source" !== t2.kind) {
            const { interpolationType: i2, minZoom: s4, maxZoom: a2 } = t2, o2 = i2 ? M(Qr.interpolationFactor(i2, e2, s4, a2), 0, 1) : 0;
            "camera" === t2.kind ? n3 = Er(t2.minSize, t2.maxSize, o2) : r2 = o2;
          }
          return { uSizeT: r2, uSize: n3 };
        }
        var qh = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Uh, evaluateSizeForFeature: jh, evaluateSizeForZoom: Oh, getSizeData: $h });
        function Nh(t2, e2, r2) {
          return t2.sections.forEach((t3) => {
            t3.text = function(t4, e3, r3) {
              const n3 = e3.layout.get("text-transform").evaluate(r3, {});
              return "uppercase" === n3 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n3 && (t4 = t4.toLocaleLowerCase()), bs.applyArabicShaping && (t4 = bs.applyArabicShaping(t4)), t4;
            }(t3.text, e2, r2);
          }), t2;
        }
        const Gh = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂", "←": "↑", "→": "↓" };
        function Zh(t2) {
          return "︶" === t2 || "﹈" === t2 || "︸" === t2 || "﹄" === t2 || "﹂" === t2 || "︾" === t2 || "︼" === t2 || "︺" === t2 || "︘" === t2 || "﹀" === t2 || "︐" === t2 || "︓" === t2 || "︔" === t2 || "｀" === t2 || "￣" === t2 || "︑" === t2 || "︒" === t2;
        }
        function Kh(t2) {
          return "︵" === t2 || "﹇" === t2 || "︷" === t2 || "﹃" === t2 || "﹁" === t2 || "︽" === t2 || "︻" === t2 || "︹" === t2 || "︗" === t2 || "︿" === t2;
        }
        var Xh = Yh, Jh = function(t2, e2, r2, n3, i2) {
          var s4, a2, o2 = 8 * i2 - n3 - 1, l3 = (1 << o2) - 1, u3 = l3 >> 1, c4 = -7, h3 = r2 ? i2 - 1 : 0, p3 = r2 ? -1 : 1, d3 = t2[e2 + h3];
          for (h3 += p3, s4 = d3 & (1 << -c4) - 1, d3 >>= -c4, c4 += o2; c4 > 0; s4 = 256 * s4 + t2[e2 + h3], h3 += p3, c4 -= 8)
            ;
          for (a2 = s4 & (1 << -c4) - 1, s4 >>= -c4, c4 += n3; c4 > 0; a2 = 256 * a2 + t2[e2 + h3], h3 += p3, c4 -= 8)
            ;
          if (0 === s4)
            s4 = 1 - u3;
          else {
            if (s4 === l3)
              return a2 ? NaN : 1 / 0 * (d3 ? -1 : 1);
            a2 += Math.pow(2, n3), s4 -= u3;
          }
          return (d3 ? -1 : 1) * a2 * Math.pow(2, s4 - n3);
        }, Hh = function(t2, e2, r2, n3, i2, s4) {
          var a2, o2, l3, u3 = 8 * s4 - i2 - 1, c4 = (1 << u3) - 1, h3 = c4 >> 1, p3 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d3 = n3 ? 0 : s4 - 1, f2 = n3 ? 1 : -1, y2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c4) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l3 = Math.pow(2, -a2)) < 1 && (a2--, l3 *= 2), (e2 += a2 + h3 >= 1 ? p3 / l3 : p3 * Math.pow(2, 1 - h3)) * l3 >= 2 && (a2++, l3 /= 2), a2 + h3 >= c4 ? (o2 = 0, a2 = c4) : a2 + h3 >= 1 ? (o2 = (e2 * l3 - 1) * Math.pow(2, i2), a2 += h3) : (o2 = e2 * Math.pow(2, h3 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + d3] = 255 & o2, d3 += f2, o2 /= 256, i2 -= 8)
            ;
          for (a2 = a2 << i2 | o2, u3 += i2; u3 > 0; t2[r2 + d3] = 255 & a2, d3 += f2, a2 /= 256, u3 -= 8)
            ;
          t2[r2 + d3 - f2] |= 128 * y2;
        };
        function Yh(t2) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        Yh.Varint = 0, Yh.Fixed64 = 1, Yh.Bytes = 2, Yh.Fixed32 = 5;
        var Wh = 4294967296, Qh = 1 / Wh, tp = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function ep(t2) {
          return t2.type === Yh.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
        }
        function rp(t2, e2, r2) {
          return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
        }
        function np(t2, e2, r2) {
          var n3 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r2.realloc(n3);
          for (var i2 = r2.pos - 1; i2 >= t2; i2--)
            r2.buf[i2 + n3] = r2.buf[i2];
        }
        function ip(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeVarint(t2[r2]);
        }
        function sp(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSVarint(t2[r2]);
        }
        function ap(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFloat(t2[r2]);
        }
        function op(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeDouble(t2[r2]);
        }
        function lp(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeBoolean(t2[r2]);
        }
        function up(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFixed32(t2[r2]);
        }
        function cp(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSFixed32(t2[r2]);
        }
        function hp(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFixed64(t2[r2]);
        }
        function pp(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSFixed64(t2[r2]);
        }
        function dp(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
        }
        function fp(t2, e2, r2) {
          t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
        }
        function yp(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
        }
        Yh.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t2, e2, r2) {
          for (r2 = r2 || this.length; this.pos < r2; ) {
            var n3 = this.readVarint(), i2 = n3 >> 3, s4 = this.pos;
            this.type = 7 & n3, t2(i2, e2, this), this.pos === s4 && this.skip(n3);
          }
          return e2;
        }, readMessage: function(t2, e2) {
          return this.readFields(t2, e2, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t2 = dp(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readSFixed32: function() {
          var t2 = yp(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readFixed64: function() {
          var t2 = dp(this.buf, this.pos) + dp(this.buf, this.pos + 4) * Wh;
          return this.pos += 8, t2;
        }, readSFixed64: function() {
          var t2 = dp(this.buf, this.pos) + yp(this.buf, this.pos + 4) * Wh;
          return this.pos += 8, t2;
        }, readFloat: function() {
          var t2 = Jh(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t2;
        }, readDouble: function() {
          var t2 = Jh(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t2;
        }, readVarint: function(t2) {
          var e2, r2, n3 = this.buf;
          return e2 = 127 & (r2 = n3[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n3[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n3[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n3[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
            var n4, i2, s4 = r3.buf;
            if (n4 = (112 & (i2 = s4[r3.pos++])) >> 4, i2 < 128)
              return rp(t3, n4, e3);
            if (n4 |= (127 & (i2 = s4[r3.pos++])) << 3, i2 < 128)
              return rp(t3, n4, e3);
            if (n4 |= (127 & (i2 = s4[r3.pos++])) << 10, i2 < 128)
              return rp(t3, n4, e3);
            if (n4 |= (127 & (i2 = s4[r3.pos++])) << 17, i2 < 128)
              return rp(t3, n4, e3);
            if (n4 |= (127 & (i2 = s4[r3.pos++])) << 24, i2 < 128)
              return rp(t3, n4, e3);
            if (n4 |= (1 & (i2 = s4[r3.pos++])) << 31, i2 < 128)
              return rp(t3, n4, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r2 = n3[this.pos])) << 28, t2, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t2 = this.readVarint();
          return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t2, t2 - e2 >= 12 && tp ? function(t3, e3, r2) {
            return tp.decode(t3.subarray(e3, r2));
          }(this.buf, e2, t2) : function(t3, e3, r2) {
            for (var n3 = "", i2 = e3; i2 < r2; ) {
              var s4, a2, o2, l3 = t3[i2], u3 = null, c4 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
              if (i2 + c4 > r2)
                break;
              1 === c4 ? l3 < 128 && (u3 = l3) : 2 === c4 ? 128 == (192 & (s4 = t3[i2 + 1])) && (u3 = (31 & l3) << 6 | 63 & s4) <= 127 && (u3 = null) : 3 === c4 ? (a2 = t3[i2 + 2], 128 == (192 & (s4 = t3[i2 + 1])) && 128 == (192 & a2) && ((u3 = (15 & l3) << 12 | (63 & s4) << 6 | 63 & a2) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c4 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & (s4 = t3[i2 + 1])) && 128 == (192 & a2) && 128 == (192 & o2) && ((u3 = (15 & l3) << 18 | (63 & s4) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c4 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i2 += c4;
            }
            return n3;
          }(this.buf, e2, t2);
        }, readBytes: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
          return this.pos = t2, e2;
        }, readPackedVarint: function(t2, e2) {
          if (this.type !== Yh.Bytes)
            return t2.push(this.readVarint(e2));
          var r2 = ep(this);
          for (t2 = t2 || []; this.pos < r2; )
            t2.push(this.readVarint(e2));
          return t2;
        }, readPackedSVarint: function(t2) {
          if (this.type !== Yh.Bytes)
            return t2.push(this.readSVarint());
          var e2 = ep(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSVarint());
          return t2;
        }, readPackedBoolean: function(t2) {
          if (this.type !== Yh.Bytes)
            return t2.push(this.readBoolean());
          var e2 = ep(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readBoolean());
          return t2;
        }, readPackedFloat: function(t2) {
          if (this.type !== Yh.Bytes)
            return t2.push(this.readFloat());
          var e2 = ep(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFloat());
          return t2;
        }, readPackedDouble: function(t2) {
          if (this.type !== Yh.Bytes)
            return t2.push(this.readDouble());
          var e2 = ep(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readDouble());
          return t2;
        }, readPackedFixed32: function(t2) {
          if (this.type !== Yh.Bytes)
            return t2.push(this.readFixed32());
          var e2 = ep(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFixed32());
          return t2;
        }, readPackedSFixed32: function(t2) {
          if (this.type !== Yh.Bytes)
            return t2.push(this.readSFixed32());
          var e2 = ep(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSFixed32());
          return t2;
        }, readPackedFixed64: function(t2) {
          if (this.type !== Yh.Bytes)
            return t2.push(this.readFixed64());
          var e2 = ep(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFixed64());
          return t2;
        }, readPackedSFixed64: function(t2) {
          if (this.type !== Yh.Bytes)
            return t2.push(this.readSFixed64());
          var e2 = ep(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSFixed64());
          return t2;
        }, skip: function(t2) {
          var e2 = 7 & t2;
          if (e2 === Yh.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e2 === Yh.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e2 === Yh.Fixed32)
            this.pos += 4;
          else {
            if (e2 !== Yh.Fixed64)
              throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        }, writeTag: function(t2, e2) {
          this.writeVarint(t2 << 3 | e2);
        }, realloc: function(t2) {
          for (var e2 = this.length || 16; e2 < this.pos + t2; )
            e2 *= 2;
          if (e2 !== this.length) {
            var r2 = new Uint8Array(e2);
            r2.set(this.buf), this.buf = r2, this.length = e2;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t2) {
          this.realloc(4), fp(this.buf, t2, this.pos), this.pos += 4;
        }, writeSFixed32: function(t2) {
          this.realloc(4), fp(this.buf, t2, this.pos), this.pos += 4;
        }, writeFixed64: function(t2) {
          this.realloc(8), fp(this.buf, -1 & t2, this.pos), fp(this.buf, Math.floor(t2 * Qh), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t2) {
          this.realloc(8), fp(this.buf, -1 & t2, this.pos), fp(this.buf, Math.floor(t2 * Qh), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t2) {
          (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
            var r2, n3;
            if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n3 = t3 / 4294967296 | 0) : (n3 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n3 = n3 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t4, e3, r3) {
              r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
            }(r2, 0, e2), function(t4, e3) {
              var r3 = (7 & t4) << 4;
              e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
            }(n3, e2);
          }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
        }, writeSVarint: function(t2) {
          this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
        }, writeBoolean: function(t2) {
          this.writeVarint(Boolean(t2));
        }, writeString: function(t2) {
          t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t3, e3, r3) {
            for (var n3, i2, s4 = 0; s4 < e3.length; s4++) {
              if ((n3 = e3.charCodeAt(s4)) > 55295 && n3 < 57344) {
                if (!i2) {
                  n3 > 56319 || s4 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n3;
                  continue;
                }
                if (n3 < 56320) {
                  t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n3;
                  continue;
                }
                n3 = i2 - 55296 << 10 | n3 - 56320 | 65536, i2 = null;
              } else
                i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
              n3 < 128 ? t3[r3++] = n3 : (n3 < 2048 ? t3[r3++] = n3 >> 6 | 192 : (n3 < 65536 ? t3[r3++] = n3 >> 12 | 224 : (t3[r3++] = n3 >> 18 | 240, t3[r3++] = n3 >> 12 & 63 | 128), t3[r3++] = n3 >> 6 & 63 | 128), t3[r3++] = 63 & n3 | 128);
            }
            return r3;
          }(this.buf, t2, this.pos);
          var r2 = this.pos - e2;
          r2 >= 128 && np(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
        }, writeFloat: function(t2) {
          this.realloc(4), Hh(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t2) {
          this.realloc(8), Hh(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t2) {
          var e2 = t2.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r2 = 0; r2 < e2; r2++)
            this.buf[this.pos++] = t2[r2];
        }, writeRawMessage: function(t2, e2) {
          this.pos++;
          var r2 = this.pos;
          t2(e2, this);
          var n3 = this.pos - r2;
          n3 >= 128 && np(r2, n3, this), this.pos = r2 - 1, this.writeVarint(n3), this.pos += n3;
        }, writeMessage: function(t2, e2, r2) {
          this.writeTag(t2, Yh.Bytes), this.writeRawMessage(e2, r2);
        }, writePackedVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, ip, e2);
        }, writePackedSVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, sp, e2);
        }, writePackedBoolean: function(t2, e2) {
          e2.length && this.writeMessage(t2, lp, e2);
        }, writePackedFloat: function(t2, e2) {
          e2.length && this.writeMessage(t2, ap, e2);
        }, writePackedDouble: function(t2, e2) {
          e2.length && this.writeMessage(t2, op, e2);
        }, writePackedFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, up, e2);
        }, writePackedSFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, cp, e2);
        }, writePackedFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, hp, e2);
        }, writePackedSFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, pp, e2);
        }, writeBytesField: function(t2, e2) {
          this.writeTag(t2, Yh.Bytes), this.writeBytes(e2);
        }, writeFixed32Field: function(t2, e2) {
          this.writeTag(t2, Yh.Fixed32), this.writeFixed32(e2);
        }, writeSFixed32Field: function(t2, e2) {
          this.writeTag(t2, Yh.Fixed32), this.writeSFixed32(e2);
        }, writeFixed64Field: function(t2, e2) {
          this.writeTag(t2, Yh.Fixed64), this.writeFixed64(e2);
        }, writeSFixed64Field: function(t2, e2) {
          this.writeTag(t2, Yh.Fixed64), this.writeSFixed64(e2);
        }, writeVarintField: function(t2, e2) {
          this.writeTag(t2, Yh.Varint), this.writeVarint(e2);
        }, writeSVarintField: function(t2, e2) {
          this.writeTag(t2, Yh.Varint), this.writeSVarint(e2);
        }, writeStringField: function(t2, e2) {
          this.writeTag(t2, Yh.Bytes), this.writeString(e2);
        }, writeFloatField: function(t2, e2) {
          this.writeTag(t2, Yh.Fixed32), this.writeFloat(e2);
        }, writeDoubleField: function(t2, e2) {
          this.writeTag(t2, Yh.Fixed64), this.writeDouble(e2);
        }, writeBooleanField: function(t2, e2) {
          this.writeVarintField(t2, Boolean(e2));
        } };
        var mp = p2(Xh);
        const gp = 3;
        function xp(t2, e2, r2) {
          e2.glyphs = [], 1 === t2 && r2.readMessage(vp, e2);
        }
        function vp(t2, e2, r2) {
          if (3 === t2) {
            const { id: t3, bitmap: n3, width: i2, height: s4, left: a2, top: o2, advance: l3 } = r2.readMessage(bp, {});
            e2.glyphs.push({ id: t3, bitmap: new Ru({ width: i2 + 2 * gp, height: s4 + 2 * gp }, n3), metrics: { width: i2, height: s4, left: a2, top: o2, advance: l3 } });
          } else
            4 === t2 ? e2.ascender = r2.readSVarint() : 5 === t2 && (e2.descender = r2.readSVarint());
        }
        function bp(t2, e2, r2) {
          1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
        }
        const wp = gp;
        function _p(t2) {
          let e2 = 0, r2 = 0;
          for (const n4 of t2)
            e2 += n4.w * n4.h, r2 = Math.max(r2, n4.w);
          t2.sort((t3, e3) => e3.h - t3.h);
          const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
          let i2 = 0, s4 = 0;
          for (const e3 of t2)
            for (let t3 = n3.length - 1; t3 >= 0; t3--) {
              const r3 = n3[t3];
              if (!(e3.w > r3.w || e3.h > r3.h)) {
                if (e3.x = r3.x, e3.y = r3.y, s4 = Math.max(s4, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                  const e4 = n3.pop();
                  t3 < n3.length && (n3[t3] = e4);
                } else
                  e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n3.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
                break;
              }
            }
          return { w: i2, h: s4, fill: e2 / (i2 * s4) || 0 };
        }
        const Ap = 1;
        class Sp {
          constructor(t2, { pixelRatio: e2, version: r2, stretchX: n3, stretchY: i2, content: s4 }) {
            this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n3, this.stretchY = i2, this.content = s4, this.version = r2;
          }
          get tl() {
            return [this.paddedRect.x + Ap, this.paddedRect.y + Ap];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - Ap, this.paddedRect.y + this.paddedRect.h - Ap];
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * Ap) / this.pixelRatio, (this.paddedRect.h - 2 * Ap) / this.pixelRatio];
          }
        }
        class kp {
          constructor(t2, e2) {
            const r2 = {}, n3 = {};
            this.haveRenderCallbacks = [];
            const i2 = [];
            this.addImages(t2, r2, i2), this.addImages(e2, n3, i2);
            const { w: s4, h: a2 } = _p(i2), o2 = new Uu({ width: s4 || 1, height: a2 || 1 });
            for (const e3 in t2) {
              const n4 = t2[e3], i3 = r2[e3].paddedRect;
              Uu.copy(n4.data, o2, { x: 0, y: 0 }, { x: i3.x + Ap, y: i3.y + Ap }, n4.data);
            }
            for (const t3 in e2) {
              const r3 = e2[t3], i3 = n3[t3].paddedRect, s5 = i3.x + Ap, a3 = i3.y + Ap, l3 = r3.data.width, u3 = r3.data.height;
              Uu.copy(r3.data, o2, { x: 0, y: 0 }, { x: s5, y: a3 }, r3.data), Uu.copy(r3.data, o2, { x: 0, y: u3 - 1 }, { x: s5, y: a3 - 1 }, { width: l3, height: 1 }), Uu.copy(r3.data, o2, { x: 0, y: 0 }, { x: s5, y: a3 + u3 }, { width: l3, height: 1 }), Uu.copy(r3.data, o2, { x: l3 - 1, y: 0 }, { x: s5 - 1, y: a3 }, { width: 1, height: u3 }), Uu.copy(r3.data, o2, { x: 0, y: 0 }, { x: s5 + l3, y: a3 }, { width: 1, height: u3 });
            }
            this.image = o2, this.iconPositions = r2, this.patternPositions = n3;
          }
          addImages(t2, e2, r2) {
            for (const n3 in t2) {
              const i2 = t2[n3], s4 = { x: 0, y: 0, w: i2.data.width + 2 * Ap, h: i2.data.height + 2 * Ap };
              r2.push(s4), e2[n3] = new Sp(s4, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n3);
            }
          }
          patchUpdatedImages(t2, e2) {
            this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t2.hasImage(e3)), t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r2 in t2.updatedImages)
              this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
          }
          patchUpdatedImage(t2, e2, r2) {
            if (!t2 || !e2)
              return;
            if (t2.version === e2.version)
              return;
            t2.version = e2.version;
            const [n3, i2] = t2.tl;
            r2.update(e2.data, void 0, { x: n3, y: i2 });
          }
        }
        Ji(Sp, "ImagePosition"), Ji(kp, "ImageAtlas");
        const Ip = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, Mp = -17;
        class Tp {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t2, e2) {
            const r2 = new Tp();
            return r2.scale = t2 || 1, r2.fontStack = e2, r2;
          }
          static forImage(t2) {
            const e2 = new Tp();
            return e2.imageName = t2, e2;
          }
        }
        class zp {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t2, e2) {
            const r2 = new zp();
            for (let n3 = 0; n3 < t2.sections.length; n3++) {
              const i2 = t2.sections[n3];
              i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
            }
            return r2;
          }
          length() {
            return this.text.length;
          }
          getSection(t2) {
            return this.sections[this.sectionIndex[t2]];
          }
          getSections() {
            return this.sections;
          }
          getSectionIndex(t2) {
            return this.sectionIndex[t2];
          }
          getCharCode(t2) {
            return this.text.charCodeAt(t2);
          }
          verticalizePunctuation(t2) {
            this.text = function(t3, e2) {
              let r2 = "";
              for (let n3 = 0; n3 < t3.length; n3++) {
                const i2 = t3.charCodeAt(n3 + 1) || null, s4 = t3.charCodeAt(n3 - 1) || null;
                r2 += !e2 && (i2 && ss(i2) && !Gh[t3[n3 + 1]] || s4 && ss(s4) && !Gh[t3[n3 - 1]]) || !Gh[t3[n3]] ? t3[n3] : Gh[t3[n3]];
              }
              return r2;
            }(this.text, t2);
          }
          trim() {
            let t2 = 0;
            for (let e3 = 0; e3 < this.text.length && Ep[this.text.charCodeAt(e3)]; e3++)
              t2++;
            let e2 = this.text.length;
            for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && Ep[this.text.charCodeAt(r2)]; r2--)
              e2--;
            this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
          }
          substring(t2, e2) {
            const r2 = new zp();
            return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
          }
          addTextSection(t2, e2) {
            this.text += t2.text, this.sections.push(Tp.forText(t2.scale, t2.fontStack || e2));
            const r2 = this.sections.length - 1;
            for (let e3 = 0; e3 < t2.text.length; ++e3)
              this.sectionIndex.push(r2);
          }
          addImageSection(t2) {
            const e2 = t2.image ? t2.image.name : "";
            if (0 === e2.length)
              return void N("Can't add FormattedSection with an empty image.");
            const r2 = this.getNextImageSectionCharCode();
            r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Tp.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : N("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Bp(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3, f2) {
          const y2 = zp.fromFeature(t2, i2);
          h3 === Ip.vertical && y2.verticalizePunctuation(p3);
          let m3 = [];
          const g2 = function(t3, e3, r3, n4, i3, s5) {
            if (!t3)
              return [];
            const a3 = [], o3 = function(t4, e4, r4, n5, i4, s6) {
              let a4 = 0;
              for (let r5 = 0; r5 < t4.length(); r5++) {
                const o4 = t4.getSection(r5);
                a4 += Pp(t4.getCharCode(r5), o4, n5, i4, e4, s6);
              }
              return a4 / Math.max(1, Math.ceil(a4 / r4));
            }(t3, e3, r3, n4, i3, s5), l4 = t3.text.indexOf("​") >= 0;
            let u4 = 0;
            for (let r4 = 0; r4 < t3.length(); r4++) {
              const h4 = t3.getSection(r4), p4 = t3.getCharCode(r4);
              if (Ep[p4] || (u4 += Pp(p4, h4, n4, i3, e3, s5)), r4 < t3.length() - 1) {
                const e4 = !((c5 = p4) < 11904 || !(ts["Bopomofo Extended"](c5) || ts.Bopomofo(c5) || ts["CJK Compatibility Forms"](c5) || ts["CJK Compatibility Ideographs"](c5) || ts["CJK Compatibility"](c5) || ts["CJK Radicals Supplement"](c5) || ts["CJK Strokes"](c5) || ts["CJK Symbols and Punctuation"](c5) || ts["CJK Unified Ideographs Extension A"](c5) || ts["CJK Unified Ideographs"](c5) || ts["Enclosed CJK Letters and Months"](c5) || ts["Halfwidth and Fullwidth Forms"](c5) || ts.Hiragana(c5) || ts["Ideographic Description Characters"](c5) || ts["Kangxi Radicals"](c5) || ts["Katakana Phonetic Extensions"](c5) || ts.Katakana(c5) || ts["Vertical Forms"](c5) || ts["Yi Radicals"](c5) || ts["Yi Syllables"](c5)));
                (Cp[p4] || e4 || h4.imageName) && a3.push(Lp(r4 + 1, u4, o3, a3, Vp(p4, t3.getCharCode(r4 + 1), e4 && l4), false));
              }
            }
            var c5;
            return Fp(Lp(t3.length(), u4, o3, a3, 0, true));
          }(y2, u3, s4, e2, n3, d3), { processBidirectionalText: x2, processStyledBidirectionalText: v4 } = bs;
          if (x2 && 1 === y2.sections.length) {
            const t3 = x2(y2.toString(), g2);
            for (const e3 of t3) {
              const t4 = new zp();
              t4.text = e3, t4.sections = y2.sections;
              for (let r3 = 0; r3 < e3.length; r3++)
                t4.sectionIndex.push(0);
              m3.push(t4);
            }
          } else if (v4) {
            const t3 = v4(y2.text, y2.sectionIndex, g2);
            for (const e3 of t3) {
              const t4 = new zp();
              t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = y2.sections, m3.push(t4);
            }
          } else
            m3 = function(t3, e3) {
              const r3 = [], n4 = t3.text;
              let i3 = 0;
              for (const n5 of e3)
                r3.push(t3.substring(i3, n5)), i3 = n5;
              return i3 < n4.length && r3.push(t3.substring(i3, n4.length)), r3;
            }(y2, g2);
          const b3 = [], w2 = { positionedLines: b3, text: y2.toString(), top: c4[1], bottom: c4[1], left: c4[0], right: c4[0], writingMode: h3, iconsInText: false, verticalizable: false, hasBaseline: false };
          return function(t3, e3, r3, n4, i3, s5, a3, o3, l4, u4, c5, h4) {
            let p4 = 0, d4 = 0, f3 = 0;
            const y3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5;
            let m4 = false;
            for (const t4 of i3) {
              const r4 = t4.getSections();
              for (const t5 of r4) {
                if (t5.imageName)
                  continue;
                const r5 = e3[t5.fontStack];
                if (r5 && (m4 = void 0 !== r5.ascender && void 0 !== r5.descender, !m4))
                  break;
              }
              if (!m4)
                break;
            }
            let g3 = 0;
            for (const a4 of i3) {
              a4.trim();
              const i4 = a4.getMaxScale(), o4 = (i4 - 1) * Rh, v6 = { positionedGlyphs: [], lineOffset: 0 };
              t3.positionedLines[g3] = v6;
              const b5 = v6.positionedGlyphs;
              let w4 = 0;
              if (!a4.length()) {
                d4 += s5, ++g3;
                continue;
              }
              let _2 = 0, A2 = 0;
              for (let s6 = 0; s6 < a4.length(); s6++) {
                const o5 = a4.getSection(s6), f4 = a4.getSectionIndex(s6), y4 = a4.getCharCode(s6);
                let g4 = o5.scale, v7 = null, S3 = null, k2 = null, I2 = Rh, M2 = 0;
                const T3 = !(l4 === Ip.horizontal || !c5 && !is(y4) || c5 && (Ep[y4] || (x3 = y4, ts.Arabic(x3) || ts["Arabic Supplement"](x3) || ts["Arabic Extended-A"](x3) || ts["Arabic Presentation Forms-A"](x3) || ts["Arabic Presentation Forms-B"](x3))));
                if (o5.imageName) {
                  const e4 = n4[o5.imageName];
                  if (!e4)
                    continue;
                  k2 = o5.imageName, t3.iconsInText = t3.iconsInText || true, S3 = e4.paddedRect;
                  const r4 = e4.displaySize;
                  g4 = g4 * Rh / h4, v7 = { width: r4[0], height: r4[1], left: Ap, top: -wp, advance: T3 ? r4[1] : r4[0], localGlyph: false }, M2 = m4 ? -v7.height * g4 : Mp + i4 * Rh - r4[1] * g4, I2 = v7.advance;
                  const s7 = (T3 ? r4[0] : r4[1]) * g4 - Rh * i4;
                  s7 > 0 && s7 > w4 && (w4 = s7);
                } else {
                  const t4 = r3[o5.fontStack];
                  if (!t4)
                    continue;
                  t4[y4] && (S3 = t4[y4]);
                  const n5 = e3[o5.fontStack];
                  if (!n5)
                    continue;
                  const s7 = n5.glyphs[y4];
                  if (!s7)
                    continue;
                  if (v7 = s7.metrics, I2 = 8203 !== y4 ? Rh : 0, m4) {
                    const t5 = void 0 !== n5.ascender ? Math.abs(n5.ascender) : 0, e4 = void 0 !== n5.descender ? Math.abs(n5.descender) : 0, r4 = (t5 + e4) * g4;
                    _2 < r4 && (_2 = r4, A2 = (t5 - e4) / 2 * g4), M2 = -t5 * g4;
                  } else
                    M2 = Mp + (i4 - g4) * Rh;
                }
                T3 ? (t3.verticalizable = true, b5.push({ glyph: y4, imageName: k2, x: p4, y: d4 + M2, vertical: T3, scale: g4, localGlyph: v7.localGlyph, fontStack: o5.fontStack, sectionIndex: f4, metrics: v7, rect: S3 }), p4 += I2 * g4 + u4) : (b5.push({ glyph: y4, imageName: k2, x: p4, y: d4 + M2, vertical: T3, scale: g4, localGlyph: v7.localGlyph, fontStack: o5.fontStack, sectionIndex: f4, metrics: v7, rect: S3 }), p4 += v7.advance * g4 + u4);
              }
              0 !== b5.length && (f3 = Math.max(p4 - u4, f3), m4 ? Up(b5, y3, w4, A2, s5 * i4 / 2) : Up(b5, y3, w4, 0, s5 / 2)), p4 = 0;
              const S2 = s5 * i4 + w4;
              v6.lineOffset = Math.max(w4, o4), d4 += S2, ++g3;
            }
            var x3;
            const v5 = d4, { horizontalAlign: b4, verticalAlign: w3 } = Rp(a3);
            (function(t4, e4, r4, n5, i4, s6) {
              const a4 = (e4 - r4) * i4, o4 = -s6 * n5;
              for (const e5 of t4)
                for (const t5 of e5.positionedGlyphs)
                  t5.x += a4, t5.y += o4;
            })(t3.positionedLines, y3, b4, w3, f3, v5), t3.top += -w3 * v5, t3.bottom = t3.top + v5, t3.left += -b4 * f3, t3.right = t3.left + f3, t3.hasBaseline = m4;
          }(w2, e2, r2, n3, m3, a2, o2, l3, h3, u3, p3, f2), !function(t3) {
            for (const e3 of t3)
              if (0 !== e3.positionedGlyphs.length)
                return false;
            return true;
          }(b3) && w2;
        }
        const Ep = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Cp = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function Pp(t2, e2, r2, n3, i2, s4) {
          if (e2.imageName) {
            const t3 = n3[e2.imageName];
            return t3 ? t3.displaySize[0] * e2.scale * Rh / s4 + i2 : 0;
          }
          {
            const n4 = r2[e2.fontStack], s5 = n4 && n4.glyphs[t2];
            return s5 ? s5.metrics.advance * e2.scale + i2 : 0;
          }
        }
        function Dp(t2, e2, r2, n3) {
          const i2 = Math.pow(t2 - e2, 2);
          return n3 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
        }
        function Vp(t2, e2, r2) {
          let n3 = 0;
          return 10 === t2 && (n3 -= 1e4), r2 && (n3 += 150), 40 !== t2 && 65288 !== t2 || (n3 += 50), 41 !== e2 && 65289 !== e2 || (n3 += 50), n3;
        }
        function Lp(t2, e2, r2, n3, i2, s4) {
          let a2 = null, o2 = Dp(e2, r2, i2, s4);
          for (const t3 of n3) {
            const n4 = Dp(e2 - t3.x, r2, i2, s4) + t3.badness;
            n4 <= o2 && (a2 = t3, o2 = n4);
          }
          return { index: t2, x: e2, priorBreak: a2, badness: o2 };
        }
        function Fp(t2) {
          return t2 ? Fp(t2.priorBreak).concat(t2.index) : [];
        }
        function Rp(t2) {
          let e2 = 0.5, r2 = 0.5;
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t2) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r2 };
        }
        function Up(t2, e2, r2, n3, i2) {
          if (!(e2 || r2 || n3 || i2))
            return;
          const s4 = t2.length - 1, a2 = t2[s4], o2 = (a2.x + a2.metrics.advance * a2.scale) * e2;
          for (let e3 = 0; e3 <= s4; e3++)
            t2[e3].x -= o2, t2[e3].y += r2 + n3 + i2;
        }
        function $p(t2, e2, r2) {
          const { horizontalAlign: n3, verticalAlign: i2 } = Rp(r2), s4 = e2[0] - t2.displaySize[0] * n3, a2 = e2[1] - t2.displaySize[1] * i2;
          return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s4, right: s4 + t2.displaySize[0] };
        }
        function jp(t2, e2, r2, n3, i2, s4) {
          const a2 = t2.image;
          let o2;
          if (a2.content) {
            const t3 = a2.content, e3 = a2.pixelRatio || 1;
            o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
          }
          const l3 = e2.left * s4, u3 = e2.right * s4;
          let c4, h3, p3, d3;
          "width" === r2 || "both" === r2 ? (d3 = i2[0] + l3 - n3[3], h3 = i2[0] + u3 + n3[1]) : (d3 = i2[0] + (l3 + u3 - a2.displaySize[0]) / 2, h3 = d3 + a2.displaySize[0]);
          const f2 = e2.top * s4, y2 = e2.bottom * s4;
          return "height" === r2 || "both" === r2 ? (c4 = i2[1] + f2 - n3[0], p3 = i2[1] + y2 + n3[2]) : (c4 = i2[1] + (f2 + y2 - a2.displaySize[1]) / 2, p3 = c4 + a2.displaySize[1]), { image: a2, top: c4, right: h3, bottom: p3, left: d3, collisionPadding: o2 };
        }
        class Op extends x {
          constructor(t2, e2, r2, n3, i2) {
            super(t2, e2), this.angle = n3, this.z = r2, void 0 !== i2 && (this.segment = i2);
          }
          clone() {
            return new Op(this.x, this.y, this.z, this.angle, this.segment);
          }
        }
        function qp(t2, e2, r2, n3, i2) {
          if (void 0 === e2.segment)
            return true;
          let s4 = e2, a2 = e2.segment + 1, o2 = 0;
          for (; o2 > -r2 / 2; ) {
            if (a2--, a2 < 0)
              return false;
            o2 -= t2[a2].dist(s4), s4 = t2[a2];
          }
          o2 += t2[a2].dist(t2[a2 + 1]), a2++;
          const l3 = [];
          let u3 = 0;
          for (; o2 < r2 / 2; ) {
            const e3 = t2[a2], r3 = t2[a2 + 1];
            if (!r3)
              return false;
            let s5 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
            for (s5 = Math.abs((s5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l3.push({ distance: o2, angleDelta: s5 }), u3 += s5; o2 - l3[0].distance > n3; )
              u3 -= l3.shift().angleDelta;
            if (u3 > i2)
              return false;
            a2++, o2 += e3.dist(r3);
          }
          return true;
        }
        function Np(t2) {
          let e2 = 0;
          for (let r2 = 0; r2 < t2.length - 1; r2++)
            e2 += t2[r2].dist(t2[r2 + 1]);
          return e2;
        }
        function Gp(t2, e2, r2) {
          return t2 ? 0.6 * e2 * r2 : 0;
        }
        function Zp(t2, e2) {
          return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function Kp(t2, e2, r2, n3, i2, s4) {
          const a2 = Gp(r2, i2, s4), o2 = Zp(r2, n3) * s4;
          let l3 = 0;
          const u3 = Np(t2) / 2;
          for (let r3 = 0; r3 < t2.length - 1; r3++) {
            const n4 = t2[r3], i3 = t2[r3 + 1], s5 = n4.dist(i3);
            if (l3 + s5 > u3) {
              const c4 = (u3 - l3) / s5, h3 = Er(n4.x, i3.x, c4), p3 = Er(n4.y, i3.y, c4), d3 = new Op(h3, p3, 0, i3.angleTo(n4), r3);
              return !a2 || qp(t2, d3, o2, a2, e2) ? d3 : void 0;
            }
            l3 += s5;
          }
        }
        function Xp(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
          const u3 = Gp(n3, s4, a2), c4 = Zp(n3, i2), h3 = c4 * a2, p3 = 0 === t2[0].x || t2[0].x === l3 || 0 === t2[0].y || t2[0].y === l3;
          return e2 - h3 < e2 / 4 && (e2 = h3 + e2 / 4), Jp(t2, p3 ? e2 / 2 * o2 % e2 : (c4 / 2 + 2 * s4) * a2 * o2 % e2, e2, u3, r2, h3, p3, false, l3);
        }
        function Jp(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
          const u3 = s4 / 2, c4 = Np(t2);
          let h3 = 0, p3 = e2 - r2, d3 = [];
          for (let e3 = 0; e3 < t2.length - 1; e3++) {
            const a3 = t2[e3], o3 = t2[e3 + 1], f2 = a3.dist(o3), y2 = o3.angleTo(a3);
            for (; p3 + r2 < h3 + f2; ) {
              p3 += r2;
              const m3 = (p3 - h3) / f2, g2 = Er(a3.x, o3.x, m3), x2 = Er(a3.y, o3.y, m3);
              if (g2 >= 0 && g2 < l3 && x2 >= 0 && x2 < l3 && p3 - u3 >= 0 && p3 + u3 <= c4) {
                const r3 = new Op(g2, x2, 0, y2, e3);
                r3._round(), n3 && !qp(t2, r3, s4, n3, i2) || d3.push(r3);
              }
            }
            h3 += f2;
          }
          return o2 || d3.length || a2 || (d3 = Jp(t2, h3 / 2, r2, n3, i2, s4, a2, true, l3)), d3;
        }
        function Hp(t2, e2, r2, n3, i2) {
          const s4 = [];
          for (let a2 = 0; a2 < t2.length; a2++) {
            const o2 = t2[a2];
            let l3;
            for (let t3 = 0; t3 < o2.length - 1; t3++) {
              let a3 = o2[t3], u3 = o2[t3 + 1];
              a3.x < e2 && u3.x < e2 || (a3.x < e2 ? a3 = new x(e2, a3.y + (e2 - a3.x) / (u3.x - a3.x) * (u3.y - a3.y))._round() : u3.x < e2 && (u3 = new x(e2, a3.y + (e2 - a3.x) / (u3.x - a3.x) * (u3.y - a3.y))._round()), a3.y < r2 && u3.y < r2 || (a3.y < r2 ? a3 = new x(a3.x + (r2 - a3.y) / (u3.y - a3.y) * (u3.x - a3.x), r2)._round() : u3.y < r2 && (u3 = new x(a3.x + (r2 - a3.y) / (u3.y - a3.y) * (u3.x - a3.x), r2)._round()), a3.x >= n3 && u3.x >= n3 || (a3.x >= n3 ? a3 = new x(n3, a3.y + (n3 - a3.x) / (u3.x - a3.x) * (u3.y - a3.y))._round() : u3.x >= n3 && (u3 = new x(n3, a3.y + (n3 - a3.x) / (u3.x - a3.x) * (u3.y - a3.y))._round()), a3.y >= i2 && u3.y >= i2 || (a3.y >= i2 ? a3 = new x(a3.x + (i2 - a3.y) / (u3.y - a3.y) * (u3.x - a3.x), i2)._round() : u3.y >= i2 && (u3 = new x(a3.x + (i2 - a3.y) / (u3.y - a3.y) * (u3.x - a3.x), i2)._round()), l3 && a3.equals(l3[l3.length - 1]) || (l3 = [a3], s4.push(l3)), l3.push(u3)))));
            }
          }
          return s4;
        }
        Ji(Op, "Anchor");
        const Yp = 1e20;
        function Wp(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
          for (let u3 = e2; u3 < e2 + n3; u3++)
            Qp(t2, r2 * s4 + u3, s4, i2, a2, o2, l3);
          for (let u3 = r2; u3 < r2 + i2; u3++)
            Qp(t2, u3 * s4 + e2, 1, n3, a2, o2, l3);
        }
        function Qp(t2, e2, r2, n3, i2, s4, a2) {
          s4[0] = 0, a2[0] = -Yp, a2[1] = Yp, i2[0] = t2[e2];
          for (let o2 = 1, l3 = 0, u3 = 0; o2 < n3; o2++) {
            i2[o2] = t2[e2 + o2 * r2];
            const n4 = o2 * o2;
            do {
              const t3 = s4[l3];
              u3 = (i2[o2] - i2[t3] + n4 - t3 * t3) / (o2 - t3) / 2;
            } while (u3 <= a2[l3] && --l3 > -1);
            l3++, s4[l3] = o2, a2[l3] = u3, a2[l3 + 1] = Yp;
          }
          for (let o2 = 0, l3 = 0; o2 < n3; o2++) {
            for (; a2[l3 + 1] < o2; )
              l3++;
            const n4 = s4[l3], u3 = o2 - n4;
            t2[e2 + o2 * r2] = i2[n4] + u3 * u3;
          }
        }
        const td = 2, ed = { none: 0, ideographs: 1, all: 2 };
        class rd {
          constructor(t2, e2, r2) {
            this.requestManager = t2, this.localGlyphMode = e2, this.localFontFamily = r2, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
          }
          setURL(t2) {
            this.url = t2;
          }
          getGlyphs(t2, e2) {
            const r2 = [];
            for (const e3 in t2)
              for (const n3 of t2[e3])
                r2.push({ stack: e3, id: n3 });
            B(r2, ({ stack: t3, id: e3 }, r3) => {
              let n3 = this.entries[t3];
              n3 || (n3 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let i2 = n3.glyphs[e3];
              if (void 0 !== i2)
                return void r3(null, { stack: t3, id: e3, glyph: i2 });
              if (i2 = this._tinySDF(n3, t3, e3), i2)
                return n3.glyphs[e3] = i2, void r3(null, { stack: t3, id: e3, glyph: i2 });
              const s4 = Math.floor(e3 / 256);
              if (256 * s4 > 65535)
                return void r3(new Error("glyphs > 65535 not supported"));
              if (n3.ranges[s4])
                return void r3(null, { stack: t3, id: e3, glyph: i2 });
              let a2 = n3.requests[s4];
              a2 || (a2 = n3.requests[s4] = [], rd.loadGlyphRange(t3, s4, this.url, this.requestManager, (t4, e4) => {
                if (e4) {
                  n3.ascender = e4.ascender, n3.descender = e4.descender;
                  for (const t5 in e4.glyphs)
                    this._doesCharSupportLocalGlyph(+t5) || (n3.glyphs[+t5] = e4.glyphs[+t5]);
                  n3.ranges[s4] = true;
                }
                for (const r4 of a2)
                  r4(t4, e4);
                delete n3.requests[s4];
              })), a2.push((n4, i3) => {
                n4 ? r3(n4) : i3 && r3(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
              });
            }, (t3, r3) => {
              if (t3)
                e2(t3);
              else if (r3) {
                const t4 = {};
                for (const { stack: e3, id: n3, glyph: i2 } of r3)
                  void 0 === t4[e3] && (t4[e3] = {}), void 0 === t4[e3].glyphs && (t4[e3].glyphs = {}), t4[e3].glyphs[n3] = i2 && { id: i2.id, bitmap: i2.bitmap.clone(), metrics: i2.metrics }, t4[e3].ascender = this.entries[e3].ascender, t4[e3].descender = this.entries[e3].descender;
                e2(null, t4);
              }
            });
          }
          _doesCharSupportLocalGlyph(t2) {
            return this.localGlyphMode !== ed.none && (this.localGlyphMode === ed.all ? !!this.localFontFamily : !!this.localFontFamily && (ts["CJK Unified Ideographs"](t2) || ts["Hangul Syllables"](t2) || ts.Hiragana(t2) || ts.Katakana(t2) || ts["CJK Symbols and Punctuation"](t2)));
          }
          _tinySDF(t2, e2, r2) {
            const n3 = this.localFontFamily;
            if (!n3 || !this._doesCharSupportLocalGlyph(r2))
              return;
            let i2 = t2.tinySDF;
            if (!i2) {
              let r3 = "400";
              /bold/i.test(e2) ? r3 = "900" : /medium/i.test(e2) ? r3 = "500" : /light/i.test(e2) && (r3 = "200"), i2 = t2.tinySDF = new rd.TinySDF({ fontFamily: n3, fontWeight: r3, fontSize: 24 * td, buffer: 3 * td, radius: 8 * td }), i2.fontWeight = r3;
            }
            if (this.localGlyphs[i2.fontWeight][r2])
              return this.localGlyphs[i2.fontWeight][r2];
            const s4 = String.fromCharCode(r2), { data: a2, width: o2, height: l3, glyphWidth: u3, glyphHeight: c4, glyphLeft: h3, glyphTop: p3, glyphAdvance: d3 } = i2.draw(s4);
            return this.localGlyphs[i2.fontWeight][r2] = { id: r2, bitmap: new Ru({ width: o2, height: l3 }, a2), metrics: { width: u3 / td, height: c4 / td, left: h3 / td, top: p3 / td - 27, advance: d3 / td, localGlyph: true } };
          }
        }
        rd.loadGlyphRange = function(t2, e2, r2, n3, i2) {
          const s4 = 256 * e2, a2 = s4 + 255, o2 = n3.transformRequest(n3.normalizeGlyphsURL(r2).replace("{fontstack}", t2).replace("{range}", `${s4}-${a2}`), lt.Glyphs);
          pt(o2, (t3, e3) => {
            if (t3)
              i2(t3);
            else if (e3) {
              const t4 = {}, r3 = function(t5) {
                return new mp(t5).readFields(xp, {});
              }(e3);
              for (const e4 of r3.glyphs)
                t4[e4.id] = e4;
              i2(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
            }
          });
        }, rd.TinySDF = class {
          constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: r2 = 8, cutoff: n3 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s4 = "normal", fontStyle: a2 = "normal" } = {}) {
            this.buffer = e2, this.cutoff = n3, this.radius = r2;
            const o2 = this.size = t2 + 4 * e2, l3 = this._createCanvas(o2), u3 = this.ctx = l3.getContext("2d", { willReadFrequently: true });
            u3.font = `${a2} ${s4} ${t2}px ${i2}`, u3.textBaseline = "alphabetic", u3.textAlign = "left", u3.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
          }
          _createCanvas(t2) {
            const e2 = document.createElement("canvas");
            return e2.width = e2.height = t2, e2;
          }
          draw(t2) {
            const { width: e2, actualBoundingBoxAscent: r2, actualBoundingBoxDescent: n3, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s4 } = this.ctx.measureText(t2), a2 = Math.ceil(r2), o2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s4 - i2))), l3 = Math.min(this.size - this.buffer, a2 + Math.ceil(n3)), u3 = o2 + 2 * this.buffer, c4 = l3 + 2 * this.buffer, h3 = Math.max(u3 * c4, 0), p3 = new Uint8ClampedArray(h3), d3 = { data: p3, width: u3, height: c4, glyphWidth: o2, glyphHeight: l3, glyphTop: a2, glyphLeft: 0, glyphAdvance: e2 };
            if (0 === o2 || 0 === l3)
              return d3;
            const { ctx: f2, buffer: y2, gridInner: m3, gridOuter: g2 } = this;
            f2.clearRect(y2, y2, o2, l3), f2.fillText(t2, y2, y2 + a2);
            const x2 = f2.getImageData(y2, y2, o2, l3);
            g2.fill(Yp, 0, h3), m3.fill(0, 0, h3);
            for (let t3 = 0; t3 < l3; t3++)
              for (let e3 = 0; e3 < o2; e3++) {
                const r3 = x2.data[4 * (t3 * o2 + e3) + 3] / 255;
                if (0 === r3)
                  continue;
                const n4 = (t3 + y2) * u3 + e3 + y2;
                if (1 === r3)
                  g2[n4] = 0, m3[n4] = Yp;
                else {
                  const t4 = 0.5 - r3;
                  g2[n4] = t4 > 0 ? t4 * t4 : 0, m3[n4] = t4 < 0 ? t4 * t4 : 0;
                }
              }
            Wp(g2, 0, 0, u3, c4, u3, this.f, this.v, this.z), Wp(m3, y2, y2, o2, l3, u3, this.f, this.v, this.z);
            for (let t3 = 0; t3 < h3; t3++) {
              const e3 = Math.sqrt(g2[t3]) - Math.sqrt(m3[t3]);
              p3[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
            }
            return d3;
          }
        };
        const nd = Ap;
        function id(t2, e2, r2, n3) {
          const i2 = [], s4 = t2.image, a2 = s4.pixelRatio, o2 = s4.paddedRect.w - 2 * nd, l3 = s4.paddedRect.h - 2 * nd, u3 = t2.right - t2.left, c4 = t2.bottom - t2.top, h3 = s4.stretchX || [[0, o2]], p3 = s4.stretchY || [[0, l3]], d3 = (t3, e3) => t3 + e3[1] - e3[0], f2 = h3.reduce(d3, 0), y2 = p3.reduce(d3, 0), m3 = o2 - f2, g2 = l3 - y2;
          let v4 = 0, b3 = f2, w2 = 0, _2 = y2, A2 = 0, S2 = m3, k2 = 0, I2 = g2;
          if (s4.content && n3) {
            const t3 = s4.content;
            v4 = sd(h3, 0, t3[0]), w2 = sd(p3, 0, t3[1]), b3 = sd(h3, t3[0], t3[2]), _2 = sd(p3, t3[1], t3[3]), A2 = t3[0] - v4, k2 = t3[1] - w2, S2 = t3[2] - t3[0] - b3, I2 = t3[3] - t3[1] - _2;
          }
          const M2 = (n4, i3, o3, l4) => {
            const h4 = od(n4.stretch - v4, b3, u3, t2.left), p4 = ld(n4.fixed - A2, S2, n4.stretch, f2), d4 = od(i3.stretch - w2, _2, c4, t2.top), m4 = ld(i3.fixed - k2, I2, i3.stretch, y2), g3 = od(o3.stretch - v4, b3, u3, t2.left), M3 = ld(o3.fixed - A2, S2, o3.stretch, f2), T3 = od(l4.stretch - w2, _2, c4, t2.top), z2 = ld(l4.fixed - k2, I2, l4.stretch, y2), B2 = new x(h4, d4), E2 = new x(g3, d4), C3 = new x(g3, T3), P3 = new x(h4, T3), D2 = new x(p4 / a2, m4 / a2), V2 = new x(M3 / a2, z2 / a2), L2 = e2 * Math.PI / 180;
            if (L2) {
              const t3 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t3, t3, e3];
              B2._matMult(r3), E2._matMult(r3), P3._matMult(r3), C3._matMult(r3);
            }
            const F2 = n4.stretch + n4.fixed, R2 = i3.stretch + i3.fixed;
            return { tl: B2, tr: E2, bl: P3, br: C3, tex: { x: s4.paddedRect.x + nd + F2, y: s4.paddedRect.y + nd + R2, w: o3.stretch + o3.fixed - F2, h: l4.stretch + l4.fixed - R2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D2, pixelOffsetBR: V2, minFontScaleX: S2 / a2 / u3, minFontScaleY: I2 / a2 / c4, isSDF: r2 };
          };
          if (n3 && (s4.stretchX || s4.stretchY)) {
            const t3 = ad(h3, m3, f2), e3 = ad(p3, g2, y2);
            for (let r3 = 0; r3 < t3.length - 1; r3++) {
              const n4 = t3[r3], s5 = t3[r3 + 1];
              for (let t4 = 0; t4 < e3.length - 1; t4++)
                i2.push(M2(n4, e3[t4], s5, e3[t4 + 1]));
            }
          } else
            i2.push(M2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l3 + 1 }));
          return i2;
        }
        function sd(t2, e2, r2) {
          let n3 = 0;
          for (const i2 of t2)
            n3 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
          return n3;
        }
        function ad(t2, e2, r2) {
          const n3 = [{ fixed: -nd, stretch: 0 }];
          for (const [e3, r3] of t2) {
            const t3 = n3[n3.length - 1];
            n3.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n3.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
          }
          return n3.push({ fixed: e2 + nd, stretch: r2 }), n3;
        }
        function od(t2, e2, r2, n3) {
          return t2 / e2 * r2 + n3;
        }
        function ld(t2, e2, r2, n3) {
          return t2 - e2 * r2 / n3;
        }
        function ud(t2, e2, r2, n3) {
          const i2 = e2 + t2.positionedLines[n3].lineOffset;
          return 0 === n3 ? r2 + i2 / 2 : r2 + (i2 + (e2 + t2.positionedLines[n3 - 1].lineOffset)) / 2;
        }
        class cd {
          constructor(t2 = [], e2 = hd) {
            if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
              for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
                this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (0 === this.length)
              return;
            const t2 = this.data[0], e2 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            const { data: e2, compare: r2 } = this, n3 = e2[t2];
            for (; t2 > 0; ) {
              const i2 = t2 - 1 >> 1, s4 = e2[i2];
              if (r2(n3, s4) >= 0)
                break;
              e2[t2] = s4, t2 = i2;
            }
            e2[t2] = n3;
          }
          _down(t2) {
            const { data: e2, compare: r2 } = this, n3 = this.length >> 1, i2 = e2[t2];
            for (; t2 < n3; ) {
              let n4 = 1 + (t2 << 1), s4 = e2[n4];
              const a2 = n4 + 1;
              if (a2 < this.length && r2(e2[a2], s4) < 0 && (n4 = a2, s4 = e2[a2]), r2(s4, i2) >= 0)
                break;
              e2[t2] = s4, t2 = n4;
            }
            e2[t2] = i2;
          }
        }
        function hd(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function pd(t2, e2 = 1, r2 = false) {
          let n3 = 1 / 0, i2 = 1 / 0, s4 = -1 / 0, a2 = -1 / 0;
          const o2 = t2[0];
          for (let t3 = 0; t3 < o2.length; t3++) {
            const e3 = o2[t3];
            (!t3 || e3.x < n3) && (n3 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s4) && (s4 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
          }
          const l3 = Math.min(s4 - n3, a2 - i2);
          let u3 = l3 / 2;
          const c4 = new cd([], dd);
          if (0 === l3)
            return new x(n3, i2);
          for (let e3 = n3; e3 < s4; e3 += l3)
            for (let r3 = i2; r3 < a2; r3 += l3)
              c4.push(new fd(e3 + u3, r3 + u3, u3, t2));
          let h3 = function(t3) {
            let e3 = 0, r3 = 0, n4 = 0;
            const i3 = t3[0];
            for (let t4 = 0, s5 = i3.length, a3 = s5 - 1; t4 < s5; a3 = t4++) {
              const s6 = i3[t4], o3 = i3[a3], l4 = s6.x * o3.y - o3.x * s6.y;
              r3 += (s6.x + o3.x) * l4, n4 += (s6.y + o3.y) * l4, e3 += 3 * l4;
            }
            return new fd(r3 / e3, n4 / e3, 0, t3);
          }(t2), p3 = c4.length;
          for (; c4.length; ) {
            const n4 = c4.pop();
            (n4.d > h3.d || !h3.d) && (h3 = n4, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, p3)), n4.max - h3.d <= e2 || (u3 = n4.h / 2, c4.push(new fd(n4.p.x - u3, n4.p.y - u3, u3, t2)), c4.push(new fd(n4.p.x + u3, n4.p.y - u3, u3, t2)), c4.push(new fd(n4.p.x - u3, n4.p.y + u3, u3, t2)), c4.push(new fd(n4.p.x + u3, n4.p.y + u3, u3, t2)), p3 += 4);
          }
          return r2 && (console.log(`num probes: ${p3}`), console.log(`best distance: ${h3.d}`)), h3.p;
        }
        function dd(t2, e2) {
          return e2.max - t2.max;
        }
        class fd {
          constructor(t2, e2, r2, n3) {
            this.p = new x(t2, e2), this.h = r2, this.d = function(t3, e3) {
              let r3 = false, n4 = 1 / 0;
              for (let i2 = 0; i2 < e3.length; i2++) {
                const s4 = e3[i2];
                for (let e4 = 0, i3 = s4.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                  const i4 = s4[e4], o2 = s4[a2];
                  i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n4 = Math.min(n4, xu(t3, i4, o2));
                }
              }
              return (r3 ? 1 : -1) * Math.sqrt(n4);
            }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
          }
        }
        const yd = 7, md = Number.POSITIVE_INFINITY, gd = Math.sqrt(2);
        function xd(t2, [e2, r2]) {
          let n3 = 0, i2 = 0;
          if (r2 === md) {
            e2 < 0 && (e2 = 0);
            const r3 = e2 / gd;
            switch (t2) {
              case "top-right":
              case "top-left":
                i2 = r3 - yd;
                break;
              case "bottom-right":
              case "bottom-left":
                i2 = -r3 + yd;
                break;
              case "bottom":
                i2 = -e2 + yd;
                break;
              case "top":
                i2 = e2 - yd;
            }
            switch (t2) {
              case "top-right":
              case "bottom-right":
                n3 = -r3;
                break;
              case "top-left":
              case "bottom-left":
                n3 = r3;
                break;
              case "left":
                n3 = e2;
                break;
              case "right":
                n3 = -e2;
            }
          } else {
            switch (e2 = Math.abs(e2), r2 = Math.abs(r2), t2) {
              case "top-right":
              case "top-left":
              case "top":
                i2 = r2 - yd;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i2 = -r2 + yd;
            }
            switch (t2) {
              case "top-right":
              case "bottom-right":
              case "right":
                n3 = -e2;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n3 = e2;
            }
          }
          return [n3, i2];
        }
        function vd(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3) {
          t2.createArrays(), t2.tilePixelRatio = ao / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
          const c4 = t2.layers[0].layout, h3 = t2.layers[0]._unevaluatedLayout._values, p3 = {};
          if ("composite" === t2.textSizeData.kind) {
            const { minZoom: e3, maxZoom: r3 } = t2.textSizeData;
            p3.compositeTextSizes = [h3["text-size"].possiblyEvaluate(new ws(e3), o2), h3["text-size"].possiblyEvaluate(new ws(r3), o2)];
          }
          if ("composite" === t2.iconSizeData.kind) {
            const { minZoom: e3, maxZoom: r3 } = t2.iconSizeData;
            p3.compositeIconSizes = [h3["icon-size"].possiblyEvaluate(new ws(e3), o2), h3["icon-size"].possiblyEvaluate(new ws(r3), o2)];
          }
          p3.layoutTextSize = h3["text-size"].possiblyEvaluate(new ws(l3 + 1), o2), p3.layoutIconSize = h3["icon-size"].possiblyEvaluate(new ws(l3 + 1), o2), p3.textMaxSize = h3["text-size"].possiblyEvaluate(new ws(18), o2);
          const d3 = "map" === c4.get("text-rotation-alignment") && "point" !== c4.get("symbol-placement"), f2 = c4.get("text-size");
          for (const s5 of t2.features) {
            const l4 = c4.get("text-font").evaluate(s5, {}, o2).join(","), h4 = f2.evaluate(s5, {}, o2), y2 = p3.layoutTextSize.evaluate(s5, {}, o2), m3 = (p3.layoutIconSize.evaluate(s5, {}, o2), { horizontal: {}, vertical: void 0 }), g2 = s5.text;
            let x2, v4 = [0, 0];
            if (g2) {
              const n4 = g2.toString(), a3 = c4.get("text-letter-spacing").evaluate(s5, {}, o2) * Rh, u4 = c4.get("text-line-height").evaluate(s5, {}, o2) * Rh, p4 = rs(n4) ? a3 : 0, f3 = c4.get("text-anchor").evaluate(s5, {}, o2), x3 = c4.get("text-variable-anchor");
              if (!x3) {
                const t3 = c4.get("text-radial-offset").evaluate(s5, {}, o2);
                v4 = t3 ? xd(f3, [t3 * Rh, md]) : c4.get("text-offset").evaluate(s5, {}, o2).map((t4) => t4 * Rh);
              }
              let b4 = d3 ? "center" : c4.get("text-justify").evaluate(s5, {}, o2);
              const w3 = "point" === c4.get("symbol-placement"), _2 = w3 ? c4.get("text-max-width").evaluate(s5, {}, o2) * Rh : 1 / 0, A2 = (s6) => {
                t2.allowVerticalPlacement && es(n4) && (m3.vertical = Bp(g2, e2, r2, i2, l4, _2, u4, f3, s6, p4, v4, Ip.vertical, true, y2, h4));
              };
              if (!d3 && x3) {
                const t3 = "auto" === b4 ? x3.map((t4) => bd(t4)) : [b4];
                let n5 = false;
                for (let s6 = 0; s6 < t3.length; s6++) {
                  const a4 = t3[s6];
                  if (!m3.horizontal[a4])
                    if (n5)
                      m3.horizontal[a4] = m3.horizontal[0];
                    else {
                      const t4 = Bp(g2, e2, r2, i2, l4, _2, u4, "center", a4, p4, v4, Ip.horizontal, false, y2, h4);
                      t4 && (m3.horizontal[a4] = t4, n5 = 1 === t4.positionedLines.length);
                    }
                }
                A2("left");
              } else {
                if ("auto" === b4 && (b4 = bd(f3)), w3 || c4.get("text-writing-mode").indexOf("horizontal") >= 0 || !es(n4)) {
                  const t3 = Bp(g2, e2, r2, i2, l4, _2, u4, f3, b4, p4, v4, Ip.horizontal, false, y2, h4);
                  t3 && (m3.horizontal[b4] = t3);
                }
                A2(w3 ? "left" : b4);
              }
            }
            let b3 = false;
            if (s5.icon && s5.icon.name) {
              const e3 = n3[s5.icon.name];
              e3 && (x2 = $p(i2[s5.icon.name], c4.get("icon-offset").evaluate(s5, {}, o2), c4.get("icon-anchor").evaluate(s5, {}, o2)), b3 = e3.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = e3.sdf : t2.sdfIcons !== e3.sdf && N("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t2.pixelRatio || 0 !== c4.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true));
            }
            const w2 = kd(m3.horizontal) || m3.vertical;
            t2.iconsInText || (t2.iconsInText = !!w2 && w2.iconsInText), (w2 || x2) && wd(t2, s5, m3, x2, n3, p3, y2, 0, v4, b3, a2, o2, u3);
          }
          s4 && t2.generateCollisionDebugBuffers(l3, t2.collisionBoxArray);
        }
        function bd(t2) {
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function wd(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3) {
          let d3 = s4.textMaxSize.evaluate(e2, {}, h3);
          void 0 === d3 && (d3 = a2);
          const f2 = t2.layers[0].layout, y2 = f2.get("icon-offset").evaluate(e2, {}, h3), m3 = kd(r2.horizontal) || r2.vertical, g2 = "globe" === p3.name, x2 = Rh, v4 = a2 / x2, b3 = t2.tilePixelRatio * d3 / x2, _2 = (B2 = t2.overscaling, t2.zoom > 18 && B2 > 2 && (B2 >>= 1), Math.max(ao / (512 * B2), 1) * f2.get("symbol-spacing")), A2 = f2.get("text-padding") * t2.tilePixelRatio, S2 = f2.get("icon-padding") * t2.tilePixelRatio, k2 = w(f2.get("text-max-angle")), I2 = "map" === f2.get("text-rotation-alignment") && "point" !== f2.get("symbol-placement"), M2 = "map" === f2.get("icon-rotation-alignment") && "point" !== f2.get("symbol-placement"), T3 = f2.get("symbol-placement"), z2 = _2 / 2;
          var B2;
          const E2 = f2.get("icon-text-fit");
          let C3;
          n3 && "none" !== E2 && (t2.allowVerticalPlacement && r2.vertical && (C3 = jp(n3, r2.vertical, E2, f2.get("icon-text-fit-padding"), y2, v4)), m3 && (n3 = jp(n3, m3, E2, f2.get("icon-text-fit-padding"), y2, v4)));
          const P3 = (a3, o3, d4) => {
            if (o3.x < 0 || o3.x >= ao || o3.y < 0 || o3.y >= ao)
              return;
            let f3 = null;
            if (g2) {
              const { x: t3, y: e3, z: r3 } = p3.projectTilePoint(o3.x, o3.y, d4);
              f3 = { anchor: new Op(t3, e3, r3, 0, void 0), up: p3.upVector(d4, o3.x, o3.y) };
            }
            !function(t3, e3, r3, n4, i3, s5, a4, o4, l4, u4, c5, h4, p4, d5, f4, y3, m4, g3, x3, v5, b4, w2, _3, A3, S3) {
              const k3 = t3.addToLineVertexArray(e3, n4);
              let I3, M3, T4, z3, B3, E3, C4, P4 = 0, D2 = 0, V2 = 0, L2 = 0, F2 = -1, R2 = -1;
              const U2 = {};
              let $2 = Ba("");
              const j2 = r3 ? r3.anchor : e3;
              let O2 = 0, q2 = 0;
              if (void 0 === l4._unevaluatedLayout.getValue("text-radial-offset") ? [O2, q2] = l4.layout.get("text-offset").evaluate(b4, {}, S3).map((t4) => t4 * Rh) : (O2 = l4.layout.get("text-radial-offset").evaluate(b4, {}, S3) * Rh, q2 = md), t3.allowVerticalPlacement && i3.vertical) {
                const t4 = i3.vertical;
                if (f4)
                  E3 = Md(t4), o4 && (C4 = Md(o4));
                else {
                  const r4 = l4.layout.get("text-rotate").evaluate(b4, {}, S3) + 90;
                  T4 = Id(u4, j2, e3, c5, h4, p4, t4, d5, r4, y3), o4 && (z3 = Id(u4, j2, e3, c5, h4, p4, o4, g3, r4));
                }
              }
              if (s5) {
                const n5 = l4.layout.get("icon-rotate").evaluate(b4, {}, S3), i4 = "none" !== l4.layout.get("icon-text-fit"), a5 = id(s5, n5, _3, i4), d6 = o4 ? id(o4, n5, _3, i4) : void 0;
                M3 = Id(u4, j2, e3, c5, h4, p4, s5, g3, n5), P4 = 4 * a5.length;
                const f5 = t3.iconSizeData;
                let y4 = null;
                "source" === f5.kind ? (y4 = [Uh * l4.layout.get("icon-size").evaluate(b4, {}, S3)], y4[0] > Ad && N(`${t3.layerIds[0]}: Value for "icon-size" is >= ${_d}. Reduce your "icon-size".`)) : "composite" === f5.kind && (y4 = [Uh * w2.compositeIconSizes[0].evaluate(b4, {}, S3), Uh * w2.compositeIconSizes[1].evaluate(b4, {}, S3)], (y4[0] > Ad || y4[1] > Ad) && N(`${t3.layerIds[0]}: Value for "icon-size" is >= ${_d}. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, a5, y4, v5, x3, b4, false, r3, e3, k3.lineStartIndex, k3.lineLength, -1, A3, S3), F2 = t3.icon.placedSymbolArray.length - 1, d6 && (D2 = 4 * d6.length, t3.addSymbols(t3.icon, d6, y4, v5, x3, b4, Ip.vertical, r3, e3, k3.lineStartIndex, k3.lineLength, -1, A3, S3), R2 = t3.icon.placedSymbolArray.length - 1);
              }
              for (const n5 in i3.horizontal) {
                const s6 = i3.horizontal[n5];
                I3 || ($2 = Ba(s6.text), f4 ? B3 = Md(s6) : I3 = Id(u4, j2, e3, c5, h4, p4, s6, d5, l4.layout.get("text-rotate").evaluate(b4, {}, S3), y3));
                const o5 = 1 === s6.positionedLines.length;
                if (V2 += Sd(t3, r3, e3, s6, a4, l4, f4, b4, y3, k3, i3.vertical ? Ip.horizontal : Ip.horizontalOnly, o5 ? Object.keys(i3.horizontal) : [n5], U2, F2, w2, A3, S3), o5)
                  break;
              }
              i3.vertical && (L2 += Sd(t3, r3, e3, i3.vertical, a4, l4, f4, b4, y3, k3, Ip.vertical, ["vertical"], U2, R2, w2, A3, S3));
              let G2 = -1;
              const Z2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
              G2 = Z2(B3, G2), G2 = Z2(E3, G2), G2 = Z2(C4, G2);
              const K2 = G2 > -1 ? 1 : 0;
              t3.glyphOffsetArray.length >= of.MAX_GLYPHS && N("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b4.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, b4.sortKey), t3.symbolInstances.emplaceBack(j2.x, j2.y, j2.z, e3.x, e3.y, U2.right >= 0 ? U2.right : -1, U2.center >= 0 ? U2.center : -1, U2.left >= 0 ? U2.left : -1, U2.vertical >= 0 ? U2.vertical : -1, F2, R2, $2, void 0 !== I3 ? I3 : t3.collisionBoxArray.length, void 0 !== I3 ? I3 + 1 : t3.collisionBoxArray.length, void 0 !== T4 ? T4 : t3.collisionBoxArray.length, void 0 !== T4 ? T4 + 1 : t3.collisionBoxArray.length, void 0 !== M3 ? M3 : t3.collisionBoxArray.length, void 0 !== M3 ? M3 + 1 : t3.collisionBoxArray.length, z3 || t3.collisionBoxArray.length, z3 ? z3 + 1 : t3.collisionBoxArray.length, c5, V2, L2, P4, D2, K2, 0, O2, q2, G2);
            }(t2, o3, f3, a3, r2, n3, i2, C3, t2.layers[0], t2.collisionBoxArray, e2.index, e2.sourceLayerIndex, t2.index, A2, I2, l3, 0, S2, M2, y2, e2, s4, u3, c4, h3);
          };
          if ("line" === T3)
            for (const i3 of Hp(e2.geometry, 0, 0, ao, ao)) {
              const e3 = Xp(i3, _2, k2, r2.vertical || m3, n3, x2, b3, t2.overscaling, ao);
              for (const r3 of e3)
                m3 && Td(t2, m3.text, z2, r3) || P3(i3, r3, h3);
            }
          else if ("line-center" === T3) {
            for (const t3 of e2.geometry)
              if (t3.length > 1) {
                const e3 = Kp(t3, k2, r2.vertical || m3, n3, x2, b3);
                e3 && P3(t3, e3, h3);
              }
          } else if ("Polygon" === e2.type)
            for (const t3 of Ac(e2.geometry, 0)) {
              const e3 = pd(t3, 16);
              P3(t3[0], new Op(e3.x, e3.y, 0, 0, void 0), h3);
            }
          else if ("LineString" === e2.type)
            for (const t3 of e2.geometry)
              P3(t3, new Op(t3[0].x, t3[0].y, 0, 0, void 0), h3);
          else if ("Point" === e2.type)
            for (const t3 of e2.geometry)
              for (const e3 of t3)
                P3([e3], new Op(e3.x, e3.y, 0, 0, void 0), h3);
        }
        const _d = 255, Ad = _d * Uh;
        function Sd(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3, f2, y2, m3) {
          const g2 = function(t3, e3, r3, n4, i3, s5, a3, o3) {
            const l4 = [];
            if (0 === e3.positionedLines.length)
              return l4;
            const u4 = n4.layout.get("text-rotate").evaluate(s5, {}) * Math.PI / 180, c5 = function(t4) {
              const e4 = t4[0], r4 = t4[1], n5 = e4 * r4;
              return n5 > 0 ? [e4, -r4] : n5 < 0 ? [-e4, r4] : 0 === e4 ? [r4, e4] : [r4, -e4];
            }(r3);
            let h4 = Math.abs(e3.top - e3.bottom);
            for (const t4 of e3.positionedLines)
              h4 -= t4.lineOffset;
            const p4 = e3.positionedLines.length, d4 = h4 / p4;
            let f3 = e3.top - r3[1];
            for (let t4 = 0; t4 < p4; ++t4) {
              const n5 = e3.positionedLines[t4];
              f3 = ud(e3, d4, f3, t4);
              for (const t5 of n5.positionedGlyphs) {
                if (!t5.rect)
                  continue;
                const n6 = t5.rect || {};
                let s6 = wp + 1, h5 = true, p5 = 1, d5 = 0;
                if (t5.imageName) {
                  const e4 = a3[t5.imageName];
                  if (!e4)
                    continue;
                  if (e4.sdf) {
                    N("SDF images are not supported in formatted text and will be ignored.");
                    continue;
                  }
                  h5 = false, p5 = e4.pixelRatio, s6 = Ap / p5;
                }
                const y3 = (i3 || o3) && t5.vertical, m4 = t5.metrics.advance * t5.scale / 2, g3 = t5.metrics, v5 = t5.rect;
                if (null === v5)
                  continue;
                o3 && e3.verticalizable && (d5 = t5.imageName ? m4 - t5.metrics.width * t5.scale / 2 : 0);
                const b4 = i3 ? [t5.x + m4, t5.y] : [0, 0];
                let w2 = [0, 0], _2 = [0, 0], A2 = false;
                i3 || (y3 ? (_2 = [t5.x + m4 + c5[0], t5.y + c5[1] - d5], A2 = true) : w2 = [t5.x + m4 + r3[0], t5.y + r3[1] - d5]);
                const S2 = v5.w * t5.scale / (p5 * (t5.localGlyph ? td : 1)), k2 = v5.h * t5.scale / (p5 * (t5.localGlyph ? td : 1));
                let I2, M2, T3, z2;
                if (y3) {
                  const e4 = t5.y - f3, r4 = new x(-m4, m4 - e4), n7 = -Math.PI / 2, i4 = new x(..._2);
                  I2 = new x(-m4 + w2[0], w2[1]), I2._rotateAround(n7, r4)._add(i4), I2.x += -e4 + m4, I2.y -= (g3.left - s6) * t5.scale;
                  const a4 = t5.imageName ? g3.advance * t5.scale : Rh * t5.scale, o4 = String.fromCharCode(t5.glyph);
                  Zh(o4) ? I2.x += (1 - s6) * t5.scale : Kh(o4) ? I2.x += a4 - g3.height * t5.scale + (-s6 - 1) * t5.scale : I2.x += t5.imageName || g3.width + 2 * s6 === v5.w && g3.height + 2 * s6 === v5.h ? (a4 - k2) / 2 : (a4 - (g3.height + 2 * s6) * t5.scale) / 2, M2 = new x(I2.x, I2.y - S2), T3 = new x(I2.x + k2, I2.y), z2 = new x(I2.x + k2, I2.y - S2);
                } else {
                  const e4 = (g3.left - s6) * t5.scale - m4 + w2[0], r4 = (-g3.top - s6) * t5.scale + w2[1], n7 = e4 + S2, i4 = r4 + k2;
                  I2 = new x(e4, r4), M2 = new x(n7, r4), T3 = new x(e4, i4), z2 = new x(n7, i4);
                }
                if (u4) {
                  let t6;
                  t6 = i3 ? new x(0, 0) : A2 ? new x(c5[0], c5[1]) : new x(r3[0], r3[1]), I2._rotateAround(u4, t6), M2._rotateAround(u4, t6), T3._rotateAround(u4, t6), z2._rotateAround(u4, t6);
                }
                const B2 = new x(0, 0), E2 = new x(0, 0);
                l4.push({ tl: I2, tr: M2, bl: T3, br: z2, tex: n6, writingMode: e3.writingMode, glyphOffset: b4, sectionIndex: t5.sectionIndex, isSDF: h5, pixelOffsetTL: B2, pixelOffsetBR: E2, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return l4;
          }(0, n3, l3, s4, a2, o2, i2, t2.allowVerticalPlacement), v4 = t2.textSizeData;
          let b3 = null;
          "source" === v4.kind ? (b3 = [Uh * s4.layout.get("text-size").evaluate(o2, {}, m3)], b3[0] > Ad && N(`${t2.layerIds[0]}: Value for "text-size" is >= ${_d}. Reduce your "text-size".`)) : "composite" === v4.kind && (b3 = [Uh * f2.compositeTextSizes[0].evaluate(o2, {}, m3), Uh * f2.compositeTextSizes[1].evaluate(o2, {}, m3)], (b3[0] > Ad || b3[1] > Ad) && N(`${t2.layerIds[0]}: Value for "text-size" is >= ${_d}. Reduce your "text-size".`)), t2.addSymbols(t2.text, g2, b3, l3, a2, o2, c4, e2, r2, u3.lineStartIndex, u3.lineLength, d3, y2, m3);
          for (const e3 of h3)
            p3[e3] = t2.text.placedSymbolArray.length - 1;
          return 4 * g2.length;
        }
        function kd(t2) {
          for (const e2 in t2)
            return t2[e2];
          return null;
        }
        function Id(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3) {
          let c4 = a2.top, h3 = a2.bottom, p3 = a2.left, d3 = a2.right;
          const f2 = a2.collisionPadding;
          if (f2 && (p3 -= f2[0], c4 -= f2[1], d3 += f2[2], h3 += f2[3]), l3) {
            const t3 = new x(p3, c4), e3 = new x(d3, c4), r3 = new x(p3, h3), n4 = new x(d3, h3), i3 = w(l3);
            let s5 = new x(0, 0);
            u3 && (s5 = new x(u3[0], u3[1])), t3._rotateAround(i3, s5), e3._rotateAround(i3, s5), r3._rotateAround(i3, s5), n4._rotateAround(i3, s5), p3 = Math.min(t3.x, e3.x, r3.x, n4.x), d3 = Math.max(t3.x, e3.x, r3.x, n4.x), c4 = Math.min(t3.y, e3.y, r3.y, n4.y), h3 = Math.max(t3.y, e3.y, r3.y, n4.y);
          }
          return t2.emplaceBack(e2.x, e2.y, e2.z, r2.x, r2.y, p3, c4, d3, h3, o2, n3, i2, s4), t2.length - 1;
        }
        function Md(t2) {
          t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
          const e2 = t2.bottom - t2.top;
          return e2 > 0 ? Math.max(10, e2) : null;
        }
        function Td(t2, e2, r2, n3) {
          const i2 = t2.compareText;
          if (e2 in i2) {
            const t3 = i2[e2];
            for (let e3 = t3.length - 1; e3 >= 0; e3--)
              if (n3.dist(t3[e3]) < r2)
                return true;
          } else
            i2[e2] = [];
          return i2[e2].push(n3), false;
        }
        function zd(t2, e2) {
          const r2 = t2.fovAboveCenter, n3 = t2.elevation ? t2.elevation.getMinElevationBelowMSL() * e2 : 0, i2 = (t2._camera.position[2] * t2.worldSize - n3) / Math.cos(t2._pitch), s4 = Math.sin(r2) * i2 / Math.sin(Math.max(Math.PI / 2 - t2._pitch - r2, 0.01)), a2 = Math.sin(t2._pitch) * s4 + i2;
          return Math.min(1.01 * a2, i2 * (1 / t2._horizonShift));
        }
        function Bd(t2, e2) {
          if (!e2.isReprojectedInTileSpace)
            return { scale: 1 << t2.z, x: t2.x, y: t2.y, x2: t2.x + 1, y2: t2.y + 1, projection: e2 };
          const r2 = Math.pow(2, -t2.z), n3 = t2.x * r2, i2 = (t2.x + 1) * r2, s4 = t2.y * r2, a2 = (t2.y + 1) * r2, o2 = Kl(n3), l3 = Kl(i2), u3 = Xl(s4), c4 = Xl(a2), h3 = e2.project(o2, u3), p3 = e2.project(l3, u3), d3 = e2.project(l3, c4), f2 = e2.project(o2, c4);
          let y2 = Math.min(h3.x, p3.x, d3.x, f2.x), m3 = Math.min(h3.y, p3.y, d3.y, f2.y), g2 = Math.max(h3.x, p3.x, d3.x, f2.x), x2 = Math.max(h3.y, p3.y, d3.y, f2.y);
          const v4 = r2 / 16;
          function b3(t3, r3, n4, i3, s5, a3) {
            const o3 = (n4 + s5) / 2, l4 = (i3 + a3) / 2, u4 = e2.project(Kl(o3), Xl(l4)), c5 = Math.max(0, y2 - u4.x, m3 - u4.y, u4.x - g2, u4.y - x2);
            y2 = Math.min(y2, u4.x), g2 = Math.max(g2, u4.x), m3 = Math.min(m3, u4.y), x2 = Math.max(x2, u4.y), c5 > v4 && (b3(t3, u4, n4, i3, o3, l4), b3(u4, r3, o3, l4, s5, a3));
          }
          b3(h3, p3, n3, s4, i2, s4), b3(p3, d3, i2, s4, i2, a2), b3(d3, f2, i2, a2, n3, a2), b3(f2, h3, n3, a2, n3, s4), y2 -= v4, m3 -= v4, g2 += v4, x2 += v4;
          const w2 = 1 / Math.max(g2 - y2, x2 - m3);
          return { scale: w2, x: y2 * w2, y: m3 * w2, x2: g2 * w2, y2: x2 * w2, projection: e2 };
        }
        const Ed = po(new Float32Array(16));
        class Cd {
          constructor(t2) {
            this.spec = t2, this.name = t2.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
          }
          project(t2, e2) {
            return { x: 0, y: 0, z: 0 };
          }
          unproject(t2, e2) {
            return new Ol(0, 0);
          }
          projectTilePoint(t2, e2, r2) {
            return { x: t2, y: e2, z: 0 };
          }
          locationPoint(t2, e2, r2 = true) {
            return t2._coordinatePoint(t2.locationCoordinate(e2), r2);
          }
          pixelsPerMeter(t2, e2) {
            return Zl(1, t2) * e2;
          }
          pixelSpaceConversion(t2, e2, r2) {
            return 1;
          }
          farthestPixelDistance(t2) {
            return zd(t2, t2.pixelsPerMeter);
          }
          pointCoordinate(t2, e2, r2, n3) {
            const i2 = t2.horizonLineFromTop(false), s4 = new x(e2, Math.max(i2, r2));
            return t2.rayIntersectionCoordinate(t2.pointRayIntersection(s4, n3));
          }
          pointCoordinate3D(t2, e2, r2) {
            const n3 = new x(e2, r2);
            if (t2.elevation)
              return t2.elevation.pointCoordinate(n3);
            {
              const e3 = this.pointCoordinate(t2, n3.x, n3.y, 0);
              return [e3.x, e3.y, e3.z];
            }
          }
          isPointAboveHorizon(t2, e2) {
            if (t2.elevation)
              return !this.pointCoordinate3D(t2, e2.x, e2.y);
            const r2 = t2.horizonLineFromTop();
            return e2.y < r2;
          }
          createInversionMatrix(t2, e2) {
            return Ed;
          }
          createTileMatrix(t2, e2, r2) {
            let n3, i2, s4;
            const a2 = r2.canonical, o2 = po(new Float64Array(16));
            if (this.isReprojectedInTileSpace) {
              const l3 = Bd(a2, this);
              n3 = 1, i2 = l3.x + r2.wrap * l3.scale, s4 = l3.y, go(o2, o2, [n3 / l3.scale, n3 / l3.scale, t2.pixelsPerMeter / e2]);
            } else
              n3 = e2 / t2.zoomScale(a2.z), i2 = (a2.x + Math.pow(2, a2.z) * r2.wrap) * n3, s4 = a2.y * n3;
            return mo(o2, o2, [i2, s4, 0]), go(o2, o2, [n3 / ao, n3 / ao, 1]), o2;
          }
          upVector(t2, e2, r2) {
            return [0, 0, 1];
          }
          upVectorScale(t2, e2, r2) {
            return { metersToTile: 1 };
          }
        }
        class Pd extends Cd {
          constructor(t2) {
            super(t2), this.range = [4, 7], this.center = t2.center || [-96, 37.5];
            const [e2, r2] = this.parallels = t2.parallels || [29.5, 45.5], n3 = Math.sin(w(e2));
            this.n = (n3 + Math.sin(w(r2))) / 2, this.c = 1 + n3 * (2 * this.n - n3), this.r0 = Math.sqrt(this.c) / this.n;
          }
          project(t2, e2) {
            const { n: r2, c: n3, r0: i2 } = this, s4 = w(t2 - this.center[0]), a2 = w(e2), o2 = Math.sqrt(n3 - 2 * r2 * Math.sin(a2)) / r2;
            return { x: o2 * Math.sin(s4 * r2), y: o2 * Math.cos(s4 * r2) - i2, z: 0 };
          }
          unproject(t2, e2) {
            const { n: r2, c: n3, r0: i2 } = this, s4 = i2 + e2;
            let a2 = Math.atan2(t2, Math.abs(s4)) * Math.sign(s4);
            s4 * r2 < 0 && (a2 -= Math.PI * Math.sign(t2) * Math.sign(s4));
            const o2 = w(this.center[0]) * r2;
            a2 = z(a2, -Math.PI - o2, Math.PI - o2);
            const l3 = M(_(a2 / r2) + this.center[0], -180, 180), u3 = Math.asin(M((n3 - (t2 * t2 + s4 * s4) * r2 * r2) / (2 * r2), -1, 1)), c4 = M(_(u3), -Hl, Hl);
            return new Ol(l3, c4);
          }
        }
        const Dd = 1.340264, Vd = -0.081106, Ld = 893e-6, Fd = 3796e-6, Rd = Math.sqrt(3) / 2;
        class Ud extends Cd {
          project(t2, e2) {
            e2 = e2 / 180 * Math.PI, t2 = t2 / 180 * Math.PI;
            const r2 = Math.asin(Rd * Math.sin(e2)), n3 = r2 * r2, i2 = n3 * n3 * n3;
            return { x: 0.5 * (t2 * Math.cos(r2) / (Rd * (Dd + 3 * Vd * n3 + i2 * (7 * Ld + 9 * Fd * n3))) / Math.PI + 0.5), y: 1 - 0.5 * (r2 * (Dd + Vd * n3 + i2 * (Ld + Fd * n3)) / Math.PI + 1), z: 0 };
          }
          unproject(t2, e2) {
            t2 = (2 * t2 - 0.5) * Math.PI;
            let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n3 = r2 * r2, i2 = n3 * n3 * n3;
            for (let t3, s5, a3, o3 = 0; o3 < 12 && (s5 = r2 * (Dd + Vd * n3 + i2 * (Ld + Fd * n3)) - e2, a3 = Dd + 3 * Vd * n3 + i2 * (7 * Ld + 9 * Fd * n3), t3 = s5 / a3, r2 = M(r2 - t3, -Math.PI / 3, Math.PI / 3), n3 = r2 * r2, i2 = n3 * n3 * n3, !(Math.abs(t3) < 1e-12)); ++o3)
              ;
            const s4 = Rd * t2 * (Dd + 3 * Vd * n3 + i2 * (7 * Ld + 9 * Fd * n3)) / Math.cos(r2), a2 = Math.asin(Math.sin(r2) / Rd), o2 = M(180 * s4 / Math.PI, -180, 180), l3 = M(180 * a2 / Math.PI, -Hl, Hl);
            return new Ol(o2, l3);
          }
        }
        class $d extends Cd {
          constructor(t2) {
            super(t2), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t2, e2) {
            return { x: 0.5 + t2 / 360, y: 0.5 - e2 / 360, z: 0 };
          }
          unproject(t2, e2) {
            const r2 = 360 * (t2 - 0.5), n3 = M(360 * (0.5 - e2), -Hl, Hl);
            return new Ol(r2, n3);
          }
        }
        const jd = Math.PI / 2;
        function Od(t2) {
          return Math.tan((jd + t2) / 2);
        }
        class qd extends Cd {
          constructor(t2) {
            super(t2), this.center = t2.center || [0, 30];
            const [e2, r2] = this.parallels = t2.parallels || [30, 30];
            let n3 = w(e2), i2 = w(r2);
            this.southernCenter = n3 + i2 < 0, this.southernCenter && (n3 = -n3, i2 = -i2);
            const s4 = Math.cos(n3), a2 = Od(n3);
            this.n = n3 === i2 ? Math.sin(n3) : Math.log(s4 / Math.cos(i2)) / Math.log(Od(i2) / a2), this.f = s4 * Math.pow(Od(n3), this.n) / this.n;
          }
          project(t2, e2) {
            e2 = w(e2), this.southernCenter && (e2 = -e2), t2 = w(t2 - this.center[0]);
            const r2 = 1e-6, { n: n3, f: i2 } = this;
            i2 > 0 ? e2 < -jd + r2 && (e2 = -jd + r2) : e2 > jd - r2 && (e2 = jd - r2);
            const s4 = i2 / Math.pow(Od(e2), n3);
            let a2 = s4 * Math.sin(n3 * t2), o2 = i2 - s4 * Math.cos(n3 * t2);
            return a2 = 0.5 * (a2 / Math.PI + 0.5), o2 = 0.5 * (o2 / Math.PI + 0.5), { x: a2, y: this.southernCenter ? o2 : 1 - o2, z: 0 };
          }
          unproject(t2, e2) {
            t2 = (2 * t2 - 0.5) * Math.PI, this.southernCenter && (e2 = 1 - e2), e2 = (2 * (1 - e2) - 0.5) * Math.PI;
            const { n: r2, f: n3 } = this, i2 = n3 - e2, s4 = Math.sign(i2), a2 = Math.sign(r2) * Math.sqrt(t2 * t2 + i2 * i2);
            let o2 = Math.atan2(t2, Math.abs(i2)) * s4;
            i2 * r2 < 0 && (o2 -= Math.PI * Math.sign(t2) * s4);
            const l3 = M(_(o2 / r2) + this.center[0], -180, 180), u3 = M(_(2 * Math.atan(Math.pow(n3 / a2, 1 / r2)) - jd), -Hl, Hl);
            return new Ol(l3, this.southernCenter ? -u3 : u3);
          }
        }
        class Nd extends Cd {
          constructor(t2) {
            super(t2), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
          }
          project(t2, e2) {
            return { x: Nl(t2), y: Gl(e2), z: 0 };
          }
          unproject(t2, e2) {
            const r2 = Kl(t2), n3 = Xl(e2);
            return new Ol(r2, n3);
          }
        }
        const Gd = w(Hl);
        class Zd extends Cd {
          project(t2, e2) {
            const r2 = (e2 = w(e2)) * e2, n3 = r2 * r2;
            return { x: 0.5 * ((t2 = w(t2)) * (0.8707 - 0.131979 * r2 + n3 * (n3 * (3971e-6 * r2 - 1529e-6 * n3) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e2 * (1.007226 + r2 * (0.015085 + n3 * (0.028874 * r2 - 0.044475 - 5916e-6 * n3))) / Math.PI + 1), z: 0 };
          }
          unproject(t2, e2) {
            t2 = (2 * t2 - 0.5) * Math.PI;
            let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n3 = 25, i2 = 0, s4 = r2 * r2;
            do {
              s4 = r2 * r2;
              const t3 = s4 * s4;
              i2 = (r2 * (1.007226 + s4 * (0.015085 + t3 * (0.028874 * s4 - 0.044475 - 5916e-6 * t3))) - e2) / (1.007226 + s4 * (0.045255 + t3 * (0.259866 * s4 - 0.311325 - 5916e-6 * 11 * t3))), r2 = M(r2 - i2, -Gd, Gd);
            } while (Math.abs(i2) > 1e-6 && --n3 > 0);
            s4 = r2 * r2;
            const a2 = M(_(t2 / (0.8707 + s4 * (s4 * (s4 * s4 * s4 * (3971e-6 - 1529e-6 * s4) - 0.013791) - 0.131979))), -180, 180), o2 = _(r2);
            return new Ol(a2, o2);
          }
        }
        const Kd = w(Hl);
        class Xd extends Cd {
          project(t2, e2) {
            e2 = w(e2), t2 = w(t2);
            const r2 = Math.cos(e2), n3 = 2 / Math.PI, i2 = Math.acos(r2 * Math.cos(t2 / 2)), s4 = Math.sin(i2) / i2, a2 = 0.5 * (t2 * n3 + 2 * r2 * Math.sin(t2 / 2) / s4) || 0, o2 = 0.5 * (e2 + Math.sin(e2) / s4) || 0;
            return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
          }
          unproject(t2, e2) {
            let r2 = t2 = (2 * t2 - 0.5) * Math.PI, n3 = e2 = (2 * (1 - e2) - 1) * Math.PI, i2 = 25;
            const s4 = 1e-6;
            let a2 = 0, o2 = 0;
            do {
              const i3 = Math.cos(n3), s5 = Math.sin(n3), l3 = 2 * s5 * i3, u3 = s5 * s5, c4 = i3 * i3, h3 = Math.cos(r2 / 2), p3 = Math.sin(r2 / 2), d3 = 2 * h3 * p3, f2 = p3 * p3, y2 = 1 - c4 * h3 * h3, m3 = y2 ? 1 / y2 : 0, g2 = y2 ? Math.acos(i3 * h3) * Math.sqrt(1 / y2) : 0, x2 = 0.5 * (2 * g2 * i3 * p3 + 2 * r2 / Math.PI) - t2, v4 = 0.5 * (g2 * s5 + n3) - e2, b3 = 0.5 * m3 * (c4 * f2 + g2 * i3 * h3 * u3) + 1 / Math.PI, w2 = m3 * (d3 * l3 / 4 - g2 * s5 * p3), _2 = 0.125 * m3 * (l3 * p3 - g2 * s5 * c4 * d3), A2 = 0.5 * m3 * (u3 * h3 + g2 * f2 * i3) + 0.5, S2 = w2 * _2 - A2 * b3;
              a2 = (v4 * w2 - x2 * A2) / S2, o2 = (x2 * _2 - v4 * b3) / S2, r2 = M(r2 - a2, -Math.PI, Math.PI), n3 = M(n3 - o2, -Kd, Kd);
            } while ((Math.abs(a2) > s4 || Math.abs(o2) > s4) && --i2 > 0);
            return new Ol(_(r2), _(n3));
          }
        }
        class Jd extends Cd {
          constructor(t2) {
            super(t2), this.center = t2.center || [0, 0], this.parallels = t2.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(w(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t2, e2) {
            const { scale: r2, cosPhi: n3 } = this;
            return { x: w(t2) * n3 * r2 + 0.5, y: -Math.sin(w(e2)) / n3 * r2 + 0.5, z: 0 };
          }
          unproject(t2, e2) {
            const { scale: r2, cosPhi: n3 } = this, i2 = -(e2 - 0.5) / r2, s4 = M(_((t2 - 0.5) / r2) / n3, -180, 180), a2 = Math.asin(M(i2 * n3, -1, 1)), o2 = M(_(a2), -Hl, Hl);
            return new Ol(s4, o2);
          }
        }
        class Hd extends Nd {
          constructor(t2) {
            super(t2), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
          }
          projectTilePoint(t2, e2, r2) {
            const n3 = Ml(t2, e2, r2);
            return Fo(n3, n3, Bl(xl(r2))), { x: n3[0], y: n3[1], z: n3[2] };
          }
          locationPoint(t2, e2) {
            const r2 = Il(e2.lat, e2.lng), n3 = Do([], r2), i2 = t2.elevation ? t2.elevation.getAtPointOrZero(t2.locationCoordinate(e2), t2._centerAltitude) : t2._centerAltitude;
            Po(r2, r2, n3, Zl(1, 0) * ao * i2);
            const s4 = po(new Float64Array(16));
            return yo(s4, t2.pixelMatrix, t2.globeMatrix), Fo(r2, r2, s4), new x(r2[0], r2[1]);
          }
          pixelsPerMeter(t2, e2) {
            return Zl(1, 0) * e2;
          }
          pixelSpaceConversion(t2, e2, r2) {
            const n3 = Zl(1, t2) * e2, i2 = Er(Zl(1, 45) * e2, n3, r2);
            return this.pixelsPerMeter(t2, e2) / i2;
          }
          createTileMatrix(t2, e2, r2) {
            const n3 = El(xl(r2.canonical));
            return yo(new Float64Array(16), t2.globeMatrix, n3);
          }
          createInversionMatrix(t2, e2) {
            const { center: r2 } = t2, n3 = Bl(xl(e2));
            return vo(n3, n3, w(r2.lng)), xo(n3, n3, w(r2.lat)), go(n3, n3, [t2._pixelsPerMercatorPixel, t2._pixelsPerMercatorPixel, 1]), Float32Array.from(n3);
          }
          pointCoordinate(t2, e2, r2, n3) {
            return yl(t2, e2, r2, true) || new Wl(0, 0);
          }
          pointCoordinate3D(t2, e2, r2) {
            const n3 = this.pointCoordinate(t2, e2, r2, 0);
            return [n3.x, n3.y, n3.z];
          }
          isPointAboveHorizon(t2, e2) {
            return !yl(t2, e2.x, e2.y, false);
          }
          farthestPixelDistance(t2) {
            const e2 = function(t3, e3) {
              const r3 = t3.cameraToCenterDistance, n3 = t3._centerAltitude * e3, i2 = t3._camera, s4 = t3._camera.forward(), a2 = Mo([], Co([], s4, -r3), [0, 0, n3]), o2 = t3.worldSize / (2 * Math.PI), l3 = [0, 0, -o2], u3 = t3.width / t3.height, c4 = Math.tan(t3.fovAboveCenter), h3 = Co([], i2.up(), c4), p3 = Co([], i2.right(), c4 * u3), d3 = Do([], Mo([], Mo([], s4, h3), p3)), f2 = [];
              let y2;
              if (new el(a2, d3).closestPointOnSphere(l3, o2, f2)) {
                const e4 = Mo([], f2, l3), r4 = $o([], e4, a2);
                y2 = Math.cos(t3.fovAboveCenter) * ko(r4);
              } else {
                const t4 = $o([], a2, l3), e4 = $o([], l3, a2);
                Do(e4, e4);
                const r4 = ko(t4) - o2;
                y2 = Math.sqrt(r4 * (r4 + 2 * o2));
                const n4 = Math.acos(y2 / (o2 + r4)) - Math.acos(Vo(s4, e4));
                y2 *= Math.cos(n4);
              }
              return 1.01 * y2;
            }(t2, this.pixelsPerMeter(t2.center.lat, t2.worldSize)), r2 = Pl(t2.zoom);
            if (r2 > 0) {
              const n3 = zd(t2, Zl(1, t2.center.lat) * t2.worldSize), i2 = t2.worldSize / (2 * Math.PI), s4 = Math.max(t2.width, t2.height) / t2.worldSize * Math.PI;
              return Er(e2, n3 + i2 * (1 - Math.cos(s4)), Math.pow(r2, 10));
            }
            return e2;
          }
          upVector(t2, e2, r2) {
            return Ml(e2, r2, t2, 1);
          }
          upVectorScale(t2) {
            return { metersToTile: fl(Tl(xl(t2))) };
          }
        }
        function Yd(t2) {
          const e2 = t2.parallels, r2 = !!e2 && Math.abs(e2[0] + e2[1]) < 0.01;
          switch (t2.name) {
            case "mercator":
              return new Nd(t2);
            case "equirectangular":
              return new $d(t2);
            case "naturalEarth":
              return new Zd(t2);
            case "equalEarth":
              return new Ud(t2);
            case "winkelTripel":
              return new Xd(t2);
            case "albers":
              return r2 ? new Jd(t2) : new Pd(t2);
            case "lambertConformalConic":
              return r2 ? new Jd(t2) : new qd(t2);
            case "globe":
              return new Hd(t2);
          }
          throw new Error(`Invalid projection name: ${t2.name}`);
        }
        const Wd = Kc.types, Qd = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function tf(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3) {
          const d3 = o2 ? Math.min(Ad, Math.round(o2[0])) : 0, f2 = o2 ? Math.min(Ad, Math.round(o2[1])) : 0;
          t2.emplaceBack(e2, r2, Math.round(32 * n3), Math.round(32 * i2), s4, a2, (d3 << 1) + (l3 ? 1 : 0), f2, 16 * u3, 16 * c4, 256 * h3, 256 * p3);
        }
        function ef(t2, e2, r2, n3, i2, s4, a2) {
          t2.emplaceBack(e2, r2, n3, i2, s4, a2);
        }
        function rf(t2, e2, r2, n3, i2) {
          t2.emplaceBack(e2, r2, n3, i2), t2.emplaceBack(e2, r2, n3, i2), t2.emplaceBack(e2, r2, n3, i2), t2.emplaceBack(e2, r2, n3, i2);
        }
        function nf(t2) {
          for (const e2 of t2.sections)
            if (ls(e2.text))
              return true;
          return false;
        }
        class sf {
          constructor(t2) {
            this.layoutVertexArray = new Xs(), this.indexArray = new ra(), this.programConfigurations = t2, this.segments = new so(), this.dynamicLayoutVertexArray = new Ns(), this.opacityVertexArray = new Hs(), this.placedSymbolArray = new fa(), this.globeExtVertexArray = new Js();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t2, e2, r2, n3) {
            this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Eh.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Ph.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Qd, true), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Ch.members, true)), this.opacityVertexBuffer.itemSize = 1), (r2 || n3) && this.programConfigurations.upload(t2));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
        }
        Ji(sf, "SymbolBuffers");
        class af {
          constructor(t2, e2, r2) {
            this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new so(), this.collisionVertexArray = new ta(), this.collisionVertexArrayExt = new ea();
          }
          upload(t2) {
            this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Dh.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, Vh.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
          }
        }
        Ji(af, "CollisionBuffers");
        class of {
          constructor(t2) {
            this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = po([]), this.placementViewportMatrix = po([]);
            const e2 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = $h(this.zoom, e2["text-size"]), this.iconSizeData = $h(this.zoom, e2["icon-size"]);
            const r2 = this.layers[0].layout, n3 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
            this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n3.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r2.get("text-writing-mode").map((t3) => Ip[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t2.sourceID, this.projection = t2.projection;
          }
          createArrays() {
            this.text = new sf(new Ja(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new sf(new Ja(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new ga(), this.lineVertexArray = new xa(), this.symbolInstances = new ma();
          }
          calculateGlyphDependencies(t2, e2, r2, n3, i2) {
            for (let r3 = 0; r3 < t2.length; r3++)
              if (e2[t2.charCodeAt(r3)] = true, n3 && i2) {
                const n4 = Gh[t2.charAt(r3)];
                n4 && (e2[n4.charCodeAt(0)] = true);
              }
          }
          populate(t2, e2, r2, n3) {
            const i2 = this.layers[0], s4 = i2.layout, a2 = "globe" === this.projection.name, o2 = s4.get("text-font"), l3 = s4.get("text-field"), u3 = s4.get("icon-image"), c4 = ("constant" !== l3.value.kind || l3.value.value instanceof De && !l3.value.value.isEmpty() || l3.value.value.toString().length > 0) && ("constant" !== o2.value.kind || o2.value.value.length > 0), h3 = "constant" !== u3.value.kind || !!u3.value.value || Object.keys(u3.parameters).length > 0, p3 = s4.get("symbol-sort-key");
            if (this.features = [], !c4 && !h3)
              return;
            const d3 = e2.iconDependencies, f2 = e2.glyphDependencies, y2 = e2.availableImages, m3 = new ws(this.zoom);
            for (const { feature: e3, id: l4, index: u4, sourceLayerIndex: g2 } of t2) {
              const t3 = i2._featureFilter.needGeometry, x2 = ou(e3, t3);
              if (!i2._featureFilter.filter(m3, x2, r2))
                continue;
              if (t3 || (x2.geometry = au(e3, r2, n3)), a2 && 1 !== e3.type && r2.z <= 5) {
                const t4 = x2.geometry, e4 = 0.98078528056, n4 = (t5, n5) => Vo(Ml(t5.x, t5.y, r2, 1), Ml(n5.x, n5.y, r2, 1)) < e4;
                for (let e5 = 0; e5 < t4.length; e5++)
                  t4[e5] = ru(t4[e5], n4);
              }
              let v4, b3;
              if (c4) {
                const t4 = i2.getValueAndResolveTokens("text-field", x2, r2, y2), e4 = De.factory(t4);
                nf(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === xs() || this.hasRTLText && bs.isParsed()) && (v4 = Nh(e4, i2, x2));
              }
              if (h3) {
                const t4 = i2.getValueAndResolveTokens("icon-image", x2, r2, y2);
                b3 = t4 instanceof Ve ? t4 : Ve.fromString(t4);
              }
              if (!v4 && !b3)
                continue;
              const w2 = this.sortFeaturesByKey ? p3.evaluate(x2, {}, r2) : void 0;
              if (this.features.push({ id: l4, text: v4, icon: b3, index: u4, sourceLayerIndex: g2, geometry: x2.geometry, properties: e3.properties, type: Wd[e3.type], sortKey: w2 }), b3 && (d3[b3.name] = true), v4) {
                const t4 = o2.evaluate(x2, {}, r2).join(","), e4 = "map" === s4.get("text-rotation-alignment") && "point" !== s4.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Ip.vertical) >= 0;
                for (const r3 of v4.sections)
                  if (r3.image)
                    d3[r3.image.name] = true;
                  else {
                    const n4 = es(v4.toString()), i3 = r3.fontStack || t4, s5 = f2[i3] = f2[i3] || {};
                    this.calculateGlyphDependencies(r3.text, s5, e4, this.allowVerticalPlacement, n4);
                  }
              }
            }
            "line" === s4.get("symbol-placement") && (this.features = function(t3) {
              const e3 = {}, r3 = {}, n4 = [];
              let i3 = 0;
              function s5(e4) {
                n4.push(t3[e4]), i3++;
              }
              function a3(t4, e4, i4) {
                const s6 = r3[t4];
                return delete r3[t4], r3[e4] = s6, n4[s6].geometry[0].pop(), n4[s6].geometry[0] = n4[s6].geometry[0].concat(i4[0]), s6;
              }
              function o3(t4, r4, i4) {
                const s6 = e3[r4];
                return delete e3[r4], e3[t4] = s6, n4[s6].geometry[0].shift(), n4[s6].geometry[0] = i4[0].concat(n4[s6].geometry[0]), s6;
              }
              function l4(t4, e4, r4) {
                const n5 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                return `${t4}:${n5.x}:${n5.y}`;
              }
              for (let u4 = 0; u4 < t3.length; u4++) {
                const c5 = t3[u4], h4 = c5.geometry, p4 = c5.text ? c5.text.toString() : null;
                if (!p4) {
                  s5(u4);
                  continue;
                }
                const d4 = l4(p4, h4), f3 = l4(p4, h4, true);
                if (d4 in r3 && f3 in e3 && r3[d4] !== e3[f3]) {
                  const t4 = o3(d4, f3, h4), i4 = a3(d4, f3, n4[t4].geometry);
                  delete e3[d4], delete r3[f3], r3[l4(p4, n4[i4].geometry, true)] = i4, n4[t4].geometry = null;
                } else
                  d4 in r3 ? a3(d4, f3, h4) : f3 in e3 ? o3(d4, f3, h4) : (s5(u4), e3[d4] = i3 - 1, r3[f3] = i3 - 1);
              }
              return n4.filter((t4) => t4.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
          }
          update(t2, e2, r2, n3) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2, n3), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2, n3));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t2) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          getProjection() {
            return this.projectionInstance || (this.projectionInstance = Yd(this.projection)), this.projectionInstance;
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t2, e2) {
            const r2 = this.lineVertexArray.length;
            if (void 0 !== t2.segment)
              for (const { x: t3, y: r3 } of e2)
                this.lineVertexArray.emplaceBack(t3, r3);
            return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
          }
          addSymbols(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4, h3, p3, d3) {
            const f2 = t2.indexArray, y2 = t2.layoutVertexArray, m3 = t2.globeExtVertexArray, g2 = t2.segments.prepareSegment(4 * e2.length, y2, f2, this.canOverlap ? s4.sortKey : void 0), x2 = this.glyphOffsetArray.length, v4 = g2.vertexLength, b3 = this.allowVerticalPlacement && a2 === Ip.vertical ? Math.PI / 2 : 0, w2 = s4.text && s4.text.sections;
            for (let n4 = 0; n4 < e2.length; n4++) {
              const { tl: i3, tr: a3, bl: u4, br: c5, tex: h4, pixelOffsetTL: x3, pixelOffsetBR: v5, minFontScaleX: _3, minFontScaleY: A2, glyphOffset: S2, isSDF: k2, sectionIndex: I2 } = e2[n4], M2 = g2.vertexLength, T3 = S2[1];
              if (tf(y2, l3.x, l3.y, i3.x, T3 + i3.y, h4.x, h4.y, r2, k2, x3.x, x3.y, _3, A2), tf(y2, l3.x, l3.y, a3.x, T3 + a3.y, h4.x + h4.w, h4.y, r2, k2, v5.x, x3.y, _3, A2), tf(y2, l3.x, l3.y, u4.x, T3 + u4.y, h4.x, h4.y + h4.h, r2, k2, x3.x, v5.y, _3, A2), tf(y2, l3.x, l3.y, c5.x, T3 + c5.y, h4.x + h4.w, h4.y + h4.h, r2, k2, v5.x, v5.y, _3, A2), o2) {
                const { x: e3, y: r3, z: n5 } = o2.anchor, [i4, s5, a4] = o2.up;
                ef(m3, e3, r3, n5, i4, s5, a4), ef(m3, e3, r3, n5, i4, s5, a4), ef(m3, e3, r3, n5, i4, s5, a4), ef(m3, e3, r3, n5, i4, s5, a4), rf(t2.dynamicLayoutVertexArray, e3, r3, n5, b3);
              } else
                rf(t2.dynamicLayoutVertexArray, l3.x, l3.y, l3.z, b3);
              f2.emplaceBack(M2, M2 + 1, M2 + 2), f2.emplaceBack(M2 + 1, M2 + 2, M2 + 3), g2.vertexLength += 4, g2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S2[0]), n4 !== e2.length - 1 && I2 === e2[n4 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(y2.length, s4, s4.index, {}, p3, d3, w2 && w2[I2]);
            }
            const _2 = o2 ? o2.anchor : l3;
            t2.placedSymbolArray.emplaceBack(_2.x, _2.y, _2.z, l3.x, l3.y, x2, this.glyphOffsetArray.length - x2, v4, u3, c4, l3.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n3[0], n3[1], a2, 0, false, 0, h3, 0);
          }
          _commitLayoutVertex(t2, e2, r2, n3, i2, s4, a2) {
            t2.emplaceBack(e2, r2, n3, i2, s4, Math.round(a2.x), Math.round(a2.y));
          }
          _addCollisionDebugVertices(t2, e2, r2, n3, i2, s4, a2) {
            const o2 = r2.segments.prepareSegment(4, r2.layoutVertexArray, r2.indexArray), l3 = o2.vertexLength, u3 = a2.tileAnchorX, c4 = a2.tileAnchorY;
            for (let t3 = 0; t3 < 4; t3++)
              r2.collisionVertexArray.emplaceBack(0, 0, 0, 0);
            r2.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, -t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, t2.padding, -t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, t2.padding, t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, t2.padding), this._commitLayoutVertex(r2.layoutVertexArray, n3, i2, s4, u3, c4, new x(t2.x1, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n3, i2, s4, u3, c4, new x(t2.x2, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n3, i2, s4, u3, c4, new x(t2.x2, t2.y2)), this._commitLayoutVertex(r2.layoutVertexArray, n3, i2, s4, u3, c4, new x(t2.x1, t2.y2)), o2.vertexLength += 4;
            const h3 = r2.indexArray;
            h3.emplaceBack(l3, l3 + 1), h3.emplaceBack(l3 + 1, l3 + 2), h3.emplaceBack(l3 + 2, l3 + 3), h3.emplaceBack(l3 + 3, l3), o2.primitiveLength += 4;
          }
          _addTextDebugCollisionBoxes(t2, e2, r2, n3, i2, s4) {
            for (let a2 = n3; a2 < i2; a2++) {
              const n4 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s4, e2, a2);
              this._addCollisionDebugVertices(n4, i3, this.textCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s4);
            }
          }
          _addIconDebugCollisionBoxes(t2, e2, r2, n3, i2, s4) {
            for (let a2 = n3; a2 < i2; a2++) {
              const n4 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s4.placedIconSymbolIndex);
              this._addCollisionDebugVertices(n4, i3, this.iconCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s4);
            }
          }
          generateCollisionDebugBuffers(t2, e2) {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new af(Ws, Lh.members, la), this.iconCollisionBox = new af(Ws, Lh.members, la);
            const r2 = Oh(this.iconSizeData, t2), n3 = Oh(this.textSizeData, t2);
            for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
              const s4 = this.symbolInstances.get(i2);
              this._addTextDebugCollisionBoxes(n3, t2, e2, s4.textBoxStartIndex, s4.textBoxEndIndex, s4), this._addTextDebugCollisionBoxes(n3, t2, e2, s4.verticalTextBoxStartIndex, s4.verticalTextBoxEndIndex, s4), this._addIconDebugCollisionBoxes(r2, t2, e2, s4.iconBoxStartIndex, s4.iconBoxEndIndex, s4), this._addIconDebugCollisionBoxes(r2, t2, e2, s4.verticalIconBoxStartIndex, s4.verticalIconBoxEndIndex, s4);
            }
          }
          getSymbolInstanceTextSize(t2, e2, r2, n3) {
            const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n3), s4 = jh(this.textSizeData, t2, i2) / Rh;
            return this.tilePixelRatio * s4;
          }
          getSymbolInstanceIconSize(t2, e2, r2) {
            const n3 = this.icon.placedSymbolArray.get(r2), i2 = jh(this.iconSizeData, t2, n3);
            return this.tilePixelRatio * i2;
          }
          _commitDebugCollisionVertexUpdate(t2, e2, r2) {
            t2.emplaceBack(e2, -r2, -r2), t2.emplaceBack(e2, r2, -r2), t2.emplaceBack(e2, r2, r2), t2.emplaceBack(e2, -r2, r2);
          }
          _updateTextDebugCollisionBoxes(t2, e2, r2, n3, i2, s4) {
            for (let a2 = n3; a2 < i2; a2++) {
              const n4 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s4, e2, a2);
              this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n4.padding);
            }
          }
          _updateIconDebugCollisionBoxes(t2, e2, r2, n3, i2, s4) {
            for (let a2 = n3; a2 < i2; a2++) {
              const n4 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s4);
              this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n4.padding);
            }
          }
          updateCollisionDebugBuffers(t2, e2) {
            if (!this.hasDebugData())
              return;
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
            const r2 = Oh(this.iconSizeData, t2), n3 = Oh(this.textSizeData, t2);
            for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
              const s4 = this.symbolInstances.get(i2);
              this._updateTextDebugCollisionBoxes(n3, t2, e2, s4.textBoxStartIndex, s4.textBoxEndIndex, s4), this._updateTextDebugCollisionBoxes(n3, t2, e2, s4.verticalTextBoxStartIndex, s4.verticalTextBoxEndIndex, s4), this._updateIconDebugCollisionBoxes(r2, t2, e2, s4.iconBoxStartIndex, s4.iconBoxEndIndex, s4.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r2, t2, e2, s4.verticalIconBoxStartIndex, s4.verticalIconBoxEndIndex, s4.placedIconSymbolIndex);
            }
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
          }
          _deserializeCollisionBoxesForSymbol(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
            const u3 = {};
            if (e2 < r2) {
              const { x1: r3, y1: n4, x2: i3, y2: s5, padding: a3, projectedAnchorX: o3, projectedAnchorY: l4, projectedAnchorZ: c4, tileAnchorX: h3, tileAnchorY: p3, featureIndex: d3 } = t2.get(e2);
              u3.textBox = { x1: r3, y1: n4, x2: i3, y2: s5, padding: a3, projectedAnchorX: o3, projectedAnchorY: l4, projectedAnchorZ: c4, tileAnchorX: h3, tileAnchorY: p3 }, u3.textFeatureIndex = d3;
            }
            if (n3 < i2) {
              const { x1: e3, y1: r3, x2: i3, y2: s5, padding: a3, projectedAnchorX: o3, projectedAnchorY: l4, projectedAnchorZ: c4, tileAnchorX: h3, tileAnchorY: p3, featureIndex: d3 } = t2.get(n3);
              u3.verticalTextBox = { x1: e3, y1: r3, x2: i3, y2: s5, padding: a3, projectedAnchorX: o3, projectedAnchorY: l4, projectedAnchorZ: c4, tileAnchorX: h3, tileAnchorY: p3 }, u3.verticalTextFeatureIndex = d3;
            }
            if (s4 < a2) {
              const { x1: e3, y1: r3, x2: n4, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l4, projectedAnchorZ: c4, tileAnchorX: h3, tileAnchorY: p3, featureIndex: d3 } = t2.get(s4);
              u3.iconBox = { x1: e3, y1: r3, x2: n4, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l4, projectedAnchorZ: c4, tileAnchorX: h3, tileAnchorY: p3 }, u3.iconFeatureIndex = d3;
            }
            if (o2 < l3) {
              const { x1: e3, y1: r3, x2: n4, y2: i3, padding: s5, projectedAnchorX: a3, projectedAnchorY: l4, projectedAnchorZ: c4, tileAnchorX: h3, tileAnchorY: p3, featureIndex: d3 } = t2.get(o2);
              u3.verticalIconBox = { x1: e3, y1: r3, x2: n4, y2: i3, padding: s5, projectedAnchorX: a3, projectedAnchorY: l4, projectedAnchorZ: c4, tileAnchorX: h3, tileAnchorY: p3 }, u3.verticalIconFeatureIndex = d3;
            }
            return u3;
          }
          deserializeCollisionBoxes(t2) {
            this.collisionArrays = [];
            for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
              const r2 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t2, e2) {
            const r2 = t2.placedSymbolArray.get(e2), n3 = r2.vertexStartIndex + 4 * r2.numGlyphs;
            for (let e3 = r2.vertexStartIndex; e3 < n3; e3 += 4)
              t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
          }
          getSortedSymbolIndexes(t2) {
            if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
              return this.symbolInstanceIndexes;
            const e2 = Math.sin(t2), r2 = Math.cos(t2), n3 = [], i2 = [], s4 = [];
            for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
              s4.push(t3);
              const a2 = this.symbolInstances.get(t3);
              n3.push(0 | Math.round(e2 * a2.tileAnchorX + r2 * a2.tileAnchorY)), i2.push(a2.featureIndex);
            }
            return s4.sort((t3, e3) => n3[t3] - n3[e3] || i2[e3] - i2[t3]), s4;
          }
          addToSortKeyRanges(t2, e2) {
            const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
          }
          sortFeatures(t2) {
            if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t3 of this.symbolInstanceIndexes) {
                const e2 = this.symbolInstances.get(t3);
                this.featureSortOrder.push(e2.featureIndex);
                const { rightJustifiedTextSymbolIndex: r2, centerJustifiedTextSymbolIndex: n3, leftJustifiedTextSymbolIndex: i2, verticalPlacedTextSymbolIndex: s4, placedIconSymbolIndex: a2, verticalPlacedIconSymbolIndex: o2 } = e2;
                r2 >= 0 && this.addIndicesForPlacedSymbol(this.text, r2), n3 >= 0 && n3 !== r2 && this.addIndicesForPlacedSymbol(this.text, n3), i2 >= 0 && i2 !== n3 && i2 !== r2 && this.addIndicesForPlacedSymbol(this.text, i2), s4 >= 0 && this.addIndicesForPlacedSymbol(this.text, s4), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        Ji(of, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), of.MAX_GLYPHS = 65535, of.addDynamicAttributes = rf;
        const lf = new Ps({ "symbol-placement": new Bs(te.layout_symbol["symbol-placement"]), "symbol-spacing": new Bs(te.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Bs(te.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Es(te.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Bs(te.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Bs(te.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Bs(te.layout_symbol["icon-ignore-placement"]), "icon-optional": new Bs(te.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Bs(te.layout_symbol["icon-rotation-alignment"]), "icon-size": new Es(te.layout_symbol["icon-size"]), "icon-text-fit": new Bs(te.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Bs(te.layout_symbol["icon-text-fit-padding"]), "icon-image": new Es(te.layout_symbol["icon-image"]), "icon-rotate": new Es(te.layout_symbol["icon-rotate"]), "icon-padding": new Bs(te.layout_symbol["icon-padding"]), "icon-keep-upright": new Bs(te.layout_symbol["icon-keep-upright"]), "icon-offset": new Es(te.layout_symbol["icon-offset"]), "icon-anchor": new Es(te.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Bs(te.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Bs(te.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Bs(te.layout_symbol["text-rotation-alignment"]), "text-field": new Es(te.layout_symbol["text-field"]), "text-font": new Es(te.layout_symbol["text-font"]), "text-size": new Es(te.layout_symbol["text-size"]), "text-max-width": new Es(te.layout_symbol["text-max-width"]), "text-line-height": new Es(te.layout_symbol["text-line-height"]), "text-letter-spacing": new Es(te.layout_symbol["text-letter-spacing"]), "text-justify": new Es(te.layout_symbol["text-justify"]), "text-radial-offset": new Es(te.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Bs(te.layout_symbol["text-variable-anchor"]), "text-anchor": new Es(te.layout_symbol["text-anchor"]), "text-max-angle": new Bs(te.layout_symbol["text-max-angle"]), "text-writing-mode": new Bs(te.layout_symbol["text-writing-mode"]), "text-rotate": new Es(te.layout_symbol["text-rotate"]), "text-padding": new Bs(te.layout_symbol["text-padding"]), "text-keep-upright": new Bs(te.layout_symbol["text-keep-upright"]), "text-transform": new Es(te.layout_symbol["text-transform"]), "text-offset": new Es(te.layout_symbol["text-offset"]), "text-allow-overlap": new Bs(te.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Bs(te.layout_symbol["text-ignore-placement"]), "text-optional": new Bs(te.layout_symbol["text-optional"]) });
        var uf = { paint: new Ps({ "icon-opacity": new Es(te.paint_symbol["icon-opacity"]), "icon-color": new Es(te.paint_symbol["icon-color"]), "icon-halo-color": new Es(te.paint_symbol["icon-halo-color"]), "icon-halo-width": new Es(te.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Es(te.paint_symbol["icon-halo-blur"]), "icon-translate": new Bs(te.paint_symbol["icon-translate"]), "icon-translate-anchor": new Bs(te.paint_symbol["icon-translate-anchor"]), "text-opacity": new Es(te.paint_symbol["text-opacity"]), "text-color": new Es(te.paint_symbol["text-color"], { runtimeType: pe, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Es(te.paint_symbol["text-halo-color"]), "text-halo-width": new Es(te.paint_symbol["text-halo-width"]), "text-halo-blur": new Es(te.paint_symbol["text-halo-blur"]), "text-translate": new Bs(te.paint_symbol["text-translate"]), "text-translate-anchor": new Bs(te.paint_symbol["text-translate-anchor"]) }), layout: lf };
        class cf {
          constructor(t2) {
            this.type = t2.property.overrides ? t2.property.overrides.runtimeType : le, this.defaultValue = t2;
          }
          evaluate(t2) {
            if (t2.formattedSection) {
              const e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t2.formattedSection))
                return e2.getOverride(t2.formattedSection);
            }
            return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t2) {
            this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Ji(cf, "FormatSectionOverride", { omit: ["defaultValue"] });
        class hf extends ro {
          constructor(t2) {
            super(t2, uf);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
            const r2 = this.layout.get("text-writing-mode");
            if (r2) {
              const t3 = [];
              for (const e3 of r2)
                t3.indexOf(e3) < 0 && t3.push(e3);
              this.layout._values["text-writing-mode"] = t3;
            } else
              this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t2, e2, r2, n3) {
            const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n3), s4 = this._unevaluatedLayout._values[t2];
            return s4.isDataDriven() || Jn(s4.value) || !i2 ? i2 : function(t3, e3) {
              return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
            }(e2.properties, i2);
          }
          createBucket(t2) {
            return new of(t2);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          _setPaintOverrides() {
            for (const t2 of uf.paint.overridableProperties) {
              if (!hf.hasPaintOverride(this.layout, t2))
                continue;
              const e2 = this.paint.get(t2), r2 = new cf(e2), n3 = new Xn(r2, e2.property.specification);
              let i2 = null;
              i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Yn("source", n3) : new Wn("composite", n3, e2.value.zoomStops, e2.value._interpolationType), this.paint._values[t2] = new Ts(e2.property, i2, e2.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && hf.hasPaintOverride(this.layout, t2);
          }
          static hasPaintOverride(t2, e2) {
            const r2 = t2.get("text-field"), n3 = uf.paint.properties[e2];
            let i2 = false;
            const s4 = (t3) => {
              for (const e3 of t3)
                if (n3.overrides && n3.overrides.hasOverride(e3))
                  return void (i2 = true);
            };
            if ("constant" === r2.value.kind && r2.value.value instanceof De)
              s4(r2.value.value.sections);
            else if ("source" === r2.value.kind) {
              const t3 = (e4) => {
                i2 || (e4 instanceof je && Re(e4.value) === me ? s4(e4.value.sections) : e4 instanceof Ze ? s4(e4.sections) : e4.eachChild(t3));
              }, e3 = r2.value;
              e3._styleExpression && t3(e3._styleExpression.expression);
            }
            return i2;
          }
          getProgramConfiguration(t2) {
            return new Xa(this, t2);
          }
        }
        var pf = { paint: new Ps({ "background-color": new Bs(te.paint_background["background-color"]), "background-pattern": new Bs(te.paint_background["background-pattern"]), "background-opacity": new Bs(te.paint_background["background-opacity"]) }) }, df = { paint: new Ps({ "raster-opacity": new Bs(te.paint_raster["raster-opacity"]), "raster-hue-rotate": new Bs(te.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Bs(te.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Bs(te.paint_raster["raster-brightness-max"]), "raster-saturation": new Bs(te.paint_raster["raster-saturation"]), "raster-contrast": new Bs(te.paint_raster["raster-contrast"]), "raster-resampling": new Bs(te.paint_raster["raster-resampling"]), "raster-fade-duration": new Bs(te.paint_raster["raster-fade-duration"]) }) };
        class ff extends ro {
          constructor(t2) {
            super(t2, {}), this.implementation = t2;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          isLayerDraped() {
            return void 0 !== this.implementation.renderToTile;
          }
          shouldRedrape() {
            return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
          }
          onAdd(t2) {
            this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
          }
          onRemove(t2) {
            this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
          }
        }
        var yf = { paint: new Ps({ "sky-type": new Bs(te.paint_sky["sky-type"]), "sky-atmosphere-sun": new Bs(te.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Bs(te.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Bs(te.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Bs(te.paint_sky["sky-gradient-radius"]), "sky-gradient": new Cs(te.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Bs(te.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Bs(te.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Bs(te.paint_sky["sky-opacity"]) }) };
        function mf(t2, e2, r2) {
          const n3 = [0, 0, 1], i2 = Ko([]);
          return Jo(i2, i2, r2 ? -w(t2) + Math.PI : w(t2)), Xo(i2, i2, -w(e2)), Ro(n3, n3, i2), Do(n3, n3);
        }
        const gf = { circle: class extends ro {
          constructor(t2) {
            super(t2, Tu);
          }
          createBucket(t2) {
            return new cu(t2);
          }
          queryRadius(t2) {
            const e2 = t2;
            return Au("circle-radius", this, e2) + Au("circle-stroke-width", this, e2) + Su(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n3, i2, s4, a2, o2) {
            const l3 = Iu(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s4.angle, t2.pixelToTileUnitsFactor), u3 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2);
            return zu(t2, n3, s4, a2, o2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l3, u3);
          }
          getProgramIds() {
            return ["circle"];
          }
          getProgramConfiguration(t2) {
            return new Xa(this, t2);
          }
        }, heatmap: class extends ro {
          createBucket(t2) {
            return new Du(t2);
          }
          constructor(t2) {
            super(t2, $u), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "heatmap-color" === t2 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = ju({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius(t2) {
            return Au("heatmap-radius", this, t2);
          }
          queryIntersectsFeature(t2, e2, r2, n3, i2, s4, a2, o2) {
            const l3 = this.paint.get("heatmap-radius").evaluate(e2, r2);
            return zu(t2, n3, s4, a2, o2, true, true, new x(0, 0), l3);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["heatmap", "heatmapTexture"];
          }
          getProgramConfiguration(t2) {
            return new Xa(this, t2);
          }
        }, hillshade: class extends ro {
          constructor(t2) {
            super(t2, Ou);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["hillshade", "hillshadePrepare"];
          }
        }, fill: class extends ro {
          constructor(t2) {
            super(t2, zc);
          }
          getProgramIds() {
            const t2 = this.paint.get("fill-pattern"), e2 = t2 && t2.constantOr(1), r2 = [e2 ? "fillPattern" : "fill"];
            return this.paint.get("fill-antialias") && r2.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r2;
          }
          getProgramConfiguration(t2) {
            return new Xa(this, t2);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2);
            const r2 = this.paint._values["fill-outline-color"];
            "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t2) {
            return new Mc(t2);
          }
          queryRadius() {
            return Su(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n3, i2, s4) {
            return !t2.queryGeometry.isAboveHorizon && du(ku(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s4.angle, t2.pixelToTileUnitsFactor), n3);
          }
          isTileClipped() {
            return true;
          }
        }, "fill-extrusion": class extends ro {
          constructor(t2) {
            super(t2, ch);
          }
          createBucket(t2) {
            return new th(t2);
          }
          queryRadius() {
            return Su(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          getProgramIds() {
            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
          }
          getProgramConfiguration(t2) {
            return new Xa(this, t2);
          }
          queryIntersectsFeature(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
            const u3 = Iu(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s4.angle, t2.pixelToTileUnitsFactor), c4 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h3 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p3 = [0, 0], d3 = o2 && s4.elevation, f2 = s4.elevation ? s4.elevation.exaggeration() : 1, y2 = t2.tile.getBucket(this);
            if (d3 && y2 instanceof th) {
              const t3 = y2.centroidVertexArray, e3 = l3 + 1;
              e3 < t3.length && (p3[0] = t3.geta_centroid_pos0(e3), p3[1] = t3.geta_centroid_pos1(e3));
            }
            if (0 === p3[0] && 1 === p3[1])
              return false;
            "globe" === s4.projection.name && (n3 = lh([n3], [new x(0, 0), new x(ao, ao)], t2.tileID.canonical).map((t3) => t3.polygon).flat());
            const m3 = d3 ? o2 : null, [g2, v4] = function(t3, e3, r3, n4, i3, s5, a3, o3, l4, u4, c5) {
              return "globe" === t3.projection.name ? function(t4, e4, r4, n5, i4, s6, a4, o4, l5, u5, c6) {
                const h4 = [], p4 = [], d4 = t4.projection.upVectorScale(c6, t4.center.lat, t4.worldSize).metersToTile, f3 = [0, 0, 0, 1], y3 = [0, 0, 0, 1], m4 = (t5, e5, r5, n6) => {
                  t5[0] = e5, t5[1] = r5, t5[2] = n6, t5[3] = 1;
                }, g3 = oh();
                r4 > 0 && (r4 += g3), n5 += g3;
                for (const g4 of e4) {
                  const e5 = [], x2 = [];
                  for (const h5 of g4) {
                    const p5 = h5.x + i4.x, g5 = h5.y + i4.y, v5 = t4.projection.projectTilePoint(p5, g5, c6), b4 = t4.projection.upVector(c6, h5.x, h5.y);
                    let w2 = r4, _2 = n5;
                    if (a4) {
                      const t5 = vh(p5, g5, r4, n5, a4, o4, l5, u5);
                      w2 += t5.base, _2 += t5.top;
                    }
                    0 !== r4 ? m4(f3, v5.x + b4[0] * d4 * w2, v5.y + b4[1] * d4 * w2, v5.z + b4[2] * d4 * w2) : m4(f3, v5.x, v5.y, v5.z), m4(y3, v5.x + b4[0] * d4 * _2, v5.y + b4[1] * d4 * _2, v5.z + b4[2] * d4 * _2), Fo(f3, f3, s6), Fo(y3, y3, s6), e5.push(new mh(f3[0], f3[1], f3[2])), x2.push(new mh(y3[0], y3[1], y3[2]));
                  }
                  h4.push(e5), p4.push(x2);
                }
                return [h4, p4];
              }(t3, e3, r3, n4, i3, s5, a3, o3, l4, u4, c5) : a3 ? function(t4, e4, r4, n5, i4, s6, a4, o4, l5) {
                const u5 = [], c6 = [], h4 = [0, 0, 0, 1];
                for (const p4 of t4) {
                  const t5 = [], d4 = [];
                  for (const u6 of p4) {
                    const c7 = u6.x + n5.x, p5 = u6.y + n5.y, f3 = vh(c7, p5, e4, r4, s6, a4, o4, l5);
                    h4[0] = c7, h4[1] = p5, h4[2] = f3.base, h4[3] = 1, Go(h4, h4, i4), h4[3] = Math.max(h4[3], 1e-5);
                    const y3 = new mh(h4[0] / h4[3], h4[1] / h4[3], h4[2] / h4[3]);
                    h4[0] = c7, h4[1] = p5, h4[2] = f3.top, h4[3] = 1, Go(h4, h4, i4), h4[3] = Math.max(h4[3], 1e-5);
                    const m4 = new mh(h4[0] / h4[3], h4[1] / h4[3], h4[2] / h4[3]);
                    t5.push(y3), d4.push(m4);
                  }
                  u5.push(t5), c6.push(d4);
                }
                return [u5, c6];
              }(e3, r3, n4, i3, s5, a3, o3, l4, u4) : function(t4, e4, r4, n5, i4) {
                const s6 = [], a4 = [], o4 = i4[8] * e4, l5 = i4[9] * e4, u5 = i4[10] * e4, c6 = i4[11] * e4, h4 = i4[8] * r4, p4 = i4[9] * r4, d4 = i4[10] * r4, f3 = i4[11] * r4;
                for (const e5 of t4) {
                  const t5 = [], r5 = [];
                  for (const s7 of e5) {
                    const e6 = s7.x + n5.x, a5 = s7.y + n5.y, y3 = i4[0] * e6 + i4[4] * a5 + i4[12], m4 = i4[1] * e6 + i4[5] * a5 + i4[13], g3 = i4[2] * e6 + i4[6] * a5 + i4[14], x2 = i4[3] * e6 + i4[7] * a5 + i4[15], v5 = y3 + o4, b4 = m4 + l5, w2 = g3 + u5, _2 = Math.max(x2 + c6, 1e-5), A2 = y3 + h4, S2 = m4 + p4, k2 = g3 + d4, I2 = Math.max(x2 + f3, 1e-5);
                    t5.push(new mh(v5 / _2, b4 / _2, w2 / _2)), r5.push(new mh(A2 / I2, S2 / I2, k2 / I2));
                  }
                  s6.push(t5), a4.push(r5);
                }
                return [s6, a4];
              }(e3, r3, n4, i3, s5);
            }(s4, n3, h3, c4, u3, a2, m3, p3, f2, s4.center.lat, t2.tileID.canonical), b3 = t2.queryGeometry;
            return function(t3, e3, r3) {
              let n4 = 1 / 0;
              du(r3, e3) && (n4 = xh(r3, e3[0]));
              for (let i3 = 0; i3 < e3.length; i3++) {
                const s5 = e3[i3], a3 = t3[i3];
                for (let t4 = 0; t4 < s5.length - 1; t4++) {
                  const e4 = s5[t4], i4 = [e4, s5[t4 + 1], a3[t4 + 1], a3[t4], e4];
                  hu(r3, i4) && (n4 = Math.min(n4, xh(r3, i4)));
                }
              }
              return n4 !== 1 / 0 && n4;
            }(g2, v4, b3.isPointQuery() ? b3.screenBounds : b3.screenGeometry);
          }
        }, line: class extends ro {
          constructor(t2) {
            super(t2, Th), this.gradientVersion = 0;
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            if ("line-gradient" === t2) {
              const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
              this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof Br, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          widthExpression() {
            return this._transitionablePaint._values["line-width"].value.expression;
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = zh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
          }
          createBucket(t2) {
            return new Ih(t2);
          }
          getProgramIds() {
            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
          }
          getProgramConfiguration(t2) {
            return new Xa(this, t2);
          }
          queryRadius(t2) {
            const e2 = t2, r2 = Bh(Au("line-width", this, e2), Au("line-gap-width", this, e2)), n3 = Au("line-offset", this, e2);
            return r2 / 2 + Math.abs(n3) + Su(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n3, i2, s4) {
            if (t2.queryGeometry.isAboveHorizon)
              return false;
            const a2 = ku(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s4.angle, t2.pixelToTileUnitsFactor), o2 = t2.pixelToTileUnitsFactor / 2 * Bh(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), l3 = this.paint.get("line-offset").evaluate(e2, r2);
            return l3 && (n3 = function(t3, e3) {
              const r3 = [], n4 = new x(0, 0);
              for (let i3 = 0; i3 < t3.length; i3++) {
                const s5 = t3[i3], a3 = [];
                for (let t4 = 0; t4 < s5.length; t4++) {
                  const r4 = s5[t4], i4 = s5[t4 + 1], o3 = 0 === t4 ? n4 : r4.sub(s5[t4 - 1])._unit()._perp(), l4 = t4 === s5.length - 1 ? n4 : i4.sub(r4)._unit()._perp(), u3 = o3._add(l4)._unit();
                  u3._mult(1 / (u3.x * l4.x + u3.y * l4.y)), a3.push(u3._mult(e3)._add(r4));
                }
                r3.push(a3);
              }
              return r3;
            }(n3, l3 * t2.pixelToTileUnitsFactor)), function(t3, e3, r3) {
              for (let n4 = 0; n4 < e3.length; n4++) {
                const i3 = e3[n4];
                if (t3.length >= 3) {
                  for (let e4 = 0; e4 < i3.length; e4++)
                    if (bu(t3, i3[e4]))
                      return true;
                }
                if (fu(t3, i3, r3))
                  return true;
              }
              return false;
            }(a2, n3, o2);
          }
          isTileClipped() {
            return true;
          }
        }, symbol: hf, background: class extends ro {
          constructor(t2) {
            super(t2, pf);
          }
          getProgramIds() {
            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
          }
        }, raster: class extends ro {
          constructor(t2) {
            super(t2, df);
          }
          getProgramIds() {
            return ["raster"];
          }
        }, sky: class extends ro {
          constructor(t2) {
            super(t2, yf), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "sky-gradient" === t2 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t2 && "sky-atmosphere-halo-color" !== t2 && "sky-atmosphere-color" !== t2 && "sky-atmosphere-sun-intensity" !== t2 || (this._skyboxInvalidated = true);
          }
          _updateColorRamp() {
            this.colorRamp = ju({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          needsSkyboxCapture(t2) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
              return true;
            if (!this.paint.get("sky-atmosphere-sun")) {
              const e2 = t2.style.light.properties.get("position");
              return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
            }
            return false;
          }
          getCenter(t2, e2) {
            if ("atmosphere" === this.paint.get("sky-type")) {
              const r3 = this.paint.get("sky-atmosphere-sun"), n3 = !r3, i2 = t2.style.light, s4 = i2.properties.get("position");
              return n3 && "viewport" === i2.properties.get("anchor") && N("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n3 ? mf(s4.azimuthal, 90 - s4.polar, e2) : mf(r3[0], 90 - r3[1], e2);
            }
            const r2 = this.paint.get("sky-gradient-center");
            return mf(r2[0], 90 - r2[1], e2);
          }
          is3D() {
            return false;
          }
          isSky() {
            return true;
          }
          markSkyboxValid(t2) {
            this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
          }
          hasOffscreenPass() {
            return true;
          }
          getProgramIds() {
            const t2 = this.paint.get("sky-type");
            return "atmosphere" === t2 ? ["skyboxCapture", "skybox"] : "gradient" === t2 ? ["skyboxGradient"] : null;
          }
        } };
        class xf {
          constructor(t2, e2, r2, n3) {
            this.context = t2, this.format = r2, this.texture = t2.gl.createTexture(), this.update(e2, n3);
          }
          update(t2, r2, n3) {
            const { width: i2, height: s4 } = t2, { context: a2 } = this, { gl: o2 } = a2, { HTMLImageElement: l3, HTMLCanvasElement: u3, HTMLVideoElement: c4, ImageData: h3, ImageBitmap: p3 } = e;
            if (o2.bindTexture(o2.TEXTURE_2D, this.texture), a2.pixelStoreUnpackFlipY.set(false), a2.pixelStoreUnpack.set(1), a2.pixelStoreUnpackPremultiplyAlpha.set(this.format === o2.RGBA && (!r2 || false !== r2.premultiply)), n3 || this.size && this.size[0] === i2 && this.size[1] === s4) {
              const { x: e2, y: r3 } = n3 || { x: 0, y: 0 };
              t2 instanceof l3 || t2 instanceof u3 || t2 instanceof c4 || t2 instanceof h3 || p3 && t2 instanceof p3 ? o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r3, o2.RGBA, o2.UNSIGNED_BYTE, t2) : o2.texSubImage2D(o2.TEXTURE_2D, 0, e2, r3, i2, s4, o2.RGBA, o2.UNSIGNED_BYTE, t2.data);
            } else
              this.size = [i2, s4], t2 instanceof l3 || t2 instanceof u3 || t2 instanceof c4 || t2 instanceof h3 || p3 && t2 instanceof p3 ? o2.texImage2D(o2.TEXTURE_2D, 0, this.format, this.format, o2.UNSIGNED_BYTE, t2) : o2.texImage2D(o2.TEXTURE_2D, 0, this.format, i2, s4, 0, this.format, o2.UNSIGNED_BYTE, t2.data);
            this.useMipmap = Boolean(r2 && r2.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o2.generateMipmap(o2.TEXTURE_2D);
          }
          bind(t2, e2) {
            const { context: r2 } = this, { gl: n3 } = r2;
            n3.bindTexture(n3.TEXTURE_2D, this.texture), t2 !== this.filter && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MAG_FILTER, t2), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MIN_FILTER, this.useMipmap ? t2 === n3.NEAREST ? n3.NEAREST_MIPMAP_NEAREST : n3.LINEAR_MIPMAP_NEAREST : t2), this.filter = t2), e2 !== this.wrap && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_S, e2), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_T, e2), this.wrap = e2);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t2 } = this.context;
            t2.deleteTexture(this.texture), this.texture = null;
          }
        }
        class vf {
          constructor(t2) {
            this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            this._channel = void 0, this._callback = () => {
            };
          }
        }
        class bf {
          constructor() {
            this.tasks = {}, this.taskQueue = [], R(["process"], this), this.invoker = new vf(this.process), this.nextId = 0;
          }
          add(t2, e2) {
            const r2 = this.nextId++, n3 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
              return r3 = r3 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r3 : "maybePrepare" === t3 && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
            }(e2);
            if (0 === n3) {
              K();
              try {
                t2();
              } finally {
              }
              return { cancel: () => {
              } };
            }
            return this.tasks[r2] = { fn: t2, metadata: e2, priority: n3, id: r2 }, this.taskQueue.push(r2), this.invoker.trigger(), { cancel: () => {
              delete this.tasks[r2];
            } };
          }
          process() {
            K();
            try {
              if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length)
                return;
              const t2 = this.pick();
              if (null === t2)
                return;
              const e2 = this.tasks[t2];
              if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e2)
                return;
              e2.fn();
            } finally {
            }
          }
          pick() {
            let t2 = null, e2 = 1 / 0;
            for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
              const n3 = this.tasks[this.taskQueue[r3]];
              n3.priority < e2 && (e2 = n3.priority, t2 = r3);
            }
            if (null === t2)
              return null;
            const r2 = this.taskQueue[t2];
            return this.taskQueue.splice(t2, 1), r2;
          }
          remove() {
            this.invoker.remove();
          }
        }
        class wf {
          constructor(t2) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e2 = 0; e2 < t2.length; e2++) {
              const r2 = t2[e2];
              this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
            }
          }
          encode(t2) {
            return this._stringToNumber[t2];
          }
          decode(t2) {
            return this._numberToString[t2];
          }
        }
        const _f = ["tile", "layer", "source", "sourceLayer", "state"];
        class Af {
          constructor(t2, e2, r2, n3, i2) {
            this.type = "Feature", this._vectorTileFeature = t2, this._z = e2, this._x = r2, this._y = n3, this.properties = t2.properties, this.id = i2;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
          }
          set geometry(t2) {
            this._geometry = t2;
          }
          toJSON() {
            const t2 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
            void 0 !== this.id && (t2.id = this.id);
            for (const e2 of _f)
              void 0 !== this[e2] && (t2[e2] = this[e2]);
            return t2;
          }
        }
        const Sf = 32, kf = 33, If = new Uint16Array(8184);
        for (let t2 = 0; t2 < 2046; t2++) {
          let e2 = t2 + 2, r2 = 0, n3 = 0, i2 = 0, s4 = 0, a2 = 0, o2 = 0;
          for (1 & e2 ? i2 = s4 = a2 = Sf : r2 = n3 = o2 = Sf; (e2 >>= 1) > 1; ) {
            const t3 = r2 + i2 >> 1, l4 = n3 + s4 >> 1;
            1 & e2 ? (i2 = r2, s4 = n3, r2 = a2, n3 = o2) : (r2 = i2, n3 = s4, i2 = a2, s4 = o2), a2 = t3, o2 = l4;
          }
          const l3 = 4 * t2;
          If[l3 + 0] = r2, If[l3 + 1] = n3, If[l3 + 2] = i2, If[l3 + 3] = s4;
        }
        const Mf = new Uint16Array(2178), Tf = new Uint8Array(1089), zf = new Uint16Array(1089);
        function Bf(t2) {
          return 0 === t2 ? -0.03125 : 32 === t2 ? 0.03125 : 0;
        }
        var Ef = Rs([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        const Cf = { type: 2, extent: ao, loadGeometry: () => [[new x(0, 0), new x(ao + 1, 0), new x(ao + 1, ao + 1), new x(0, ao + 1), new x(0, 0)]] };
        class Pf {
          constructor(t2, e2, r2, n3, i2) {
            this.tileID = t2, this.uid = D(), this.uses = 0, this.tileSize = e2, this.tileZoom = r2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = i2, this.expiredRequestCount = 0, this.state = "loading", n3 && n3.transform && (this.projection = n3.transform.projection);
          }
          registerFadeDuration(t2) {
            const e2 = t2 + this.timeAdded;
            e2 < Xt.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          get tileTransform() {
            return this._tileTransform || (this._tileTransform = Bd(this.tileID.canonical, this.projection)), this._tileTransform;
          }
          loadVectorData(t2, e2, r2) {
            if (this.unloadVectorData(), this.state = "loaded", t2) {
              t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
                const r3 = {};
                if (!e3)
                  return r3;
                for (const n3 of t3) {
                  const t4 = n3.layerIds.map((t5) => e3.getLayer(t5)).filter(Boolean);
                  if (0 !== t4.length) {
                    n3.layers = t4, n3.stateDependentLayerIds && (n3.stateDependentLayers = n3.stateDependentLayerIds.map((e4) => t4.filter((t5) => t5.id === e4)[0]));
                    for (const e4 of t4)
                      r3[e4.id] = n3;
                  }
                }
                return r3;
              }(t2.buckets, e2.style), this.hasSymbolBuckets = false;
              for (const t3 in this.buckets) {
                const e3 = this.buckets[t3];
                if (e3 instanceof of) {
                  if (this.hasSymbolBuckets = true, !r2)
                    break;
                  e3.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets)
                for (const t3 in this.buckets) {
                  const e3 = this.buckets[t3];
                  if (e3 instanceof of && e3.hasRTLText) {
                    this.hasRTLText = true, bs.isLoading() || bs.isLoaded() || "deferred" !== xs() || vs();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const t3 in this.buckets) {
                const r3 = this.buckets[t3];
                this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(t3).queryRadius(r3));
              }
              t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas);
            } else
              this.collisionBoxArray = new pa();
          }
          unloadVectorData() {
            if (this.hasData()) {
              for (const t2 in this.buckets)
                this.buckets[t2].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          getBucket(t2) {
            return this.buckets[t2.id];
          }
          upload(t2) {
            for (const e3 in this.buckets) {
              const r2 = this.buckets[e3];
              r2.uploadPending() && r2.upload(t2);
            }
            const e2 = t2.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new xf(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new xf(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new xf(t2, this.lineAtlas.image, e2.ALPHA), this.lineAtlas.uploaded = true);
          }
          prepare(t2) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t2, e2, r2, n3, i2, s4, a2, o2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n3, pixelPosMatrix: a2, transform: s4, params: i2, tileTransform: this.tileTransform }, t2, e2, r2) : {};
          }
          querySourceFeatures(t2, e2) {
            const r2 = this.latestFeatureIndex;
            if (!r2 || !r2.rawTileData)
              return;
            const n3 = r2.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", s4 = n3._geojsonTileLayer || n3[i2];
            if (!s4)
              return;
            const a2 = hi(e2 && e2.filter), { z: o2, x: l3, y: u3 } = this.tileID.canonical, c4 = { z: o2, x: l3, y: u3 };
            for (let e3 = 0; e3 < s4.length; e3++) {
              const n4 = s4.feature(e3);
              if (a2.needGeometry) {
                const t3 = ou(n4, true);
                if (!a2.filter(new ws(this.tileID.overscaledZ), t3, this.tileID.canonical))
                  continue;
              } else if (!a2.filter(new ws(this.tileID.overscaledZ), n4))
                continue;
              const h3 = r2.getId(n4, i2), p3 = new Af(n4, o2, l3, u3, h3);
              p3.tile = c4, t2.push(p3);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t2) {
            const e2 = this.expirationTime;
            if (t2.cacheControl) {
              const e3 = X(t2.cacheControl);
              e3["max-age"] && (this.expirationTime = Date.now() + 1e3 * e3["max-age"]);
            } else
              t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
            if (this.expirationTime) {
              const t3 = Date.now();
              let r2 = false;
              if (this.expirationTime > t3)
                r2 = false;
              else if (e2)
                if (this.expirationTime < e2)
                  r2 = true;
                else {
                  const n3 = this.expirationTime - e2;
                  n3 ? this.expirationTime = t3 + Math.max(n3, 3e4) : r2 = true;
                }
              else
                r2 = true;
              r2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t2, e2) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t2).length || !e2)
              return;
            const r2 = this.latestFeatureIndex.loadVTLayers(), n3 = e2.style.listImages();
            for (const i2 in this.buckets) {
              if (!e2.style.hasLayer(i2))
                continue;
              const s4 = this.buckets[i2], a2 = s4.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r2[a2], l3 = t2[a2];
              if (!o2 || !l3 || 0 === Object.keys(l3).length)
                continue;
              if (s4.update(l3, o2, n3, this.imageAtlas && this.imageAtlas.patternPositions || {}), s4 instanceof Ih || s4 instanceof Mc) {
                const t3 = e2.style._getSourceCache(s4.layers[0].source);
                e2._terrain && e2._terrain.enabled && t3 && s4.programConfigurations.needsUpload && e2._terrain._clearRenderCacheForTile(t3.id, this.tileID);
              }
              const u3 = e2 && e2.style && e2.style.getLayer(i2);
              u3 && (this.queryPadding = Math.max(this.queryPadding, u3.queryRadius(s4)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Xt.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t2) {
            this.symbolFadeHoldUntil = Xt.now() + t2;
          }
          setTexture(t2, e2) {
            const r2 = e2.context, n3 = r2.gl;
            this.texture = this.texture || e2.getTileTexture(t2.width), this.texture ? this.texture.update(t2, { useMipmap: true }) : (this.texture = new xf(r2, t2, n3.RGBA, { useMipmap: true }), this.texture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE));
          }
          setDependencies(t2, e2) {
            const r2 = {};
            for (const t3 of e2)
              r2[t3] = true;
            this.dependencies[t2] = r2;
          }
          hasDependency(t2, e2) {
            for (const r2 of t2) {
              const t3 = this.dependencies[r2];
              if (t3) {
                for (const r3 of e2)
                  if (t3[r3])
                    return true;
              }
            }
            return false;
          }
          clearQueryDebugViz() {
          }
          _makeDebugTileBoundsBuffers(t2, e2) {
            if (!e2 || "mercator" === e2.name || this._tileDebugBuffer)
              return;
            const r2 = au(Cf, this.tileID.canonical, this.tileTransform)[0], n3 = new $s(), i2 = new ua();
            for (let t3 = 0; t3 < r2.length; t3++) {
              const { x: e3, y: s4 } = r2[t3];
              n3.emplaceBack(e3, s4), i2.emplaceBack(t3);
            }
            i2.emplaceBack(0), this._tileDebugIndexBuffer = t2.createIndexBuffer(i2), this._tileDebugBuffer = t2.createVertexBuffer(n3, tl.members), this._tileDebugSegments = so.simpleSegment(0, 0, n3.length, i2.length);
          }
          _makeTileBoundsBuffers(t2, e2) {
            if (this._tileBoundsBuffer || !e2 || "mercator" === e2.name)
              return;
            const r2 = au(Cf, this.tileID.canonical, this.tileTransform)[0];
            let n3, i2;
            if (this.isRaster) {
              const t3 = function(t4, e3) {
                const r3 = Bd(t4, e3), n4 = Math.pow(2, t4.z);
                for (let i4 = 0; i4 < kf; i4++)
                  for (let s5 = 0; s5 < kf; s5++) {
                    const a3 = Kl((t4.x + (s5 + Bf(s5)) / Sf) / n4), o3 = Xl((t4.y + (i4 + Bf(i4)) / Sf) / n4), l4 = e3.project(a3, o3), u3 = i4 * kf + s5;
                    Mf[2 * u3 + 0] = Math.round((l4.x * r3.scale - r3.x) * ao), Mf[2 * u3 + 1] = Math.round((l4.y * r3.scale - r3.y) * ao);
                  }
                Tf.fill(0), zf.fill(0);
                for (let t5 = 2045; t5 >= 0; t5--) {
                  const e4 = 4 * t5, r4 = If[e4 + 0], n5 = If[e4 + 1], i4 = If[e4 + 2], s5 = If[e4 + 3], a3 = r4 + i4 >> 1, o3 = n5 + s5 >> 1, l4 = a3 + o3 - n5, u3 = o3 + r4 - a3, c4 = n5 * kf + r4, h3 = s5 * kf + i4, p3 = o3 * kf + a3, d3 = Math.hypot((Mf[2 * c4 + 0] + Mf[2 * h3 + 0]) / 2 - Mf[2 * p3 + 0], (Mf[2 * c4 + 1] + Mf[2 * h3 + 1]) / 2 - Mf[2 * p3 + 1]) >= 16;
                  Tf[p3] = Tf[p3] || (d3 ? 1 : 0), t5 < 1022 && (Tf[p3] = Tf[p3] || Tf[(n5 + u3 >> 1) * kf + (r4 + l4 >> 1)] || Tf[(s5 + u3 >> 1) * kf + (i4 + l4 >> 1)]);
                }
                const i3 = new Os(), s4 = new ra();
                let a2 = 0;
                function o2(t5, e4) {
                  const r4 = e4 * kf + t5;
                  return 0 === zf[r4] && (i3.emplaceBack(Mf[2 * r4 + 0], Mf[2 * r4 + 1], t5 * ao / Sf, e4 * ao / Sf), zf[r4] = ++a2), zf[r4] - 1;
                }
                function l3(t5, e4, r4, n5, i4, a3) {
                  const u3 = t5 + r4 >> 1, c4 = e4 + n5 >> 1;
                  if (Math.abs(t5 - i4) + Math.abs(e4 - a3) > 1 && Tf[c4 * kf + u3])
                    l3(i4, a3, t5, e4, u3, c4), l3(r4, n5, i4, a3, u3, c4);
                  else {
                    const l4 = o2(t5, e4), u4 = o2(r4, n5), c5 = o2(i4, a3);
                    s4.emplaceBack(l4, u4, c5);
                  }
                }
                return l3(0, 0, Sf, Sf, Sf, 0), l3(Sf, Sf, 0, 0, 0, Sf), { vertices: i3, indices: s4 };
              }(this.tileID.canonical, e2);
              n3 = t3.vertices, i2 = t3.indices;
            } else {
              n3 = new Os(), i2 = new ra();
              for (const { x: t4, y: e3 } of r2)
                n3.emplaceBack(t4, e3, 0, 0);
              const t3 = xc(n3.int16, void 0, 4);
              for (let e3 = 0; e3 < t3.length; e3 += 3)
                i2.emplaceBack(t3[e3], t3[e3 + 1], t3[e3 + 2]);
            }
            this._tileBoundsBuffer = t2.createVertexBuffer(n3, Ef.members), this._tileBoundsIndexBuffer = t2.createIndexBuffer(i2), this._tileBoundsSegments = so.simpleSegment(0, 0, n3.length, i2.length);
          }
          _makeGlobeTileDebugBuffers(t2, e2) {
            const r2 = e2.projection;
            if (!r2 || "globe" !== r2.name || e2.freezeTileCoverage)
              return;
            const n3 = this.tileID.canonical, i2 = Bl(bl(n3, e2)), s4 = Pl(e2.zoom);
            let a2;
            s4 > 0 && (a2 = fo(new Float64Array(16), e2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t2, n3, e2, i2, a2, s4), this._makeGlobeTileDebugTextBuffer(t2, n3, e2, i2, a2, s4);
          }
          _globePoint(t2, e2, r2, n3, i2, s4, a2) {
            let o2 = Ml(t2, e2, r2);
            if (s4) {
              const i3 = 1 << r2.z, l3 = Nl(n3.center.lng), u3 = Gl(n3.center.lat), c4 = (r2.x + 0.5) / i3 - l3;
              let h3 = 0;
              c4 > 0.5 ? h3 = -1 : c4 < -0.5 && (h3 = 1);
              let p3 = (t2 / ao + r2.x) / i3 + h3, d3 = (e2 / ao + r2.y) / i3;
              p3 = (p3 - l3) * n3._pixelsPerMercatorPixel + l3, d3 = (d3 - u3) * n3._pixelsPerMercatorPixel + u3;
              const f2 = [p3 * n3.worldSize, d3 * n3.worldSize, 0];
              Fo(f2, f2, s4), o2 = vl(o2, f2, a2);
            }
            return Fo(o2, o2, i2);
          }
          _makeGlobeTileDebugBorderBuffer(t2, e2, r2, n3, i2, s4) {
            const a2 = new $s(), o2 = new ua(), l3 = new js(), u3 = (t3, u4, c5, h3, p3) => {
              const d3 = (c5 - t3) / (p3 - 1), f2 = (h3 - u4) / (p3 - 1), y2 = a2.length;
              for (let c6 = 0; c6 < p3; c6++) {
                const h4 = t3 + c6 * d3, p4 = u4 + c6 * f2;
                a2.emplaceBack(h4, p4);
                const m3 = this._globePoint(h4, p4, e2, r2, n3, i2, s4);
                l3.emplaceBack(m3[0], m3[1], m3[2]), o2.emplaceBack(y2 + c6);
              }
            }, c4 = ao;
            u3(0, 0, c4, 0, 16), u3(c4, 0, c4, c4, 16), u3(c4, c4, 0, c4, 16), u3(0, c4, 0, 0, 16), this._tileDebugIndexBuffer = t2.createIndexBuffer(o2), this._tileDebugBuffer = t2.createVertexBuffer(a2, tl.members), this._globeTileDebugBorderBuffer = t2.createVertexBuffer(l3, Qo.members), this._tileDebugSegments = so.simpleSegment(0, 0, a2.length, o2.length);
          }
          _makeGlobeTileDebugTextBuffer(t2, e2, r2, n3, i2, s4) {
            const a2 = ao / 4, o2 = new $s(), l3 = new ra(), u3 = new js(), c4 = 25;
            l3.reserve(32), o2.reserve(c4), u3.reserve(c4);
            const h3 = (t3, e3) => c4 * t3 + e3;
            for (let t3 = 0; t3 < c4; t3++) {
              const l4 = t3 * a2;
              for (let t4 = 0; t4 < c4; t4++) {
                const c5 = t4 * a2;
                o2.emplaceBack(c5, l4);
                const h4 = this._globePoint(c5, l4, e2, r2, n3, i2, s4);
                u3.emplaceBack(h4[0], h4[1], h4[2]);
              }
            }
            for (let t3 = 0; t3 < 4; t3++)
              for (let e3 = 0; e3 < 4; e3++) {
                const r3 = h3(t3, e3), n4 = h3(t3, e3 + 1), i3 = h3(t3 + 1, e3), s5 = h3(t3 + 1, e3 + 1);
                l3.emplaceBack(r3, n4, i3), l3.emplaceBack(i3, n4, s5);
              }
            this._tileDebugTextIndexBuffer = t2.createIndexBuffer(l3), this._tileDebugTextBuffer = t2.createVertexBuffer(o2, tl.members), this._globeTileDebugTextBuffer = t2.createVertexBuffer(u3, Qo.members), this._tileDebugTextSegments = so.simpleSegment(0, 0, c4, 32);
          }
        }
        class Df {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t2, e2, r2) {
            const n3 = String(e2);
            if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n3] = this.stateChanges[t2][n3] || {}, C2(this.stateChanges[t2][n3], r2), null === this.deletedStates[t2]) {
              this.deletedStates[t2] = {};
              for (const e3 in this.state[t2])
                e3 !== n3 && (this.deletedStates[t2][e3] = null);
            } else if (this.deletedStates[t2] && null === this.deletedStates[t2][n3]) {
              this.deletedStates[t2][n3] = {};
              for (const e3 in this.state[t2][n3])
                r2[e3] || (this.deletedStates[t2][n3][e3] = null);
            } else
              for (const e3 in r2)
                this.deletedStates[t2] && this.deletedStates[t2][n3] && null === this.deletedStates[t2][n3][e3] && delete this.deletedStates[t2][n3][e3];
          }
          removeFeatureState(t2, e2, r2) {
            if (null === this.deletedStates[t2])
              return;
            const n3 = String(e2);
            if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r2 && void 0 !== e2)
              null !== this.deletedStates[t2][n3] && (this.deletedStates[t2][n3] = this.deletedStates[t2][n3] || {}, this.deletedStates[t2][n3][r2] = null);
            else if (void 0 !== e2)
              if (this.stateChanges[t2] && this.stateChanges[t2][n3])
                for (r2 in this.deletedStates[t2][n3] = {}, this.stateChanges[t2][n3])
                  this.deletedStates[t2][n3][r2] = null;
              else
                this.deletedStates[t2][n3] = null;
            else
              this.deletedStates[t2] = null;
          }
          getState(t2, e2) {
            const r2 = String(e2), n3 = C2({}, (this.state[t2] || {})[r2], (this.stateChanges[t2] || {})[r2]);
            if (null === this.deletedStates[t2])
              return {};
            if (this.deletedStates[t2]) {
              const r3 = this.deletedStates[t2][e2];
              if (null === r3)
                return {};
              for (const t3 in r3)
                delete n3[t3];
            }
            return n3;
          }
          initializeTileState(t2, e2) {
            t2.setFeatureState(this.state, e2);
          }
          coalesceChanges(t2, e2) {
            const r2 = {};
            for (const t3 in this.stateChanges) {
              this.state[t3] = this.state[t3] || {};
              const e3 = {};
              for (const r3 in this.stateChanges[t3])
                this.state[t3][r3] || (this.state[t3][r3] = {}), C2(this.state[t3][r3], this.stateChanges[t3][r3]), e3[r3] = this.state[t3][r3];
              r2[t3] = e3;
            }
            for (const t3 in this.deletedStates) {
              this.state[t3] = this.state[t3] || {};
              const e3 = {};
              if (null === this.deletedStates[t3])
                for (const r3 in this.state[t3])
                  e3[r3] = {}, this.state[t3][r3] = {};
              else
                for (const r3 in this.deletedStates[t3]) {
                  if (null === this.deletedStates[t3][r3])
                    this.state[t3][r3] = {};
                  else if (this.state[t3][r3])
                    for (const e4 of Object.keys(this.deletedStates[t3][r3]))
                      delete this.state[t3][r3][e4];
                  e3[r3] = this.state[t3][r3];
                }
              r2[t3] = r2[t3] || {}, C2(r2[t3], e3);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r2).length)
              for (const n3 in t2)
                t2[n3].setFeatureState(r2, e2);
          }
        }
        class Vf {
          constructor(t2) {
            this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
          }
          getElevation(t2, e2) {
            const r2 = this.toIdx(t2, e2);
            return { min: this.minimums[r2], max: this.maximums[r2] };
          }
          isLeaf(t2, e2) {
            return this.leaves[this.toIdx(t2, e2)];
          }
          toIdx(t2, e2) {
            return e2 * this.size + t2;
          }
        }
        function Lf(t2, e2, r2, n3) {
          let i2 = 0, s4 = Number.MAX_VALUE;
          for (let a2 = 0; a2 < 3; a2++)
            if (Math.abs(n3[a2]) < 1e-15) {
              if (r2[a2] < t2[a2] || r2[a2] > e2[a2])
                return null;
            } else {
              const o2 = 1 / n3[a2];
              let l3 = (t2[a2] - r2[a2]) * o2, u3 = (e2[a2] - r2[a2]) * o2;
              if (l3 > u3) {
                const t3 = l3;
                l3 = u3, u3 = t3;
              }
              if (l3 > i2 && (i2 = l3), u3 < s4 && (s4 = u3), i2 > s4)
                return null;
            }
          return i2;
        }
        function Ff(t2, e2, r2, n3, i2, s4, a2, o2, l3, u3, c4) {
          const h3 = n3 - t2, p3 = i2 - e2, d3 = s4 - r2, f2 = a2 - t2, y2 = o2 - e2, m3 = l3 - r2, g2 = c4[1] * m3 - c4[2] * y2, x2 = c4[2] * f2 - c4[0] * m3, v4 = c4[0] * y2 - c4[1] * f2, b3 = h3 * g2 + p3 * x2 + d3 * v4;
          if (Math.abs(b3) < 1e-15)
            return null;
          const w2 = 1 / b3, _2 = u3[0] - t2, A2 = u3[1] - e2, S2 = u3[2] - r2, k2 = (_2 * g2 + A2 * x2 + S2 * v4) * w2;
          if (k2 < 0 || k2 > 1)
            return null;
          const I2 = A2 * d3 - S2 * p3, M2 = S2 * h3 - _2 * d3, T3 = _2 * p3 - A2 * h3, z2 = (c4[0] * I2 + c4[1] * M2 + c4[2] * T3) * w2;
          return z2 < 0 || k2 + z2 > 1 ? null : (f2 * I2 + y2 * M2 + m3 * T3) * w2;
        }
        function Rf(t2, e2, r2) {
          return (t2 - e2) / (r2 - e2);
        }
        function Uf(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
          const u3 = 1 << r2, c4 = s4 - n3, h3 = a2 - i2, p3 = (t2 + 1) / u3 * c4 + n3, d3 = (e2 + 0) / u3 * h3 + i2, f2 = (e2 + 1) / u3 * h3 + i2;
          o2[0] = (t2 + 0) / u3 * c4 + n3, o2[1] = d3, l3[0] = p3, l3[1] = f2;
        }
        class $f {
          constructor(t2) {
            if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
              return;
            const e2 = function(t3) {
              const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
              let n4 = Math.ceil(Math.pow(2, e3));
              const i2 = 1 / n4, s4 = (t4, e4, r4, n5, i3) => {
                const s5 = n5 ? 1 : 0, a3 = (t4 + 1) * r4 - s5, o3 = e4 * r4, l3 = (e4 + 1) * r4 - s5;
                i3[0] = t4 * r4, i3[1] = o3, i3[2] = a3, i3[3] = l3;
              };
              let a2 = new Vf(n4);
              const o2 = [];
              for (let e4 = 0; e4 < n4 * n4; e4++) {
                s4(e4 % n4, Math.floor(e4 / n4), i2, false, o2);
                const r4 = Of(o2[0], o2[1], t3), l3 = Of(o2[2], o2[1], t3), u3 = Of(o2[2], o2[3], t3), c4 = Of(o2[0], o2[3], t3);
                a2.minimums.push(Math.min(r4, l3, u3, c4)), a2.maximums.push(Math.max(r4, l3, u3, c4)), a2.leaves.push(1);
              }
              for (r3.push(a2), n4 /= 2; n4 >= 1; n4 /= 2) {
                const t4 = r3[r3.length - 1];
                a2 = new Vf(n4);
                for (let e4 = 0; e4 < n4 * n4; e4++) {
                  s4(e4 % n4, Math.floor(e4 / n4), 2, true, o2);
                  const r4 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l3 = t4.getElevation(o2[2], o2[3]), u3 = t4.getElevation(o2[0], o2[3]), c4 = t4.isLeaf(o2[0], o2[1]), h3 = t4.isLeaf(o2[2], o2[1]), p3 = t4.isLeaf(o2[2], o2[3]), d3 = t4.isLeaf(o2[0], o2[3]), f2 = Math.min(r4.min, i3.min, l3.min, u3.min), y2 = Math.max(r4.max, i3.max, l3.max, u3.max), m3 = c4 && h3 && p3 && d3;
                  a2.maximums.push(y2), a2.minimums.push(f2), a2.leaves.push(y2 - f2 <= 5 && m3 ? 1 : 0);
                }
                r3.push(a2);
              }
              return r3;
            }(this.dem), r2 = e2.length - 1, n3 = e2[r2];
            this._addNode(n3.minimums[0], n3.maximums[0], n3.leaves[0]), this._construct(e2, 0, 0, r2, 0);
          }
          raycastRoot(t2, e2, r2, n3, i2, s4, a2 = 1) {
            return Lf([t2, e2, -100], [r2, n3, this.maximums[0] * a2], i2, s4);
          }
          raycast(t2, e2, r2, n3, i2, s4, a2 = 1) {
            if (!this.nodeCount)
              return null;
            const o2 = this.raycastRoot(t2, e2, r2, n3, i2, s4, a2);
            if (null == o2)
              return null;
            const l3 = [], u3 = [], c4 = [], h3 = [], p3 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
            for (; p3.length > 0; ) {
              const { idx: o3, t: d3, nodex: f2, nodey: y2, depth: m3 } = p3.pop();
              if (this.leaves[o3]) {
                Uf(f2, y2, m3, t2, e2, r2, n3, c4, h3);
                const o4 = 1 << m3, l4 = (f2 + 0) / o4, u4 = (f2 + 1) / o4, p4 = (y2 + 0) / o4, g3 = (y2 + 1) / o4, x2 = Of(l4, p4, this.dem) * a2, v4 = Of(u4, p4, this.dem) * a2, b3 = Of(u4, g3, this.dem) * a2, w2 = Of(l4, g3, this.dem) * a2, _2 = Ff(c4[0], c4[1], x2, h3[0], c4[1], v4, h3[0], h3[1], b3, i2, s4), A2 = Ff(h3[0], h3[1], b3, c4[0], h3[1], w2, c4[0], c4[1], x2, i2, s4), S2 = Math.min(null !== _2 ? _2 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
                if (S2 !== Number.MAX_VALUE)
                  return S2;
                {
                  const t3 = Po([], i2, s4, d3);
                  if (jf(x2, v4, w2, b3, Rf(t3[0], c4[0], h3[0]), Rf(t3[1], c4[1], h3[1])) >= t3[2])
                    return d3;
                }
                continue;
              }
              let g2 = 0;
              for (let p4 = 0; p4 < this._siblingOffset.length; p4++) {
                Uf((f2 << 1) + this._siblingOffset[p4][0], (y2 << 1) + this._siblingOffset[p4][1], m3 + 1, t2, e2, r2, n3, c4, h3), c4[2] = -100, h3[2] = this.maximums[this.childOffsets[o3] + p4] * a2;
                const d4 = Lf(c4, h3, i2, s4);
                if (null != d4) {
                  const t3 = d4;
                  l3[p4] = t3;
                  let e3 = false;
                  for (let r3 = 0; r3 < g2 && !e3; r3++)
                    t3 >= l3[u3[r3]] && (u3.splice(r3, 0, p4), e3 = true);
                  e3 || (u3[g2] = p4), g2++;
                }
              }
              for (let t3 = 0; t3 < g2; t3++) {
                const e3 = u3[t3];
                p3.push({ idx: this.childOffsets[o3] + e3, t: l3[e3], nodex: (f2 << 1) + this._siblingOffset[e3][0], nodey: (y2 << 1) + this._siblingOffset[e3][1], depth: m3 + 1 });
              }
            }
            return null;
          }
          _addNode(t2, e2, r2) {
            return this.minimums.push(t2), this.maximums.push(e2), this.leaves.push(r2), this.childOffsets.push(0), this.nodeCount++;
          }
          _construct(t2, e2, r2, n3, i2) {
            if (1 === t2[n3].isLeaf(e2, r2))
              return;
            this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
            const s4 = n3 - 1, a2 = t2[s4];
            let o2 = 0, l3 = 0;
            for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
              const n4 = 2 * e2 + this._siblingOffset[t3][0], i3 = 2 * r2 + this._siblingOffset[t3][1], s5 = a2.getElevation(n4, i3), u3 = a2.isLeaf(n4, i3), c4 = this._addNode(s5.min, s5.max, u3);
              u3 && (o2 |= 1 << t3), l3 || (l3 = c4);
            }
            for (let n4 = 0; n4 < this._siblingOffset.length; n4++)
              o2 & 1 << n4 || this._construct(t2, 2 * e2 + this._siblingOffset[n4][0], 2 * r2 + this._siblingOffset[n4][1], s4, l3 + n4);
          }
        }
        function jf(t2, e2, r2, n3, i2, s4) {
          return Er(Er(t2, r2, s4), Er(e2, n3, s4), i2);
        }
        function Of(t2, e2, r2) {
          const n3 = r2.dim, i2 = M(t2 * n3 - 0.5, 0, n3 - 1), s4 = M(e2 * n3 - 0.5, 0, n3 - 1), a2 = Math.floor(i2), o2 = Math.floor(s4), l3 = Math.min(a2 + 1, n3 - 1), u3 = Math.min(o2 + 1, n3 - 1);
          return jf(r2.get(a2, o2), r2.get(l3, o2), r2.get(a2, u3), r2.get(l3, u3), i2 - a2, s4 - o2);
        }
        const qf = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
        function Nf(t2, e2, r2) {
          return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
        }
        function Gf(t2, e2, r2) {
          return 256 * t2 + e2 + r2 / 256 - 32768;
        }
        class Zf {
          get tree() {
            return this._tree || this._buildQuadTree(), this._tree;
          }
          constructor(t2, e2, r2, n3 = false, i2 = false) {
            if (this.uid = t2, e2.height !== e2.width)
              throw new RangeError("DEM tiles must be square");
            if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
              return N(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = e2.height;
            const s4 = this.dim = e2.height - 2, a2 = new Uint32Array(e2.data.buffer);
            if (this.pixels = new Uint8Array(e2.data.buffer), this.encoding = r2 || "mapbox", this.borderReady = n3, !n3) {
              for (let t3 = 0; t3 < s4; t3++)
                a2[this._idx(-1, t3)] = a2[this._idx(0, t3)], a2[this._idx(s4, t3)] = a2[this._idx(s4 - 1, t3)], a2[this._idx(t3, -1)] = a2[this._idx(t3, 0)], a2[this._idx(t3, s4)] = a2[this._idx(t3, s4 - 1)];
              a2[this._idx(-1, -1)] = a2[this._idx(0, 0)], a2[this._idx(s4, -1)] = a2[this._idx(s4 - 1, 0)], a2[this._idx(-1, s4)] = a2[this._idx(0, s4 - 1)], a2[this._idx(s4, s4)] = a2[this._idx(s4 - 1, s4 - 1)], i2 && this._buildQuadTree();
            }
          }
          _buildQuadTree() {
            this._tree = new $f(this);
          }
          get(t2, e2, r2 = false) {
            r2 && (t2 = M(t2, -1, this.dim), e2 = M(e2, -1, this.dim));
            const n3 = 4 * this._idx(t2, e2);
            return ("terrarium" === this.encoding ? Gf : Nf)(this.pixels[n3], this.pixels[n3 + 1], this.pixels[n3 + 2]);
          }
          static getUnpackVector(t2) {
            return qf[t2];
          }
          get unpackVector() {
            return qf[this.encoding];
          }
          _idx(t2, e2) {
            if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e2 + 1) * this.stride + (t2 + 1);
          }
          static pack(t2, e2) {
            const r2 = [0, 0, 0, 0], n3 = Zf.getUnpackVector(e2);
            let i2 = Math.floor((t2 + n3[3]) / n3[2]);
            return r2[2] = i2 % 256, i2 = Math.floor(i2 / 256), r2[1] = i2 % 256, i2 = Math.floor(i2 / 256), r2[0] = i2, r2;
          }
          getPixels() {
            return new Uu({ width: this.stride, height: this.stride }, this.pixels);
          }
          backfillBorder(t2, e2, r2) {
            if (this.dim !== t2.dim)
              throw new Error("dem dimension mismatch");
            let n3 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s4 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n3 = i2 - 1;
                break;
              case 1:
                i2 = n3 + 1;
            }
            switch (r2) {
              case -1:
                s4 = a2 - 1;
                break;
              case 1:
                a2 = s4 + 1;
            }
            const o2 = -e2 * this.dim, l3 = -r2 * this.dim;
            for (let e3 = s4; e3 < a2; e3++)
              for (let r3 = n3; r3 < i2; r3++) {
                const n4 = 4 * this._idx(r3, e3), i3 = 4 * this._idx(r3 + o2, e3 + l3);
                this.pixels[n4 + 0] = t2.pixels[i3 + 0], this.pixels[n4 + 1] = t2.pixels[i3 + 1], this.pixels[n4 + 2] = t2.pixels[i3 + 2], this.pixels[n4 + 3] = t2.pixels[i3 + 3];
              }
          }
          onDeserialize() {
            this._tree && (this._tree.dem = this);
          }
        }
        Ji(Zf, "DEMData"), Ji($f, "DemMinMaxQuadTree", { omit: ["dem"] });
        class Kf {
          constructor(t2, e2) {
            this.max = t2, this.onRemove = e2, this.reset();
          }
          reset() {
            for (const t2 in this.data)
              for (const e2 of this.data[t2])
                e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
            return this.data = {}, this.order = [], this;
          }
          add(t2, e2, r2) {
            const n3 = t2.wrapped().key;
            void 0 === this.data[n3] && (this.data[n3] = []);
            const i2 = { value: e2, timeout: void 0 };
            if (void 0 !== r2 && (i2.timeout = setTimeout(() => {
              this.remove(t2, i2);
            }, r2)), this.data[n3].push(i2), this.order.push(n3), this.order.length > this.max) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          has(t2) {
            return t2.wrapped().key in this.data;
          }
          getAndRemove(t2) {
            return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
          }
          _getAndRemoveByKey(t2) {
            const e2 = this.data[t2].shift();
            return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
          }
          getByKey(t2) {
            const e2 = this.data[t2];
            return e2 ? e2[0].value : null;
          }
          get(t2) {
            return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
          }
          remove(t2, e2) {
            if (!this.has(t2))
              return this;
            const r2 = t2.wrapped().key, n3 = void 0 === e2 ? 0 : this.data[r2].indexOf(e2), i2 = this.data[r2][n3];
            return this.data[r2].splice(n3, 1), i2.timeout && clearTimeout(i2.timeout), 0 === this.data[r2].length && delete this.data[r2], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r2), 1), this;
          }
          setMaxSize(t2) {
            for (this.max = t2; this.order.length > this.max; ) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          filter(t2) {
            const e2 = [];
            for (const r2 in this.data)
              for (const n3 of this.data[r2])
                t2(n3.value) || e2.push(n3);
            for (const t3 of e2)
              this.remove(t3.value.tileID, t3);
          }
        }
        class Xf {
          constructor(t2, e2, r2) {
            this.func = t2, this.mask = e2, this.range = r2;
          }
        }
        Xf.ReadOnly = false, Xf.ReadWrite = true, Xf.disabled = new Xf(519, Xf.ReadOnly, [0, 1]);
        const Jf = 7680;
        class Hf {
          constructor(t2, e2, r2, n3, i2, s4) {
            this.test = t2, this.ref = e2, this.mask = r2, this.fail = n3, this.depthFail = i2, this.pass = s4;
          }
        }
        Hf.disabled = new Hf({ func: 519, mask: 0 }, 0, 0, Jf, Jf, Jf);
        class Yf {
          constructor(t2, e2, r2) {
            this.blendFunction = t2, this.blendColor = e2, this.mask = r2;
          }
        }
        Yf.Replace = [1, 0], Yf.disabled = new Yf(Yf.Replace, Ee.transparent, [false, false, false, false]), Yf.unblended = new Yf(Yf.Replace, Ee.transparent, [true, true, true, true]), Yf.alphaBlended = new Yf([1, 771], Ee.transparent, [true, true, true, true]);
        const Wf = 1029, Qf = 2305;
        class ty {
          constructor(t2, e2, r2) {
            this.enable = t2, this.mode = e2, this.frontFace = r2;
          }
        }
        ty.disabled = new ty(false, Wf, Qf), ty.backCCW = new ty(true, Wf, Qf), ty.backCW = new ty(true, Wf, 2304), ty.frontCW = new ty(true, 1028, 2304), ty.frontCCW = new ty(true, 1028, Qf);
        class ey extends Qt {
          constructor(t2, e2, r2) {
            super(), this.id = t2, this._onlySymbols = r2, e2.on("data", (t3) => {
              "source" === t3.dataType && "metadata" === t3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t3.dataType && "content" === t3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
            }), e2.on("error", () => {
              this._sourceErrored = true;
            }), this._source = e2, this._tiles = {}, this._cache = new Kf(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e2.minTileCacheSize, this._maxTileCacheSize = e2.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Df(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
          }
          onAdd(t2) {
            this.map = t2, this._minTileCacheSize = void 0 === this._minTileCacheSize && t2 ? t2._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t2 ? t2._maxTileCacheSize : this._maxTileCacheSize;
          }
          loaded() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            for (const t2 in this._tiles) {
              const e2 = this._tiles[t2];
              if ("loaded" !== e2.state && "errored" !== e2.state)
                return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused)
              return;
            const t2 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(t2, e2) {
            return t2.isSymbolTile = this._onlySymbols, this._source.loadTile(t2, e2);
          }
          _unloadTile(t2) {
            if (this._source.unloadTile)
              return this._source.unloadTile(t2, () => {
              });
          }
          _abortTile(t2) {
            if (this._source.abortTile)
              return this._source.abortTile(t2, () => {
              });
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t2) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e2 in this._tiles) {
              const r2 = this._tiles[e2];
              r2.upload(t2), r2.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return E(this._tiles).map((t2) => t2.tileID).sort(ry).map((t2) => t2.key);
          }
          getRenderableIds(t2) {
            const e2 = [];
            for (const r2 in this._tiles)
              this._isIdRenderable(+r2, t2) && e2.push(this._tiles[r2]);
            return t2 ? e2.sort((t3, e3) => {
              const r2 = t3.tileID, n3 = e3.tileID, i2 = new x(r2.canonical.x, r2.canonical.y)._rotate(this.transform.angle), s4 = new x(n3.canonical.x, n3.canonical.y)._rotate(this.transform.angle);
              return r2.overscaledZ - n3.overscaledZ || s4.y - i2.y || s4.x - i2.x;
            }).map((t3) => t3.tileID.key) : e2.map((t3) => t3.tileID).sort(ry).map((t3) => t3.key);
          }
          hasRenderableParent(t2) {
            const e2 = this.findLoadedParent(t2, 0);
            return !!e2 && this._isIdRenderable(e2.tileID.key);
          }
          _isIdRenderable(t2, e2) {
            return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
          }
          reload() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t2 in this._tiles)
                "errored" !== this._tiles[t2].state && this._reloadTile(+t2, "reloading");
            }
          }
          _reloadTile(t2, e2) {
            const r2 = this._tiles[t2];
            r2 && ("loading" !== r2.state && (r2.state = e2), this._loadTile(r2, this._tileLoaded.bind(this, r2, t2, e2)));
          }
          _tileLoaded(t2, e2, r2, n3) {
            if (n3)
              if (t2.state = "errored", 404 !== n3.status)
                this._source.fire(new Wt(n3, { tile: t2 }));
              else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                const t3 = this.map.painter.terrain;
                this.update(this.transform, t3.getScaledDemTileSize(), true), t3.resetTileLookupCache(this.id);
              } else
                this.update(this.transform);
            else
              t2.timeAdded = Xt.now(), "expired" === r2 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(e2, t2), "raster-dem" === this._source.type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._source.fire(new Yt("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id }));
          }
          _backfillDEM(t2) {
            const e2 = this.getRenderableIds();
            for (let n3 = 0; n3 < e2.length; n3++) {
              const i2 = e2[n3];
              if (t2.neighboringTiles && t2.neighboringTiles[i2]) {
                const e3 = this.getTileByID(i2);
                r2(t2, e3), r2(e3, t2);
              }
            }
            function r2(t3, e3) {
              if (!t3.dem || t3.dem.borderReady)
                return;
              t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true;
              let r3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
              const n3 = e3.tileID.canonical.y - t3.tileID.canonical.y, i2 = Math.pow(2, t3.tileID.canonical.z), s4 = e3.tileID.key;
              0 === r3 && 0 === n3 || Math.abs(n3) > 1 || (Math.abs(r3) > 1 && (1 === Math.abs(r3 + i2) ? r3 += i2 : 1 === Math.abs(r3 - i2) && (r3 -= i2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, r3, n3), t3.neighboringTiles && t3.neighboringTiles[s4] && (t3.neighboringTiles[s4].backfilled = true)));
            }
          }
          getTile(t2) {
            return this.getTileByID(t2.key);
          }
          getTileByID(t2) {
            return this._tiles[t2];
          }
          _retainLoadedChildren(t2, e2, r2, n3) {
            for (const i2 in this._tiles) {
              let s4 = this._tiles[i2];
              if (n3[i2] || !s4.hasData() || s4.tileID.overscaledZ <= e2 || s4.tileID.overscaledZ > r2)
                continue;
              let a2 = s4.tileID;
              for (; s4 && s4.tileID.overscaledZ > e2 + 1; ) {
                const t3 = s4.tileID.scaledTo(s4.tileID.overscaledZ - 1);
                s4 = this._tiles[t3.key], s4 && s4.hasData() && (a2 = t3);
              }
              let o2 = a2;
              for (; o2.overscaledZ > e2; )
                if (o2 = o2.scaledTo(o2.overscaledZ - 1), t2[o2.key]) {
                  n3[a2.key] = a2;
                  break;
                }
            }
          }
          findLoadedParent(t2, e2) {
            if (t2.key in this._loadedParentTiles) {
              const r2 = this._loadedParentTiles[t2.key];
              return r2 && r2.tileID.overscaledZ >= e2 ? r2 : null;
            }
            for (let r2 = t2.overscaledZ - 1; r2 >= e2; r2--) {
              const e3 = t2.scaledTo(r2), n3 = this._getLoadedTile(e3);
              if (n3)
                return n3;
            }
          }
          _getLoadedTile(t2) {
            const e2 = this._tiles[t2.key];
            return e2 && e2.hasData() ? e2 : this._cache.getByKey(this._source.reparseOverscaled ? t2.wrapped().key : t2.canonical.key);
          }
          updateCacheSize(t2, e2) {
            e2 = e2 || this._source.tileSize;
            const r2 = Math.ceil(t2.width / e2) + 1, n3 = Math.ceil(t2.height / e2) + 1, i2 = Math.floor(r2 * n3 * 5), s4 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i2) : i2, a2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s4) : s4;
            this._cache.setMaxSize(a2);
          }
          handleWrapJump(t2) {
            const e2 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
            if (this._prevLng = t2, e2) {
              const t3 = {};
              for (const r2 in this._tiles) {
                const n3 = this._tiles[r2];
                n3.tileID = n3.tileID.unwrapTo(n3.tileID.wrap + e2), t3[n3.tileID.key] = n3;
              }
              this._tiles = t3;
              for (const t4 in this._timers)
                clearTimeout(this._timers[t4]), delete this._timers[t4];
              for (const t4 in this._tiles)
                this._setTileReloadTimer(+t4, this._tiles[t4]);
            }
          }
          update(t2, e2, r2) {
            if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
              return;
            if (this.usedForTerrain && !r2)
              return;
            let n3;
            this.updateCacheSize(t2, e2), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n3 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new fh(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (n3 = t2.coveringTiles({ tileSize: e2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n3 = n3.filter((t3) => this._source.hasTile(t3)))) : n3 = [];
            const i2 = this._updateRetainedTiles(n3);
            if (ny(this._source.type) && 0 !== n3.length) {
              const t3 = {}, e3 = {}, r3 = Object.keys(i2);
              for (const n4 of r3) {
                const r4 = i2[n4], s6 = this._tiles[n4];
                if (!s6 || s6.fadeEndTime && s6.fadeEndTime <= Xt.now())
                  continue;
                const a2 = this.findLoadedParent(r4, Math.max(r4.overscaledZ - ey.maxOverzooming, this._source.minzoom));
                a2 && (this._addTile(a2.tileID), t3[a2.tileID.key] = a2.tileID), e3[n4] = r4;
              }
              const s5 = n3[n3.length - 1].overscaledZ;
              for (const t4 in this._tiles) {
                const r4 = this._tiles[t4];
                if (i2[t4] || !r4.hasData())
                  continue;
                let n4 = r4.tileID;
                for (; n4.overscaledZ > s5; ) {
                  n4 = n4.scaledTo(n4.overscaledZ - 1);
                  const s6 = this._tiles[n4.key];
                  if (s6 && s6.hasData() && e3[n4.key]) {
                    i2[t4] = r4.tileID;
                    break;
                  }
                }
              }
              for (const e4 in t3)
                i2[e4] || (this._coveredTiles[e4] = true, i2[e4] = t3[e4]);
            }
            for (const t3 in i2)
              this._tiles[t3].clearFadeHold();
            const s4 = function(t3, e3) {
              const r3 = [];
              for (const n4 in t3)
                n4 in e3 || r3.push(n4);
              return r3;
            }(this._tiles, i2);
            for (const t3 of s4) {
              const e3 = this._tiles[t3];
              e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(+t3);
            }
            this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
          }
          releaseSymbolFadeTiles() {
            for (const t2 in this._tiles)
              this._tiles[t2].holdingForFade() && this._removeTile(+t2);
          }
          _updateRetainedTiles(t2) {
            const e2 = {};
            if (0 === t2.length)
              return e2;
            const r2 = {}, n3 = t2.reduce((t3, e3) => Math.min(t3, e3.overscaledZ), 1 / 0), i2 = t2[0].overscaledZ, s4 = Math.max(i2 - ey.maxOverzooming, this._source.minzoom), a2 = Math.max(i2 + ey.maxUnderzooming, this._source.minzoom), o2 = {};
            for (const r3 of t2) {
              const t3 = this._addTile(r3);
              e2[r3.key] = r3, t3.hasData() || n3 < this._source.maxzoom && (o2[r3.key] = r3);
            }
            this._retainLoadedChildren(o2, n3, a2, e2);
            for (const n4 of t2) {
              let t3 = this._tiles[n4.key];
              if (t3.hasData())
                continue;
              if (n4.canonical.z >= this._source.maxzoom) {
                const t4 = n4.children(this._source.maxzoom)[0], r3 = this.getTile(t4);
                if (r3 && r3.hasData()) {
                  e2[t4.key] = t4;
                  continue;
                }
              } else {
                const t4 = n4.children(this._source.maxzoom);
                if (e2[t4[0].key] && e2[t4[1].key] && e2[t4[2].key] && e2[t4[3].key])
                  continue;
              }
              let i3 = t3.wasRequested();
              for (let a3 = n4.overscaledZ - 1; a3 >= s4; --a3) {
                const s5 = n4.scaledTo(a3);
                if (r2[s5.key])
                  break;
                if (r2[s5.key] = true, t3 = this.getTile(s5), !t3 && i3 && (t3 = this._addTile(s5)), t3 && (e2[s5.key] = s5, i3 = t3.wasRequested(), t3.hasData()))
                  break;
              }
            }
            return e2;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t2 in this._tiles) {
              const e2 = [];
              let r2, n3 = this._tiles[t2].tileID;
              for (; n3.overscaledZ > 0; ) {
                if (n3.key in this._loadedParentTiles) {
                  r2 = this._loadedParentTiles[n3.key];
                  break;
                }
                e2.push(n3.key);
                const t3 = n3.scaledTo(n3.overscaledZ - 1);
                if (r2 = this._getLoadedTile(t3), r2)
                  break;
                n3 = t3;
              }
              for (const t3 of e2)
                this._loadedParentTiles[t3] = r2;
            }
          }
          _addTile(t2) {
            let e2 = this._tiles[t2.key];
            if (e2)
              return e2;
            e2 = this._cache.getAndRemove(t2), e2 && (this._setTileReloadTimer(t2.key, e2), e2.tileID = t2, this._state.initializeTileState(e2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, e2)));
            const r2 = Boolean(e2);
            if (!r2) {
              const r3 = this.map ? this.map.painter : null;
              e2 = new Pf(t2, this._source.tileSize * t2.overscaleFactor(), this.transform.tileZoom, r3, this._isRaster), this._loadTile(e2, this._tileLoaded.bind(this, e2, t2.key, e2.state));
            }
            return e2 ? (e2.uses++, this._tiles[t2.key] = e2, r2 || this._source.fire(new Yt("dataloading", { tile: e2, coord: e2.tileID, dataType: "source" })), e2) : null;
          }
          _setTileReloadTimer(t2, e2) {
            t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
            const r2 = e2.getExpiryTimeout();
            r2 && (this._timers[t2] = setTimeout(() => {
              this._reloadTile(t2, "expired"), delete this._timers[t2];
            }, r2));
          }
          _removeTile(t2) {
            const e2 = this._tiles[t2];
            e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && "reloading" !== e2.state ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t2 in this._tiles)
              this._removeTile(+t2);
            this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
          }
          tilesIn(t2, e2, r2) {
            const n3 = [], i2 = this.transform;
            if (!i2)
              return n3;
            const s4 = "globe" === i2.projection.name, a2 = Nl(i2.center.lng);
            for (const o2 in this._tiles) {
              const l3 = this._tiles[o2];
              if (r2 && l3.clearQueryDebugViz(), l3.holdingForFade())
                continue;
              let u3;
              if (s4) {
                const t3 = l3.tileID.canonical;
                if (0 === t3.z) {
                  const e3 = [Math.abs(M(a2, ...iy(t3, -1)) - a2), Math.abs(M(a2, ...iy(t3, 1)) - a2)];
                  u3 = [0, 2 * e3.indexOf(Math.min(...e3)) - 1];
                } else {
                  const e3 = [Math.abs(M(a2, ...iy(t3, -1)) - a2), Math.abs(M(a2, ...iy(t3, 0)) - a2), Math.abs(M(a2, ...iy(t3, 1)) - a2)];
                  u3 = [e3.indexOf(Math.min(...e3)) - 1];
                }
              } else
                u3 = [0];
              for (const r3 of u3) {
                const s5 = t2.containsTile(l3, i2, e2, r3);
                s5 && n3.push(s5);
              }
            }
            return n3;
          }
          getVisibleCoordinates(t2) {
            const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
            for (const t3 of e2)
              t3.projMatrix = this.transform.calculateProjMatrix(t3.toUnwrapped());
            return e2;
          }
          hasTransition() {
            if (this._source.hasTransition())
              return true;
            if (ny(this._source.type))
              for (const t2 in this._tiles) {
                const e2 = this._tiles[t2];
                if (void 0 !== e2.fadeEndTime && e2.fadeEndTime >= Xt.now())
                  return true;
              }
            return false;
          }
          setFeatureState(t2, e2, r2) {
            this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, r2);
          }
          removeFeatureState(t2, e2, r2) {
            this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, r2);
          }
          getFeatureState(t2, e2) {
            return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
          }
          setDependencies(t2, e2, r2) {
            const n3 = this._tiles[t2];
            n3 && n3.setDependencies(e2, r2);
          }
          reloadTilesForDependencies(t2, e2) {
            for (const r2 in this._tiles)
              this._tiles[r2].hasDependency(t2, e2) && this._reloadTile(+r2, "reloading");
            this._cache.filter((r2) => !r2.hasDependency(t2, e2));
          }
          _preloadTiles(t2, e2) {
            if (!this._sourceLoaded) {
              const r3 = () => {
                this._sourceLoaded && (this._source.off("data", r3), this._preloadTiles(t2, e2));
              };
              return void this._source.on("data", r3);
            }
            const r2 = /* @__PURE__ */ new Map(), n3 = Array.isArray(t2) ? t2 : [t2], i2 = this.map.painter.terrain, s4 = this.usedForTerrain && i2 ? i2.getScaledDemTileSize() : this._source.tileSize;
            for (const t3 of n3) {
              const e3 = t3.coveringTiles({ tileSize: s4, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
              for (const t4 of e3)
                r2.set(t4.key, t4);
              this.usedForTerrain && t3.updateElevation(false);
            }
            B(Array.from(r2.values()), (t3, e3) => {
              const r3 = new Pf(t3, this._source.tileSize * t3.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
              this._loadTile(r3, (t4) => {
                "raster-dem" === this._source.type && r3.dem && this._backfillDEM(r3), e3(t4, r3);
              });
            }, e2);
          }
        }
        function ry(t2, e2) {
          const r2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), n3 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t2.overscaledZ - e2.overscaledZ || n3 - r2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
        }
        function ny(t2) {
          return "raster" === t2 || "image" === t2 || "video" === t2 || "custom" === t2;
        }
        function iy(t2, e2) {
          const r2 = 1 << t2.z;
          return [t2.x / r2 + e2, (t2.x + 1) / r2 + e2];
        }
        ey.maxOverzooming = 10, ey.maxUnderzooming = 3;
        class sy {
          constructor(t2, e2, r2) {
            this._demTile = t2, this._dem = this._demTile.dem, this._scale = e2, this._offset = r2;
          }
          static create(t2, e2, r2) {
            const n3 = r2 || t2.findDEMTileFor(e2);
            if (!n3 || !n3.dem)
              return;
            const i2 = n3.dem, s4 = n3.tileID, a2 = 1 << e2.canonical.z - s4.canonical.z;
            return new sy(n3, n3.tileSize / ao / a2, [(e2.canonical.x / a2 - s4.canonical.x) * i2.dim, (e2.canonical.y / a2 - s4.canonical.y) * i2.dim]);
          }
          tileCoordToPixel(t2, e2) {
            const r2 = e2 * this._scale + this._offset[1], n3 = Math.floor(t2 * this._scale + this._offset[0]), i2 = Math.floor(r2);
            return new x(n3, i2);
          }
          getElevationAt(t2, e2, r2, n3) {
            const i2 = t2 * this._scale + this._offset[0], s4 = e2 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s4), l3 = this._dem;
            return n3 = !!n3, r2 ? Er(Er(l3.get(a2, o2, n3), l3.get(a2, o2 + 1, n3), s4 - o2), Er(l3.get(a2 + 1, o2, n3), l3.get(a2 + 1, o2 + 1, n3), s4 - o2), i2 - a2) : l3.get(a2, o2, n3);
          }
          getElevationAtPixel(t2, e2, r2) {
            return this._dem.get(t2, e2, !!r2);
          }
          getMeterToDEM(t2) {
            return (1 << this._demTile.tileID.canonical.z) * Zl(1, t2) * this._dem.stride;
          }
        }
        class ay {
          constructor(t2, e2) {
            this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new Ki(ao, 16, 0), this.featureIndexArray = new ba(), this.promoteId = e2;
          }
          insert(t2, e2, r2, n3, i2, s4 = 0) {
            const a2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r2, n3, i2, s4);
            const o2 = this.grid;
            for (let t3 = 0; t3 < e2.length; t3++) {
              const r3 = e2[t3], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t4 = 0; t4 < r3.length; t4++) {
                const e3 = r3[t4];
                n4[0] = Math.min(n4[0], e3.x), n4[1] = Math.min(n4[1], e3.y), n4[2] = Math.max(n4[2], e3.x), n4[3] = Math.max(n4[3], e3.y);
              }
              n4[0] < ao && n4[1] < ao && n4[2] >= 0 && n4[3] >= 0 && o2.insert(a2, n4[0], n4[1], n4[2], n4[3]);
            }
          }
          loadVTLayers() {
            if (!this.vtLayers) {
              this.vtLayers = new Zc(new mp(this.rawTileData)).layers, this.sourceLayerCoder = new wf(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
              for (const t2 in this.vtLayers)
                this.vtFeatures[t2] = [];
            }
            return this.vtLayers;
          }
          query(t2, e2, r2, n3) {
            this.loadVTLayers();
            const i2 = t2.params || {}, s4 = hi(i2.filter), a2 = t2.tileResult, o2 = t2.transform, l3 = a2.bufferedTilespaceBounds, u3 = this.grid.query(l3.min.x, l3.min.y, l3.max.x, l3.max.y, (t3, e3, r3, n4) => wu(a2.bufferedTilespaceGeometry, t3, e3, r3, n4));
            u3.sort(ly);
            let c4 = null;
            o2.elevation && u3.length > 0 && (c4 = sy.create(o2.elevation, this.tileID));
            const h3 = {};
            let p3;
            for (let o3 = 0; o3 < u3.length; o3++) {
              const l4 = u3[o3];
              if (l4 === p3)
                continue;
              p3 = l4;
              const d3 = this.featureIndexArray.get(l4);
              let f2 = null;
              this.loadMatchingFeature(h3, d3, s4, i2.layers, i2.availableImages, e2, r2, n3, (e3, r3, n4, i3 = 0) => (f2 || (f2 = au(e3, this.tileID.canonical, t2.tileTransform)), r3.queryIntersectsFeature(a2, e3, n4, f2, this.z, t2.transform, t2.pixelPosMatrix, c4, i3)));
            }
            return h3;
          }
          loadMatchingFeature(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
            const { featureIndex: u3, bucketIndex: c4, sourceLayerIndex: h3, layoutVertexArrayOffset: p3 } = e2, d3 = this.bucketLayerIDs[c4];
            if (n3 && !function(t3, e3) {
              for (let r3 = 0; r3 < t3.length; r3++)
                if (e3.indexOf(t3[r3]) >= 0)
                  return true;
              return false;
            }(n3, d3))
              return;
            const f2 = this.sourceLayerCoder.decode(h3), y2 = this.vtLayers[f2].feature(u3);
            if (r2.needGeometry) {
              const t3 = ou(y2, true);
              if (!r2.filter(new ws(this.tileID.overscaledZ), t3, this.tileID.canonical))
                return;
            } else if (!r2.filter(new ws(this.tileID.overscaledZ), y2))
              return;
            const m3 = this.getId(y2, f2);
            for (let e3 = 0; e3 < d3.length; e3++) {
              const r3 = d3[e3];
              if (n3 && n3.indexOf(r3) < 0)
                continue;
              const c5 = s4[r3];
              if (!c5)
                continue;
              let h4 = {};
              void 0 !== m3 && o2 && (h4 = o2.getState(c5.sourceLayer || "_geojsonTileLayer", m3));
              const f3 = C2({}, a2[r3]);
              f3.paint = oy(f3.paint, c5.paint, y2, h4, i2), f3.layout = oy(f3.layout, c5.layout, y2, h4, i2);
              const g2 = !l3 || l3(y2, c5, h4, p3);
              if (!g2)
                continue;
              const x2 = new Af(y2, this.z, this.x, this.y, m3);
              x2.layer = f3;
              let v4 = t2[r3];
              void 0 === v4 && (v4 = t2[r3] = []), v4.push({ featureIndex: u3, feature: x2, intersectionZ: g2 });
            }
          }
          lookupSymbolFeatures(t2, e2, r2, n3, i2, s4, a2, o2) {
            const l3 = {};
            this.loadVTLayers();
            const u3 = hi(i2);
            for (const i3 of t2)
              this.loadMatchingFeature(l3, { bucketIndex: r2, sourceLayerIndex: n3, featureIndex: i3, layoutVertexArrayOffset: 0 }, u3, s4, a2, o2, e2);
            return l3;
          }
          loadFeature(t2) {
            const { featureIndex: e2, sourceLayerIndex: r2 } = t2;
            this.loadVTLayers();
            const n3 = this.sourceLayerCoder.decode(r2), i2 = this.vtFeatures[n3];
            if (i2[e2])
              return i2[e2];
            const s4 = this.vtLayers[n3].feature(e2);
            return i2[e2] = s4, s4;
          }
          hasLayer(t2) {
            for (const e2 of this.bucketLayerIDs)
              for (const r2 of e2)
                if (t2 === r2)
                  return true;
            return false;
          }
          getId(t2, e2) {
            let r2 = t2.id;
            if (this.promoteId) {
              const n3 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2];
              null != n3 && (r2 = t2.properties[n3]), "boolean" == typeof r2 && (r2 = Number(r2));
            }
            return r2;
          }
        }
        function oy(t2, e2, r2, n3, i2) {
          return $(t2, (t3, s4) => {
            const a2 = e2 instanceof zs ? e2.get(s4) : null;
            return a2 && a2.evaluate ? a2.evaluate(r2, n3, i2) : a2;
          });
        }
        function ly(t2, e2) {
          return e2 - t2;
        }
        Ji(ay, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
        class uy {
          constructor(t2, e2) {
            this.width = t2, this.height = e2, this.nextRow = 0, this.image = new Ru({ width: t2, height: e2 }), this.positions = {}, this.uploaded = false;
          }
          getDash(t2, e2) {
            const r2 = this.getKey(t2, e2);
            return this.positions[r2];
          }
          trim() {
            const t2 = this.width, e2 = this.height = L(this.nextRow);
            this.image.resize({ width: t2, height: e2 });
          }
          getKey(t2, e2) {
            return t2.join(",") + e2;
          }
          getDashRanges(t2, e2, r2) {
            const n3 = [];
            let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r2 : 0, s4 = t2[0] * r2, a2 = true;
            n3.push({ left: i2, right: s4, isDash: a2, zeroLength: 0 === t2[0] });
            let o2 = t2[0];
            for (let e3 = 1; e3 < t2.length; e3++) {
              a2 = !a2;
              const l3 = t2[e3];
              i2 = o2 * r2, o2 += l3, s4 = o2 * r2, n3.push({ left: i2, right: s4, isDash: a2, zeroLength: 0 === l3 });
            }
            return n3;
          }
          addRoundDash(t2, e2, r2) {
            const n3 = e2 / 2;
            for (let e3 = -r2; e3 <= r2; e3++) {
              const i2 = this.width * (this.nextRow + r2 + e3);
              let s4 = 0, a2 = t2[s4];
              for (let o2 = 0; o2 < this.width; o2++) {
                o2 / a2.right > 1 && (a2 = t2[++s4]);
                const l3 = Math.abs(o2 - a2.left), u3 = Math.abs(o2 - a2.right), c4 = Math.min(l3, u3);
                let h3;
                const p3 = e3 / r2 * (n3 + 1);
                if (a2.isDash) {
                  const t3 = n3 - Math.abs(p3);
                  h3 = Math.sqrt(c4 * c4 + t3 * t3);
                } else
                  h3 = n3 - Math.sqrt(c4 * c4 + p3 * p3);
                this.image.data[i2 + o2] = Math.max(0, Math.min(255, h3 + 128));
              }
            }
          }
          addRegularDash(t2, e2) {
            for (let e3 = t2.length - 1; e3 >= 0; --e3) {
              const r3 = t2[e3], n4 = t2[e3 + 1];
              r3.zeroLength ? t2.splice(e3, 1) : n4 && n4.isDash === r3.isDash && (n4.left = r3.left, t2.splice(e3, 1));
            }
            const r2 = t2[0], n3 = t2[t2.length - 1];
            r2.isDash === n3.isDash && (r2.left = n3.left - this.width, n3.right = r2.right + this.width);
            const i2 = this.width * this.nextRow;
            let s4 = 0, a2 = t2[s4];
            for (let r3 = 0; r3 < this.width; r3++) {
              r3 / a2.right > 1 && (a2 = t2[++s4]);
              const n4 = Math.abs(r3 - a2.left), o2 = Math.abs(r3 - a2.right), l3 = Math.min(n4, o2);
              this.image.data[i2 + r3] = Math.max(0, Math.min(255, (a2.isDash ? l3 : -l3) + e2 + 128));
            }
          }
          addDash(t2, e2) {
            const r2 = this.getKey(t2, e2);
            if (this.positions[r2])
              return this.positions[r2];
            const n3 = "round" === e2, i2 = n3 ? 7 : 0, s4 = 2 * i2 + 1;
            if (this.nextRow + s4 > this.height)
              return N("LineAtlas out of space"), null;
            0 === t2.length && t2.push(1);
            let a2 = 0;
            for (let e3 = 0; e3 < t2.length; e3++)
              t2[e3] < 0 && (N("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), a2 += t2[e3];
            if (0 !== a2) {
              const r3 = this.width / a2, s5 = this.getDashRanges(t2, this.width, r3);
              n3 ? this.addRoundDash(s5, r3, i2) : this.addRegularDash(s5, "square" === e2 ? 0.5 * r3 : 0);
            }
            const o2 = this.nextRow + i2;
            this.nextRow += s4;
            const l3 = { tl: [o2, i2], br: [a2, 0] };
            return this.positions[r2] = l3, l3;
          }
        }
        Ji(uy, "LineAtlas");
        const cy = 1 * td;
        class hy {
          constructor(t2) {
            const e2 = {}, r2 = [];
            for (const n4 in t2) {
              const i3 = t2[n4], s5 = e2[n4] = {};
              for (const t3 in i3.glyphs) {
                const e3 = i3.glyphs[+t3];
                if (!e3 || 0 === e3.bitmap.width || 0 === e3.bitmap.height)
                  continue;
                const n5 = e3.metrics.localGlyph ? cy : 1, a2 = { x: 0, y: 0, w: e3.bitmap.width + 2 * n5, h: e3.bitmap.height + 2 * n5 };
                r2.push(a2), s5[t3] = a2;
              }
            }
            const { w: n3, h: i2 } = _p(r2), s4 = new Ru({ width: n3 || 1, height: i2 || 1 });
            for (const r3 in t2) {
              const n4 = t2[r3];
              for (const t3 in n4.glyphs) {
                const i3 = n4.glyphs[+t3];
                if (!i3 || 0 === i3.bitmap.width || 0 === i3.bitmap.height)
                  continue;
                const a2 = e2[r3][t3], o2 = i3.metrics.localGlyph ? cy : 1;
                Ru.copy(i3.bitmap, s4, { x: 0, y: 0 }, { x: a2.x + o2, y: a2.y + o2 }, i3.bitmap);
              }
            }
            this.image = s4, this.positions = e2;
          }
        }
        Ji(hy, "GlyphAtlas");
        class py {
          constructor(t2) {
            this.tileID = new fh(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.enableTerrain = !!t2.enableTerrain, this.isSymbolTile = t2.isSymbolTile, this.tileTransform = Bd(t2.tileID.canonical, t2.projection), this.projection = t2.projection;
          }
          parse(t2, e2, r2, n3, i2) {
            this.status = "parsing", this.data = t2, this.collisionBoxArray = new pa();
            const s4 = new wf(Object.keys(t2.layers).sort()), a2 = new ay(this.tileID, this.promoteId);
            a2.bucketLayerIDs = [];
            const o2 = {}, l3 = new uy(256, 256), u3 = { featureIndex: a2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l3, availableImages: r2 }, c4 = e2.familiesBySource[this.source];
            for (const e3 in c4) {
              const n4 = t2.layers[e3];
              if (!n4)
                continue;
              let i3 = false, l4 = false;
              for (const t3 of c4[e3])
                "symbol" === t3[0].type ? i3 = true : l4 = true;
              if (true === this.isSymbolTile && !i3)
                continue;
              if (false === this.isSymbolTile && !l4)
                continue;
              1 === n4.version && N(`Vector tile source "${this.source}" layer "${e3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const h4 = s4.encode(e3), p4 = [];
              for (let t3 = 0; t3 < n4.length; t3++) {
                const r3 = n4.feature(t3), i4 = a2.getId(r3, e3);
                p4.push({ feature: r3, id: i4, index: t3, sourceLayerIndex: h4 });
              }
              for (const t3 of c4[e3]) {
                const e4 = t3[0];
                void 0 !== this.isSymbolTile && "symbol" === e4.type !== this.isSymbolTile || e4.minzoom && this.zoom < Math.floor(e4.minzoom) || e4.maxzoom && this.zoom >= e4.maxzoom || "none" !== e4.visibility && (dy(t3, this.zoom, r2), (o2[e4.id] = e4.createBucket({ index: a2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h4, sourceID: this.source, enableTerrain: this.enableTerrain, projection: this.projection.spec, availableImages: r2 })).populate(p4, u3, this.tileID.canonical, this.tileTransform), a2.bucketLayerIDs.push(t3.map((t4) => t4.id)));
              }
            }
            let h3, p3, d3, f2;
            l3.trim();
            const y2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, m3 = () => {
              if (h3)
                return i2(h3);
              if (p3 && d3 && f2) {
                const t3 = new hy(p3), e3 = new kp(d3, f2);
                for (const n4 in o2) {
                  const i3 = o2[n4];
                  i3 instanceof of ? (dy(i3.layers, this.zoom, r2), vd(i3, p3, t3.positions, d3, e3.iconPositions, this.showCollisionBoxes, r2, this.tileID.canonical, this.tileZoom, this.projection)) : i3.hasPattern && (i3 instanceof Ih || i3 instanceof Mc || i3 instanceof th) && (dy(i3.layers, this.zoom, r2), i3.addFeatures(u3, this.tileID.canonical, e3.patternPositions, r2, this.tileTransform));
                }
                this.status = "done", i2(null, { buckets: E(o2).filter((t4) => !t4.isEmpty()), featureIndex: a2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, lineAtlas: l3, imageAtlas: e3, glyphMap: this.returnDependencies ? p3 : null, iconMap: this.returnDependencies ? d3 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
              }
            }, g2 = $(u3.glyphDependencies, (t3) => Object.keys(t3).map(Number));
            Object.keys(g2).length ? n3.send("getGlyphs", { uid: this.uid, stacks: g2 }, (t3, e3) => {
              h3 || (h3 = t3, p3 = e3, m3());
            }, void 0, false, y2) : p3 = {};
            const x2 = Object.keys(u3.iconDependencies);
            x2.length ? n3.send("getImages", { icons: x2, source: this.source, tileID: this.tileID, type: "icons" }, (t3, e3) => {
              h3 || (h3 = t3, d3 = e3, m3());
            }, void 0, false, y2) : d3 = {};
            const v4 = Object.keys(u3.patternDependencies);
            v4.length ? n3.send("getImages", { icons: v4, source: this.source, tileID: this.tileID, type: "patterns" }, (t3, e3) => {
              h3 || (h3 = t3, f2 = e3, m3());
            }, void 0, false, y2) : f2 = {}, m3();
          }
        }
        function dy(t2, e2, r2) {
          const n3 = new ws(e2);
          for (const e3 of t2)
            e3.recalculate(n3, r2);
        }
        class fy {
          constructor(t2) {
            this.entries = {}, this.scheduler = t2;
          }
          request(t2, e2, r2, n3) {
            const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
            if (i2.result) {
              const [t3, r3] = i2.result;
              return this.scheduler ? this.scheduler.add(() => {
                n3(t3, r3);
              }, e2) : n3(t3, r3), () => {
              };
            }
            return i2.callbacks.push(n3), i2.cancel || (i2.cancel = r2((r3, n4) => {
              i2.result = [r3, n4];
              for (const t3 of i2.callbacks)
                this.scheduler ? this.scheduler.add(() => {
                  t3(r3, n4);
                }, e2) : t3(r3, n4);
              setTimeout(() => delete this.entries[t2], 3e3);
            })), () => {
              i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n3), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
            };
          }
        }
        function yy(t2, e2, r2) {
          const n3 = JSON.stringify(t2.request);
          return t2.data && (this.deduped.entries[n3] = { result: [null, t2.data] }), this.deduped.request(n3, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
            const n4 = pt(t2.request, (t3, n5, i2, s4) => {
              t3 ? e3(t3) : n5 && e3(null, { vectorTile: r2 ? void 0 : new Zc(new mp(n5)), rawData: n5, cacheControl: i2, expires: s4 });
            });
            return () => {
              n4.cancel(), e3();
            };
          }, e2);
        }
        const my = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class gy {
          static from(t2) {
            if (!(t2 instanceof ArrayBuffer))
              throw new Error("Data must be an instance of ArrayBuffer.");
            const [e2, r2] = new Uint8Array(t2, 0, 2);
            if (219 !== e2)
              throw new Error("Data does not appear to be in a KDBush format.");
            const n3 = r2 >> 4;
            if (1 !== n3)
              throw new Error(`Got v${n3} data when expected v1.`);
            const i2 = my[15 & r2];
            if (!i2)
              throw new Error("Unrecognized array type.");
            const [s4] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
            return new gy(a2, s4, i2, t2);
          }
          constructor(t2, e2 = 64, r2 = Float64Array, n3) {
            if (isNaN(t2) || t2 < 0)
              throw new Error(`Unpexpected numItems value: ${t2}.`);
            this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
            const i2 = my.indexOf(this.ArrayType), s4 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
            if (i2 < 0)
              throw new Error(`Unexpected typed array class: ${r2}.`);
            n3 && n3 instanceof ArrayBuffer ? (this.data = n3, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s4 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
          }
          add(t2, e2) {
            const r2 = this._pos >> 1;
            return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
          }
          finish() {
            const t2 = this._pos >> 1;
            if (t2 !== this.numItems)
              throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
            return xy(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t2, e2, r2, n3) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i2, coords: s4, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l3 = [];
            for (; o2.length; ) {
              const u3 = o2.pop() || 0, c4 = o2.pop() || 0, h3 = o2.pop() || 0;
              if (c4 - h3 <= a2) {
                for (let a3 = h3; a3 <= c4; a3++) {
                  const o3 = s4[2 * a3], u4 = s4[2 * a3 + 1];
                  o3 >= t2 && o3 <= r2 && u4 >= e2 && u4 <= n3 && l3.push(i2[a3]);
                }
                continue;
              }
              const p3 = h3 + c4 >> 1, d3 = s4[2 * p3], f2 = s4[2 * p3 + 1];
              d3 >= t2 && d3 <= r2 && f2 >= e2 && f2 <= n3 && l3.push(i2[p3]), (0 === u3 ? t2 <= d3 : e2 <= f2) && (o2.push(h3), o2.push(p3 - 1), o2.push(1 - u3)), (0 === u3 ? r2 >= d3 : n3 >= f2) && (o2.push(p3 + 1), o2.push(c4), o2.push(1 - u3));
            }
            return l3;
          }
          within(t2, e2, r2) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n3, coords: i2, nodeSize: s4 } = this, a2 = [0, n3.length - 1, 0], o2 = [], l3 = r2 * r2;
            for (; a2.length; ) {
              const u3 = a2.pop() || 0, c4 = a2.pop() || 0, h3 = a2.pop() || 0;
              if (c4 - h3 <= s4) {
                for (let r3 = h3; r3 <= c4; r3++)
                  _y(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l3 && o2.push(n3[r3]);
                continue;
              }
              const p3 = h3 + c4 >> 1, d3 = i2[2 * p3], f2 = i2[2 * p3 + 1];
              _y(d3, f2, t2, e2) <= l3 && o2.push(n3[p3]), (0 === u3 ? t2 - r2 <= d3 : e2 - r2 <= f2) && (a2.push(h3), a2.push(p3 - 1), a2.push(1 - u3)), (0 === u3 ? t2 + r2 >= d3 : e2 + r2 >= f2) && (a2.push(p3 + 1), a2.push(c4), a2.push(1 - u3));
            }
            return o2;
          }
        }
        function xy(t2, e2, r2, n3, i2, s4) {
          if (i2 - n3 <= r2)
            return;
          const a2 = n3 + i2 >> 1;
          vy(t2, e2, a2, n3, i2, s4), xy(t2, e2, r2, n3, a2 - 1, 1 - s4), xy(t2, e2, r2, a2 + 1, i2, 1 - s4);
        }
        function vy(t2, e2, r2, n3, i2, s4) {
          for (; i2 > n3; ) {
            if (i2 - n3 > 600) {
              const a3 = i2 - n3 + 1, o3 = r2 - n3 + 1, l4 = Math.log(a3), u3 = 0.5 * Math.exp(2 * l4 / 3), c4 = 0.5 * Math.sqrt(l4 * u3 * (a3 - u3) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
              vy(t2, e2, r2, Math.max(n3, Math.floor(r2 - o3 * u3 / a3 + c4)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u3 / a3 + c4)), s4);
            }
            const a2 = e2[2 * r2 + s4];
            let o2 = n3, l3 = i2;
            for (by(t2, e2, n3, r2), e2[2 * i2 + s4] > a2 && by(t2, e2, n3, i2); o2 < l3; ) {
              for (by(t2, e2, o2, l3), o2++, l3--; e2[2 * o2 + s4] < a2; )
                o2++;
              for (; e2[2 * l3 + s4] > a2; )
                l3--;
            }
            e2[2 * n3 + s4] === a2 ? by(t2, e2, n3, l3) : (l3++, by(t2, e2, l3, i2)), l3 <= r2 && (n3 = l3 + 1), r2 <= l3 && (i2 = l3 - 1);
          }
        }
        function by(t2, e2, r2, n3) {
          wy(t2, r2, n3), wy(e2, 2 * r2, 2 * n3), wy(e2, 2 * r2 + 1, 2 * n3 + 1);
        }
        function wy(t2, e2, r2) {
          const n3 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n3;
        }
        function _y(t2, e2, r2, n3) {
          const i2 = t2 - r2, s4 = e2 - n3;
          return i2 * i2 + s4 * s4;
        }
        t.ARRAY_TYPE = uo, t.AUTH_ERR_MSG = xt, t.Aabb = il, t.Actor = class {
          constructor(t2, r2, n3) {
            this.target = t2, this.parent = r2, this.mapId = n3, this.callbacks = {}, this.cancelCallbacks = {}, R(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = K() ? t2 : e, this.scheduler = new bf();
          }
          send(t2, e2, r2, n3, i2 = false, s4) {
            const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r2 && (r2.metadata = s4, this.callbacks[a2] = r2);
            const o2 = H(this.globalScope) ? void 0 : [];
            return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r2, targetMapId: n3, mustQueue: i2, sourceMapId: this.mapId, data: Wi(e2, o2) }, o2), { cancel: () => {
              r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n3, sourceMapId: this.mapId });
            } };
          }
          receive(t2) {
            const e2 = t2.data, r2 = e2.id;
            if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
              if ("<cancel>" === e2.type) {
                const t3 = this.cancelCallbacks[r2];
                delete this.cancelCallbacks[r2], t3 && t3.cancel();
              } else if (e2.mustQueue || K()) {
                const t3 = this.callbacks[r2];
                this.cancelCallbacks[r2] = this.scheduler.add(() => this.processTask(r2, e2), t3 && t3.metadata || { type: "message" });
              } else
                this.processTask(r2, e2);
          }
          processTask(t2, e2) {
            if ("<response>" === e2.type) {
              const r2 = this.callbacks[t2];
              delete this.callbacks[t2], r2 && (e2.error ? r2(Qi(e2.error)) : r2(null, Qi(e2.data)));
            } else {
              const r2 = H(this.globalScope) ? void 0 : [], n3 = e2.hasCallback ? (e3, n4) => {
                delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? Wi(e3) : null, data: Wi(n4, r2) }, r2);
              } : (t3) => {
              }, i2 = Qi(e2.data);
              if (this.parent[e2.type])
                this.parent[e2.type](e2.sourceMapId, i2, n3);
              else if (this.parent.getWorkerSource) {
                const t3 = e2.type.split(".");
                this.parent.getWorkerSource(e2.sourceMapId, t3[0], i2.source)[t3[1]](i2, n3);
              } else
                n3(new Error(`Could not find function ${e2.type}`));
            }
          }
          remove() {
            this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }, t.CanonicalTileID = ph, t.Color = Ee, t.ColorMode = Yf, t.CullFaceMode = ty, t.DEMData = Zf, t.DataConstantProperty = Bs, t.DedupedRequest = fy, t.DepthMode = Xf, t.EXTENT = ao, t.Elevation = class {
          isDataAvailableAtPoint(t2) {
            const e2 = this._source();
            if (this.isUsingMockSource() || !e2 || t2.y < 0 || t2.y > 1)
              return false;
            const r2 = e2.getSource().maxzoom, n3 = 1 << r2, i2 = Math.floor(t2.x), s4 = Math.floor((t2.x - i2) * n3), a2 = Math.floor(t2.y * n3), o2 = this.findDEMTileFor(new fh(r2, i2, r2, s4, a2));
            return !(!o2 || !o2.dem);
          }
          getAtPointOrZero(t2, e2 = 0) {
            return this.getAtPoint(t2, e2) || 0;
          }
          getAtPoint(t2, e2, r2 = true) {
            if (this.isUsingMockSource())
              return null;
            null == e2 && (e2 = null);
            const n3 = this._source();
            if (!n3)
              return e2;
            if (t2.y < 0 || t2.y > 1)
              return e2;
            const i2 = n3.getSource().maxzoom, s4 = 1 << i2, a2 = Math.floor(t2.x), o2 = t2.x - a2, l3 = new fh(i2, a2, i2, Math.floor(o2 * s4), Math.floor(t2.y * s4)), u3 = this.findDEMTileFor(l3);
            if (!u3 || !u3.dem)
              return e2;
            const c4 = u3.dem, h3 = 1 << u3.tileID.canonical.z, p3 = (o2 * h3 - u3.tileID.canonical.x) * c4.dim, d3 = (t2.y * h3 - u3.tileID.canonical.y) * c4.dim, f2 = Math.floor(p3), y2 = Math.floor(d3);
            return (r2 ? this.exaggeration() : 1) * Er(Er(c4.get(f2, y2), c4.get(f2, y2 + 1), d3 - y2), Er(c4.get(f2 + 1, y2), c4.get(f2 + 1, y2 + 1), d3 - y2), p3 - f2);
          }
          getAtTileOffset(t2, e2, r2) {
            const n3 = 1 << t2.canonical.z;
            return this.getAtPointOrZero(new Wl(t2.wrap + (t2.canonical.x + e2 / ao) / n3, (t2.canonical.y + r2 / ao) / n3));
          }
          getAtTileOffsetFunc(t2, e2, r2, n3) {
            return (i2) => {
              const s4 = this.getAtTileOffset(t2, i2.x, i2.y), a2 = n3.upVector(t2.canonical, i2.x, i2.y);
              return Co(a2, a2, s4 * n3.upVectorScale(t2.canonical, e2, r2).metersToTile), a2;
            };
          }
          getForTilePoints(t2, e2, r2, n3) {
            if (this.isUsingMockSource())
              return false;
            const i2 = sy.create(this, t2, n3);
            return !!i2 && (e2.forEach((t3) => {
              t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r2);
            }), true);
          }
          getMinMaxForTile(t2) {
            if (this.isUsingMockSource())
              return null;
            const e2 = this.findDEMTileFor(t2);
            if (!e2 || !e2.dem)
              return null;
            const r2 = e2.dem.tree, n3 = e2.tileID, i2 = 1 << t2.canonical.z - n3.canonical.z;
            let s4 = t2.canonical.x / i2 - n3.canonical.x, a2 = t2.canonical.y / i2 - n3.canonical.y, o2 = 0;
            for (let e3 = 0; e3 < t2.canonical.z - n3.canonical.z && !r2.leaves[o2]; e3++) {
              s4 *= 2, a2 *= 2;
              const t3 = 2 * Math.floor(a2) + Math.floor(s4);
              o2 = r2.childOffsets[o2] + t3, s4 %= 1, a2 %= 1;
            }
            return { min: this.exaggeration() * r2.minimums[o2], max: this.exaggeration() * r2.maximums[o2] };
          }
          getMinElevationBelowMSL() {
            throw new Error("Pure virtual method called.");
          }
          raycast(t2, e2, r2) {
            throw new Error("Pure virtual method called.");
          }
          pointCoordinate(t2) {
            throw new Error("Pure virtual method called.");
          }
          _source() {
            throw new Error("Pure virtual method called.");
          }
          isUsingMockSource() {
            throw new Error("Pure virtual method called.");
          }
          exaggeration() {
            throw new Error("Pure virtual method called.");
          }
          findDEMTileFor(t2) {
            throw new Error("Pure virtual method called.");
          }
          get visibleDemTiles() {
            throw new Error("Getter must be implemented in subclass.");
          }
        }, t.ErrorEvent = Wt, t.EvaluationParameters = ws, t.Event = Yt, t.Evented = Qt, t.FillExtrusionBucket = th, t.Frustum = nl, t.FrustumCorners = rl, t.GLOBE_RADIUS = ol, t.GLOBE_SCALE_MATCH_LATITUDE = 45, t.GLOBE_ZOOM_THRESHOLD_MAX = al, t.GLOBE_ZOOM_THRESHOLD_MIN = sl, t.GlobeSharedBuffers = class {
          constructor(t2) {
            this._createGrid(t2), this._createPoles(t2);
          }
          destroy() {
            this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
            for (const t2 of this._poleSegments)
              t2.destroy();
            for (const t2 of this._gridSegments)
              t2.withSkirts.destroy(), t2.withoutSkirts.destroy();
            if (this._wireframeIndexBuffer) {
              this._wireframeIndexBuffer.destroy();
              for (const t2 of this._wireframeSegments)
                t2.destroy();
            }
          }
          _fillGridMeshWithLods(t2, e2) {
            const r2 = new $s(), n3 = new ra(), i2 = [], s4 = t2 + 1 + 2, a2 = e2[0] + 1, o2 = e2[0] + 1 + (1 + e2.length), l3 = (t3, e3, r3) => {
              let n4 = t3 === s4 - 1 ? t3 - 2 : 0 === t3 ? t3 : t3 - 1;
              return n4 += r3 ? 24575 : 0, [n4, e3];
            };
            for (let t3 = 0; t3 < s4; ++t3)
              r2.emplaceBack(...l3(t3, 0, true));
            for (let t3 = 0; t3 < a2; ++t3)
              for (let e3 = 0; e3 < s4; ++e3)
                r2.emplaceBack(...l3(e3, t3, (0 === e3 || e3 === s4 - 1) && true));
            for (let t3 = 0; t3 < e2.length; ++t3) {
              const n4 = e2[t3];
              for (let t4 = 0; t4 < s4; ++t4)
                r2.emplaceBack(...l3(t4, n4, true));
            }
            for (let t3 = 0; t3 < e2.length; ++t3) {
              const a3 = n3.length, l4 = e2[t3] + 1 + 2, u3 = new ra();
              for (let r3 = 0; r3 < l4 - 1; r3++) {
                const i3 = r3 === l4 - 2, a4 = i3 ? s4 * (o2 - e2.length + t3 - r3) : s4;
                for (let t4 = 0; t4 < s4 - 1; t4++) {
                  const e3 = r3 * s4 + t4;
                  0 === r3 || i3 || 0 === t4 || t4 === s4 - 2 ? (u3.emplaceBack(e3 + 1, e3, e3 + a4), u3.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1)) : (n3.emplaceBack(e3 + 1, e3, e3 + a4), n3.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1));
                }
              }
              const c4 = so.simpleSegment(0, a3, r2.length, n3.length - a3);
              for (let t4 = 0; t4 < u3.uint16.length; t4 += 3)
                n3.emplaceBack(u3.uint16[t4], u3.uint16[t4 + 1], u3.uint16[t4 + 2]);
              const h3 = so.simpleSegment(0, a3, r2.length, n3.length - a3);
              i2.push({ withoutSkirts: c4, withSkirts: h3 });
            }
            return { vertices: r2, indices: n3, segments: i2 };
          }
          _createGrid(t2) {
            const e2 = this._fillGridMeshWithLods(ul, cl);
            this._gridSegments = e2.segments, this._gridBuffer = t2.createVertexBuffer(e2.vertices, tl.members), this._gridIndexBuffer = t2.createIndexBuffer(e2.indices, true);
          }
          _createPoles(t2) {
            const e2 = new ra();
            for (let t3 = 0; t3 <= ul; t3++)
              e2.emplaceBack(0, t3 + 1, t3 + 2);
            this._poleIndexBuffer = t2.createIndexBuffer(e2, true);
            const r2 = new aa(), n3 = new aa();
            this._poleSegments = [];
            for (let t3 = 0, e3 = 0; t3 < sl; t3++) {
              const i2 = 360 / (1 << t3);
              r2.emplaceBack(0, -ol, 0, 0.5, 0), n3.emplaceBack(0, -ol, 0, 0.5, 1);
              for (let t4 = 0; t4 <= ul; t4++) {
                const e4 = t4 / ul, s4 = Er(0, i2, e4), [a2, o2, l3] = kl(Fl, Rl, s4, ol);
                r2.emplaceBack(a2, o2, l3, e4, 0), n3.emplaceBack(a2, o2, l3, e4, 1);
              }
              this._poleSegments.push(so.simpleSegment(e3, 0, 66, 64)), e3 += 66;
            }
            this._poleNorthVertexBuffer = t2.createVertexBuffer(r2, Wo, false), this._poleSouthVertexBuffer = t2.createVertexBuffer(n3, Wo, false);
          }
          getGridBuffers(t2, e2) {
            return [this._gridBuffer, this._gridIndexBuffer, e2 ? this._gridSegments[t2].withSkirts : this._gridSegments[t2].withoutSkirts];
          }
          getPoleBuffers(t2) {
            return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t2]];
          }
          getWirefameBuffers(t2, e2) {
            if (!this._wireframeSegments) {
              const e3 = new la(), r2 = ul, n3 = r2 + 1 + 2, i2 = 1;
              this._wireframeSegments = [];
              for (let t3 = 0, s4 = 0; t3 < cl.length; t3++) {
                const a2 = cl[t3];
                for (let t4 = i2; t4 < a2 + i2; t4++)
                  for (let s5 = i2; s5 < r2 + i2; s5++) {
                    const r3 = t4 * n3 + s5;
                    e3.emplaceBack(r3, r3 + 1), e3.emplaceBack(r3, r3 + n3), e3.emplaceBack(r3, r3 + n3 + 1);
                  }
                const o2 = a2 * r2 * 3;
                this._wireframeSegments.push(so.simpleSegment(0, s4, (a2 + 1) * n3, o2)), s4 += o2;
              }
              this._wireframeIndexBuffer = t2.createIndexBuffer(e3);
            }
            return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e2]];
          }
        }, t.GlyphManager = rd, t.ImagePosition = Sp, t.KDBush = gy, t.LivePerformanceUtils = $t, t.LngLat = Ol, t.LngLatBounds = oo, t.LocalGlyphMode = ed, t.MAX_MERCATOR_LATITUDE = Hl, t.MercatorCoordinate = Wl, t.ONE_EM = Rh, t.OverscaledTileID = fh, t.PerformanceMarkers = Ut, t.Point = x, t.Properties = Ps, t.RGBAImage = Uu, t.Ray = el, t.RequestManager = class {
          constructor(t2, e2, r2) {
            this._transformRequestFn = t2, this._customAccessToken = e2, this._silenceAuthErrors = !!r2, this._createSkuToken();
          }
          _createSkuToken() {
            const t2 = function() {
              let t3 = "";
              for (let e2 = 0; e2 < 10; e2++)
                t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", h2, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
          }
          _isSkuTokenExpired() {
            return Date.now() > this._skuTokenExpiresAt;
          }
          transformRequest(t2, e2) {
            return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
          }
          normalizeStyleURL(t2, e2) {
            if (!vt(t2))
              return t2;
            const r2 = kt(t2);
            return r2.path = `/styles/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e2);
          }
          normalizeGlyphsURL(t2, e2) {
            if (!vt(t2))
              return t2;
            const r2 = kt(t2);
            return r2.path = `/fonts/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e2);
          }
          normalizeSourceURL(t2, e2, r2, n3) {
            if (!vt(t2))
              return t2;
            const i2 = kt(t2);
            return i2.path = `/v4/${i2.authority}.json`, i2.params.push("secure"), r2 && i2.params.push(`language=${r2}`), n3 && i2.params.push(`worldview=${n3}`), this._makeAPIURL(i2, this._customAccessToken || e2);
          }
          normalizeSpriteURL(t2, e2, r2, n3) {
            const i2 = kt(t2);
            return vt(t2) ? (i2.path = `/styles/v1${i2.path}/sprite${e2}${r2}`, this._makeAPIURL(i2, this._customAccessToken || n3)) : (i2.path += `${e2}${r2}`, It(i2));
          }
          normalizeTileURL(t2, e2, r2) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !vt(t2))
              return t2;
            const n3 = kt(t2);
            n3.path = n3.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e2 || r2 && "raster" !== n3.authority && 512 === r2 ? "@2x" : ""}${s3.supported ? ".webp" : "$1"}`), "raster" === n3.authority ? n3.path = `/${i.RASTER_URL_PREFIX}${n3.path}` : (n3.path = n3.path.replace(/^.+\/v4\//, "/"), n3.path = `/${i.TILE_URL_VERSION}${n3.path}`);
            const a2 = this._customAccessToken || function(t3) {
              for (const e3 of t3) {
                const t4 = e3.match(/^access_token=(.*)$/);
                if (t4)
                  return t4[1];
              }
              return null;
            }(n3.params) || i.ACCESS_TOKEN;
            return i.REQUIRE_ACCESS_TOKEN && a2 && this._skuToken && n3.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n3, a2);
          }
          canonicalizeTileURL(t2, e2) {
            const r2 = kt(t2);
            if (!r2.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r2.path.match(/\.[\w]+$/))
              return t2;
            let n3 = "mapbox://";
            r2.path.match(/^\/raster\/v1\//) ? n3 += `raster/${r2.path.replace(`/${i.RASTER_URL_PREFIX}/`, "")}` : n3 += `tiles/${r2.path.replace(`/${i.TILE_URL_VERSION}/`, "")}`;
            let s4 = r2.params;
            return e2 && (s4 = s4.filter((t3) => !t3.match(/^access_token=/))), s4.length && (n3 += `?${s4.join("&")}`), n3;
          }
          canonicalizeTileset(t2, e2) {
            const r2 = !!e2 && vt(e2), n3 = [];
            for (const e3 of t2.tiles || [])
              bt(e3) ? n3.push(this.canonicalizeTileURL(e3, r2)) : n3.push(e3);
            return n3;
          }
          _makeAPIURL(t2, e2) {
            const r2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n3 = kt(i.API_URL);
            if (t2.protocol = n3.protocol, t2.authority = n3.authority, "http" === t2.protocol) {
              const e3 = t2.params.indexOf("secure");
              e3 >= 0 && t2.params.splice(e3, 1);
            }
            if ("/" !== n3.path && (t2.path = `${n3.path}${t2.path}`), !i.REQUIRE_ACCESS_TOKEN)
              return It(t2);
            if (e2 = e2 || i.ACCESS_TOKEN, !this._silenceAuthErrors) {
              if (!e2)
                throw new Error(`An API access token is required to use Mapbox GL. ${r2}`);
              if ("s" === e2[0])
                throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r2}`);
            }
            return t2.params = t2.params.filter((t3) => -1 === t3.indexOf("access_token")), t2.params.push(`access_token=${e2 || ""}`), It(t2);
          }
        }, t.ResourceType = lt, t.SegmentVector = so, t.SourceCache = ey, t.StencilMode = Hf, t.StructArrayLayout1ui2 = ua, t.StructArrayLayout2f1f2i16 = Qs, t.StructArrayLayout2i4 = $s, t.StructArrayLayout2ui4 = la, t.StructArrayLayout3f12 = ea, t.StructArrayLayout3ui6 = ra, t.StructArrayLayout4i8 = Os, t.StructArrayLayout5f20 = aa, t.Texture = xf, t.Tile = Pf, t.Transitionable = Ss, t.Uniform1f = La, t.Uniform1i = class extends Va {
          constructor(t2) {
            super(t2), this.current = 0;
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1i(this.location, r2));
          }
        }, t.Uniform2f = class extends Va {
          constructor(t2) {
            super(t2), this.current = [0, 0];
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] || (this.current = r2, this.gl.uniform2f(this.location, r2[0], r2[1])));
          }
        }, t.Uniform3f = class extends Va {
          constructor(t2) {
            super(t2), this.current = [0, 0, 0];
          }
          set(t2, e2, r2) {
            this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] || (this.current = r2, this.gl.uniform3f(this.location, r2[0], r2[1], r2[2])));
          }
        }, t.Uniform4f = Fa, t.UniformColor = Ra, t.UniformMatrix2f = class extends Va {
          constructor(t2) {
            super(t2), this.current = ja;
          }
          set(t2, e2, r2) {
            if (this.fetchUniformLocation(t2, e2)) {
              for (let t3 = 0; t3 < 4; t3++)
                if (r2[t3] !== this.current[t3]) {
                  this.current = r2, this.gl.uniformMatrix2fv(this.location, false, r2);
                  break;
                }
            }
          }
        }, t.UniformMatrix3f = class extends Va {
          constructor(t2) {
            super(t2), this.current = $a;
          }
          set(t2, e2, r2) {
            if (this.fetchUniformLocation(t2, e2)) {
              for (let t3 = 0; t3 < 9; t3++)
                if (r2[t3] !== this.current[t3]) {
                  this.current = r2, this.gl.uniformMatrix3fv(this.location, false, r2);
                  break;
                }
            }
          }
        }, t.UniformMatrix4f = class extends Va {
          constructor(t2) {
            super(t2), this.current = Ua;
          }
          set(t2, e2, r2) {
            if (this.fetchUniformLocation(t2, e2)) {
              if (r2[12] !== this.current[12] || r2[0] !== this.current[0])
                return this.current = r2, void this.gl.uniformMatrix4fv(this.location, false, r2);
              for (let t3 = 1; t3 < 16; t3++)
                if (r2[t3] !== this.current[t3]) {
                  this.current = r2, this.gl.uniformMatrix4fv(this.location, false, r2);
                  break;
                }
            }
          }
        }, t.UnwrappedTileID = dh, t.ValidationError = ri, t.VectorTileFeature = Kc, t.VectorTileWorkerSource = class extends Qt {
          constructor(t2, e2, r2, n3, i2) {
            super(), this.actor = t2, this.layerIndex = e2, this.availableImages = r2, this.loadVectorData = i2 || yy, this.loading = {}, this.loaded = {}, this.deduped = new fy(t2.scheduler), this.isSpriteLoaded = n3, this.scheduler = t2.scheduler;
          }
          loadTile(t2, e2) {
            const r2 = t2.uid, n3 = t2 && t2.request, i2 = n3 && n3.collectResourceTiming, s4 = this.loading[r2] = new py(t2);
            s4.abort = this.loadVectorData(t2, (a2, o2) => {
              const l3 = !this.loading[r2];
              if (delete this.loading[r2], l3 || a2 || !o2)
                return s4.status = "done", l3 || (this.loaded[r2] = s4), e2(a2);
              const u3 = o2.rawData, c4 = {};
              o2.expires && (c4.expires = o2.expires), o2.cacheControl && (c4.cacheControl = o2.cacheControl), s4.vectorTile = o2.vectorTile || new Zc(new mp(u3));
              const h3 = () => {
                s4.parse(s4.vectorTile, this.layerIndex, this.availableImages, this.actor, (t3, r3) => {
                  if (t3 || !r3)
                    return e2(t3);
                  const s5 = {};
                  if (i2) {
                    const t4 = qt(n3);
                    t4.length > 0 && (s5.resourceTiming = JSON.parse(JSON.stringify(t4)));
                  }
                  e2(null, C2({ rawTileData: u3.slice(0) }, r3, c4, s5));
                });
              };
              this.isSpriteLoaded ? h3() : this.once("isSpriteLoaded", () => {
                this.scheduler ? this.scheduler.add(h3, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }) : h3();
              }), this.loaded = this.loaded || {}, this.loaded[r2] = s4;
            });
          }
          reloadTile(t2, e2) {
            const r2 = this.loaded, n3 = t2.uid, i2 = this;
            if (r2 && r2[n3]) {
              const s4 = r2[n3];
              s4.showCollisionBoxes = t2.showCollisionBoxes, s4.enableTerrain = !!t2.enableTerrain, s4.projection = t2.projection, s4.tileTransform = Bd(t2.tileID.canonical, t2.projection);
              const a2 = (t3, r3) => {
                const n4 = s4.reloadCallback;
                n4 && (delete s4.reloadCallback, s4.parse(s4.vectorTile, i2.layerIndex, this.availableImages, i2.actor, n4)), e2(t3, r3);
              };
              "parsing" === s4.status ? s4.reloadCallback = a2 : "done" === s4.status && (s4.vectorTile ? s4.parse(s4.vectorTile, this.layerIndex, this.availableImages, this.actor, a2) : a2());
            }
          }
          abortTile(t2, e2) {
            const r2 = t2.uid, n3 = this.loading[r2];
            n3 && (n3.abort && n3.abort(), delete this.loading[r2]), e2();
          }
          removeTile(t2, e2) {
            const r2 = this.loaded, n3 = t2.uid;
            r2 && r2[n3] && delete r2[n3], e2();
          }
        }, t.WritingMode = Ip, t.ZoomDependentExpression = Wn, t.add = Mo, t.addDynamicAttributes = rf, t.adjoint = function(t2, e2) {
          var r2 = e2[0], n3 = e2[1], i2 = e2[2], s4 = e2[3], a2 = e2[4], o2 = e2[5], l3 = e2[6], u3 = e2[7], c4 = e2[8];
          return t2[0] = a2 * c4 - o2 * u3, t2[1] = i2 * u3 - n3 * c4, t2[2] = n3 * o2 - i2 * a2, t2[3] = o2 * l3 - s4 * c4, t2[4] = r2 * c4 - i2 * l3, t2[5] = i2 * s4 - r2 * o2, t2[6] = s4 * u3 - a2 * l3, t2[7] = n3 * l3 - r2 * u3, t2[8] = r2 * a2 - n3 * s4, t2;
        }, t.asyncAll = B, t.bezier = k, t.bindAll = R, t.boundsAttributes = Ef, t.bufferConvexPolygon = function(t2, e2) {
          const r2 = [];
          for (let n3 = 0; n3 < t2.length; n3++) {
            const i2 = z(n3 - 1, -1, t2.length - 1), s4 = z(n3 + 1, -1, t2.length - 1), a2 = t2[n3], o2 = t2[s4], l3 = t2[i2].sub(a2).unit(), u3 = o2.sub(a2).unit(), c4 = u3.angleWithSep(l3.x, l3.y), h3 = l3.add(u3).unit().mult(-1 * e2 / Math.sin(c4 / 2));
            r2.push(a2.add(h3));
          }
          return r2;
        }, t.cacheEntryPossiblyAdded = function(t2) {
          ot++, ot > et && (t2.getActor().send("enforceCacheSizeLimit", tt), ot = 0);
        }, t.calculateGlobeLabelMatrix = function(t2, e2) {
          const { x: r2, y: n3 } = t2.point, i2 = Cl(r2, n3, t2.worldSize / t2._pixelsPerMercatorPixel, 0, 0);
          return yo(i2, i2, El(xl(e2)));
        }, t.calculateGlobeMatrix = function(t2) {
          const { x: e2, y: r2 } = t2.point, { lng: n3, lat: i2 } = t2._center;
          return Cl(e2, r2, t2.worldSize, n3, i2);
        }, t.calculateGlobeMercatorMatrix = function(t2) {
          const e2 = t2.pixelsPerMeter, r2 = e2 / Zl(1, t2.center.lat), n3 = po(new Float64Array(16));
          return mo(n3, n3, [t2.point.x, t2.point.y, 0]), go(n3, n3, [r2, r2, e2]), Float32Array.from(n3);
        }, t.circumferenceAtLatitude = ql, t.clamp = M, t.clearTileCache = function(t2) {
          if (!it())
            return;
          const r2 = e.caches.delete(Q);
          t2 && r2.catch(t2).then(() => t2());
        }, t.clipLine = Hp, t.clone = function(t2) {
          var e2 = new uo(16);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
        }, t.clone$1 = O, t.collisionCircleLayout = Fh, t.config = i, t.conjugate = function(t2, e2) {
          return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2[3] = e2[3], t2;
        }, t.create = function() {
          var t2 = new uo(16);
          return uo != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }, t.create$1 = co, t.createExpression = Hn, t.createLayout = Rs, t.createStyleLayer = function(t2) {
          return "custom" === t2.type ? new ff(t2) : new gf[t2.type](t2);
        }, t.cross = Lo, t.degToRad = w, t.distance = function(t2, e2) {
          return Math.hypot(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
        }, t.div = function(t2, e2, r2) {
          return t2[0] = e2[0] / r2[0], t2[1] = e2[1] / r2[1], t2[2] = e2[2] / r2[2], t2;
        }, t.dot = Vo, t.earthRadius = Ul, t.ease = I, t.easeCubicInOut = S, t.ecefToLatLng = function([t2, e2, r2]) {
          const n3 = Math.hypot(t2, e2, r2), i2 = Math.atan2(t2, r2), s4 = 0.5 * Math.PI - Math.acos(-e2 / n3);
          return new Ol(_(i2), _(s4));
        }, t.emitValidationErrors = qi, t.endsWith = U, t.enforceCacheSizeLimit = function(t2) {
          st(), rt && rt.then((e2) => {
            e2.keys().then((r2) => {
              for (let n3 = 0; n3 < r2.length - t2; n3++)
                e2.delete(r2[n3]);
            });
          });
        }, t.evaluateSizeForFeature = jh, t.evaluateSizeForZoom = Oh, t.evaluateVariableOffset = xd, t.evented = gs, t.exactEquals = function(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3];
        }, t.exactEquals$1 = function(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2];
        }, t.exported = Xt, t.exported$1 = s3, t.extend = C2, t.extend$1 = ee, t.fillExtrusionHeightLift = oh, t.filterObject = j, t.fromMat4 = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[4], t2[4] = e2[5], t2[5] = e2[6], t2[6] = e2[8], t2[7] = e2[9], t2[8] = e2[10], t2;
        }, t.fromQuat = function(t2, e2) {
          var r2 = e2[0], n3 = e2[1], i2 = e2[2], s4 = e2[3], a2 = r2 + r2, o2 = n3 + n3, l3 = i2 + i2, u3 = r2 * a2, c4 = n3 * a2, h3 = n3 * o2, p3 = i2 * a2, d3 = i2 * o2, f2 = i2 * l3, y2 = s4 * a2, m3 = s4 * o2, g2 = s4 * l3;
          return t2[0] = 1 - h3 - f2, t2[1] = c4 + g2, t2[2] = p3 - m3, t2[3] = 0, t2[4] = c4 - g2, t2[5] = 1 - u3 - f2, t2[6] = d3 + y2, t2[7] = 0, t2[8] = p3 + m3, t2[9] = d3 - y2, t2[10] = 1 - u3 - h3, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, t.fromRotation = function(t2, e2) {
          var r2 = Math.sin(e2), n3 = Math.cos(e2);
          return t2[0] = n3, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n3, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        }, t.fromScaling = bo, t.furthestTileCorner = function(t2) {
          const e2 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
          return A[e2];
        }, t.getAABBPointSquareDist = function(t2, e2, r2) {
          let n3 = 0;
          for (let i2 = 0; i2 < 2; ++i2) {
            const s4 = r2 ? r2[i2] : 0;
            t2[i2] > s4 && (n3 += (t2[i2] - s4) * (t2[i2] - s4)), e2[i2] < s4 && (n3 += (s4 - e2[i2]) * (s4 - e2[i2]));
          }
          return n3;
        }, t.getAnchorAlignment = Rp, t.getAnchorJustification = bd, t.getBounds = function(t2) {
          let e2 = 1 / 0, r2 = 1 / 0, n3 = -1 / 0, i2 = -1 / 0;
          for (const s4 of t2)
            e2 = Math.min(e2, s4.x), r2 = Math.min(r2, s4.y), n3 = Math.max(n3, s4.x), i2 = Math.max(i2, s4.y);
          return { min: new x(e2, r2), max: new x(n3, i2) };
        }, t.getColumn = W, t.getDefaultExportFromCjs = p2, t.getGridMatrix = function(t2, e2, r2, n3) {
          const i2 = e2.getNorth(), s4 = e2.getSouth(), a2 = e2.getWest(), o2 = e2.getEast(), l3 = 1 << t2.z, u3 = o2 - a2, c4 = i2 - s4, h3 = u3 / ul, p3 = -c4 / cl[r2], d3 = [0, h3, 0, p3, 0, 0, i2, a2, 0];
          if (t2.z > 0) {
            const t3 = 180 / n3;
            ho(d3, d3, [t3 / u3 + 1, 0, 0, 0, t3 / c4 + 1, 0, -0.5 * t3 / h3, 0.5 * t3 / p3, 1]);
          }
          return d3[2] = l3, d3[5] = t2.x, d3[8] = t2.y, d3;
        }, t.getImage = gt, t.getJSON = function(t2, e2) {
          return ht(C2(t2, { type: "json" }), e2);
        }, t.getLatitudinalLod = function(t2) {
          const e2 = Hl - 5;
          t2 = M(t2, -e2, e2) / e2 * 90;
          const r2 = Math.pow(Math.abs(Math.sin(w(t2))), 3);
          return Math.round(r2 * (cl.length - 1));
        }, t.getMapSessionAPI = Ft, t.getPerformanceMeasurement = qt, t.getProjection = Yd, t.getRTLTextPluginStatus = xs, t.getReferrer = ct, t.getTilePoint = function(t2, { x: e2, y: r2 }, n3 = 0) {
          return new x(((e2 - n3) * t2.scale - t2.x) * ao, (r2 * t2.scale - t2.y) * ao);
        }, t.getTileVec3 = function(t2, e2, r2 = 0) {
          return Io(((e2.x - r2) * t2.scale - t2.x) * ao, (e2.y * t2.scale - t2.y) * ao, Jl(e2.z, e2.y));
        }, t.getVideo = function(t2, r2) {
          const n3 = e.document.createElement("video");
          n3.muted = true, n3.onloadstart = function() {
            r2(null, n3);
          };
          for (let r3 = 0; r3 < t2.length; r3++) {
            const i2 = e.document.createElement("source");
            dt(t2[r3]) || (n3.crossOrigin = "Anonymous"), i2.src = t2[r3], n3.appendChild(i2);
          }
          return { cancel: () => {
          } };
        }, t.globeCenterToScreenPoint = function(t2) {
          const e2 = [0, 0, 0], r2 = po(new Float64Array(16));
          return yo(r2, t2.pixelMatrix, t2.globeMatrix), Fo(e2, e2, r2), new x(e2[0], e2[1]);
        }, t.globeDenormalizeECEF = El, t.globeECEFOrigin = function(t2, e2) {
          const r2 = [0, 0, 0];
          return Fo(r2, r2, Bl(xl(e2.canonical))), Fo(r2, r2, t2), r2;
        }, t.globeMetersToEcef = fl, t.globeNormalizeECEF = Bl, t.globePixelsToTileUnits = function(t2, e2) {
          return ao / (512 * Math.pow(2, t2)) * Tl(xl(e2));
        }, t.globePoleMatrixForTile = function(t2, e2, r2) {
          const n3 = po(new Float64Array(16)), i2 = (e2 / (1 << t2) - 0.5) * Math.PI * 2;
          return vo(n3, r2.globeMatrix, i2), Float32Array.from(n3);
        }, t.globeTileBounds = xl, t.globeTiltAtLngLat = Dl, t.globeToMercatorTransition = Pl, t.globeUseCustomAntiAliasing = function(t2, e2, r2) {
          const n3 = Pl(r2.zoom), i2 = t2.style.map._antialias, s4 = !!e2.extStandardDerivatives, a2 = e2.extStandardDerivativesForceOff || t2.terrain && t2.terrain.exaggeration() > 0;
          return 0 === n3 && !i2 && !a2 && s4;
        }, t.identity = po, t.identity$1 = Ko, t.invert = fo, t.isFullscreen = function() {
          return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement;
        }, t.isLngLatBehindGlobe = Vl, t.isMapAuthenticated = function(t2) {
          return Rt.has(t2);
        }, t.isMapboxURL = vt, t.isSafariWithAntialiasingBug = function(t2) {
          const e2 = t2.navigator ? t2.navigator.userAgent : null;
          return !!H(t2) && e2 && (e2.match("Version/15.4") || e2.match("Version/15.5") || e2.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t.latFromMercatorY = Xl, t.latLngToECEF = Il, t.len = Oo, t.length = ko, t.length$1 = function(t2) {
          return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
        }, t.lngFromMercatorX = Kl, t.loadVectorTile = yy, t.makeRequest = ht, t.mapValue = function(t2, e2, r2, n3, i2) {
          return M((t2 - e2) / (r2 - e2) * (i2 - n3) + n3, n3, i2);
        }, t.mercatorScale = Yl, t.mercatorXfromLng = Nl, t.mercatorYfromLat = Gl, t.mercatorZfromAltitude = Zl, t.mul = _o, t.mul$1 = jo, t.multiply = yo, t.multiply$1 = ho, t.multiply$2 = zo, t.nextPowerOfTwo = L, t.normalize = Do, t.normalize$1 = Ho, t.normalize$2 = No, t.number = Er, t.ortho = function(t2, e2, r2, n3, i2, s4, a2) {
          var o2 = 1 / (e2 - r2), l3 = 1 / (n3 - i2), u3 = 1 / (s4 - a2);
          return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l3, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u3, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n3) * l3, t2[14] = (a2 + s4) * u3, t2[15] = 1, t2;
        }, t.pbf = Xh, t.perspective = function(t2, e2, r2, n3, i2) {
          var s4, a2 = 1 / Math.tan(e2 / 2);
          return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n3) * (s4 = 1 / (n3 - i2)), t2[14] = 2 * i2 * n3 * s4) : (t2[10] = -1, t2[14] = -2 * n3), t2;
        }, t.pick = function(t2, e2) {
          const r2 = {};
          for (let n3 = 0; n3 < e2.length; n3++) {
            const i2 = e2[n3];
            i2 in t2 && (r2[i2] = t2[i2]);
          }
          return r2;
        }, t.plugin = bs, t.pointGeometry = m2, t.polesInViewport = function(t2) {
          const e2 = po(new Float64Array(16));
          yo(e2, t2.pixelMatrix, t2.globeMatrix);
          const r2 = [0, hl, 0], n3 = [0, pl, 0];
          return Fo(r2, r2, e2), Fo(n3, n3, e2), [r2[0] > 0 && r2[0] <= t2.width && r2[1] > 0 && r2[1] <= t2.height && !Vl(t2, new Ol(t2.center.lat, 90)), n3[0] > 0 && n3[0] <= t2.width && n3[1] > 0 && n3[1] <= t2.height && !Vl(t2, new Ol(t2.center.lat, -90))];
        }, t.polygonContainsPoint = bu, t.polygonIntersectsBox = wu, t.polygonIntersectsPolygon = hu, t.polygonizeBounds = function(t2, e2, r2 = 0, n3 = true) {
          const i2 = new x(r2, r2), s4 = t2.sub(i2), a2 = e2.add(i2), o2 = [s4, new x(a2.x, s4.y), a2, new x(s4.x, a2.y)];
          return n3 && o2.push(s4.clone()), o2;
        }, t.posAttributes = tl, t.postMapLoadEvent = Pt, t.postPerformanceEvent = Vt, t.postTurnstileEvent = Et, t.potpack = _p, t.prevPowerOfTwo = function(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
        }, t.radToDeg = _, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.registerForPluginStateChange = function(t2) {
          return t2({ pluginStatus: ds, pluginURL: fs }), gs.on("pluginStateChange", t2), t2;
        }, t.removeAuthState = function(t2) {
          Rt.delete(t2);
        }, t.renderColorRamp = ju, t.resample = tu, t.rotateX = xo, t.rotateX$1 = Xo, t.rotateY = vo, t.rotateY$1 = Jo, t.rotateZ = function(t2, e2, r2) {
          var n3 = Math.sin(r2), i2 = Math.cos(r2), s4 = e2[0], a2 = e2[1], o2 = e2[2], l3 = e2[3], u3 = e2[4], c4 = e2[5], h3 = e2[6], p3 = e2[7];
          return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s4 * i2 + u3 * n3, t2[1] = a2 * i2 + c4 * n3, t2[2] = o2 * i2 + h3 * n3, t2[3] = l3 * i2 + p3 * n3, t2[4] = u3 * i2 - s4 * n3, t2[5] = c4 * i2 - a2 * n3, t2[6] = h3 * i2 - o2 * n3, t2[7] = p3 * i2 - l3 * n3, t2;
        }, t.rotateZ$1 = function(t2, e2, r2) {
          r2 *= 0.5;
          var n3 = e2[0], i2 = e2[1], s4 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l3 = Math.cos(r2);
          return t2[0] = n3 * l3 + i2 * o2, t2[1] = i2 * l3 - n3 * o2, t2[2] = s4 * l3 + a2 * o2, t2[3] = a2 * l3 - s4 * o2, t2;
        }, t.scale = go, t.scale$1 = qo, t.scale$2 = Co, t.scaleAndAdd = Po, t.set = function(t2, e2, r2, n3) {
          return t2[0] = e2, t2[1] = r2, t2[2] = n3, t2;
        }, t.setCacheLimits = function(t2, e2) {
          tt = t2, et = e2;
        }, t.setColumn = function(t2, e2, r2) {
          t2[4 * e2 + 0] = r2[0], t2[4 * e2 + 1] = r2[1], t2[4 * e2 + 2] = r2[2], t2[4 * e2 + 3] = r2[3];
        }, t.setRTLTextPlugin = function(t2, e2, r2 = false) {
          if (ds === us || ds === cs || ds === hs)
            throw new Error("setRTLTextPlugin cannot be called multiple times.");
          fs = Xt.resolveURL(t2), ds = us, ps = e2, ms(), r2 || vs();
        }, t.smoothstep = T2, t.spec = te, t.squaredLength = function(t2) {
          var e2 = t2[0], r2 = t2[1], n3 = t2[2];
          return e2 * e2 + r2 * r2 + n3 * n3;
        }, t.storeAuthState = function(t2, e2) {
          e2 ? Rt.add(t2) : Rt.delete(t2);
        }, t.sub = $o, t.subtract = To, t.symbolSize = qh, t.tileAABB = function(t2, e2, r2, n3, i2, s4, a2, o2, l3) {
          if ("globe" === l3.name)
            return _l(t2, e2, new ph(r2, n3, i2));
          const u3 = Bd({ z: r2, x: n3, y: i2 }, l3);
          return new il([(s4 + u3.x / u3.scale) * e2, e2 * (u3.y / u3.scale), a2], [(s4 + u3.x2 / u3.scale) * e2, e2 * (u3.y2 / u3.scale), o2]);
        }, t.tileCornersToBounds = Al, t.tileTransform = Bd, t.transformMat3 = function(t2, e2, r2) {
          var n3 = e2[0], i2 = e2[1], s4 = e2[2];
          return t2[0] = n3 * r2[0] + i2 * r2[3] + s4 * r2[6], t2[1] = n3 * r2[1] + i2 * r2[4] + s4 * r2[7], t2[2] = n3 * r2[2] + i2 * r2[5] + s4 * r2[8], t2;
        }, t.transformMat4 = Fo, t.transformMat4$1 = Go, t.transformQuat = Ro, t.transitionTileAABBinECEF = bl, t.translate = mo, t.transpose = function(t2, e2) {
          if (t2 === e2) {
            var r2 = e2[1], n3 = e2[2], i2 = e2[5];
            t2[1] = e2[3], t2[2] = e2[6], t2[3] = r2, t2[5] = e2[7], t2[6] = n3, t2[7] = i2;
          } else
            t2[0] = e2[0], t2[1] = e2[3], t2[2] = e2[6], t2[3] = e2[1], t2[4] = e2[4], t2[5] = e2[7], t2[6] = e2[2], t2[7] = e2[5], t2[8] = e2[8];
          return t2;
        }, t.triggerPluginCompletionEvent = ys, t.uniqueId = D, t.updateGlobeVertexNormal = function(t2, e2, r2, n3, i2) {
          const s4 = 5 * e2 + 2;
          t2.float32[s4 + 0] = r2, t2.float32[s4 + 1] = n3, t2.float32[s4 + 2] = i2;
        }, t.validateCustomStyleLayer = function(t2) {
          const e2 = [], r2 = t2.id;
          return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
        }, t.validateFilter = (t2) => Oi(Ai(t2)), t.validateFog = (t2) => Oi(Vi(t2)), t.validateLayer = (t2) => Oi(Ti(t2)), t.validateLight = (t2) => Oi(Pi(t2)), t.validateSource = (t2) => Oi(Ei(t2)), t.validateStyle = Ui, t.validateTerrain = (t2) => Oi(Di(t2)), t.values = E, t.vectorTile = Dc, t.version = r, t.warnOnce = N, t.window = e, t.wrap = z;
      });
      define2(["./shared"], function(e) {
        "use strict";
        function t(e2) {
          if ("number" == typeof e2 || "boolean" == typeof e2 || "string" == typeof e2 || null == e2)
            return JSON.stringify(e2);
          if (Array.isArray(e2)) {
            let r3 = "[";
            for (const o2 of e2)
              r3 += `${t(o2)},`;
            return `${r3}]`;
          }
          let r2 = "{";
          for (const o2 of Object.keys(e2).sort())
            r2 += `${o2}:${t(e2[o2])},`;
          return `${r2}}`;
        }
        function r(r2) {
          let o2 = "";
          for (const i2 of e.refProperties)
            o2 += `/${t(r2[i2])}`;
          return o2;
        }
        class o {
          constructor(e2) {
            this.keyCache = {}, e2 && this.replace(e2);
          }
          replace(e2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
          }
          update(t2, o2) {
            for (const r2 of t2)
              this._layerConfigs[r2.id] = r2, (this._layers[r2.id] = e.createStyleLayer(r2)).compileFilter(), this.keyCache[r2.id] && delete this.keyCache[r2.id];
            for (const e2 of o2)
              delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
            this.familiesBySource = {};
            const i2 = function(e2, t3) {
              const o3 = {};
              for (let i4 = 0; i4 < e2.length; i4++) {
                const n3 = t3 && t3[e2[i4].id] || r(e2[i4]);
                t3 && (t3[e2[i4].id] = n3);
                let s4 = o3[n3];
                s4 || (s4 = o3[n3] = []), s4.push(e2[i4]);
              }
              const i3 = [];
              for (const e3 in o3)
                i3.push(o3[e3]);
              return i3;
            }(e.values(this._layerConfigs), this.keyCache);
            for (const e2 of i2) {
              const t3 = e2.map((e3) => this._layers[e3.id]), r2 = t3[0];
              if ("none" === r2.visibility)
                continue;
              const o3 = r2.source || "";
              let i3 = this.familiesBySource[o3];
              i3 || (i3 = this.familiesBySource[o3] = {});
              const n3 = r2.sourceLayer || "_geojsonTileLayer";
              let s4 = i3[n3];
              s4 || (s4 = i3[n3] = []), s4.push(t3);
            }
          }
        }
        class i {
          loadTile(t2, r2) {
            const { uid: o2, encoding: i2, rawImageData: n3, padding: s4, buildQuadTree: a2 } = t2, l3 = e.window.ImageBitmap && n3 instanceof e.window.ImageBitmap ? this.getImageData(n3, s4) : n3;
            r2(null, new e.DEMData(o2, l3, i2, s4 < 1, a2));
          }
          getImageData(e2, t2) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e2.width, e2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e2.width, this.offscreenCanvas.height = e2.height, this.offscreenCanvasContext.drawImage(e2, 0, 0, e2.width, e2.height);
            const r2 = this.offscreenCanvasContext.getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r2;
          }
        }
        function n2(e2, t2) {
          if (0 !== e2.length) {
            s3(e2[0], t2);
            for (var r2 = 1; r2 < e2.length; r2++)
              s3(e2[r2], !t2);
          }
        }
        function s3(e2, t2) {
          for (var r2 = 0, o2 = 0, i2 = 0, n3 = e2.length, s4 = n3 - 1; i2 < n3; s4 = i2++) {
            var a2 = (e2[i2][0] - e2[s4][0]) * (e2[s4][1] + e2[i2][1]), l3 = r2 + a2;
            o2 += Math.abs(r2) >= Math.abs(a2) ? r2 - l3 + a2 : a2 - l3 + r2, r2 = l3;
          }
          r2 + o2 >= 0 != !!t2 && e2.reverse();
        }
        var a = e.getDefaultExportFromCjs(function e2(t2, r2) {
          var o2, i2 = t2 && t2.type;
          if ("FeatureCollection" === i2)
            for (o2 = 0; o2 < t2.features.length; o2++)
              e2(t2.features[o2], r2);
          else if ("GeometryCollection" === i2)
            for (o2 = 0; o2 < t2.geometries.length; o2++)
              e2(t2.geometries[o2], r2);
          else if ("Feature" === i2)
            e2(t2.geometry, r2);
          else if ("Polygon" === i2)
            n2(t2.coordinates, r2);
          else if ("MultiPolygon" === i2)
            for (o2 = 0; o2 < t2.coordinates.length; o2++)
              n2(t2.coordinates[o2], r2);
          return t2;
        });
        const l2 = e.VectorTileFeature.prototype.toGeoJSON;
        var u2 = { exports: {} }, h2 = e.pointGeometry, c3 = e.vectorTile.VectorTileFeature, f = p2;
        function p2(e2, t2) {
          this.options = t2 || {}, this.features = e2, this.length = e2.length;
        }
        function g(e2, t2) {
          this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
        }
        p2.prototype.feature = function(e2) {
          return new g(this.features[e2], this.options.extent);
        }, g.prototype.loadGeometry = function() {
          var e2 = this.rawGeometry;
          this.geometry = [];
          for (var t2 = 0; t2 < e2.length; t2++) {
            for (var r2 = e2[t2], o2 = [], i2 = 0; i2 < r2.length; i2++)
              o2.push(new h2(r2[i2][0], r2[i2][1]));
            this.geometry.push(o2);
          }
          return this.geometry;
        }, g.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e2 = this.geometry, t2 = 1 / 0, r2 = -1 / 0, o2 = 1 / 0, i2 = -1 / 0, n3 = 0; n3 < e2.length; n3++)
            for (var s4 = e2[n3], a2 = 0; a2 < s4.length; a2++) {
              var l3 = s4[a2];
              t2 = Math.min(t2, l3.x), r2 = Math.max(r2, l3.x), o2 = Math.min(o2, l3.y), i2 = Math.max(i2, l3.y);
            }
          return [t2, o2, r2, i2];
        }, g.prototype.toGeoJSON = c3.prototype.toGeoJSON;
        var d2 = e.pbf, m2 = f;
        function y(e2) {
          var t2 = new d2();
          return function(e3, t3) {
            for (var r2 in e3.layers)
              t3.writeMessage(3, v3, e3.layers[r2]);
          }(e2, t2), t2.finish();
        }
        function v3(e2, t2) {
          var r2;
          t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
          var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (r2 = 0; r2 < e2.length; r2++)
            o2.feature = e2.feature(r2), t2.writeMessage(2, x, o2);
          var i2 = o2.keys;
          for (r2 = 0; r2 < i2.length; r2++)
            t2.writeStringField(3, i2[r2]);
          var n3 = o2.values;
          for (r2 = 0; r2 < n3.length; r2++)
            t2.writeMessage(4, b2, n3[r2]);
        }
        function x(e2, t2) {
          var r2 = e2.feature;
          void 0 !== r2.id && t2.writeVarintField(1, r2.id), t2.writeMessage(2, w, e2), t2.writeVarintField(3, r2.type), t2.writeMessage(4, P2, r2);
        }
        function w(e2, t2) {
          var r2 = e2.feature, o2 = e2.keys, i2 = e2.values, n3 = e2.keycache, s4 = e2.valuecache;
          for (var a2 in r2.properties) {
            var l3 = r2.properties[a2], u3 = n3[a2];
            if (null !== l3) {
              void 0 === u3 && (o2.push(a2), n3[a2] = u3 = o2.length - 1), t2.writeVarint(u3);
              var h3 = typeof l3;
              "string" !== h3 && "boolean" !== h3 && "number" !== h3 && (l3 = JSON.stringify(l3));
              var c4 = h3 + ":" + l3, f2 = s4[c4];
              void 0 === f2 && (i2.push(l3), s4[c4] = f2 = i2.length - 1), t2.writeVarint(f2);
            }
          }
        }
        function S(e2, t2) {
          return (t2 << 3) + (7 & e2);
        }
        function M(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function P2(e2, t2) {
          for (var r2 = e2.loadGeometry(), o2 = e2.type, i2 = 0, n3 = 0, s4 = r2.length, a2 = 0; a2 < s4; a2++) {
            var l3 = r2[a2], u3 = 1;
            1 === o2 && (u3 = l3.length), t2.writeVarint(S(1, u3));
            for (var h3 = 3 === o2 ? l3.length - 1 : l3.length, c4 = 0; c4 < h3; c4++) {
              1 === c4 && 1 !== o2 && t2.writeVarint(S(2, h3 - 1));
              var f2 = l3[c4].x - i2, p3 = l3[c4].y - n3;
              t2.writeVarint(M(f2)), t2.writeVarint(M(p3)), i2 += f2, n3 += p3;
            }
            3 === o2 && t2.writeVarint(S(7, 1));
          }
        }
        function b2(e2, t2) {
          var r2 = typeof e2;
          "string" === r2 ? t2.writeStringField(1, e2) : "boolean" === r2 ? t2.writeBooleanField(7, e2) : "number" === r2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
        }
        u2.exports = y, u2.exports.fromVectorTileJs = y, u2.exports.fromGeojsonVt = function(e2, t2) {
          t2 = t2 || {};
          var r2 = {};
          for (var o2 in e2)
            r2[o2] = new m2(e2[o2].features, t2), r2[o2].name = o2, r2[o2].version = t2.version, r2[o2].extent = t2.extent;
          return y({ layers: r2 });
        }, u2.exports.GeoJSONWrapper = m2;
        var T2 = e.getDefaultExportFromCjs(u2.exports);
        const k = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, I = Math.fround || (_ = new Float32Array(1), (e2) => (_[0] = +e2, _[0]));
        var _;
        const C2 = 3, L = 5, O = 6;
        class E {
          constructor(e2) {
            this.options = Object.assign(Object.create(k), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e2) {
            const { log: t2, minZoom: r2, maxZoom: o2 } = this.options;
            t2 && console.time("total time");
            const i2 = `prepare ${e2.length} points`;
            t2 && console.time(i2), this.points = e2;
            const n3 = [];
            for (let t3 = 0; t3 < e2.length; t3++) {
              const r3 = e2[t3];
              if (!r3.geometry)
                continue;
              const [o3, i3] = r3.geometry.coordinates, s5 = I(N(o3)), a2 = I(Z(i3));
              n3.push(s5, a2, 1 / 0, t3, -1, 1), this.options.reduce && n3.push(0);
            }
            let s4 = this.trees[o2 + 1] = this._createTree(n3);
            t2 && console.timeEnd(i2);
            for (let e3 = o2; e3 >= r2; e3--) {
              const r3 = +Date.now();
              s4 = this.trees[e3] = this._createTree(this._cluster(s4, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, s4.numItems, +Date.now() - r3);
            }
            return t2 && console.timeEnd("total time"), this;
          }
          getClusters(e2, t2) {
            let r2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
            const o2 = Math.max(-90, Math.min(90, e2[1]));
            let i2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
            const n3 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360)
              r2 = -180, i2 = 180;
            else if (r2 > i2) {
              const e3 = this.getClusters([r2, o2, 180, n3], t2), s5 = this.getClusters([-180, o2, i2, n3], t2);
              return e3.concat(s5);
            }
            const s4 = this.trees[this._limitZoom(t2)], a2 = s4.range(N(r2), Z(n3), N(i2), Z(o2)), l3 = s4.data, u3 = [];
            for (const e3 of a2) {
              const t3 = this.stride * e3;
              u3.push(l3[t3 + L] > 1 ? j(l3, t3, this.clusterProps) : this.points[l3[t3 + C2]]);
            }
            return u3;
          }
          getChildren(e2) {
            const t2 = this._getOriginId(e2), r2 = this._getOriginZoom(e2), o2 = "No cluster with the specified id.", i2 = this.trees[r2];
            if (!i2)
              throw new Error(o2);
            const n3 = i2.data;
            if (t2 * this.stride >= n3.length)
              throw new Error(o2);
            const s4 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), a2 = i2.within(n3[t2 * this.stride], n3[t2 * this.stride + 1], s4), l3 = [];
            for (const t3 of a2) {
              const r3 = t3 * this.stride;
              n3[r3 + 4] === e2 && l3.push(n3[r3 + L] > 1 ? j(n3, r3, this.clusterProps) : this.points[n3[r3 + C2]]);
            }
            if (0 === l3.length)
              throw new Error(o2);
            return l3;
          }
          getLeaves(e2, t2, r2) {
            const o2 = [];
            return this._appendLeaves(o2, e2, t2 = t2 || 10, r2 = r2 || 0, 0), o2;
          }
          getTile(e2, t2, r2) {
            const o2 = this.trees[this._limitZoom(e2)], i2 = Math.pow(2, e2), { extent: n3, radius: s4 } = this.options, a2 = s4 / n3, l3 = (r2 - a2) / i2, u3 = (r2 + 1 + a2) / i2, h3 = { features: [] };
            return this._addTileFeatures(o2.range((t2 - a2) / i2, l3, (t2 + 1 + a2) / i2, u3), o2.data, t2, r2, i2, h3), 0 === t2 && this._addTileFeatures(o2.range(1 - a2 / i2, l3, 1, u3), o2.data, i2, r2, i2, h3), t2 === i2 - 1 && this._addTileFeatures(o2.range(0, l3, a2 / i2, u3), o2.data, -1, r2, i2, h3), h3.features.length ? h3 : null;
          }
          getClusterExpansionZoom(e2) {
            let t2 = this._getOriginZoom(e2) - 1;
            for (; t2 <= this.options.maxZoom; ) {
              const r2 = this.getChildren(e2);
              if (t2++, 1 !== r2.length)
                break;
              e2 = r2[0].properties.cluster_id;
            }
            return t2;
          }
          _appendLeaves(e2, t2, r2, o2, i2) {
            const n3 = this.getChildren(t2);
            for (const t3 of n3) {
              const n4 = t3.properties;
              if (n4 && n4.cluster ? i2 + n4.point_count <= o2 ? i2 += n4.point_count : i2 = this._appendLeaves(e2, n4.cluster_id, r2, o2, i2) : i2 < o2 ? i2++ : e2.push(t3), e2.length === r2)
                break;
            }
            return i2;
          }
          _createTree(t2) {
            const r2 = new e.KDBush(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e2 = 0; e2 < t2.length; e2 += this.stride)
              r2.add(t2[e2], t2[e2 + 1]);
            return r2.finish(), r2.data = t2, r2;
          }
          _addTileFeatures(e2, t2, r2, o2, i2, n3) {
            for (const s4 of e2) {
              const e3 = s4 * this.stride, a2 = t2[e3 + L] > 1;
              let l3, u3, h3;
              if (a2)
                l3 = F(t2, e3, this.clusterProps), u3 = t2[e3], h3 = t2[e3 + 1];
              else {
                const r3 = this.points[t2[e3 + C2]];
                l3 = r3.properties;
                const [o3, i3] = r3.geometry.coordinates;
                u3 = N(o3), h3 = Z(i3);
              }
              const c4 = { type: 1, geometry: [[Math.round(this.options.extent * (u3 * i2 - r2)), Math.round(this.options.extent * (h3 * i2 - o2))]], tags: l3 };
              let f2;
              f2 = a2 || this.options.generateId ? t2[e3 + C2] : this.points[t2[e3 + C2]].id, void 0 !== f2 && (c4.id = f2), n3.features.push(c4);
            }
          }
          _limitZoom(e2) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
          }
          _cluster(e2, t2) {
            const { radius: r2, extent: o2, reduce: i2, minPoints: n3 } = this.options, s4 = r2 / (o2 * Math.pow(2, t2)), a2 = e2.data, l3 = [], u3 = this.stride;
            for (let r3 = 0; r3 < a2.length; r3 += u3) {
              if (a2[r3 + 2] <= t2)
                continue;
              a2[r3 + 2] = t2;
              const o3 = a2[r3], h3 = a2[r3 + 1], c4 = e2.within(a2[r3], a2[r3 + 1], s4), f2 = a2[r3 + L];
              let p3 = f2;
              for (const e3 of c4) {
                const r4 = e3 * u3;
                a2[r4 + 2] > t2 && (p3 += a2[r4 + L]);
              }
              if (p3 > f2 && p3 >= n3) {
                let e3, n4 = o3 * f2, s5 = h3 * f2, g2 = -1;
                const d3 = ((r3 / u3 | 0) << 5) + (t2 + 1) + this.points.length;
                for (const o4 of c4) {
                  const l4 = o4 * u3;
                  if (a2[l4 + 2] <= t2)
                    continue;
                  a2[l4 + 2] = t2;
                  const h4 = a2[l4 + L];
                  n4 += a2[l4] * h4, s5 += a2[l4 + 1] * h4, a2[l4 + 4] = d3, i2 && (e3 || (e3 = this._map(a2, r3, true), g2 = this.clusterProps.length, this.clusterProps.push(e3)), i2(e3, this._map(a2, l4)));
                }
                a2[r3 + 4] = d3, l3.push(n4 / p3, s5 / p3, 1 / 0, d3, -1, p3), i2 && l3.push(g2);
              } else {
                for (let e3 = 0; e3 < u3; e3++)
                  l3.push(a2[r3 + e3]);
                if (p3 > 1)
                  for (const e3 of c4) {
                    const r4 = e3 * u3;
                    if (!(a2[r4 + 2] <= t2)) {
                      a2[r4 + 2] = t2;
                      for (let e4 = 0; e4 < u3; e4++)
                        l3.push(a2[r4 + e4]);
                    }
                  }
              }
            }
            return l3;
          }
          _getOriginId(e2) {
            return e2 - this.points.length >> 5;
          }
          _getOriginZoom(e2) {
            return (e2 - this.points.length) % 32;
          }
          _map(e2, t2, r2) {
            if (e2[t2 + L] > 1) {
              const o3 = this.clusterProps[e2[t2 + O]];
              return r2 ? Object.assign({}, o3) : o3;
            }
            const o2 = this.points[e2[t2 + C2]].properties, i2 = this.options.map(o2);
            return r2 && i2 === o2 ? Object.assign({}, i2) : i2;
          }
        }
        function j(e2, t2, r2) {
          return { type: "Feature", id: e2[t2 + C2], properties: F(e2, t2, r2), geometry: { type: "Point", coordinates: [(o2 = e2[t2], 360 * (o2 - 0.5)), J(e2[t2 + 1])] } };
          var o2;
        }
        function F(e2, t2, r2) {
          const o2 = e2[t2 + L], i2 = o2 >= 1e4 ? `${Math.round(o2 / 1e3)}k` : o2 >= 1e3 ? Math.round(o2 / 100) / 10 + "k" : o2, n3 = e2[t2 + O], s4 = -1 === n3 ? {} : Object.assign({}, r2[n3]);
          return Object.assign(s4, { cluster: true, cluster_id: e2[t2 + C2], point_count: o2, point_count_abbreviated: i2 });
        }
        function N(e2) {
          return e2 / 360 + 0.5;
        }
        function Z(e2) {
          const t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
        }
        function J(e2) {
          const t2 = (180 - 360 * e2) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
        }
        function z(e2, t2, r2, o2) {
          for (var i2, n3 = o2, s4 = r2 - t2 >> 1, a2 = r2 - t2, l3 = e2[t2], u3 = e2[t2 + 1], h3 = e2[r2], c4 = e2[r2 + 1], f2 = t2 + 3; f2 < r2; f2 += 3) {
            var p3 = G(e2[f2], e2[f2 + 1], l3, u3, h3, c4);
            if (p3 > n3)
              i2 = f2, n3 = p3;
            else if (p3 === n3) {
              var g2 = Math.abs(f2 - s4);
              g2 < a2 && (i2 = f2, a2 = g2);
            }
          }
          n3 > o2 && (i2 - t2 > 3 && z(e2, t2, i2, o2), e2[i2 + 2] = n3, r2 - i2 > 3 && z(e2, i2, r2, o2));
        }
        function G(e2, t2, r2, o2, i2, n3) {
          var s4 = i2 - r2, a2 = n3 - o2;
          if (0 !== s4 || 0 !== a2) {
            var l3 = ((e2 - r2) * s4 + (t2 - o2) * a2) / (s4 * s4 + a2 * a2);
            l3 > 1 ? (r2 = i2, o2 = n3) : l3 > 0 && (r2 += s4 * l3, o2 += a2 * l3);
          }
          return (s4 = e2 - r2) * s4 + (a2 = t2 - o2) * a2;
        }
        function W(e2, t2, r2, o2) {
          var i2 = { id: void 0 === e2 ? null : e2, type: t2, geometry: r2, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e3) {
            var t3 = e3.geometry, r3 = e3.type;
            if ("Point" === r3 || "MultiPoint" === r3 || "LineString" === r3)
              Y(e3, t3);
            else if ("Polygon" === r3 || "MultiLineString" === r3)
              for (var o3 = 0; o3 < t3.length; o3++)
                Y(e3, t3[o3]);
            else if ("MultiPolygon" === r3)
              for (o3 = 0; o3 < t3.length; o3++)
                for (var i3 = 0; i3 < t3[o3].length; i3++)
                  Y(e3, t3[o3][i3]);
          }(i2), i2;
        }
        function Y(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2 += 3)
            e2.minX = Math.min(e2.minX, t2[r2]), e2.minY = Math.min(e2.minY, t2[r2 + 1]), e2.maxX = Math.max(e2.maxX, t2[r2]), e2.maxY = Math.max(e2.maxY, t2[r2 + 1]);
        }
        function X(e2, t2, r2, o2) {
          if (t2.geometry) {
            var i2 = t2.geometry.coordinates, n3 = t2.geometry.type, s4 = Math.pow(r2.tolerance / ((1 << r2.maxZoom) * r2.extent), 2), a2 = [], l3 = t2.id;
            if (r2.promoteId ? l3 = t2.properties[r2.promoteId] : r2.generateId && (l3 = o2 || 0), "Point" === n3)
              V(i2, a2);
            else if ("MultiPoint" === n3)
              for (var u3 = 0; u3 < i2.length; u3++)
                V(i2[u3], a2);
            else if ("LineString" === n3)
              D(i2, a2, s4, false);
            else if ("MultiLineString" === n3) {
              if (r2.lineMetrics) {
                for (u3 = 0; u3 < i2.length; u3++)
                  D(i2[u3], a2 = [], s4, false), e2.push(W(l3, "LineString", a2, t2.properties));
                return;
              }
              $(i2, a2, s4, false);
            } else if ("Polygon" === n3)
              $(i2, a2, s4, true);
            else {
              if ("MultiPolygon" !== n3) {
                if ("GeometryCollection" === n3) {
                  for (u3 = 0; u3 < t2.geometry.geometries.length; u3++)
                    X(e2, { id: l3, geometry: t2.geometry.geometries[u3], properties: t2.properties }, r2, o2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (u3 = 0; u3 < i2.length; u3++) {
                var h3 = [];
                $(i2[u3], h3, s4, true), a2.push(h3);
              }
            }
            e2.push(W(l3, n3, a2, t2.properties));
          }
        }
        function V(e2, t2) {
          t2.push(A(e2[0])), t2.push(B(e2[1])), t2.push(0);
        }
        function D(e2, t2, r2, o2) {
          for (var i2, n3, s4 = 0, a2 = 0; a2 < e2.length; a2++) {
            var l3 = A(e2[a2][0]), u3 = B(e2[a2][1]);
            t2.push(l3), t2.push(u3), t2.push(0), a2 > 0 && (s4 += o2 ? (i2 * u3 - l3 * n3) / 2 : Math.sqrt(Math.pow(l3 - i2, 2) + Math.pow(u3 - n3, 2))), i2 = l3, n3 = u3;
          }
          var h3 = t2.length - 3;
          t2[2] = 1, z(t2, 0, h3, r2), t2[h3 + 2] = 1, t2.size = Math.abs(s4), t2.start = 0, t2.end = t2.size;
        }
        function $(e2, t2, r2, o2) {
          for (var i2 = 0; i2 < e2.length; i2++) {
            var n3 = [];
            D(e2[i2], n3, r2, o2), t2.push(n3);
          }
        }
        function A(e2) {
          return e2 / 360 + 0.5;
        }
        function B(e2) {
          var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
        }
        function R(e2, t2, r2, o2, i2, n3, s4, a2) {
          if (o2 /= t2, n3 >= (r2 /= t2) && s4 < o2)
            return e2;
          if (s4 < r2 || n3 >= o2)
            return null;
          for (var l3 = [], u3 = 0; u3 < e2.length; u3++) {
            var h3 = e2[u3], c4 = h3.geometry, f2 = h3.type, p3 = 0 === i2 ? h3.minX : h3.minY, g2 = 0 === i2 ? h3.maxX : h3.maxY;
            if (p3 >= r2 && g2 < o2)
              l3.push(h3);
            else if (!(g2 < r2 || p3 >= o2)) {
              var d3 = [];
              if ("Point" === f2 || "MultiPoint" === f2)
                q(c4, d3, r2, o2, i2);
              else if ("LineString" === f2)
                Q(c4, d3, r2, o2, i2, false, a2.lineMetrics);
              else if ("MultiLineString" === f2)
                K(c4, d3, r2, o2, i2, false);
              else if ("Polygon" === f2)
                K(c4, d3, r2, o2, i2, true);
              else if ("MultiPolygon" === f2)
                for (var m3 = 0; m3 < c4.length; m3++) {
                  var y2 = [];
                  K(c4[m3], y2, r2, o2, i2, true), y2.length && d3.push(y2);
                }
              if (d3.length) {
                if (a2.lineMetrics && "LineString" === f2) {
                  for (m3 = 0; m3 < d3.length; m3++)
                    l3.push(W(h3.id, f2, d3[m3], h3.tags));
                  continue;
                }
                "LineString" !== f2 && "MultiLineString" !== f2 || (1 === d3.length ? (f2 = "LineString", d3 = d3[0]) : f2 = "MultiLineString"), "Point" !== f2 && "MultiPoint" !== f2 || (f2 = 3 === d3.length ? "Point" : "MultiPoint"), l3.push(W(h3.id, f2, d3, h3.tags));
              }
            }
          }
          return l3.length ? l3 : null;
        }
        function q(e2, t2, r2, o2, i2) {
          for (var n3 = 0; n3 < e2.length; n3 += 3) {
            var s4 = e2[n3 + i2];
            s4 >= r2 && s4 <= o2 && (t2.push(e2[n3]), t2.push(e2[n3 + 1]), t2.push(e2[n3 + 2]));
          }
        }
        function Q(e2, t2, r2, o2, i2, n3, s4) {
          for (var a2, l3, u3 = U(e2), h3 = 0 === i2 ? ee : te, c4 = e2.start, f2 = 0; f2 < e2.length - 3; f2 += 3) {
            var p3 = e2[f2], g2 = e2[f2 + 1], d3 = e2[f2 + 2], m3 = e2[f2 + 3], y2 = e2[f2 + 4], v4 = 0 === i2 ? p3 : g2, x2 = 0 === i2 ? m3 : y2, w2 = false;
            s4 && (a2 = Math.sqrt(Math.pow(p3 - m3, 2) + Math.pow(g2 - y2, 2))), v4 < r2 ? x2 > r2 && (l3 = h3(u3, p3, g2, m3, y2, r2), s4 && (u3.start = c4 + a2 * l3)) : v4 > o2 ? x2 < o2 && (l3 = h3(u3, p3, g2, m3, y2, o2), s4 && (u3.start = c4 + a2 * l3)) : H(u3, p3, g2, d3), x2 < r2 && v4 >= r2 && (l3 = h3(u3, p3, g2, m3, y2, r2), w2 = true), x2 > o2 && v4 <= o2 && (l3 = h3(u3, p3, g2, m3, y2, o2), w2 = true), !n3 && w2 && (s4 && (u3.end = c4 + a2 * l3), t2.push(u3), u3 = U(e2)), s4 && (c4 += a2);
          }
          var S2 = e2.length - 3;
          p3 = e2[S2], g2 = e2[S2 + 1], d3 = e2[S2 + 2], (v4 = 0 === i2 ? p3 : g2) >= r2 && v4 <= o2 && H(u3, p3, g2, d3), S2 = u3.length - 3, n3 && S2 >= 3 && (u3[S2] !== u3[0] || u3[S2 + 1] !== u3[1]) && H(u3, u3[0], u3[1], u3[2]), u3.length && t2.push(u3);
        }
        function U(e2) {
          var t2 = [];
          return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
        }
        function K(e2, t2, r2, o2, i2, n3) {
          for (var s4 = 0; s4 < e2.length; s4++)
            Q(e2[s4], t2, r2, o2, i2, n3, false);
        }
        function H(e2, t2, r2, o2) {
          e2.push(t2), e2.push(r2), e2.push(o2);
        }
        function ee(e2, t2, r2, o2, i2, n3) {
          var s4 = (n3 - t2) / (o2 - t2);
          return e2.push(n3), e2.push(r2 + (i2 - r2) * s4), e2.push(1), s4;
        }
        function te(e2, t2, r2, o2, i2, n3) {
          var s4 = (n3 - r2) / (i2 - r2);
          return e2.push(t2 + (o2 - t2) * s4), e2.push(n3), e2.push(1), s4;
        }
        function re(e2, t2) {
          for (var r2 = [], o2 = 0; o2 < e2.length; o2++) {
            var i2, n3 = e2[o2], s4 = n3.type;
            if ("Point" === s4 || "MultiPoint" === s4 || "LineString" === s4)
              i2 = oe(n3.geometry, t2);
            else if ("MultiLineString" === s4 || "Polygon" === s4) {
              i2 = [];
              for (var a2 = 0; a2 < n3.geometry.length; a2++)
                i2.push(oe(n3.geometry[a2], t2));
            } else if ("MultiPolygon" === s4)
              for (i2 = [], a2 = 0; a2 < n3.geometry.length; a2++) {
                for (var l3 = [], u3 = 0; u3 < n3.geometry[a2].length; u3++)
                  l3.push(oe(n3.geometry[a2][u3], t2));
                i2.push(l3);
              }
            r2.push(W(n3.id, s4, i2, n3.tags));
          }
          return r2;
        }
        function oe(e2, t2) {
          var r2 = [];
          r2.size = e2.size, void 0 !== e2.start && (r2.start = e2.start, r2.end = e2.end);
          for (var o2 = 0; o2 < e2.length; o2 += 3)
            r2.push(e2[o2] + t2, e2[o2 + 1], e2[o2 + 2]);
          return r2;
        }
        function ie(e2, t2) {
          if (e2.transformed)
            return e2;
          var r2, o2, i2, n3 = 1 << e2.z, s4 = e2.x, a2 = e2.y;
          for (r2 = 0; r2 < e2.features.length; r2++) {
            var l3 = e2.features[r2], u3 = l3.geometry, h3 = l3.type;
            if (l3.geometry = [], 1 === h3)
              for (o2 = 0; o2 < u3.length; o2 += 2)
                l3.geometry.push(ne(u3[o2], u3[o2 + 1], t2, n3, s4, a2));
            else
              for (o2 = 0; o2 < u3.length; o2++) {
                var c4 = [];
                for (i2 = 0; i2 < u3[o2].length; i2 += 2)
                  c4.push(ne(u3[o2][i2], u3[o2][i2 + 1], t2, n3, s4, a2));
                l3.geometry.push(c4);
              }
          }
          return e2.transformed = true, e2;
        }
        function ne(e2, t2, r2, o2, i2, n3) {
          return [Math.round(r2 * (e2 * o2 - i2)), Math.round(r2 * (t2 * o2 - n3))];
        }
        function se(e2, t2, r2, o2, i2) {
          for (var n3 = t2 === i2.maxZoom ? 0 : i2.tolerance / ((1 << t2) * i2.extent), s4 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r2, y: o2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
            s4.numFeatures++, ae(s4, e2[a2], n3, i2);
            var l3 = e2[a2].minX, u3 = e2[a2].minY, h3 = e2[a2].maxX, c4 = e2[a2].maxY;
            l3 < s4.minX && (s4.minX = l3), u3 < s4.minY && (s4.minY = u3), h3 > s4.maxX && (s4.maxX = h3), c4 > s4.maxY && (s4.maxY = c4);
          }
          return s4;
        }
        function ae(e2, t2, r2, o2) {
          var i2 = t2.geometry, n3 = t2.type, s4 = [];
          if ("Point" === n3 || "MultiPoint" === n3)
            for (var a2 = 0; a2 < i2.length; a2 += 3)
              s4.push(i2[a2]), s4.push(i2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === n3)
            le(s4, i2, e2, r2, false, false);
          else if ("MultiLineString" === n3 || "Polygon" === n3)
            for (a2 = 0; a2 < i2.length; a2++)
              le(s4, i2[a2], e2, r2, "Polygon" === n3, 0 === a2);
          else if ("MultiPolygon" === n3)
            for (var l3 = 0; l3 < i2.length; l3++) {
              var u3 = i2[l3];
              for (a2 = 0; a2 < u3.length; a2++)
                le(s4, u3[a2], e2, r2, true, 0 === a2);
            }
          if (s4.length) {
            var h3 = t2.tags || null;
            if ("LineString" === n3 && o2.lineMetrics) {
              for (var c4 in h3 = {}, t2.tags)
                h3[c4] = t2.tags[c4];
              h3.mapbox_clip_start = i2.start / i2.size, h3.mapbox_clip_end = i2.end / i2.size;
            }
            var f2 = { geometry: s4, type: "Polygon" === n3 || "MultiPolygon" === n3 ? 3 : "LineString" === n3 || "MultiLineString" === n3 ? 2 : 1, tags: h3 };
            null !== t2.id && (f2.id = t2.id), e2.features.push(f2);
          }
        }
        function le(e2, t2, r2, o2, i2, n3) {
          var s4 = o2 * o2;
          if (o2 > 0 && t2.size < (i2 ? s4 : o2))
            r2.numPoints += t2.length / 3;
          else {
            for (var a2 = [], l3 = 0; l3 < t2.length; l3 += 3)
              (0 === o2 || t2[l3 + 2] > s4) && (r2.numSimplified++, a2.push(t2[l3]), a2.push(t2[l3 + 1])), r2.numPoints++;
            i2 && function(e3, t3) {
              for (var r3 = 0, o3 = 0, i3 = e3.length, n4 = i3 - 2; o3 < i3; n4 = o3, o3 += 2)
                r3 += (e3[o3] - e3[n4]) * (e3[o3 + 1] + e3[n4 + 1]);
              if (r3 > 0 === t3)
                for (o3 = 0, i3 = e3.length; o3 < i3 / 2; o3 += 2) {
                  var s5 = e3[o3], a3 = e3[o3 + 1];
                  e3[o3] = e3[i3 - 2 - o3], e3[o3 + 1] = e3[i3 - 1 - o3], e3[i3 - 2 - o3] = s5, e3[i3 - 1 - o3] = a3;
                }
            }(a2, n3), e2.push(a2);
          }
        }
        function ue(e2, t2) {
          var r2 = (t2 = this.options = function(e3, t3) {
            for (var r3 in t3)
              e3[r3] = t3[r3];
            return e3;
          }(Object.create(this.options), t2)).debug;
          if (r2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t2.promoteId && t2.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var o2 = function(e3, t3) {
            var r3 = [];
            if ("FeatureCollection" === e3.type)
              for (var o3 = 0; o3 < e3.features.length; o3++)
                X(r3, e3.features[o3], t3, o3);
            else
              X(r3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
            return r3;
          }(e2, t2);
          this.tiles = {}, this.tileCoords = [], r2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o2 = function(e3, t3) {
            var r3 = t3.buffer / t3.extent, o3 = e3, i2 = R(e3, 1, -1 - r3, r3, 0, -1, 2, t3), n3 = R(e3, 1, 1 - r3, 2 + r3, 0, -1, 2, t3);
            return (i2 || n3) && (o3 = R(e3, 1, -r3, 1 + r3, 0, -1, 2, t3) || [], i2 && (o3 = re(i2, 1).concat(o3)), n3 && (o3 = o3.concat(re(n3, -1)))), o3;
          }(o2, t2), o2.length && this.splitTile(o2, 0, 0, 0), r2 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function he(e2, t2, r2) {
          return 32 * ((1 << e2) * r2 + t2) + e2;
        }
        function ce(t2, r2) {
          const o2 = t2.tileID.canonical;
          if (!this._geoJSONIndex)
            return r2(null, null);
          const i2 = this._geoJSONIndex.getTile(o2.z, o2.x, o2.y);
          if (!i2)
            return r2(null, null);
          const n3 = new class {
            constructor(t3) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t3.length, this._features = t3;
            }
            feature(t3) {
              return new class {
                constructor(t4) {
                  this._feature = t4, this.extent = e.EXTENT, this.type = t4.type, this.properties = t4.tags, "id" in t4 && !isNaN(t4.id) && (this.id = parseInt(t4.id, 10));
                }
                loadGeometry() {
                  if (1 === this._feature.type) {
                    const t4 = [];
                    for (const r3 of this._feature.geometry)
                      t4.push([new e.Point(r3[0], r3[1])]);
                    return t4;
                  }
                  {
                    const t4 = [];
                    for (const r3 of this._feature.geometry) {
                      const o3 = [];
                      for (const t5 of r3)
                        o3.push(new e.Point(t5[0], t5[1]));
                      t4.push(o3);
                    }
                    return t4;
                  }
                }
                toGeoJSON(e2, t4, r3) {
                  return l2.call(this, e2, t4, r3);
                }
              }(this._features[t3]);
            }
          }(i2.features);
          let s4 = T2(n3);
          0 === s4.byteOffset && s4.byteLength === s4.buffer.byteLength || (s4 = new Uint8Array(s4)), r2(null, { vectorTile: n3, rawData: s4.buffer });
        }
        ue.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, ue.prototype.splitTile = function(e2, t2, r2, o2, i2, n3, s4) {
          for (var a2 = [e2, t2, r2, o2], l3 = this.options, u3 = l3.debug; a2.length; ) {
            o2 = a2.pop(), r2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
            var h3 = 1 << t2, c4 = he(t2, r2, o2), f2 = this.tiles[c4];
            if (!f2 && (u3 > 1 && console.time("creation"), f2 = this.tiles[c4] = se(e2, t2, r2, o2, l3), this.tileCoords.push({ z: t2, x: r2, y: o2 }), u3)) {
              u3 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r2, o2, f2.numFeatures, f2.numPoints, f2.numSimplified), console.timeEnd("creation"));
              var p3 = "z" + t2;
              this.stats[p3] = (this.stats[p3] || 0) + 1, this.total++;
            }
            if (f2.source = e2, i2) {
              if (t2 === l3.maxZoom || t2 === i2)
                continue;
              var g2 = 1 << i2 - t2;
              if (r2 !== Math.floor(n3 / g2) || o2 !== Math.floor(s4 / g2))
                continue;
            } else if (t2 === l3.indexMaxZoom || f2.numPoints <= l3.indexMaxPoints)
              continue;
            if (f2.source = null, 0 !== e2.length) {
              u3 > 1 && console.time("clipping");
              var d3, m3, y2, v4, x2, w2, S2 = 0.5 * l3.buffer / l3.extent, M2 = 0.5 - S2, P3 = 0.5 + S2, b3 = 1 + S2;
              d3 = m3 = y2 = v4 = null, x2 = R(e2, h3, r2 - S2, r2 + P3, 0, f2.minX, f2.maxX, l3), w2 = R(e2, h3, r2 + M2, r2 + b3, 0, f2.minX, f2.maxX, l3), e2 = null, x2 && (d3 = R(x2, h3, o2 - S2, o2 + P3, 1, f2.minY, f2.maxY, l3), m3 = R(x2, h3, o2 + M2, o2 + b3, 1, f2.minY, f2.maxY, l3), x2 = null), w2 && (y2 = R(w2, h3, o2 - S2, o2 + P3, 1, f2.minY, f2.maxY, l3), v4 = R(w2, h3, o2 + M2, o2 + b3, 1, f2.minY, f2.maxY, l3), w2 = null), u3 > 1 && console.timeEnd("clipping"), a2.push(d3 || [], t2 + 1, 2 * r2, 2 * o2), a2.push(m3 || [], t2 + 1, 2 * r2, 2 * o2 + 1), a2.push(y2 || [], t2 + 1, 2 * r2 + 1, 2 * o2), a2.push(v4 || [], t2 + 1, 2 * r2 + 1, 2 * o2 + 1);
            }
          }
        }, ue.prototype.getTile = function(e2, t2, r2) {
          var o2 = this.options, i2 = o2.extent, n3 = o2.debug;
          if (e2 < 0 || e2 > 24)
            return null;
          var s4 = 1 << e2, a2 = he(e2, t2 = (t2 % s4 + s4) % s4, r2);
          if (this.tiles[a2])
            return ie(this.tiles[a2], i2);
          n3 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r2);
          for (var l3, u3 = e2, h3 = t2, c4 = r2; !l3 && u3 > 0; )
            u3--, h3 = Math.floor(h3 / 2), c4 = Math.floor(c4 / 2), l3 = this.tiles[he(u3, h3, c4)];
          return l3 && l3.source ? (n3 > 1 && console.log("found parent tile z%d-%d-%d", u3, h3, c4), n3 > 1 && console.time("drilling down"), this.splitTile(l3.source, u3, h3, c4, e2, t2, r2), n3 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ie(this.tiles[a2], i2) : null) : null;
        };
        class fe extends e.VectorTileWorkerSource {
          constructor(e2, t2, r2, o2, i2) {
            super(e2, t2, r2, o2, ce), i2 && (this.loadGeoJSON = i2);
          }
          loadData(t2, r2) {
            const o2 = t2 && t2.request, i2 = o2 && o2.collectResourceTiming;
            this.loadGeoJSON(t2, (n3, s4) => {
              if (n3 || !s4)
                return r2(n3);
              if ("object" != typeof s4)
                return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              {
                a(s4, true);
                try {
                  if (t2.filter) {
                    const r3 = e.createExpression(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === r3.result)
                      throw new Error(r3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                    const o3 = s4.features.filter((e2) => r3.value.evaluate({ zoom: 0 }, e2));
                    s4 = { type: "FeatureCollection", features: o3 };
                  }
                  this._geoJSONIndex = t2.cluster ? new E(function({ superclusterOptions: t3, clusterProperties: r3 }) {
                    if (!r3 || !t3)
                      return t3;
                    const o3 = {}, i3 = {}, n4 = { accumulated: null, zoom: 0 }, s5 = { properties: null }, a2 = Object.keys(r3);
                    for (const t4 of a2) {
                      const [n5, s6] = r3[t4], a3 = e.createExpression(s6), l4 = e.createExpression("string" == typeof n5 ? [n5, ["accumulated"], ["get", t4]] : n5);
                      o3[t4] = a3.value, i3[t4] = l4.value;
                    }
                    return t3.map = (e2) => {
                      s5.properties = e2;
                      const t4 = {};
                      for (const e3 of a2)
                        t4[e3] = o3[e3].evaluate(n4, s5);
                      return t4;
                    }, t3.reduce = (e2, t4) => {
                      s5.properties = t4;
                      for (const t5 of a2)
                        n4.accumulated = e2[t5], e2[t5] = i3[t5].evaluate(n4, s5);
                    }, t3;
                  }(t2)).load(s4.features) : function(e2, t3) {
                    return new ue(e2, t3);
                  }(s4, t2.geojsonVtOptions);
                } catch (n4) {
                  return r2(n4);
                }
                this.loaded = {};
                const l3 = {};
                if (i2) {
                  const r3 = e.getPerformanceMeasurement(o2);
                  r3 && (l3.resourceTiming = {}, l3.resourceTiming[t2.source] = JSON.parse(JSON.stringify(r3)));
                }
                r2(null, l3);
              }
            });
          }
          reloadTile(e2, t2) {
            const r2 = this.loaded;
            return r2 && r2[e2.uid] ? super.reloadTile(e2, t2) : this.loadTile(e2, t2);
          }
          loadGeoJSON(t2, r2) {
            if (t2.request)
              e.getJSON(t2.request, r2);
            else {
              if ("string" != typeof t2.data)
                return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              try {
                return r2(null, JSON.parse(t2.data));
              } catch (e2) {
                return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          getClusterExpansionZoom(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
            } catch (e3) {
              t2(e3);
            }
          }
          getClusterChildren(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
            } catch (e3) {
              t2(e3);
            }
          }
          getClusterLeaves(e2, t2) {
            try {
              t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
            } catch (e3) {
              t2(e3);
            }
          }
        }
        class pe {
          constructor(t2) {
            this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: e.VectorTileWorkerSource, geojson: fe }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
              if (this.workerSourceTypes[e2])
                throw new Error(`Worker source with name "${e2}" already registered.`);
              this.workerSourceTypes[e2] = t3;
            }, this.self.registerRTLTextPlugin = (t3) => {
              if (e.plugin.isParsed())
                throw new Error("RTL text plugin already registered.");
              e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
            };
          }
          clearCaches(e2, t2, r2) {
            delete this.layerIndexes[e2], delete this.availableImages[e2], delete this.workerSources[e2], delete this.demWorkerSources[e2], r2();
          }
          checkIfReady(e2, t2, r2) {
            r2();
          }
          setReferrer(e2, t2) {
            this.referrer = t2;
          }
          spriteLoaded(t2, r2) {
            this.isSpriteLoaded[t2] = r2;
            for (const o2 in this.workerSources[t2]) {
              const i2 = this.workerSources[t2][o2];
              for (const t3 in i2)
                i2[t3] instanceof e.VectorTileWorkerSource && (i2[t3].isSpriteLoaded = r2, i2[t3].fire(new e.Event("isSpriteLoaded")));
            }
          }
          setImages(e2, t2, r2) {
            this.availableImages[e2] = t2;
            for (const r3 in this.workerSources[e2]) {
              const o2 = this.workerSources[e2][r3];
              for (const e3 in o2)
                o2[e3].availableImages = t2;
            }
            r2();
          }
          enableTerrain(e2, t2, r2) {
            this.terrain = t2, r2();
          }
          setProjection(t2, r2) {
            this.projections[t2] = e.getProjection(r2);
          }
          setLayers(e2, t2, r2) {
            this.getLayerIndex(e2).replace(t2), r2();
          }
          updateLayers(e2, t2, r2) {
            this.getLayerIndex(e2).update(t2.layers, t2.removedIds), r2();
          }
          loadTile(t2, r2, o2) {
            const i2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r2) : r2;
            i2.projection = this.projections[t2] || this.defaultProjection, this.getWorkerSource(t2, r2.type, r2.source).loadTile(i2, o2);
          }
          loadDEMTile(t2, r2, o2) {
            const i2 = this.enableTerrain ? e.extend({ buildQuadTree: this.terrain }, r2) : r2;
            this.getDEMWorkerSource(t2, r2.source).loadTile(i2, o2);
          }
          reloadTile(t2, r2, o2) {
            const i2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r2) : r2;
            i2.projection = this.projections[t2] || this.defaultProjection, this.getWorkerSource(t2, r2.type, r2.source).reloadTile(i2, o2);
          }
          abortTile(e2, t2, r2) {
            this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, r2);
          }
          removeTile(e2, t2, r2) {
            this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, r2);
          }
          removeSource(e2, t2, r2) {
            if (!this.workerSources[e2] || !this.workerSources[e2][t2.type] || !this.workerSources[e2][t2.type][t2.source])
              return;
            const o2 = this.workerSources[e2][t2.type][t2.source];
            delete this.workerSources[e2][t2.type][t2.source], void 0 !== o2.removeSource ? o2.removeSource(t2, r2) : r2();
          }
          loadWorkerSource(e2, t2, r2) {
            try {
              this.self.importScripts(t2.url), r2();
            } catch (e3) {
              r2(e3.toString());
            }
          }
          syncRTLPluginState(t2, r2, o2) {
            try {
              e.plugin.setState(r2);
              const t3 = e.plugin.getPluginURL();
              if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t3) {
                this.self.importScripts(t3);
                const r3 = e.plugin.isParsed();
                o2(r3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), r3);
              }
            } catch (e2) {
              o2(e2.toString());
            }
          }
          getAvailableImages(e2) {
            let t2 = this.availableImages[e2];
            return t2 || (t2 = []), t2;
          }
          getLayerIndex(e2) {
            let t2 = this.layerIndexes[e2];
            return t2 || (t2 = this.layerIndexes[e2] = new o()), t2;
          }
          getWorkerSource(e2, t2, r2) {
            if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][r2]) {
              const o2 = { send: (t3, r3, o3, i2, n3, s4) => {
                this.actor.send(t3, r3, o3, e2, n3, s4);
              }, scheduler: this.actor.scheduler };
              this.workerSources[e2][t2][r2] = new this.workerSourceTypes[t2](o2, this.getLayerIndex(e2), this.getAvailableImages(e2), this.isSpriteLoaded[e2]);
            }
            return this.workerSources[e2][t2][r2];
          }
          getDEMWorkerSource(e2, t2) {
            return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new i()), this.demWorkerSources[e2][t2];
          }
          enforceCacheSizeLimit(t2, r2) {
            e.enforceCacheSizeLimit(r2);
          }
          getWorkerPerformanceMetrics(e2, t2, r2) {
            r2(void 0, void 0);
          }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new pe(self)), pe;
      });
      define2(["./shared"], function(e) {
        "use strict";
        function t(e2, i2) {
          if (Array.isArray(e2)) {
            if (!Array.isArray(i2) || e2.length !== i2.length)
              return false;
            for (let o2 = 0; o2 < e2.length; o2++)
              if (!t(e2[o2], i2[o2]))
                return false;
            return true;
          }
          if ("object" == typeof e2 && null !== e2 && null !== i2) {
            if ("object" != typeof i2)
              return false;
            if (Object.keys(e2).length !== Object.keys(i2).length)
              return false;
            for (const o2 in e2)
              if (!t(e2[o2], i2[o2]))
                return false;
            return true;
          }
          return e2 === i2;
        }
        var i = o;
        function o(e2) {
          return !function(e3) {
            return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window))
                return false;
              var e4, t3, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
              try {
                t3 = new Worker(o2), e4 = true;
              } catch (t4) {
                e4 = false;
              }
              return t3 && t3.terminate(), URL.revokeObjectURL(o2), e4;
            }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
              var e4 = document.createElement("canvas");
              e4.width = e4.height = 1;
              var t3 = e4.getContext("2d");
              if (!t3)
                return false;
              var i2 = t3.getImageData(0, 0, 1, 1);
              return i2 && i2.width === e4.width;
            }() ? (void 0 === r[t2 = e3 && e3.failIfMajorPerformanceCaveat] && (r[t2] = function(e4) {
              var t3, i2 = function(e5) {
                var t4 = document.createElement("canvas"), i3 = Object.create(o.webGLContextAttributes);
                return i3.failIfMajorPerformanceCaveat = e5, t4.getContext("webgl", i3) || t4.getContext("experimental-webgl", i3);
              }(e4);
              if (!i2)
                return false;
              try {
                t3 = i2.createShader(i2.VERTEX_SHADER);
              } catch (e5) {
                return false;
              }
              return !(!t3 || i2.isContextLost()) && (i2.shaderSource(t3, "void main() {}"), i2.compileShader(t3), true === i2.getShaderParameter(t3, i2.COMPILE_STATUS));
            }(t2)), r[t2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            var t2;
          }(e2);
        }
        var r = {};
        function n2(t2, i2, o2) {
          const r2 = e.window.document.createElement(t2);
          return void 0 !== i2 && (r2.className = i2), o2 && o2.appendChild(r2), r2;
        }
        function s3(t2, i2, o2) {
          const r2 = e.window.document.createElementNS("http://www.w3.org/2000/svg", t2);
          for (const e2 of Object.keys(i2))
            r2.setAttributeNS(null, e2, i2[e2]);
          return o2 && o2.appendChild(r2), r2;
        }
        o.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
        const a = e.window.document && e.window.document.documentElement.style, l2 = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";
        let c3;
        function h2() {
          a && l2 && (c3 = a[l2], a[l2] = "none");
        }
        function u2() {
          a && l2 && (a[l2] = c3);
        }
        function _(t2) {
          t2.preventDefault(), t2.stopPropagation(), e.window.removeEventListener("click", _, true);
        }
        function d2() {
          e.window.addEventListener("click", _, true), e.window.setTimeout(() => {
            e.window.removeEventListener("click", _, true);
          }, 0);
        }
        function p2(e2, t2) {
          const i2 = e2.getBoundingClientRect();
          return g(e2, i2, t2);
        }
        function m2(e2, t2) {
          const i2 = e2.getBoundingClientRect(), o2 = [];
          for (let r2 = 0; r2 < t2.length; r2++)
            o2.push(g(e2, i2, t2[r2]));
          return o2;
        }
        function f(t2) {
          return void 0 !== e.window.InstallTrigger && 2 === t2.button && t2.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t2.button;
        }
        function g(t2, i2, o2) {
          const r2 = t2.offsetWidth === i2.width ? 1 : t2.offsetWidth / i2.width;
          return new e.Point((o2.clientX - i2.left) * r2, (o2.clientY - i2.top) * r2);
        }
        function v3(e2, t2) {
          var i2 = t2[0], o2 = t2[1], r2 = t2[2], n3 = t2[3], s4 = i2 * n3 - r2 * o2;
          return s4 ? (e2[0] = n3 * (s4 = 1 / s4), e2[1] = -o2 * s4, e2[2] = -r2 * s4, e2[3] = i2 * s4, e2) : null;
        }
        function x(e2) {
          const { userImage: t2 } = e2;
          return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
        }
        class y extends e.Evented {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e2) {
            if (this.loaded !== e2 && (this.loaded = e2, e2)) {
              for (const { ids: e3, callback: t2 } of this.requestors)
                this._notify(e3, t2);
              this.requestors = [];
            }
          }
          hasImage(e2) {
            return !!this.getImage(e2);
          }
          getImage(e2) {
            return this.images[e2];
          }
          addImage(e2, t2) {
            this._validate(e2, t2) && (this.images[e2] = t2);
          }
          _validate(t2, i2) {
            let o2 = true;
            return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "content" value`))), o2 = false), o2;
          }
          _validateStretch(e2, t2) {
            if (!e2)
              return true;
            let i2 = 0;
            for (const o2 of e2) {
              if (o2[0] < i2 || o2[1] < o2[0] || t2 < o2[1])
                return false;
              i2 = o2[1];
            }
            return true;
          }
          _validateContent(e2, t2) {
            return !(e2 && (4 !== e2.length || e2[0] < 0 || t2.data.width < e2[0] || e2[1] < 0 || t2.data.height < e2[1] || e2[2] < 0 || t2.data.width < e2[2] || e2[3] < 0 || t2.data.height < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]));
          }
          updateImage(e2, t2) {
            t2.version = this.images[e2].version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
          }
          removeImage(e2) {
            const t2 = this.images[e2];
            delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e2, t2) {
            let i2 = true;
            if (!this.isLoaded())
              for (const t3 of e2)
                this.images[t3] || (i2 = false);
            this.isLoaded() || i2 ? this._notify(e2, t2) : this.requestors.push({ ids: e2, callback: t2 });
          }
          _notify(t2, i2) {
            const o2 = {};
            for (const i3 of t2) {
              this.images[i3] || this.fire(new e.Event("styleimagemissing", { id: i3 }));
              const t3 = this.images[i3];
              t3 ? o2[i3] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            i2(null, o2);
          }
          getPixelSize() {
            const { width: e2, height: t2 } = this.atlasImage;
            return { width: e2, height: t2 };
          }
          getPattern(t2) {
            const i2 = this.patterns[t2], o2 = this.getImage(t2);
            if (!o2)
              return null;
            if (i2 && i2.position.version === o2.version)
              return i2.position;
            if (i2)
              i2.position.version = o2.version;
            else {
              const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, r2 = new e.ImagePosition(i3, o2);
              this.patterns[t2] = { bin: i3, position: r2 };
            }
            return this._updatePatternAtlas(), this.patterns[t2].position;
          }
          bind(t2) {
            const i2 = t2.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new e.Texture(t2, this.atlasImage, i2.RGBA), this.atlasTexture && this.atlasTexture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t2 = [];
            for (const e2 in this.patterns)
              t2.push(this.patterns[e2].bin);
            const { w: i2, h: o2 } = e.potpack(t2), r2 = this.atlasImage;
            r2.resize({ width: i2 || 1, height: o2 || 1 });
            for (const t3 in this.patterns) {
              const { bin: i3 } = this.patterns[t3], o3 = i3.x + 1, n3 = i3.y + 1, s4 = this.images[t3].data, a2 = s4.width, l3 = s4.height;
              e.RGBAImage.copy(s4, r2, { x: 0, y: 0 }, { x: o3, y: n3 }, { width: a2, height: l3 }), e.RGBAImage.copy(s4, r2, { x: 0, y: l3 - 1 }, { x: o3, y: n3 - 1 }, { width: a2, height: 1 }), e.RGBAImage.copy(s4, r2, { x: 0, y: 0 }, { x: o3, y: n3 + l3 }, { width: a2, height: 1 }), e.RGBAImage.copy(s4, r2, { x: a2 - 1, y: 0 }, { x: o3 - 1, y: n3 }, { width: 1, height: l3 }), e.RGBAImage.copy(s4, r2, { x: 0, y: 0 }, { x: o3 + a2, y: n3 }, { width: 1, height: l3 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e2) {
            for (const t2 of e2) {
              if (this.callbackDispatchedThisFrame[t2])
                continue;
              this.callbackDispatchedThisFrame[t2] = true;
              const e3 = this.images[t2];
              x(e3) && this.updateImage(t2, e3);
            }
          }
        }
        const b2 = new e.Properties({ anchor: new e.DataConstantProperty(e.spec.light.anchor), position: new class {
          constructor() {
            this.specification = e.spec.light.position;
          }
          possiblyEvaluate(t2, i2) {
            return function([t3, i3, o2]) {
              const r2 = e.degToRad(i3 + 90), n3 = e.degToRad(o2);
              return { x: t3 * Math.cos(r2) * Math.sin(n3), y: t3 * Math.sin(r2) * Math.sin(n3), z: t3 * Math.cos(n3), azimuthal: i3, polar: o2 };
            }(t2.expression.evaluate(i2));
          }
          interpolate(t2, i2, o2) {
            return { x: e.number(t2.x, i2.x, o2), y: e.number(t2.y, i2.y, o2), z: e.number(t2.z, i2.z, o2), azimuthal: e.number(t2.azimuthal, i2.azimuthal, o2), polar: e.number(t2.polar, i2.polar, o2) };
          }
        }(), color: new e.DataConstantProperty(e.spec.light.color), intensity: new e.DataConstantProperty(e.spec.light.intensity) });
        class w extends e.Evented {
          constructor(t2) {
            super(), this._transitionable = new e.Transitionable(b2), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t2, i2 = {}) {
            if (!this._validate(e.validateLight, t2, i2))
              for (const i3 in t2) {
                const o2 = t2[i3];
                e.endsWith(i3, "-transition") ? this._transitionable.setTransition(i3.slice(0, -11), o2) : this._transitionable.setValue(i3, o2);
              }
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(t2, i2, o2) {
            return (!o2 || false !== o2.validate) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
          }
        }
        const T2 = new e.Properties({ source: new e.DataConstantProperty(e.spec.terrain.source), exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration) });
        let E = class extends e.Evented {
          constructor(t2, i2) {
            super(), this._transitionable = new e.Transitionable(T2), this.set(t2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2;
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t2) {
            for (const i2 in t2) {
              const o2 = t2[i2];
              e.endsWith(i2, "-transition") ? this._transitionable.setTransition(i2.slice(0, -11), o2) : this._transitionable.setValue(i2, o2);
            }
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
        };
        function C2(t2, i2, o2, r2) {
          const n3 = e.smoothstep(45, 65, o2), [s4, a2] = M(t2, r2), l3 = e.length(i2);
          let c4 = 1 - Math.min(1, Math.exp((l3 - s4) / (a2 - s4) * -6));
          return c4 *= c4 * c4, c4 = Math.min(1, 1.00747 * c4), c4 * n3 * t2.alpha;
        }
        function M(e2, t2) {
          const i2 = 0.5 / Math.tan(0.5 * t2);
          return [e2.range[0] + i2, e2.range[1] + i2];
        }
        const I = new e.Properties({ range: new e.DataConstantProperty(e.spec.fog.range), color: new e.DataConstantProperty(e.spec.fog.color), "high-color": new e.DataConstantProperty(e.spec.fog["high-color"]), "space-color": new e.DataConstantProperty(e.spec.fog["space-color"]), "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"]), "star-intensity": new e.DataConstantProperty(e.spec.fog["star-intensity"]) });
        class P2 extends e.Evented {
          constructor(t2, i2) {
            super(), this._transitionable = new e.Transitionable(I), this.set(t2), this._transitioning = this._transitionable.untransitioned(), this._transform = i2;
          }
          get state() {
            const t2 = this._transform, i2 = "globe" === t2.projection.name, o2 = e.globeToMercatorTransition(t2.zoom), r2 = this.properties.get("range"), n3 = [0.5, 3];
            return { range: i2 ? [e.number(n3[0], r2[0], o2), e.number(n3[1], r2[1], o2)] : r2, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t2, i2 = {}) {
            if (!this._validate(e.validateFog, t2, i2)) {
              for (const i3 of Object.keys(e.spec.fog))
                t2 && void 0 === t2[i3] && (t2[i3] = e.spec.fog[i3].default);
              for (const i3 in t2) {
                const o2 = t2[i3];
                e.endsWith(i3, "-transition") ? this._transitionable.setTransition(i3.slice(0, -11), o2) : this._transitionable.setValue(i3, o2);
              }
            }
          }
          getOpacity(t2) {
            if (!this._transform.projection.supportsFog)
              return 0;
            const i2 = this.properties && this.properties.get("color") || 1;
            return ("globe" === this._transform.projection.name ? 1 : e.smoothstep(45, 65, t2)) * i2.a;
          }
          getOpacityAtLatLng(t2, i2) {
            return this._transform.projection.supportsFog ? function(t3, i3, o2) {
              const r2 = e.MercatorCoordinate.fromLngLat(i3), n3 = o2.elevation ? o2.elevation.getAtPointOrZero(r2) : 0, s4 = [r2.x, r2.y, n3];
              return e.transformMat4(s4, s4, o2.mercatorFogMatrix), C2(t3, s4, o2.pitch, o2._fov);
            }(this.state, t2, i2) : 0;
          }
          getFovAdjustedRange(e2) {
            return this._transform.projection.supportsFog ? M(this.state, e2) : [0, 1];
          }
          updateTransitions(e2) {
            this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e2) {
            this.properties = this._transitioning.possiblyEvaluate(e2);
          }
          _validate(t2, i2, o2) {
            return (!o2 || false !== o2.validate) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
          }
        }
        class S {
          constructor(t2, i2) {
            this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();
            const o2 = this.workerPool.acquire(this.id);
            for (let e2 = 0; e2 < o2.length; e2++) {
              const t3 = new S.Actor(o2[e2], i2, this.id);
              t3.name = `Worker ${e2}`, this.actors.push(t3);
            }
            this.ready = false, this.broadcast("checkIfReady", null, () => {
              this.ready = true;
            });
          }
          broadcast(t2, i2, o2) {
            e.asyncAll(this.actors, (e2, o3) => {
              e2.send(t2, i2, o3);
            }, o2 = o2 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((e2) => {
              e2.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        function D(t2, i2, o2) {
          return i2 * (e.EXTENT / (t2.tileSize * Math.pow(2, o2 - t2.tileID.overscaledZ)));
        }
        S.Actor = e.Actor;
        class L {
          constructor(e2, t2, i2, o2) {
            this.screenBounds = e2, this.cameraPoint = t2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
          }
          static createFromScreenPoints(t2, i2) {
            let o2, r2;
            if (t2 instanceof e.Point || "number" == typeof t2[0]) {
              const n3 = e.Point.convert(t2);
              o2 = [n3], r2 = i2.isPointAboveHorizon(n3);
            } else {
              const n3 = e.Point.convert(t2[0]), s4 = e.Point.convert(t2[1]);
              o2 = [n3, s4], r2 = e.polygonizeBounds(n3, s4).every((e2) => i2.isPointAboveHorizon(e2));
            }
            return new L(o2, i2.getCameraPoint(), r2, i2);
          }
          isPointQuery() {
            return 1 === this.screenBounds.length;
          }
          bufferedScreenGeometry(t2) {
            return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t2);
          }
          bufferedCameraGeometry(t2) {
            const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.Point(1, 1)) : this.screenBounds[1], r2 = e.polygonizeBounds(i2, o2, 0, false);
            return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r2.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r2[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r2[3] = this.cameraPoint)), e.bufferConvexPolygon(r2, t2);
          }
          bufferedCameraGeometryGlobe(t2) {
            const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.Point(1, 1)) : this.screenBounds[1], r2 = e.polygonizeBounds(i2, o2, t2), n3 = this.cameraPoint.clone();
            switch (3 * ((n3.y > i2.y) + (n3.y > o2.y)) + ((n3.x > i2.x) + (n3.x > o2.x))) {
              case 0:
                r2[0] = n3, r2[4] = n3.clone();
                break;
              case 1:
                r2.splice(1, 0, n3);
                break;
              case 2:
                r2[1] = n3;
                break;
              case 3:
                r2.splice(4, 0, n3);
                break;
              case 5:
                r2.splice(2, 0, n3);
                break;
              case 6:
                r2[3] = n3;
                break;
              case 7:
                r2.splice(3, 0, n3);
                break;
              case 8:
                r2[2] = n3;
            }
            return r2;
          }
          containsTile(t2, i2, o2, r2 = 0) {
            const n3 = t2.queryPadding / i2._pixelsPerMercatorPixel + 1, s4 = o2 ? this._bufferedCameraMercator(n3, i2) : this._bufferedScreenMercator(n3, i2);
            let a2 = t2.tileID.wrap + (s4.unwrapped ? r2 : 0);
            const l3 = s4.polygon.map((i3) => e.getTilePoint(t2.tileTransform, i3, a2));
            if (!e.polygonIntersectsBox(l3, 0, 0, e.EXTENT, e.EXTENT))
              return;
            a2 = t2.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r2 : 0);
            const c4 = this.screenGeometryMercator.polygon.map((i3) => e.getTileVec3(t2.tileTransform, i3, a2)), h3 = c4.map((t3) => new e.Point(t3[0], t3[1])), u3 = i2.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0), _2 = e.getTileVec3(t2.tileTransform, u3, a2), d3 = c4.map((t3) => {
              const i3 = e.sub(t3, t3, _2);
              return e.normalize(i3, i3), new e.Ray(_2, i3);
            }), p3 = D(t2, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
            return { queryGeometry: this, tilespaceGeometry: h3, tilespaceRays: d3, bufferedTilespaceGeometry: l3, bufferedTilespaceBounds: (m3 = e.getBounds(l3), m3.min.x = e.clamp(m3.min.x, 0, e.EXTENT), m3.min.y = e.clamp(m3.min.y, 0, e.EXTENT), m3.max.x = e.clamp(m3.max.x, 0, e.EXTENT), m3.max.y = e.clamp(m3.max.y, 0, e.EXTENT), m3), tile: t2, tileID: t2.tileID, pixelToTileUnitsFactor: p3 };
            var m3;
          }
          _bufferedScreenMercator(e2, t2) {
            const i2 = R(e2);
            if (this._screenRaycastCache[i2])
              return this._screenRaycastCache[i2];
            {
              let o2;
              return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e2), t2) : { polygon: this.bufferedScreenGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
            }
          }
          _bufferedCameraMercator(e2, t2) {
            const i2 = R(e2);
            if (this._cameraRaycastCache[i2])
              return this._cameraRaycastCache[i2];
            {
              let o2;
              return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e2), t2) : { polygon: this.bufferedCameraGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
            }
          }
          _projectAndResample(t2, i2) {
            const o2 = function(t3, i3) {
              const o3 = e.multiply([], i3.pixelMatrix, i3.globeMatrix), r3 = [0, -e.GLOBE_RADIUS, 0, 1], n3 = [0, e.GLOBE_RADIUS, 0, 1], s4 = [0, 0, 0, 1];
              e.transformMat4$1(r3, r3, o3), e.transformMat4$1(n3, n3, o3), e.transformMat4$1(s4, s4, o3);
              const a2 = new e.Point(r3[0] / r3[3], r3[1] / r3[3]), l3 = new e.Point(n3[0] / n3[3], n3[1] / n3[3]), c4 = e.polygonContainsPoint(t3, a2) && r3[3] < s4[3], h3 = e.polygonContainsPoint(t3, l3) && n3[3] < s4[3];
              if (!c4 && !h3)
                return null;
              const u3 = function(e2, t4, i4) {
                for (let o4 = 1; o4 < e2.length; o4++) {
                  const r4 = z(t4.pointCoordinate3D(e2[o4 - 1]).x), n4 = z(t4.pointCoordinate3D(e2[o4]).x);
                  if (i4 < 0) {
                    if (r4 < n4)
                      return { idx: o4, t: -r4 / (n4 - 1 - r4) };
                  } else if (n4 < r4)
                    return { idx: o4, t: (1 - r4) / (n4 + 1 - r4) };
                }
                return null;
              }(t3, i3, c4 ? -1 : 1);
              if (!u3)
                return null;
              const { idx: _2, t: d3 } = u3;
              let p3 = _2 > 1 ? A(t3.slice(0, _2), i3) : [], m3 = _2 < t3.length ? A(t3.slice(_2), i3) : [];
              p3 = p3.map((t4) => new e.Point(z(t4.x), t4.y)), m3 = m3.map((t4) => new e.Point(z(t4.x), t4.y));
              const f2 = [...p3];
              0 === f2.length && f2.push(m3[m3.length - 1]);
              const g2 = e.number(f2[f2.length - 1].y, (0 === m3.length ? p3[0] : m3[0]).y, d3);
              let v4;
              return v4 = c4 ? [new e.Point(0, g2), new e.Point(0, 0), new e.Point(1, 0), new e.Point(1, g2)] : [new e.Point(1, g2), new e.Point(1, 1), new e.Point(0, 1), new e.Point(0, g2)], f2.push(...v4), 0 === m3.length ? f2.push(p3[0]) : f2.push(...m3), { polygon: f2.map((t4) => new e.MercatorCoordinate(t4.x, t4.y)), unwrapped: false };
            }(t2, i2);
            if (o2)
              return o2;
            const r2 = function(t3, i3) {
              let o3 = false, r3 = -1 / 0, n3 = 0;
              for (let e2 = 0; e2 < t3.length - 1; e2++)
                t3[e2].x > r3 && (r3 = t3[e2].x, n3 = e2);
              for (let e2 = 0; e2 < t3.length - 1; e2++) {
                const i4 = (n3 + e2) % (t3.length - 1), r4 = t3[i4], s5 = t3[i4 + 1];
                Math.abs(r4.x - s5.x) > 0.5 && (r4.x < s5.x ? (r4.x += 1, 0 === i4 && (t3[t3.length - 1].x += 1)) : (s5.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
              }
              const s4 = e.mercatorXfromLng(i3.center.lng);
              return o3 && s4 < Math.abs(s4 - 1) && t3.forEach((e2) => {
                e2.x -= 1;
              }), { polygon: t3, unwrapped: o3 };
            }(A(t2, i2).map((t3) => new e.Point(z(t3.x), t3.y)), i2);
            return { polygon: r2.polygon.map((t3) => new e.MercatorCoordinate(t3.x, t3.y)), unwrapped: r2.unwrapped };
          }
        }
        function A(t2, i2) {
          return e.resample(t2, (e2) => {
            const t3 = i2.pointCoordinate3D(e2);
            e2.x = t3.x, e2.y = t3.y;
          }, 1 / 256);
        }
        function z(e2) {
          return e2 < 0 ? 1 + e2 % 1 : e2 % 1;
        }
        function R(e2) {
          return 100 * e2 | 0;
        }
        function O(t2, i2, o2, r2, n3) {
          const s4 = function(o3, r3) {
            if (o3)
              return n3(o3);
            if (r3) {
              t2.url && r3.tiles && t2.tiles && delete t2.tiles;
              const o4 = e.pick(e.extend(r3, t2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
              r3.vector_layers && (o4.vectorLayers = r3.vector_layers, o4.vectorLayerIds = o4.vectorLayers.map((e2) => e2.id)), o4.tiles = i2.canonicalizeTileset(o4, t2.url), n3(null, o4);
            }
          };
          return t2.url ? e.getJSON(i2.transformRequest(i2.normalizeSourceURL(t2.url, null, o2, r2), e.ResourceType.Source), s4) : e.exported.frame(() => s4(null, t2));
        }
        class B {
          constructor(t2, i2, o2) {
            this.bounds = e.LngLatBounds.convert(this.validateBounds(t2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
          }
          validateBounds(e2) {
            return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
          }
          contains(t2) {
            const i2 = Math.pow(2, t2.z), o2 = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i2), r2 = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i2), n3 = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i2), s4 = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i2);
            return t2.x >= o2 && t2.x < n3 && t2.y >= r2 && t2.y < s4;
          }
        }
        class k {
          constructor(e2, t2, i2) {
            this.context = e2;
            const o2 = e2.gl;
            this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || t2.destroy();
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e2) {
            const t2 = this.context.gl;
            this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const F = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class U {
          constructor(e2, t2, i2, o2) {
            this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = o2, this.context = e2;
            const r2 = e2.gl;
            this.buffer = r2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), r2.bufferData(r2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || t2.destroy();
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e2) {
            const t2 = this.context.gl;
            this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
          }
          enableAttributes(e2, t2) {
            for (let i2 = 0; i2 < this.attributes.length; i2++) {
              const o2 = t2.attributes[this.attributes[i2].name];
              void 0 !== o2 && e2.enableVertexAttribArray(o2);
            }
          }
          setVertexAttribPointers(e2, t2, i2) {
            for (let o2 = 0; o2 < this.attributes.length; o2++) {
              const r2 = this.attributes[o2], n3 = t2.attributes[r2.name];
              void 0 !== n3 && e2.vertexAttribPointer(n3, r2.components, e2[F[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class N {
          constructor(e2) {
            this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e2) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class j extends N {
          getDefault() {
            return e.Color.transparent;
          }
          set(e2) {
            const t2 = this.current;
            (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
          }
        }
        class G extends N {
          getDefault() {
            return 1;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
          }
        }
        class Z extends N {
          getDefault() {
            return 0;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
          }
        }
        class V extends N {
          getDefault() {
            return [true, true, true, true];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
          }
        }
        class W extends N {
          getDefault() {
            return true;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
          }
        }
        class X extends N {
          getDefault() {
            return 255;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
          }
        }
        class q extends N {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e2) {
            const t2 = this.current;
            (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
          }
        }
        class $ extends N {
          getDefault() {
            const e2 = this.gl;
            return [e2.KEEP, e2.KEEP, e2.KEEP];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
          }
        }
        class H extends N {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
          }
        }
        class Y extends N {
          getDefault() {
            return [0, 1];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
          }
        }
        class K extends N {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
          }
        }
        class J extends N {
          getDefault() {
            return this.gl.LESS;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
          }
        }
        class Q extends N {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
          }
        }
        class ee extends N {
          getDefault() {
            const e2 = this.gl;
            return [e2.ONE, e2.ZERO];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
          }
        }
        class te extends N {
          getDefault() {
            return e.Color.transparent;
          }
          set(e2) {
            const t2 = this.current;
            (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
          }
        }
        class ie extends N {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
          }
        }
        class oe extends N {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
          }
        }
        class re extends N {
          getDefault() {
            return this.gl.BACK;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
          }
        }
        class ne extends N {
          getDefault() {
            return this.gl.CCW;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
          }
        }
        let se, ae = class extends N {
          getDefault() {
            return null;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
          }
        };
        class le extends N {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e2) {
            (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
          }
        }
        class ce extends N {
          getDefault() {
            const e2 = this.gl;
            return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
          }
          set(e2) {
            const t2 = this.current;
            (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
          }
        }
        class he extends N {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class ue extends N {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class _e extends N {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
          }
        }
        class de extends N {
          getDefault() {
            return null;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class pe extends N {
          getDefault() {
            return null;
          }
          set(e2) {
            const t2 = this.gl;
            t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class me extends N {
          constructor(e2) {
            super(e2), this.vao = e2.extVertexArrayObject;
          }
          getDefault() {
            return null;
          }
          set(e2) {
            this.vao && (e2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e2), this.current = e2, this.dirty = false);
          }
        }
        class fe extends N {
          getDefault() {
            return 4;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
          }
        }
        class ge extends N {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
          }
        }
        class ve extends N {
          getDefault() {
            return false;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            const t2 = this.gl;
            t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
          }
        }
        class xe extends N {
          constructor(e2, t2) {
            super(e2), this.context = e2, this.parent = t2;
          }
          getDefault() {
            return null;
          }
        }
        class ye extends xe {
          setDirty() {
            this.dirty = true;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
          }
        }
        class be extends xe {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e2) {
            if (e2 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const t2 = this.gl;
            t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
          }
        }
        class we extends be {
          attachment() {
            return this.gl.DEPTH_STENCIL_ATTACHMENT;
          }
        }
        class Te {
          constructor(e2, t2, i2, o2) {
            this.context = e2, this.width = t2, this.height = i2;
            const r2 = this.framebuffer = e2.gl.createFramebuffer();
            this.colorAttachment = new ye(e2, r2), o2 && (this.depthAttachment = new be(e2, r2));
          }
          destroy() {
            const e2 = this.context.gl, t2 = this.colorAttachment.get();
            if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
              const t3 = this.depthAttachment.get();
              t3 && e2.deleteRenderbuffer(t3);
            }
            e2.deleteFramebuffer(this.framebuffer);
          }
        }
        class Ee {
          constructor(e2, t2 = false) {
            if (this.gl = e2, this.isWebGL2 = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t2) {
              const t3 = e2;
              this.extVertexArrayObject = { createVertexArrayOES: t3.createVertexArray.bind(e2), deleteVertexArrayOES: t3.deleteVertexArray.bind(e2), bindVertexArrayOES: t3.bindVertexArray.bind(e2) };
            }
            this.clearColor = new j(this), this.clearDepth = new G(this), this.clearStencil = new Z(this), this.colorMask = new V(this), this.depthMask = new W(this), this.stencilMask = new X(this), this.stencilFunc = new q(this), this.stencilOp = new $(this), this.stencilTest = new H(this), this.depthRange = new Y(this), this.depthTest = new K(this), this.depthFunc = new J(this), this.blend = new Q(this), this.blendFunc = new ee(this), this.blendColor = new te(this), this.blendEquation = new ie(this), this.cullFace = new oe(this), this.cullFaceSide = new re(this), this.frontFace = new ne(this), this.program = new ae(this), this.activeTexture = new le(this), this.viewport = new ce(this), this.bindFramebuffer = new he(this), this.bindRenderbuffer = new ue(this), this.bindTexture = new _e(this), this.bindVertexBuffer = new de(this), this.bindElementBuffer = new pe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new me(this), this.pixelStoreUnpack = new fe(this), this.pixelStoreUnpackPremultiplyAlpha = new ge(this), this.pixelStoreUnpackFlipY = new ve(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extStandardDerivativesForceOff = false, this.extDebugRendererInfo = e2.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e2.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e2.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t2 || (this.extTextureHalfFloat = e2.getExtension("OES_texture_half_float")), (t2 || this.extTextureHalfFloat && e2.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t2 || e2.getExtension("OES_standard_derivatives"), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE);
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e2, t2) {
            return new k(this, e2, t2);
          }
          createVertexBuffer(e2, t2, i2) {
            return new U(this, e2, t2, i2);
          }
          createRenderbuffer(e2, t2, i2) {
            const o2 = this.gl, r2 = o2.createRenderbuffer();
            return this.bindRenderbuffer.set(r2), o2.renderbufferStorage(o2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), r2;
          }
          createFramebuffer(e2, t2, i2) {
            return new Te(this, e2, t2, i2);
          }
          clear({ color: e2, depth: t2, stencil: i2 }) {
            const o2 = this.gl;
            let r2 = 0;
            e2 && (r2 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== t2 && (r2 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (r2 |= o2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), o2.clear(r2);
          }
          setCullFace(e2) {
            false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
          }
          setDepthMode(e2) {
            e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
          }
          setStencilMode(e2) {
            e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(i2) {
            t(i2.blendFunction, e.ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(i2.blendFunction), this.blendColor.set(i2.blendColor)), this.colorMask.set(i2.mask);
          }
          unbindVAO() {
            this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
          }
        }
        class Ce extends e.Evented {
          constructor(t2, i2, o2, r2) {
            if (super(), this.id = t2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.extend(this, e.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(r2), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();
          }
          load(t2) {
            this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" }));
            const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
            this._tileJSONRequest = O(this._options, this.map._requestManager, i2, o2, (r2, n3) => {
              this._tileJSONRequest = null, this._loaded = true, r2 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.ErrorEvent(r2))) : n3 && (e.extend(this, n3), n3.bounds && (this.tileBounds = new B(n3.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n3.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(r2);
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e2) {
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          reload() {
            this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
          }
          setTiles(e2) {
            return this._options.tiles = e2, this.reload(), this;
          }
          setUrl(e2) {
            return this.url = e2, this._options.url = e2, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e.extend({}, this._options);
          }
          loadTile(t2, i2) {
            const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t2.isSymbolTile };
            if (r2.request.collectResourceTiming = this._collectResourceTiming, t2.actor && "expired" !== t2.state)
              "loading" === t2.state ? t2.reloadCallback = i2 : t2.request = t2.actor.send("reloadTile", r2, n3.bind(this));
            else if (t2.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
              t2.request = t2.actor.send("loadTile", r2, n3.bind(this), void 0, true);
            else {
              const i3 = e.loadVectorTile.call({ deduped: this._deduped }, r2, (e2, i4) => {
                e2 || !i4 ? n3.call(this, e2) : (r2.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t2.actor && t2.actor.send("loadTile", r2, n3.bind(this), void 0, true));
              }, true);
              t2.request = { cancel: i3 };
            }
            function n3(o3, r3) {
              return delete t2.request, t2.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (r3 && r3.resourceTiming && (t2.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && t2.setExpiryData(r3), t2.loadVectorData(r3, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (t2.reloadCallback && (this.loadTile(t2, t2.reloadCallback), t2.reloadCallback = null)));
            }
          }
          abortTile(e2) {
            e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id });
          }
          unloadTile(e2) {
            e2.unloadVectorData(), e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
          }
          hasTransition() {
            return false;
          }
          afterUpdate() {
            this._tileWorkers = {};
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class Me extends e.Evented {
          constructor(t2, i2, o2, r2) {
            super(), this.id = t2, this.dispatcher = o2, this.setEventedParent(r2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.extend({ type: "raster" }, i2), e.extend(this, e.pick(i2, ["url", "scheme", "tileSize"]));
          }
          load(t2) {
            this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = O(this._options, this.map._requestManager, null, null, (i2, o2) => {
              this._tileJSONRequest = null, this._loaded = true, i2 ? this.fire(new e.ErrorEvent(i2)) : o2 && (e.extend(this, o2), o2.bounds && (this.tileBounds = new B(o2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(o2.tiles), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(i2);
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          reload() {
            this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
          }
          setTiles(e2) {
            return this._options.tiles = e2, this.reload(), this;
          }
          setUrl(e2) {
            return this.url = e2, this._options.url = e2, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e.extend({}, this._options);
          }
          hasTile(e2) {
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          loadTile(t2, i2) {
            const o2 = e.exported.devicePixelRatio >= 2, r2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
            t2.request = e.getImage(this.map._requestManager.transformRequest(r2, e.ResourceType.Tile), (o3, r3, n3, s4) => (delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : o3 ? (t2.state = "errored", i2(o3)) : r3 ? (this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: n3, expires: s4 }), t2.setTexture(r3, this.map.painter), t2.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), void i2(null)) : i2(null)));
          }
          static loadTileData(e2, t2, i2) {
            e2.setTexture(t2, i2);
          }
          static unloadTileData(e2, t2) {
            e2.texture && t2.saveTileTexture(e2.texture);
          }
          abortTile(e2, t2) {
            e2.request && (e2.request.cancel(), delete e2.request), t2();
          }
          unloadTile(e2, t2) {
            e2.texture && this.map.painter.saveTileTexture(e2.texture), t2();
          }
          hasTransition() {
            return false;
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        function Ie(t2, i2, o2, r2, n3, s4, a2, l3) {
          const c4 = [t2, o2, n3, i2, r2, s4, 1, 1, 1], h3 = [a2, l3, 1], u3 = e.adjoint([], c4), [_2, d3, p3] = e.transformMat3(h3, h3, e.transpose(u3, u3));
          return e.multiply$1(c4, [_2, 0, 0, 0, d3, 0, 0, 0, p3], c4);
        }
        class Pe extends e.Evented {
          constructor(e2, t2, i2, o2) {
            super(), this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = t2, this._dirty = false;
          }
          load(t2, i2) {
            this._loaded = i2 || false, this.fire(new e.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._imageRequest = e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i3, o2) => {
              if (this._imageRequest = null, this._loaded = true, i3)
                this.fire(new e.ErrorEvent(i3));
              else if (o2) {
                const { HTMLImageElement: i4 } = e.window;
                this.image = o2 instanceof i4 ? e.exported.getImageData(o2) : o2, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t2 && (this.coordinates = t2), this._finishLoading();
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e2) {
            return this.image && e2.url ? (this._imageRequest && e2.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e2.url, this.load(e2.coordinates, this._loaded), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e2) {
            this.map = e2, this.load();
          }
          onRemove() {
            this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
          }
          setCoordinates(t2) {
            this.coordinates = t2, this._boundsArray = void 0;
            const i2 = t2.map(e.MercatorCoordinate.fromLngLat);
            return this.tileID = function(t3) {
              let i3 = 1 / 0, o2 = 1 / 0, r2 = -1 / 0, n3 = -1 / 0;
              for (const e2 of t3)
                i3 = Math.min(i3, e2.x), o2 = Math.min(o2, e2.y), r2 = Math.max(r2, e2.x), n3 = Math.max(n3, e2.y);
              const s4 = Math.max(r2 - i3, n3 - o2), a2 = Math.max(0, Math.floor(-Math.log(s4) / Math.LN2)), l3 = Math.pow(2, a2);
              return new e.CanonicalTileID(a2, Math.floor((i3 + r2) / 2 * l3), Math.floor((o2 + n3) / 2 * l3));
            }(i2), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          _clear() {
            this._boundsArray = void 0;
          }
          _prepareData(t2) {
            for (const e2 in this.tiles) {
              const t3 = this.tiles[e2];
              "loaded" !== t3.state && (t3.state = "loaded", t3.texture = this.texture);
            }
            if (this._boundsArray)
              return;
            const i2 = e.tileTransform(this.tileID, this.map.transform.projection), [o2, r2, n3, s4] = this.coordinates.map((t3) => {
              const o3 = i2.projection.project(t3[0], t3[1]);
              return e.getTilePoint(i2, o3)._round();
            });
            this.perspectiveTransform = function(t3, i3, o3, r3, n4, s5, a3, l3, c4, h3) {
              const u3 = Ie(0, 0, t3, 0, 0, i3, t3, i3), _2 = Ie(o3, r3, n4, s5, a3, l3, c4, h3);
              return e.multiply$1(_2, e.adjoint(u3, u3), _2), [_2[6] / _2[8] * t3 / e.EXTENT, _2[7] / _2[8] * i3 / e.EXTENT];
            }(this.width, this.height, o2.x, o2.y, r2.x, r2.y, s4.x, s4.y, n3.x, n3.y);
            const a2 = this._boundsArray = new e.StructArrayLayout4i8();
            a2.emplaceBack(o2.x, o2.y, 0, 0), a2.emplaceBack(r2.x, r2.y, e.EXTENT, 0), a2.emplaceBack(s4.x, s4.y, 0, e.EXTENT), a2.emplaceBack(n3.x, n3.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t2.createVertexBuffer(a2, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image)
              return;
            const t2 = this.map.painter.context, i2 = t2.gl;
            this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE)), this._dirty = false), this._prepareData(t2);
          }
          loadTile(e2, t2) {
            this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}, t2(null)) : (e2.state = "errored", t2(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
        }
        const Se = { vector: Ce, raster: Me, "raster-dem": class extends Me {
          constructor(t2, i2, o2, r2) {
            super(t2, i2, o2, r2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
          }
          loadTile(t2, i2) {
            const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
            function r2(e2, o3) {
              e2 && (t2.state = "errored", i2(e2)), o3 && (t2.dem = o3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
            }
            t2.request = e.getImage(this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), (function(o3, n3, s4, a2) {
              if (delete t2.request, t2.aborted)
                t2.state = "unloaded", i2(null);
              else if (o3)
                t2.state = "errored", i2(o3);
              else if (n3) {
                this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: s4, expires: a2 });
                const i3 = e.window.ImageBitmap && n3 instanceof e.window.ImageBitmap && (null == se && (se = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.window.createImageBitmap), se), o4 = 1 - (n3.width - e.prevPowerOfTwo(n3.width)) / 2;
                o4 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
                const l3 = i3 ? n3 : e.exported.getImageData(n3, o4), c4 = { uid: t2.uid, coord: t2.tileID, source: this.id, rawImageData: l3, encoding: this.encoding, padding: o4 };
                t2.actor && "expired" !== t2.state || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadDEMTile", c4, r2.bind(this), void 0, true));
              }
            }).bind(this));
          }
          _getNeighboringTiles(t2) {
            const i2 = t2.canonical, o2 = Math.pow(2, i2.z), r2 = (i2.x - 1 + o2) % o2, n3 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, s4 = (i2.x + 1 + o2) % o2, a2 = i2.x + 1 === o2 ? t2.wrap + 1 : t2.wrap, l3 = {};
            return l3[new e.OverscaledTileID(t2.overscaledZ, n3, i2.z, r2, i2.y).key] = { backfilled: false }, l3[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s4, i2.y).key] = { backfilled: false }, i2.y > 0 && (l3[new e.OverscaledTileID(t2.overscaledZ, n3, i2.z, r2, i2.y - 1).key] = { backfilled: false }, l3[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l3[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s4, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l3[new e.OverscaledTileID(t2.overscaledZ, n3, i2.z, r2, i2.y + 1).key] = { backfilled: false }, l3[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l3[new e.OverscaledTileID(t2.overscaledZ, a2, i2.z, s4, i2.y + 1).key] = { backfilled: false }), l3;
          }
          unloadTile(e2) {
            e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded";
          }
        }, geojson: class extends e.Evented {
          constructor(t2, i2, o2, r2) {
            super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r2), this._data = i2.data, this._options = e.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
            const n3 = e.EXTENT / this.tileSize;
            this.workerOptions = e.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * n3, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * n3, extent: e.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.EXTENT, radius: (void 0 !== i2.clusterRadius ? i2.clusterRadius : 50) * n3, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
          }
          onAdd(e2) {
            this.map = e2, this.setData(this._data);
          }
          setData(e2) {
            return this._data = e2, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e2, t2) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id }, t2), this;
          }
          getClusterChildren(e2, t2) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id }, t2), this;
          }
          getClusterLeaves(e2, t2, i2, o2) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e2, limit: t2, offset: i2 }, o2), this;
          }
          _updateWorkerData() {
            if (this._pendingLoad)
              return void (this._coalesce = true);
            this.fire(new e.Event("dataloading", { dataType: "source" })), this._loaded = false;
            const t2 = e.extend({}, this.workerOptions), i2 = this._data;
            "string" == typeof i2 ? (t2.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i2), e.ResourceType.Source), t2.request.collectResourceTiming = this._collectResourceTiming) : t2.data = JSON.stringify(i2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t2, (t3, i3) => {
              if (this._loaded = true, this._pendingLoad = null, t3)
                this.fire(new e.ErrorEvent(t3));
              else {
                const t4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                this._collectResourceTiming && i3 && i3.resourceTiming && i3.resourceTiming[this.id] && (t4.resourceTiming = i3.resourceTiming[this.id]), this.fire(new e.Event("data", t4)), this._metadataFired = true;
              }
              this._coalesce && (this._updateWorkerData(), this._coalesce = false);
            });
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t2, i2) {
            const o2 = t2.actor ? "reloadTile" : "loadTile";
            t2.actor = this.actor, t2.request = this.actor.send(o2, { type: this.type, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (e2, r2) => (delete t2.request, t2.unloadVectorData(), t2.aborted ? i2(null) : e2 ? i2(e2) : (t2.loadVectorData(r2, this.map.painter, "reloadTile" === o2), i2(null))), void 0, "loadTile" === o2);
          }
          abortTile(e2) {
            e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
          }
          unloadTile(e2) {
            e2.unloadVectorData(), this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
          }
          onRemove() {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return e.extend({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }, video: class extends Pe {
          constructor(e2, t2, i2, o2) {
            super(e2, t2, i2, o2), this.roundZoom = true, this.type = "video", this.options = t2;
          }
          load() {
            this._loaded = false;
            const t2 = this.options;
            this.urls = [];
            for (const i2 of t2.urls)
              this.urls.push(this.map._requestManager.transformRequest(i2, e.ResourceType.Source).url);
            e.getVideo(this.urls, (t3, i2) => {
              this._loaded = true, t3 ? this.fire(new e.ErrorEvent(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t2) {
            if (this.video) {
              const i2 = this.video.seekable;
              t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e2) {
            this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
              return;
            const t2 = this.map.painter.context, i2 = t2.gl;
            this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t2);
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }, image: Pe, canvas: class extends Pe {
          constructor(t2, i2, o2, r2) {
            super(t2, i2, o2, r2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e2) => !Array.isArray(e2) || 2 !== e2.length || e2.some((e3) => "number" != typeof e3)) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
          }
          load() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e2) {
            this.map = e2, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t2 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions())
              return;
            if (0 === Object.keys(this.tiles).length)
              return;
            const i2 = this.map.painter.context;
            this.texture ? (t2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.Texture(i2, this.canvas, i2.gl.RGBA, { premultiply: true }), this._prepareData(i2);
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e2 of [this.canvas.width, this.canvas.height])
              if (isNaN(e2) || e2 <= 0)
                return true;
            return false;
          }
        }, custom: class extends e.Evented {
          constructor(t2, i2, o2, r2) {
            super(), this.id = t2, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(r2), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new B(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.clearTiles = this._clearTiles.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
          }
          serialize() {
            return e.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
          }
          load() {
            this._loaded = true, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t2) {
            this._map = t2, this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t2), this.load();
          }
          onRemove(e2) {
            this._implementation.onRemove && this._implementation.onRemove(e2);
          }
          hasTile(e2) {
            if (this._implementation.hasTile) {
              const { x: t2, y: i2, z: o2 } = e2.canonical;
              return this._implementation.hasTile({ x: t2, y: i2, z: o2 });
            }
            return !this.tileBounds || this.tileBounds.contains(e2.canonical);
          }
          loadTile(t2, i2) {
            const { x: o2, y: r2, z: n3 } = t2.tileID.canonical, s4 = new e.window.AbortController();
            t2.request = Promise.resolve(this._implementation.loadTile({ x: o2, y: r2, z: n3 }, { signal: s4.signal })).then((function(o3) {
              return delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : void 0 === o3 ? (t2.state = "errored", i2(null)) : null === o3 ? (this.loadTileData(t2, { width: this.tileSize, height: this.tileSize, data: null }), t2.state = "loaded", i2(null)) : function(t3) {
                return t3 instanceof e.window.ImageData || t3 instanceof e.window.HTMLCanvasElement || t3 instanceof e.window.ImageBitmap || t3 instanceof e.window.HTMLImageElement;
              }(o3) ? (this.loadTileData(t2, o3), t2.state = "loaded", void i2(null)) : (t2.state = "errored", i2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
            }).bind(this)).catch((e2) => {
              20 !== e2.code && (t2.state = "errored", i2(e2));
            }), t2.request.cancel = () => s4.abort();
          }
          loadTileData(e2, t2) {
            Me.loadTileData(e2, t2, this._map.painter);
          }
          unloadTileData(e2) {
            Me.unloadTileData(e2, this._map.painter);
          }
          unloadTile(e2, t2) {
            if (this.unloadTileData(e2), this._implementation.unloadTile) {
              const { x: t3, y: i2, z: o2 } = e2.tileID.canonical;
              this._implementation.unloadTile({ x: t3, y: i2, z: o2 });
            }
            t2();
          }
          abortTile(e2, t2) {
            e2.request && e2.request.cancel && (e2.request.cancel(), delete e2.request), t2();
          }
          hasTransition() {
            return false;
          }
          _coveringTiles() {
            return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e2) => ({ x: e2.canonical.x, y: e2.canonical.y, z: e2.canonical.z }));
          }
          _clearTiles() {
            this._map.style._clearSource(this.id);
          }
          _update() {
            this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }));
          }
        } }, De = function(t2, i2, o2, r2) {
          const n3 = new Se[i2.type](t2, i2, o2, r2);
          if (n3.id !== t2)
            throw new Error(`Expected Source id to be ${t2} instead of ${n3.id}`);
          return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], n3), n3;
        };
        function Le(t2, i2) {
          const o2 = e.identity([]);
          return e.scale(o2, o2, [0.5 * t2.width, 0.5 * -t2.height, 1]), e.translate(o2, o2, [1, -1, 0]), e.multiply(o2, o2, t2.calculateProjMatrix(i2.toUnwrapped())), Float32Array.from(o2);
        }
        function Ae(e2, t2, i2, o2, r2, n3, s4, a2 = false) {
          const l3 = e2.tilesIn(o2, s4, a2);
          l3.sort(Re);
          const c4 = [];
          for (const o3 of l3)
            c4.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t2, i2, e2._state, o3, r2, n3, Le(e2.transform, o3.tile.tileID), a2) });
          const h3 = function(e3) {
            const t3 = {}, i3 = {};
            for (const o3 of e3) {
              const e4 = o3.queryResults, r3 = o3.wrappedTileID, n4 = i3[r3] = i3[r3] || {};
              for (const i4 in e4) {
                const o4 = e4[i4], r4 = n4[i4] = n4[i4] || {}, s5 = t3[i4] = t3[i4] || [];
                for (const e5 of o4)
                  r4[e5.featureIndex] || (r4[e5.featureIndex] = true, s5.push(e5));
              }
            }
            return t3;
          }(c4);
          for (const t3 in h3)
            h3[t3].forEach((t4) => {
              const i3 = t4.feature, o3 = i3.layer;
              o3 && "background" !== o3.type && "sky" !== o3.type && (i3.source = o3.source, o3["source-layer"] && (i3.sourceLayer = o3["source-layer"]), i3.state = void 0 !== i3.id ? e2.getFeatureState(o3["source-layer"], i3.id) : {});
            });
          return h3;
        }
        function ze(e2, t2) {
          const i2 = e2.getRenderableIds().map((t3) => e2.getTileByID(t3)), o2 = [], r2 = {};
          for (let e3 = 0; e3 < i2.length; e3++) {
            const n3 = i2[e3], s4 = n3.tileID.canonical.key;
            r2[s4] || (r2[s4] = true, n3.querySourceFeatures(o2, t2));
          }
          return o2;
        }
        function Re(e2, t2) {
          const i2 = e2.tileID, o2 = t2.tileID;
          return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
        }
        function Oe() {
          return null != dn.workerClass ? new dn.workerClass() : new e.window.Worker(dn.workerUrl);
        }
        const Be = "mapboxgl_preloaded_worker_pool";
        class ke {
          constructor() {
            this.active = {};
          }
          acquire(e2) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < ke.workerCount; )
                this.workers.push(new Oe());
            return this.active[e2] = true, this.workers.slice();
          }
          release(e2) {
            delete this.active[e2], 0 === this.numActive() && (this.workers.forEach((e3) => {
              e3.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Be];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        let Fe;
        function Ue() {
          return Fe || (Fe = new ke()), Fe;
        }
        function Ne(t2, i2) {
          const o2 = {};
          for (const e2 in t2)
            "ref" !== e2 && (o2[e2] = t2[e2]);
          return e.refProperties.forEach((e2) => {
            e2 in i2 && (o2[e2] = i2[e2]);
          }), o2;
        }
        function je(e2) {
          e2 = e2.slice();
          const t2 = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < e2.length; i2++)
            t2[e2[i2].id] = e2[i2];
          for (let i2 = 0; i2 < e2.length; i2++)
            "ref" in e2[i2] && (e2[i2] = Ne(e2[i2], t2[e2[i2].ref]));
          return e2;
        }
        ke.workerCount = 2;
        const Ge = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };
        function Ze(e2, t2, i2) {
          i2.push({ command: Ge.addSource, args: [e2, t2[e2]] });
        }
        function Ve(e2, t2, i2) {
          t2.push({ command: Ge.removeSource, args: [e2] }), i2[e2] = true;
        }
        function We(e2, t2, i2, o2) {
          Ve(e2, i2, o2), Ze(e2, t2, i2);
        }
        function Xe(e2, i2, o2) {
          let r2;
          for (r2 in e2[o2])
            if (e2[o2].hasOwnProperty(r2) && "data" !== r2 && !t(e2[o2][r2], i2[o2][r2]))
              return false;
          for (r2 in i2[o2])
            if (i2[o2].hasOwnProperty(r2) && "data" !== r2 && !t(e2[o2][r2], i2[o2][r2]))
              return false;
          return true;
        }
        function qe(e2, i2, o2, r2, n3, s4) {
          let a2;
          for (a2 in i2 = i2 || {}, e2 = e2 || {})
            e2.hasOwnProperty(a2) && (t(e2[a2], i2[a2]) || o2.push({ command: s4, args: [r2, a2, i2[a2], n3] }));
          for (a2 in i2)
            i2.hasOwnProperty(a2) && !e2.hasOwnProperty(a2) && (t(e2[a2], i2[a2]) || o2.push({ command: s4, args: [r2, a2, i2[a2], n3] }));
        }
        function $e(e2) {
          return e2.id;
        }
        function He(e2, t2) {
          return e2[t2.id] = t2, e2;
        }
        class Ye {
          constructor(e2, t2) {
            this.reset(e2, t2);
          }
          reset(e2, t2) {
            this.points = e2 || [], this._distances = [0];
            for (let e3 = 1; e3 < this.points.length; e3++)
              this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t2) {
            if (1 === this.points.length)
              return this.points[0];
            t2 = e.clamp(t2, 0, 1);
            let i2 = 1, o2 = this._distances[i2];
            const r2 = t2 * this.paddedLength + this.padding;
            for (; o2 < r2 && i2 < this._distances.length; )
              o2 = this._distances[++i2];
            const n3 = i2 - 1, s4 = this._distances[n3], a2 = o2 - s4, l3 = a2 > 0 ? (r2 - s4) / a2 : 0;
            return this.points[n3].mult(1 - l3).add(this.points[i2].mult(l3));
          }
        }
        class Ke {
          constructor(e2, t2, i2) {
            const o2 = this.boxCells = [], r2 = this.circleCells = [];
            this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
            for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++)
              o2.push([]), r2.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e2, t2, i2, o2, r2) {
            this._forEachCell(t2, i2, o2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r2);
          }
          insertCircle(e2, t2, i2, o2) {
            this._forEachCell(t2 - o2, i2 - o2, t2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(o2);
          }
          _insertBoxCell(e2, t2, i2, o2, r2, n3) {
            this.boxCells[r2].push(n3);
          }
          _insertCircleCell(e2, t2, i2, o2, r2, n3) {
            this.circleCells[r2].push(n3);
          }
          _query(e2, t2, i2, o2, r2, n3) {
            if (i2 < 0 || e2 > this.width || o2 < 0 || t2 > this.height)
              return !r2 && [];
            const s4 = [];
            if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= o2) {
              if (r2)
                return true;
              for (let e3 = 0; e3 < this.boxKeys.length; e3++)
                s4.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
              for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
                const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
                s4.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
              }
              return n3 ? s4.filter(n3) : s4;
            }
            return this._forEachCell(e2, t2, i2, o2, this._queryCell, s4, { hitTest: r2, seenUids: { box: {}, circle: {} } }, n3), r2 ? s4.length > 0 : s4;
          }
          _queryCircle(e2, t2, i2, o2, r2) {
            const n3 = e2 - i2, s4 = e2 + i2, a2 = t2 - i2, l3 = t2 + i2;
            if (s4 < 0 || n3 > this.width || l3 < 0 || a2 > this.height)
              return !o2 && [];
            const c4 = [];
            return this._forEachCell(n3, a2, s4, l3, this._queryCellCircle, c4, { hitTest: o2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r2), o2 ? c4.length > 0 : c4;
          }
          query(e2, t2, i2, o2, r2) {
            return this._query(e2, t2, i2, o2, false, r2);
          }
          hitTest(e2, t2, i2, o2, r2) {
            return this._query(e2, t2, i2, o2, true, r2);
          }
          hitTestCircle(e2, t2, i2, o2) {
            return this._queryCircle(e2, t2, i2, true, o2);
          }
          _queryCell(e2, t2, i2, o2, r2, n3, s4, a2) {
            const l3 = s4.seenUids, c4 = this.boxCells[r2];
            if (null !== c4) {
              const r3 = this.bboxes;
              for (const h4 of c4)
                if (!l3.box[h4]) {
                  l3.box[h4] = true;
                  const c5 = 4 * h4;
                  if (e2 <= r3[c5 + 2] && t2 <= r3[c5 + 3] && i2 >= r3[c5 + 0] && o2 >= r3[c5 + 1] && (!a2 || a2(this.boxKeys[h4]))) {
                    if (s4.hitTest)
                      return n3.push(true), true;
                    n3.push({ key: this.boxKeys[h4], x1: r3[c5], y1: r3[c5 + 1], x2: r3[c5 + 2], y2: r3[c5 + 3] });
                  }
                }
            }
            const h3 = this.circleCells[r2];
            if (null !== h3) {
              const r3 = this.circles;
              for (const c5 of h3)
                if (!l3.circle[c5]) {
                  l3.circle[c5] = true;
                  const h4 = 3 * c5;
                  if (this._circleAndRectCollide(r3[h4], r3[h4 + 1], r3[h4 + 2], e2, t2, i2, o2) && (!a2 || a2(this.circleKeys[c5]))) {
                    if (s4.hitTest)
                      return n3.push(true), true;
                    {
                      const e3 = r3[h4], t3 = r3[h4 + 1], i3 = r3[h4 + 2];
                      n3.push({ key: this.circleKeys[c5], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                    }
                  }
                }
            }
          }
          _queryCellCircle(e2, t2, i2, o2, r2, n3, s4, a2) {
            const l3 = s4.circle, c4 = s4.seenUids, h3 = this.boxCells[r2];
            if (null !== h3) {
              const e3 = this.bboxes;
              for (const t3 of h3)
                if (!c4.box[t3]) {
                  c4.box[t3] = true;
                  const i3 = 4 * t3;
                  if (this._circleAndRectCollide(l3.x, l3.y, l3.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!a2 || a2(this.boxKeys[t3])))
                    return n3.push(true), true;
                }
            }
            const u3 = this.circleCells[r2];
            if (null !== u3) {
              const e3 = this.circles;
              for (const t3 of u3)
                if (!c4.circle[t3]) {
                  c4.circle[t3] = true;
                  const i3 = 3 * t3;
                  if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l3.x, l3.y, l3.radius) && (!a2 || a2(this.circleKeys[t3])))
                    return n3.push(true), true;
                }
            }
          }
          _forEachCell(e2, t2, i2, o2, r2, n3, s4, a2) {
            const l3 = this._convertToXCellCoord(e2), c4 = this._convertToYCellCoord(t2), h3 = this._convertToXCellCoord(i2), u3 = this._convertToYCellCoord(o2);
            for (let _2 = l3; _2 <= h3; _2++)
              for (let l4 = c4; l4 <= u3; l4++)
                if (r2.call(this, e2, t2, i2, o2, this.xCellCount * l4 + _2, n3, s4, a2))
                  return;
          }
          _convertToXCellCoord(e2) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
          }
          _convertToYCellCoord(e2) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
          }
          _circlesCollide(e2, t2, i2, o2, r2, n3) {
            const s4 = o2 - e2, a2 = r2 - t2, l3 = i2 + n3;
            return l3 * l3 > s4 * s4 + a2 * a2;
          }
          _circleAndRectCollide(e2, t2, i2, o2, r2, n3, s4) {
            const a2 = (n3 - o2) / 2, l3 = Math.abs(e2 - (o2 + a2));
            if (l3 > a2 + i2)
              return false;
            const c4 = (s4 - r2) / 2, h3 = Math.abs(t2 - (r2 + c4));
            if (h3 > c4 + i2)
              return false;
            if (l3 <= a2 || h3 <= c4)
              return true;
            const u3 = l3 - a2, _2 = h3 - c4;
            return u3 * u3 + _2 * _2 <= i2 * i2;
          }
        }
        const Je = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, Qe = Math.tan(85 * Math.PI / 180);
        function et(t2, i2, o2, r2, n3, s4, a2) {
          const l3 = e.create();
          if (o2)
            if ("globe" === s4.name) {
              const t3 = e.calculateGlobeLabelMatrix(n3, i2);
              e.multiply(l3, l3, t3);
            } else {
              const t3 = v3([], a2);
              l3[0] = t3[0], l3[1] = t3[1], l3[4] = t3[2], l3[5] = t3[3], r2 || e.rotateZ(l3, l3, n3.angle);
            }
          else
            e.multiply(l3, n3.labelPlaneMatrix, t2);
          return l3;
        }
        function tt(e2, t2, i2, o2, r2, n3, s4) {
          const a2 = et(e2, t2, i2, o2, r2, n3, s4);
          return "globe" === n3.name && i2 || (a2[2] = a2[6] = a2[10] = a2[14] = 0), a2;
        }
        function it(t2, i2, o2, r2, n3, s4, a2) {
          if (o2) {
            if ("globe" === s4.name) {
              const l3 = et(t2, i2, o2, r2, n3, s4, a2);
              return e.invert(l3, l3), e.multiply(l3, t2, l3), l3;
            }
            {
              const i3 = e.clone(t2), o3 = e.identity([]);
              return o3[0] = a2[0], o3[1] = a2[1], o3[4] = a2[2], o3[5] = a2[3], e.multiply(i3, i3, o3), r2 || e.rotateZ(i3, i3, -n3.angle), i3;
            }
          }
          return n3.glCoordMatrix;
        }
        function ot(t2, i2, o2, r2) {
          const n3 = [t2, i2, o2, 1];
          o2 ? e.transformMat4$1(n3, n3, r2) : pt(n3, n3, r2);
          const s4 = n3[3];
          return n3[0] /= s4, n3[1] /= s4, n3[2] /= s4, n3;
        }
        function rt(e2, t2) {
          return Math.min(0.5 + e2 / t2 * 0.5, 1.5);
        }
        function nt(e2, t2) {
          const i2 = e2[0] / e2[3], o2 = e2[1] / e2[3];
          return i2 >= -t2[0] && i2 <= t2[0] && o2 >= -t2[1] && o2 <= t2[1];
        }
        function st(t2, i2, o2, r2, n3, s4, a2, l3, c4, h3) {
          const u3 = o2.transform, _2 = r2 ? t2.textSizeData : t2.iconSizeData, d3 = e.evaluateSizeForZoom(_2, o2.transform.zoom), p3 = "globe" === u3.projection.name, m3 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], f2 = r2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
          f2.clear();
          let g2 = null;
          p3 && (g2 = r2 ? t2.text.globeExtVertexArray : t2.icon.globeExtVertexArray);
          const v4 = t2.lineVertexArray, x2 = r2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, y2 = o2.transform.width / o2.transform.height;
          let b3, w2 = false;
          for (let r3 = 0; r3 < x2.length; r3++) {
            const p4 = x2.get(r3), { numGlyphs: T3, writingMode: E2 } = p4;
            if (E2 !== e.WritingMode.vertical || w2 || b3 === e.WritingMode.horizontal || (w2 = true), b3 = E2, (p4.hidden || E2 === e.WritingMode.vertical) && !w2) {
              dt(T3, f2);
              continue;
            }
            w2 = false;
            const C3 = new e.Point(p4.tileAnchorX, p4.tileAnchorY);
            let { x: M2, y: I2, z: P3 } = u3.projection.projectTilePoint(C3.x, C3.y, h3.canonical);
            if (c4) {
              const [e2, t3, i3] = c4(C3);
              M2 += e2, I2 += t3, P3 += i3;
            }
            const S2 = [M2, I2, P3, 1];
            if (e.transformMat4$1(S2, S2, i2), !nt(S2, m3)) {
              dt(T3, f2);
              continue;
            }
            const D2 = rt(o2.transform.cameraToCenterDistance, S2[3]), L2 = e.evaluateSizeForFeature(_2, d3, p4), A2 = a2 ? L2 / D2 : L2 * D2, z2 = ot(M2, I2, P3, n3);
            if (z2[3] <= 0) {
              dt(T3, f2);
              continue;
            }
            let R2 = {};
            const O2 = a2 ? null : c4, B2 = ct(p4, A2, false, l3, i2, n3, s4, t2.glyphOffsetArray, v4, f2, g2, z2, C3, R2, y2, O2, u3.projection, h3, a2);
            w2 = B2.useVertical, O2 && B2.needsFlipping && (R2 = {}), (B2.notEnoughRoom || w2 || B2.needsFlipping && ct(p4, A2, true, l3, i2, n3, s4, t2.glyphOffsetArray, v4, f2, g2, z2, C3, R2, y2, O2, u3.projection, h3, a2).notEnoughRoom) && dt(T3, f2);
          }
          r2 ? (t2.text.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.text.globeExtVertexBuffer.updateData(g2)) : (t2.icon.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.icon.globeExtVertexBuffer.updateData(g2));
        }
        function at(e2, t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3, m3) {
          const { lineStartIndex: f2, glyphStartIndex: g2, segment: v4 } = a2, x2 = g2 + a2.numGlyphs, y2 = f2 + a2.lineLength, b3 = t2.getoffsetX(g2), w2 = t2.getoffsetX(x2 - 1), T3 = _t(e2 * b3, i2, o2, r2, n3, s4, v4, f2, y2, l3, c4, h3, u3, _2, true, d3, p3, m3);
          if (!T3)
            return null;
          const E2 = _t(e2 * w2, i2, o2, r2, n3, s4, v4, f2, y2, l3, c4, h3, u3, _2, true, d3, p3, m3);
          return E2 ? { first: T3, last: E2 } : null;
        }
        function lt(t2, i2, o2, r2) {
          return t2 === e.WritingMode.horizontal && Math.abs(r2) > Math.abs(o2) ? { useVertical: true } : t2 === e.WritingMode.vertical ? r2 > 0 ? { needsFlipping: true } : null : i2 !== Je.unknown && function(e2, t3) {
            return 0 === e2 || Math.abs(t3 / e2) > Qe;
          }(o2, r2) ? i2 === Je.flipRequired ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
        }
        function ct(t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3, m3, f2, g2, v4, x2) {
          const y2 = i2 / 24, b3 = t2.lineOffsetX * y2, w2 = t2.lineOffsetY * y2, { lineStartIndex: T3, glyphStartIndex: E2, numGlyphs: C3, segment: M2, writingMode: I2, flipState: P3 } = t2, S2 = T3 + t2.lineLength, D2 = (t3) => {
            if (u3) {
              const [i4, o4, r4] = t3.up, n4 = h3.length;
              e.updateGlobeVertexNormal(u3, n4 + 0, i4, o4, r4), e.updateGlobeVertexNormal(u3, n4 + 1, i4, o4, r4), e.updateGlobeVertexNormal(u3, n4 + 2, i4, o4, r4), e.updateGlobeVertexNormal(u3, n4 + 3, i4, o4, r4);
            }
            const [i3, o3, r3] = t3.point;
            e.addDynamicAttributes(h3, i3, o3, r3, t3.angle);
          };
          if (C3 > 1) {
            const e2 = at(y2, l3, b3, w2, o2, _2, d3, t2, c4, s4, p3, f2, false, g2, v4, x2);
            if (!e2)
              return { notEnoughRoom: true };
            if (r2 && !o2) {
              let [i3, o3, r3] = e2.first.point, [n4, s5, l4] = e2.last.point;
              [i3, o3] = ot(i3, o3, r3, a2), [n4, s5] = ot(n4, s5, l4, a2);
              const c5 = lt(I2, P3, (n4 - i3) * m3, s5 - o3);
              if (t2.flipState = c5 && c5.needsFlipping ? Je.flipRequired : Je.flipNotRequired, c5)
                return c5;
            }
            D2(e2.first);
            for (let e3 = E2 + 1; e3 < E2 + C3 - 1; e3++) {
              const t3 = _t(y2 * l3.getoffsetX(e3), b3, w2, o2, _2, d3, M2, T3, S2, c4, s4, p3, f2, false, false, g2, v4, x2);
              if (!t3)
                return h3.length -= 4 * (e3 - E2), { notEnoughRoom: true };
              D2(t3);
            }
            D2(e2.last);
          } else {
            if (r2 && !o2) {
              const i4 = ot(d3.x, d3.y, 0, n3), o3 = T3 + M2 + 1, r3 = new e.Point(c4.getx(o3), c4.gety(o3)), s5 = ot(r3.x, r3.y, 0, n3), a3 = s5[3] > 0 ? s5 : ut(d3, r3, i4, 1, n3, void 0, g2, v4.canonical), l4 = lt(I2, P3, (a3[0] - i4[0]) * m3, a3[1] - i4[1]);
              if (t2.flipState = l4 && l4.needsFlipping ? Je.flipRequired : Je.flipNotRequired, l4)
                return l4;
            }
            const i3 = _t(y2 * l3.getoffsetX(E2), b3, w2, o2, _2, d3, M2, T3, S2, c4, s4, p3, f2, false, false, g2, v4, x2);
            if (!i3)
              return { notEnoughRoom: true };
            D2(i3);
          }
          return {};
        }
        function ht(e2, t2, i2, o2, r2) {
          const { x: n3, y: s4, z: a2 } = o2.projectTilePoint(e2.x, e2.y, t2);
          if (!r2)
            return ot(n3, s4, a2, i2);
          const [l3, c4, h3] = r2(e2);
          return ot(n3 + l3, s4 + c4, a2 + h3, i2);
        }
        function ut(t2, i2, o2, r2, n3, s4, a2, l3) {
          const c4 = ht(t2.sub(i2)._unit()._add(t2), l3, n3, a2, s4);
          return e.sub(c4, o2, c4), e.normalize(c4, c4), e.scaleAndAdd(c4, o2, c4, r2);
        }
        function _t(t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3, m3, f2, g2, v4) {
          const x2 = r2 ? t2 - i2 : t2 + i2;
          let y2 = x2 > 0 ? 1 : -1, b3 = 0;
          r2 && (y2 *= -1, b3 = Math.PI), y2 < 0 && (b3 += Math.PI);
          let w2 = l3 + a2 + (y2 > 0 ? 0 : 1) | 0, T3 = n3, E2 = n3, C3 = 0, M2 = 0;
          const I2 = Math.abs(x2), P3 = [], S2 = [];
          let D2 = s4, L2 = D2;
          const A2 = () => ut(L2, D2, E2, I2 - C3 + 1, u3, d3, f2, g2.canonical);
          for (; C3 + M2 <= I2; ) {
            if (w2 += y2, w2 < l3 || w2 >= c4)
              return null;
            if (E2 = T3, L2 = D2, P3.push(E2), p3 && S2.push(L2), D2 = new e.Point(h3.getx(w2), h3.gety(w2)), T3 = _2[w2], !T3) {
              const e2 = ht(D2, g2.canonical, u3, f2, d3);
              T3 = e2[3] > 0 ? _2[w2] = e2 : A2();
            }
            C3 += M2, M2 = e.distance(E2, T3);
          }
          m3 && d3 && (_2[w2] && (T3 = A2(), M2 = e.distance(E2, T3)), _2[w2] = T3);
          const z2 = (I2 - C3) / M2, R2 = D2.sub(L2)._mult(z2)._add(L2), O2 = e.sub([], T3, E2), B2 = e.scaleAndAdd([], E2, O2, z2);
          let k2 = [0, 0, 1], F2 = O2[0], U2 = O2[1];
          if (v4 && (k2 = f2.upVector(g2.canonical, R2.x, R2.y), 0 !== k2[0] || 0 !== k2[1] || 1 !== k2[2])) {
            const t3 = [k2[2], 0, -k2[0]], i3 = e.cross([], k2, t3);
            e.normalize(t3, t3), e.normalize(i3, i3), F2 = e.dot(O2, t3), U2 = e.dot(O2, i3);
          }
          if (o2) {
            const t3 = e.cross([], k2, O2);
            e.normalize(t3, t3), e.scaleAndAdd(B2, B2, t3, o2 * y2);
          }
          const N2 = b3 + Math.atan2(U2, F2);
          return P3.push(B2), p3 && S2.push(R2), { point: B2, angle: N2, path: P3, tilePath: S2, up: k2 };
        }
        function dt(e2, t2) {
          const i2 = t2.length, o2 = i2 + 4 * e2;
          t2.resize(o2), t2.float32.fill(-1 / 0, 4 * i2, 4 * o2);
        }
        function pt(e2, t2, i2) {
          const o2 = t2[0], r2 = t2[1];
          return e2[0] = i2[0] * o2 + i2[4] * r2 + i2[12], e2[1] = i2[1] * o2 + i2[5] * r2 + i2[13], e2[3] = i2[3] * o2 + i2[7] * r2 + i2[15], e2;
        }
        const mt = 100;
        class ft {
          constructor(e2, t2, i2 = new Ke(e2.width + 200, e2.height + 200, 25), o2 = new Ke(e2.width + 200, e2.height + 200, 25)) {
            this.transform = e2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + mt, this.screenBottomBoundary = e2.height + mt, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t2;
          }
          placeCollisionBox(e2, t2, i2, o2, r2, n3, s4, a2) {
            let l3 = i2.projectedAnchorX, c4 = i2.projectedAnchorY, h3 = i2.projectedAnchorZ;
            const u3 = i2.elevation, _2 = i2.tileID, d3 = e2.getProjection();
            if (u3 && _2) {
              const [e3, t3, o3] = d3.upVector(_2.canonical, i2.tileAnchorX, i2.tileAnchorY), r3 = d3.upVectorScale(_2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
              l3 += e3 * u3 * r3, c4 += t3 * u3 * r3, h3 += o3 * u3 * r3;
            }
            const p3 = this.projectAndGetPerspectiveRatio(s4, l3, c4, h3, i2.tileID, "globe" === d3.name || !!u3 || this.transform.pitch > 0, d3), m3 = n3 * p3.perspectiveRatio, f2 = (i2.x1 * t2 + o2.x - i2.padding) * m3 + p3.point.x, g2 = (i2.y1 * t2 + o2.y - i2.padding) * m3 + p3.point.y, v4 = (i2.x2 * t2 + o2.x + i2.padding) * m3 + p3.point.x, x2 = (i2.y2 * t2 + o2.y + i2.padding) * m3 + p3.point.y, y2 = p3.perspectiveRatio <= 0.55 || p3.occluded;
            return !this.isInsideGrid(f2, g2, v4, x2) || !r2 && this.grid.hitTest(f2, g2, v4, x2, a2) || y2 ? { box: [], offscreen: false, occluded: p3.occluded } : { box: [f2, g2, v4, x2], offscreen: this.isOffscreen(f2, g2, v4, x2), occluded: false };
          }
          placeCollisionCircles(t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3, m3) {
            const f2 = [], g2 = this.transform.elevation, v4 = t2.getProjection(), x2 = g2 ? g2.getAtTileOffsetFunc(m3, this.transform.center.lat, this.transform.worldSize, v4) : null, y2 = new e.Point(o2.tileAnchorX, o2.tileAnchorY);
            let { x: b3, y: w2, z: T3 } = v4.projectTilePoint(y2.x, y2.y, m3.canonical);
            if (x2) {
              const [e2, t3, i3] = x2(y2);
              b3 += e2, w2 += t3, T3 += i3;
            }
            const E2 = "globe" === v4.name, C3 = this.projectAndGetPerspectiveRatio(a2, b3, w2, T3, m3, E2 || !!g2 || this.transform.pitch > 0, v4), { perspectiveRatio: M2 } = C3, I2 = (u3 ? s4 / M2 : s4 * M2) / e.ONE_EM, P3 = ot(b3, w2, T3, l3), S2 = C3.signedDistanceFromCamera > 0 ? at(I2, n3, o2.lineOffsetX * I2, o2.lineOffsetY * I2, false, P3, y2, o2, r2, l3, {}, g2 && !u3 ? x2 : null, u3 && !!g2, v4, m3, u3) : null;
            let D2 = false, L2 = false, A2 = true;
            if (S2 && !C3.occluded) {
              const t3 = 0.5 * d3 * M2 + p3, o3 = new e.Point(-100, -100), r3 = new e.Point(this.screenRightBoundary, this.screenBottomBoundary), n4 = new Ye(), { first: s5, last: a3 } = S2, l4 = s5.path.length;
              let u4 = [];
              for (let e2 = l4 - 1; e2 >= 1; e2--)
                u4.push(s5.path[e2]);
              for (let e2 = 1; e2 < a3.path.length; e2++)
                u4.push(a3.path[e2]);
              const m4 = 2.5 * t3;
              c4 && (u4 = u4.map(([e2, t4, i3], o4) => (x2 && !E2 && (i3 = x2(o4 < l4 - 1 ? s5.tilePath[l4 - 1 - o4] : a3.tilePath[o4 - l4 + 2])[2]), ot(e2, t4, i3, c4))), u4.some((e2) => e2[3] <= 0) && (u4 = []));
              let g3 = [];
              if (u4.length > 0) {
                let t4 = 1 / 0, i3 = -1 / 0, n5 = 1 / 0, s6 = -1 / 0;
                for (const e2 of u4)
                  t4 = Math.min(t4, e2[0]), n5 = Math.min(n5, e2[1]), i3 = Math.max(i3, e2[0]), s6 = Math.max(s6, e2[1]);
                i3 >= o3.x && t4 <= r3.x && s6 >= o3.y && n5 <= r3.y && (g3 = [u4.map((t5) => new e.Point(t5[0], t5[1]))], (t4 < o3.x || i3 > r3.x || n5 < o3.y || s6 > r3.y) && (g3 = e.clipLine(g3, o3.x, o3.y, r3.x, r3.y)));
              }
              for (const e2 of g3) {
                n4.reset(e2, 0.25 * t3);
                let o4 = 0;
                o4 = n4.length <= 0.5 * t3 ? 1 : Math.ceil(n4.paddedLength / m4) + 1;
                for (let e3 = 0; e3 < o4; e3++) {
                  const r4 = e3 / Math.max(o4 - 1, 1), s6 = n4.lerp(r4), a4 = s6.x + mt, l5 = s6.y + mt;
                  f2.push(a4, l5, t3, 0);
                  const c5 = a4 - t3, u5 = l5 - t3, d4 = a4 + t3, p4 = l5 + t3;
                  if (A2 = A2 && this.isOffscreen(c5, u5, d4, p4), L2 = L2 || this.isInsideGrid(c5, u5, d4, p4), !i2 && this.grid.hitTestCircle(a4, l5, t3, _2) && (D2 = true, !h3))
                    return { circles: [], offscreen: false, collisionDetected: D2, occluded: false };
                }
              }
            }
            return { circles: !h3 && D2 || !L2 ? [] : f2, offscreen: A2, collisionDetected: D2, occluded: C3.occluded };
          }
          queryRenderedSymbols(t2) {
            if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
              return {};
            const i2 = [];
            let o2 = 1 / 0, r2 = 1 / 0, n3 = -1 / 0, s4 = -1 / 0;
            for (const a3 of t2) {
              const t3 = new e.Point(a3.x + mt, a3.y + mt);
              o2 = Math.min(o2, t3.x), r2 = Math.min(r2, t3.y), n3 = Math.max(n3, t3.x), s4 = Math.max(s4, t3.y), i2.push(t3);
            }
            const a2 = this.grid.query(o2, r2, n3, s4).concat(this.ignoredGrid.query(o2, r2, n3, s4)), l3 = {}, c4 = {};
            for (const t3 of a2) {
              const o3 = t3.key;
              if (void 0 === l3[o3.bucketInstanceId] && (l3[o3.bucketInstanceId] = {}), l3[o3.bucketInstanceId][o3.featureIndex])
                continue;
              const r3 = [new e.Point(t3.x1, t3.y1), new e.Point(t3.x2, t3.y1), new e.Point(t3.x2, t3.y2), new e.Point(t3.x1, t3.y2)];
              e.polygonIntersectsPolygon(i2, r3) && (l3[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c4[o3.bucketInstanceId] && (c4[o3.bucketInstanceId] = []), c4[o3.bucketInstanceId].push(o3.featureIndex));
            }
            return c4;
          }
          insertCollisionBox(e2, t2, i2, o2, r2) {
            (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, e2[0], e2[1], e2[2], e2[3]);
          }
          insertCollisionCircles(e2, t2, i2, o2, r2) {
            const n3 = t2 ? this.ignoredGrid : this.grid, s4 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 };
            for (let t3 = 0; t3 < e2.length; t3 += 4)
              n3.insertCircle(s4, e2[t3], e2[t3 + 1], e2[t3 + 2]);
          }
          projectAndGetPerspectiveRatio(t2, i2, o2, r2, n3, s4, a2) {
            const l3 = [i2, o2, r2, 1];
            let c4 = false;
            if (r2 || this.transform.pitch > 0) {
              if (e.transformMat4$1(l3, l3, t2), this.fogState && n3 && "globe" !== a2.name) {
                const t3 = function(t4, i3, o3, r3, n4, s5) {
                  const a3 = s5.calculateFogTileMatrix(n4), l4 = [i3, o3, r3];
                  return e.transformMat4(l4, l4, a3), C2(t4, l4, s5.pitch, s5._fov);
                }(this.fogState, i2, o2, r2, n3.toUnwrapped(), this.transform);
                c4 = t3 > 0.9;
              }
            } else
              pt(l3, l3, t2);
            const h3 = l3[3];
            return { point: new e.Point((l3[0] / h3 + 1) / 2 * this.transform.width + mt, (-l3[1] / h3 + 1) / 2 * this.transform.height + mt), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a2) / h3 * 0.5, 1.5), signedDistanceFromCamera: h3, occluded: s4 && l3[2] > h3 || c4 };
          }
          isOffscreen(e2, t2, i2, o2) {
            return i2 < mt || e2 >= this.screenRightBoundary || o2 < mt || t2 > this.screenBottomBoundary;
          }
          isInsideGrid(e2, t2, i2, o2) {
            return i2 >= 0 && e2 < this.gridRightBoundary && o2 >= 0 && t2 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t2 = e.identity([]);
            return e.translate(t2, t2, [-100, -100, 0]), t2;
          }
        }
        function gt(t2, i2, o2) {
          const r2 = i2.createTileMatrix(t2, t2.worldSize, o2.toUnwrapped());
          return e.multiply(new Float32Array(16), t2.projMatrix, r2);
        }
        function vt(e2, t2, i2) {
          if (t2.projection.name === i2.projection.name)
            return e2.projMatrix;
          const o2 = i2.clone();
          return o2.setProjection(t2.projection), gt(o2, t2.getProjection(), e2);
        }
        function xt(e2, t2, i2) {
          return t2.name === i2.projection.name ? e2.projMatrix : gt(i2, t2, e2);
        }
        class yt {
          constructor(e2, t2, i2, o2) {
            this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : o2 && i2 ? 1 : 0, this.placed = i2;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class bt {
          constructor(e2, t2, i2, o2, r2, n3 = false) {
            this.text = new yt(e2 ? e2.text : null, t2, i2, r2), this.icon = new yt(e2 ? e2.icon : null, t2, o2, r2), this.clipped = n3;
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class wt {
          constructor(e2, t2, i2, o2 = false) {
            this.text = e2, this.icon = t2, this.skipFade = i2, this.clipped = o2;
          }
        }
        class Tt {
          constructor() {
            this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];
          }
        }
        class Et {
          constructor(e2, t2, i2, o2, r2) {
            this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r2;
          }
        }
        class Ct {
          constructor(e2) {
            this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e2) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[e2]) {
              const t2 = ++this.maxGroupID;
              this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
            }
            return this.collisionGroups[e2];
          }
        }
        function Mt(t2, i2, o2, r2, n3) {
          const { horizontalAlign: s4, verticalAlign: a2 } = e.getAnchorAlignment(t2), l3 = -(s4 - 0.5) * i2, c4 = -(a2 - 0.5) * o2, h3 = e.evaluateVariableOffset(t2, r2);
          return new e.Point(l3 + h3[0] * n3, c4 + h3[1] * n3);
        }
        function It(t2, i2, o2, r2, n3) {
          const s4 = new e.Point(t2, i2);
          return o2 && s4._rotate(r2 ? n3 : -n3), s4;
        }
        class Pt {
          constructor(e2, t2, i2, o2, r2) {
            this.transform = e2.clone(), this.projection = e2.projection.name, this.collisionIndex = new ft(this.transform, r2), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new Ct(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t2, i2, o2, r2) {
            const n3 = o2.getBucket(i2), s4 = o2.latestFeatureIndex;
            if (!n3 || !s4 || i2.id !== n3.layerIds[0])
              return;
            const a2 = n3.layers[0].layout, l3 = o2.collisionBoxArray, c4 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h3 = o2.tileSize / e.EXTENT, u3 = o2.tileID.toUnwrapped();
            this.transform.setProjection(n3.projection);
            const _2 = (d3 = o2.tileID, p3 = n3.getProjection(), m3 = this.transform, p3.name === this.projection ? m3.calculateProjMatrix(d3.toUnwrapped()) : gt(m3, p3, d3));
            var d3, p3, m3;
            const f2 = "map" === a2.get("text-pitch-alignment"), g2 = "map" === a2.get("text-rotation-alignment");
            i2.compileFilter();
            const v4 = i2.dynamicFilter(), x2 = i2.dynamicFilterNeedsFeature(), y2 = this.transform.calculatePixelsToTileUnitsMatrix(o2), b3 = tt(_2, o2.tileID.canonical, f2, g2, this.transform, n3.getProjection(), y2);
            let w2 = null;
            if (f2) {
              const t3 = it(_2, o2.tileID.canonical, f2, g2, this.transform, n3.getProjection(), y2);
              w2 = e.multiply([], this.transform.labelPlaneMatrix, t3);
            }
            let T3 = null;
            v4 && o2.latestFeatureIndex && (T3 = { unwrappedTileID: u3, dynamicFilter: v4, dynamicFilterNeedsFeature: x2, featureIndex: o2.latestFeatureIndex }), this.retainedQueryData[n3.bucketInstanceId] = new Et(n3.bucketInstanceId, s4, n3.sourceLayerIndex, n3.index, o2.tileID);
            const E2 = { bucket: n3, layout: a2, posMatrix: _2, textLabelPlaneMatrix: b3, labelToScreenMatrix: w2, clippingData: T3, scale: c4, textPixelRatio: h3, holdingForFade: o2.holdingForFade(), collisionBoxArray: l3, partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n3.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n3.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n3.sourceID) };
            if (r2)
              for (const e2 of n3.sortKeyRanges) {
                const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3 } = e2;
                t2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3, parameters: E2 });
              }
            else
              t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: n3.symbolInstances.length, parameters: E2 });
          }
          attemptAnchorPlacement(e2, t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3, m3, f2, g2) {
            const { textOffset0: v4, textOffset1: x2, crossTileID: y2 } = u3, b3 = [v4, x2], w2 = Mt(e2, i2, o2, b3, r2), T3 = this.collisionIndex.placeCollisionBox(d3, r2, t2, It(w2.x, w2.y, n3, s4, this.transform.angle), h3, a2, l3, c4.predicate);
            if (m3) {
              const e3 = d3.getSymbolInstanceIconSize(g2, this.transform.zoom, u3.placedIconSymbolIndex);
              if (0 === this.collisionIndex.placeCollisionBox(d3, e3, m3, It(w2.x, w2.y, n3, s4, this.transform.angle), h3, a2, l3, c4.predicate).box.length)
                return;
            }
            if (T3.box.length > 0) {
              let t3;
              return this.prevPlacement && this.prevPlacement.variableOffsets[y2] && this.prevPlacement.placements[y2] && this.prevPlacement.placements[y2].text && (t3 = this.prevPlacement.variableOffsets[y2].anchor), this.variableOffsets[y2] = { textOffset: b3, width: i2, height: o2, anchor: e2, textScale: r2, prevAnchor: t3 }, this.markUsedJustification(d3, e2, u3, p3), d3.allowVerticalPlacement && (this.markUsedOrientation(d3, p3, u3), this.placedOrientations[y2] = p3), { shift: w2, placedGlyphBoxes: T3 };
            }
          }
          placeLayerBucketPart(t2, i2, o2, r2) {
            const { bucket: n3, layout: s4, posMatrix: a2, textLabelPlaneMatrix: l3, labelToScreenMatrix: c4, clippingData: h3, textPixelRatio: u3, holdingForFade: _2, collisionBoxArray: d3, partiallyEvaluatedTextSize: p3, partiallyEvaluatedIconSize: m3, collisionGroup: f2 } = t2.parameters, g2 = s4.get("text-optional"), v4 = s4.get("icon-optional"), x2 = s4.get("text-allow-overlap"), y2 = s4.get("icon-allow-overlap"), b3 = "map" === s4.get("text-rotation-alignment"), w2 = "map" === s4.get("text-pitch-alignment"), T3 = "none" !== s4.get("icon-text-fit"), E2 = "viewport-y" === s4.get("symbol-z-order");
            this.transform.setProjection(n3.projection);
            let C3 = x2 && (y2 || !n3.hasIconData() || v4), M2 = y2 && (x2 || !n3.hasTextData() || g2);
            !n3.collisionArrays && d3 && n3.deserializeCollisionBoxes(d3), o2 && r2 && n3.updateCollisionDebugBuffers(this.transform.zoom, d3);
            const I2 = (t3, r3, d4) => {
              const { crossTileID: E3, numVerticalGlyphVertices: I3 } = t3;
              if (h3) {
                const o3 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
                let r4 = null;
                if (h3.dynamicFilterNeedsFeature) {
                  const e2 = this.retainedQueryData[n3.bucketInstanceId];
                  r4 = h3.featureIndex.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e2.bucketIndex, sourceLayerIndex: e2.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                }
                if (!(0, h3.dynamicFilter)(o3, r4, this.retainedQueryData[n3.bucketInstanceId].tileID.canonical, new e.Point(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(h3.unwrappedTileID)))
                  return this.placements[E3] = new wt(false, false, false, true), void i2.add(E3);
              }
              if (i2.has(E3))
                return;
              if (_2)
                return void (this.placements[E3] = new wt(false, false, false));
              let P3 = false, S2 = false, D2 = true, L2 = false, A2 = false, z2 = null, R2 = { box: null, offscreen: null, occluded: null }, O2 = { box: null, offscreen: null, occluded: null }, B2 = null, k2 = null, F2 = null, U2 = 0, N2 = 0, j2 = 0;
              d4.textFeatureIndex ? U2 = d4.textFeatureIndex : t3.useRuntimeCollisionCircles && (U2 = t3.featureIndex), d4.verticalTextFeatureIndex && (N2 = d4.verticalTextFeatureIndex);
              const G2 = (e2) => {
                e2.tileID = this.retainedQueryData[n3.bucketInstanceId].tileID;
                const t4 = this.transform.elevation;
                (t4 || e2.elevation) && (e2.elevation = t4 ? t4.getAtTileOffset(e2.tileID, e2.tileAnchorX, e2.tileAnchorY) : 0);
              }, Z2 = d4.textBox;
              if (Z2) {
                G2(Z2);
                const i3 = (i4) => {
                  let o4 = e.WritingMode.horizontal;
                  if (n3.allowVerticalPlacement && !i4 && this.prevPlacement) {
                    const e2 = this.prevPlacement.placedOrientations[E3];
                    e2 && (this.placedOrientations[E3] = e2, o4 = e2, this.markUsedOrientation(n3, o4, t3));
                  }
                  return o4;
                }, o3 = (t4, i4) => {
                  if (n3.allowVerticalPlacement && I3 > 0 && d4.verticalTextBox) {
                    for (const o4 of n3.writingModes)
                      if (o4 === e.WritingMode.vertical ? (R2 = i4(), O2 = R2) : R2 = t4(), R2 && R2.box && R2.box.length)
                        break;
                  } else
                    R2 = t4();
                };
                if (s4.get("text-variable-anchor")) {
                  let l4 = s4.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[E3]) {
                    const e2 = this.prevPlacement.variableOffsets[E3];
                    l4.indexOf(e2.anchor) > 0 && (l4 = l4.filter((t4) => t4 !== e2.anchor), l4.unshift(e2.anchor));
                  }
                  const c5 = (e2, i4, o4) => {
                    const s5 = n3.getSymbolInstanceTextSize(p3, t3, this.transform.zoom, r3), c6 = (e2.x2 - e2.x1) * s5 + 2 * e2.padding, h5 = (e2.y2 - e2.y1) * s5 + 2 * e2.padding, _3 = T3 && !y2 ? i4 : null;
                    _3 && G2(_3);
                    let d5 = { box: [], offscreen: false, occluded: false };
                    const g3 = x2 ? 2 * l4.length : l4.length;
                    for (let i5 = 0; i5 < g3; ++i5) {
                      const g4 = this.attemptAnchorPlacement(l4[i5 % l4.length], e2, c6, h5, s5, b3, w2, u3, a2, f2, i5 >= l4.length, t3, r3, n3, o4, _3, p3, m3);
                      if (g4 && (d5 = g4.placedGlyphBoxes, d5 && d5.box && d5.box.length)) {
                        P3 = true, z2 = g4.shift;
                        break;
                      }
                    }
                    return d5;
                  };
                  o3(() => c5(Z2, d4.iconBox, e.WritingMode.horizontal), () => {
                    const t4 = d4.verticalTextBox;
                    return t4 && G2(t4), n3.allowVerticalPlacement && !(R2 && R2.box && R2.box.length) && I3 > 0 && t4 ? c5(t4, d4.verticalIconBox, e.WritingMode.vertical) : { box: null, offscreen: null, occluded: null };
                  }), R2 && (P3 = R2.box, D2 = R2.offscreen, L2 = R2.occluded);
                  const h4 = i3(!(!R2 || !R2.box));
                  if (!P3 && this.prevPlacement) {
                    const e2 = this.prevPlacement.variableOffsets[E3];
                    e2 && (this.variableOffsets[E3] = e2, this.markUsedJustification(n3, e2.anchor, t3, h4));
                  }
                } else {
                  const s5 = (i4, o4) => {
                    const s6 = n3.getSymbolInstanceTextSize(p3, t3, this.transform.zoom, r3), l4 = this.collisionIndex.placeCollisionBox(n3, s6, i4, new e.Point(0, 0), x2, u3, a2, f2.predicate);
                    return l4 && l4.box && l4.box.length && (this.markUsedOrientation(n3, o4, t3), this.placedOrientations[E3] = o4), l4;
                  };
                  o3(() => s5(Z2, e.WritingMode.horizontal), () => {
                    const t4 = d4.verticalTextBox;
                    return n3.allowVerticalPlacement && I3 > 0 && t4 ? (G2(t4), s5(t4, e.WritingMode.vertical)) : { box: null, offscreen: null, occluded: null };
                  }), i3(!!(R2 && R2.box && R2.box.length));
                }
              }
              if (B2 = R2, P3 = B2 && B2.box && B2.box.length > 0, D2 = B2 && B2.offscreen, L2 = B2 && B2.occluded, t3.useRuntimeCollisionCircles) {
                const i3 = n3.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), r4 = e.evaluateSizeForFeature(n3.textSizeData, p3, i3), h4 = s4.get("text-padding");
                k2 = this.collisionIndex.placeCollisionCircles(n3, x2, i3, n3.lineVertexArray, n3.glyphOffsetArray, r4, a2, l3, c4, o2, w2, f2.predicate, t3.collisionCircleDiameter * r4 / e.ONE_EM, h4, this.retainedQueryData[n3.bucketInstanceId].tileID), P3 = x2 || k2.circles.length > 0 && !k2.collisionDetected, D2 = D2 && k2.offscreen, L2 = k2.occluded;
              }
              if (d4.iconFeatureIndex && (j2 = d4.iconFeatureIndex), d4.iconBox) {
                const i3 = (i4) => {
                  G2(i4);
                  const o3 = T3 && z2 ? It(z2.x, z2.y, b3, w2, this.transform.angle) : new e.Point(0, 0), r4 = n3.getSymbolInstanceIconSize(m3, this.transform.zoom, t3.placedIconSymbolIndex);
                  return this.collisionIndex.placeCollisionBox(n3, r4, i4, o3, y2, u3, a2, f2.predicate);
                };
                O2 && O2.box && O2.box.length && d4.verticalIconBox ? (F2 = i3(d4.verticalIconBox), S2 = F2.box.length > 0) : (F2 = i3(d4.iconBox), S2 = F2.box.length > 0), D2 = D2 && F2.offscreen, A2 = F2.occluded;
              }
              const V2 = g2 || 0 === t3.numHorizontalGlyphVertices && 0 === I3, W2 = v4 || 0 === t3.numIconVertices;
              if (V2 || W2 ? W2 ? V2 || (S2 = S2 && P3) : P3 = S2 && P3 : S2 = P3 = S2 && P3, P3 && B2 && B2.box && this.collisionIndex.insertCollisionBox(B2.box, s4.get("text-ignore-placement"), n3.bucketInstanceId, O2 && O2.box && N2 ? N2 : U2, f2.ID), S2 && F2 && this.collisionIndex.insertCollisionBox(F2.box, s4.get("icon-ignore-placement"), n3.bucketInstanceId, j2, f2.ID), k2 && (P3 && this.collisionIndex.insertCollisionCircles(k2.circles, s4.get("text-ignore-placement"), n3.bucketInstanceId, U2, f2.ID), o2)) {
                const e2 = n3.bucketInstanceId;
                let t4 = this.collisionCircleArrays[e2];
                void 0 === t4 && (t4 = this.collisionCircleArrays[e2] = new Tt());
                for (let e3 = 0; e3 < k2.circles.length; e3 += 4)
                  t4.circles.push(k2.circles[e3 + 0]), t4.circles.push(k2.circles[e3 + 1]), t4.circles.push(k2.circles[e3 + 2]), t4.circles.push(k2.collisionDetected ? 1 : 0);
              }
              const X2 = "globe" !== n3.projection.name;
              C3 = C3 && (X2 || !L2), M2 = M2 && (X2 || !A2), this.placements[E3] = new wt(P3 || C3, S2 || M2, D2 || n3.justReloaded), i2.add(E3);
            };
            if (E2) {
              const e2 = n3.getSortedSymbolIndexes(this.transform.angle);
              for (let t3 = e2.length - 1; t3 >= 0; --t3) {
                const i3 = e2[t3];
                I2(n3.symbolInstances.get(i3), i3, n3.collisionArrays[i3]);
              }
            } else
              for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++)
                I2(n3.symbolInstances.get(e2), e2, n3.collisionArrays[e2]);
            if (o2 && n3.bucketInstanceId in this.collisionCircleArrays) {
              const t3 = this.collisionCircleArrays[n3.bucketInstanceId];
              e.invert(t3.invProjMatrix, a2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            n3.justReloaded = false;
          }
          markUsedJustification(t2, i2, o2, r2) {
            const { leftJustifiedTextSymbolIndex: n3, centerJustifiedTextSymbolIndex: s4, rightJustifiedTextSymbolIndex: a2, verticalPlacedTextSymbolIndex: l3, crossTileID: c4 } = o2, h3 = e.getAnchorJustification(i2), u3 = r2 === e.WritingMode.vertical ? l3 : "left" === h3 ? n3 : "center" === h3 ? s4 : "right" === h3 ? a2 : -1;
            n3 >= 0 && (t2.text.placedSymbolArray.get(n3).crossTileID = u3 >= 0 && n3 !== u3 ? 0 : c4), s4 >= 0 && (t2.text.placedSymbolArray.get(s4).crossTileID = u3 >= 0 && s4 !== u3 ? 0 : c4), a2 >= 0 && (t2.text.placedSymbolArray.get(a2).crossTileID = u3 >= 0 && a2 !== u3 ? 0 : c4), l3 >= 0 && (t2.text.placedSymbolArray.get(l3).crossTileID = u3 >= 0 && l3 !== u3 ? 0 : c4);
          }
          markUsedOrientation(t2, i2, o2) {
            const r2 = i2 === e.WritingMode.horizontal || i2 === e.WritingMode.horizontalOnly ? i2 : 0, n3 = i2 === e.WritingMode.vertical ? i2 : 0, { leftJustifiedTextSymbolIndex: s4, centerJustifiedTextSymbolIndex: a2, rightJustifiedTextSymbolIndex: l3, verticalPlacedTextSymbolIndex: c4 } = o2, h3 = t2.text.placedSymbolArray;
            s4 >= 0 && (h3.get(s4).placedOrientation = r2), a2 >= 0 && (h3.get(a2).placedOrientation = r2), l3 >= 0 && (h3.get(l3).placedOrientation = r2), c4 >= 0 && (h3.get(c4).placedOrientation = n3);
          }
          commit(e2) {
            this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const t2 = this.prevPlacement;
            let i2 = false;
            this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
            const o2 = t2 ? t2.symbolFadeChange(e2) : 1, r2 = t2 ? t2.opacities : {}, n3 = t2 ? t2.variableOffsets : {}, s4 = t2 ? t2.placedOrientations : {};
            for (const e3 in this.placements) {
              const t3 = this.placements[e3], n4 = r2[e3];
              n4 ? (this.opacities[e3] = new bt(n4, o2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== n4.text.placed || t3.icon !== n4.icon.placed) : (this.opacities[e3] = new bt(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
            }
            for (const e3 in r2) {
              const t3 = r2[e3];
              if (!this.opacities[e3]) {
                const r3 = new bt(t3, o2, false, false);
                r3.isHidden() || (this.opacities[e3] = r3, i2 = i2 || t3.text.placed || t3.icon.placed);
              }
            }
            for (const e3 in n3)
              this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = n3[e3]);
            for (const e3 in s4)
              this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = s4[e3]);
            i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
          }
          updateLayerOpacities(e2, t2) {
            const i2 = /* @__PURE__ */ new Set();
            for (const o2 of t2) {
              const t3 = o2.getBucket(e2);
              t3 && o2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, i2, o2.collisionBoxArray);
            }
          }
          updateBucketOpacities(t2, i2, o2) {
            t2.hasTextData() && t2.text.opacityVertexArray.clear(), t2.hasIconData() && t2.icon.opacityVertexArray.clear(), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
            const r2 = t2.layers[0].layout, n3 = !!t2.layers[0].dynamicFilter(), s4 = new bt(null, 0, false, false, true), a2 = r2.get("text-allow-overlap"), l3 = r2.get("icon-allow-overlap"), c4 = r2.get("text-variable-anchor"), h3 = "map" === r2.get("text-rotation-alignment"), u3 = "map" === r2.get("text-pitch-alignment"), _2 = "none" !== r2.get("icon-text-fit"), d3 = new bt(null, 0, a2 && (l3 || !t2.hasIconData() || r2.get("icon-optional")), l3 && (a2 || !t2.hasTextData() || r2.get("text-optional")), true);
            !t2.collisionArrays && o2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(o2);
            const p3 = (e2, t3, i3) => {
              for (let o3 = 0; o3 < t3 / 4; o3++)
                e2.opacityVertexArray.emplaceBack(i3);
            };
            let m3 = 0;
            for (let o3 = 0; o3 < t2.symbolInstances.length; o3++) {
              const r3 = t2.symbolInstances.get(o3), { numHorizontalGlyphVertices: a3, numVerticalGlyphVertices: l4, crossTileID: f2, numIconVertices: g2 } = r3, v4 = i2.has(f2);
              let x2 = this.opacities[f2];
              v4 ? x2 = s4 : x2 || (x2 = d3, this.opacities[f2] = x2), i2.add(f2);
              const y2 = a3 > 0 || l4 > 0, b3 = g2 > 0, w2 = this.placedOrientations[f2], T3 = w2 === e.WritingMode.vertical, E2 = w2 === e.WritingMode.horizontal || w2 === e.WritingMode.horizontalOnly;
              if (!y2 && !b3 || x2.isHidden() || m3++, y2) {
                const e2 = kt(x2.text);
                p3(t2.text, a3, T3 ? Ft : e2), p3(t2.text, l4, E2 ? Ft : e2);
                const i3 = x2.text.isHidden(), { leftJustifiedTextSymbolIndex: o4, centerJustifiedTextSymbolIndex: n4, rightJustifiedTextSymbolIndex: s5, verticalPlacedTextSymbolIndex: c5 } = r3, h4 = t2.text.placedSymbolArray, u4 = i3 || T3 ? 1 : 0;
                o4 >= 0 && (h4.get(o4).hidden = u4), n4 >= 0 && (h4.get(n4).hidden = u4), s5 >= 0 && (h4.get(s5).hidden = u4), c5 >= 0 && (h4.get(c5).hidden = i3 || E2 ? 1 : 0);
                const _3 = this.variableOffsets[f2];
                _3 && this.markUsedJustification(t2, _3.anchor, r3, w2);
                const d4 = this.placedOrientations[f2];
                d4 && (this.markUsedJustification(t2, "left", r3, d4), this.markUsedOrientation(t2, d4, r3));
              }
              if (b3) {
                const e2 = kt(x2.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o4 } = r3, n4 = t2.icon.placedSymbolArray, s5 = x2.icon.isHidden() ? 1 : 0;
                i3 >= 0 && (p3(t2.icon, g2, T3 ? Ft : e2), n4.get(i3).hidden = s5), o4 >= 0 && (p3(t2.icon, r3.numVerticalIconVertices, E2 ? Ft : e2), n4.get(o4).hidden = s5);
              }
              if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
                const i3 = t2.collisionArrays[o3];
                if (i3) {
                  let o4 = new e.Point(0, 0), r4 = true;
                  if (i3.textBox || i3.verticalTextBox) {
                    if (c4) {
                      const e2 = this.variableOffsets[f2];
                      e2 ? (o4 = Mt(e2.anchor, e2.width, e2.height, e2.textOffset, e2.textScale), h3 && o4._rotate(u3 ? this.transform.angle : -this.transform.angle)) : r4 = false;
                    }
                    n3 && (r4 = !x2.clipped), i3.textBox && St(t2.textCollisionBox.collisionVertexArray, x2.text.placed, !r4 || T3, o4.x, o4.y), i3.verticalTextBox && St(t2.textCollisionBox.collisionVertexArray, x2.text.placed, !r4 || E2, o4.x, o4.y);
                  }
                  const s5 = r4 && Boolean(!E2 && i3.verticalIconBox);
                  i3.iconBox && St(t2.iconCollisionBox.collisionVertexArray, x2.icon.placed, s5, _2 ? o4.x : 0, _2 ? o4.y : 0), i3.verticalIconBox && St(t2.iconCollisionBox.collisionVertexArray, x2.icon.placed, !s5, _2 ? o4.x : 0, _2 ? o4.y : 0);
                }
              }
            }
            if (t2.fullyClipped = 0 === m3, t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.bucketInstanceId in this.collisionCircleArrays) {
              const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
              t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
            }
          }
          symbolFadeChange(e2) {
            return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e2) {
            return Math.max(0, (this.transform.zoom - e2) / 1.5);
          }
          hasTransitions(e2) {
            return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e2, t2) {
            const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
            return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
          }
          setStale() {
            this.stale = true;
          }
        }
        function St(e2, t2, i2, o2, r2) {
          e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0);
        }
        const Dt = Math.pow(2, 25), Lt = Math.pow(2, 24), At = Math.pow(2, 17), zt = Math.pow(2, 16), Rt = Math.pow(2, 9), Ot = Math.pow(2, 8), Bt = Math.pow(2, 1);
        function kt(e2) {
          if (0 === e2.opacity && !e2.placed)
            return 0;
          if (1 === e2.opacity && e2.placed)
            return 4294967295;
          const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
          return i2 * Dt + t2 * Lt + i2 * At + t2 * zt + i2 * Rt + t2 * Ot + i2 * Bt + t2;
        }
        const Ft = 0;
        class Ut {
          constructor(e2) {
            this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && void 0 !== e2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
          }
          continuePlacement(e2, t2, i2, o2, r2) {
            const n3 = this._bucketParts;
            for (; this._currentTileIndex < e2.length; )
              if (t2.getBucketParts(n3, o2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2())
                return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n3.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < n3.length; ) {
              const e3 = n3[this._currentPartIndex];
              if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart), this._currentPartIndex++, r2())
                return true;
            }
            return false;
          }
        }
        class Nt {
          constructor(e2, t2, i2, o2, r2, n3, s4, a2) {
            this.placement = new Pt(e2, r2, n3, s4, a2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t2, i2, o2) {
            const r2 = e.exported.now(), n3 = () => {
              const t3 = e.exported.now() - r2;
              return !this._forceFullPlacement && t3 > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const e2 = i2[t2[this._currentPlacementIndex]], r3 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === e2.type && (!e2.minzoom || e2.minzoom <= r3) && (!e2.maxzoom || e2.maxzoom > r3)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ut(e2)), this._inProgressLayer.continuePlacement(o2[e2.source], this.placement, this._showCollisionBoxes, e2, n3))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e2) {
            return this.placement.commit(e2), this.placement;
          }
        }
        const jt = 512 / e.EXTENT / 2;
        class Gt {
          constructor(t2, i2, o2) {
            this.tileID = t2, this.bucketInstanceId = o2, this.index = new e.KDBush(i2.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
            const r2 = t2.canonical.x * e.EXTENT, n3 = t2.canonical.y * e.EXTENT;
            for (let e2 = 0; e2 < i2.length; e2++) {
              const { key: t3, crossTileID: o3, tileAnchorX: s4, tileAnchorY: a2 } = i2.get(e2), l3 = Math.floor((r2 + s4) * jt), c4 = Math.floor((n3 + a2) * jt);
              this.index.add(l3, c4), this.keys.push(t3), this.crossTileIDs.push(o3);
            }
            this.index.finish();
          }
          findMatches(t2, i2, o2) {
            const r2 = this.tileID.canonical.z < i2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i2.canonical.z), n3 = jt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z), s4 = i2.canonical.x * e.EXTENT, a2 = i2.canonical.y * e.EXTENT;
            for (let e2 = 0; e2 < t2.length; e2++) {
              const i3 = t2.get(e2);
              if (i3.crossTileID)
                continue;
              const { key: l3, tileAnchorX: c4, tileAnchorY: h3 } = i3, u3 = Math.floor((s4 + c4) * n3), _2 = Math.floor((a2 + h3) * n3), d3 = this.index.range(u3 - r2, _2 - r2, u3 + r2, _2 + r2);
              for (const e3 of d3) {
                const t3 = this.crossTileIDs[e3];
                if (this.keys[e3] === l3 && !o2.has(t3)) {
                  o2.add(t3), i3.crossTileID = t3;
                  break;
                }
              }
            }
          }
        }
        class Zt {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Vt {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e2) {
            const t2 = Math.round((e2 - this.lng) / 360);
            if (0 !== t2)
              for (const e3 in this.indexes) {
                const i2 = this.indexes[e3], o2 = {};
                for (const e4 in i2) {
                  const r2 = i2[e4];
                  r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), o2[r2.tileID.key] = r2;
                }
                this.indexes[e3] = o2;
              }
            this.lng = e2;
          }
          addBucket(e2, t2, i2) {
            if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
              if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId)
                return false;
              this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
            }
            for (let e3 = 0; e3 < t2.symbolInstances.length; e3++)
              t2.symbolInstances.get(e3).crossTileID = 0;
            this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = /* @__PURE__ */ new Set());
            const o2 = this.usedCrossTileIDs[e2.overscaledZ];
            for (const i3 in this.indexes) {
              const r2 = this.indexes[i3];
              if (Number(i3) > e2.overscaledZ)
                for (const i4 in r2) {
                  const n3 = r2[i4];
                  n3.tileID.isChildOf(e2) && n3.findMatches(t2.symbolInstances, e2, o2);
                }
              else {
                const n3 = r2[e2.scaledTo(Number(i3)).key];
                n3 && n3.findMatches(t2.symbolInstances, e2, o2);
              }
            }
            for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
              const r2 = t2.symbolInstances.get(e3);
              r2.crossTileID || (r2.crossTileID = i2.generate(), o2.add(r2.crossTileID));
            }
            return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new Gt(e2, t2.symbolInstances, t2.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e2, t2) {
            for (const i2 of t2.crossTileIDs)
              this.usedCrossTileIDs[e2].delete(i2);
          }
          removeStaleBuckets(e2) {
            let t2 = false;
            for (const i2 in this.indexes) {
              const o2 = this.indexes[i2];
              for (const r2 in o2)
                e2[o2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r2]), delete o2[r2], t2 = true);
            }
            return t2;
          }
        }
        class Wt {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Zt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e2, t2, i2, o2) {
            let r2 = this.layerIndexes[e2.id];
            void 0 === r2 && (r2 = this.layerIndexes[e2.id] = new Vt());
            let n3 = false;
            const s4 = {};
            "globe" !== o2.name && r2.handleWrapJump(i2);
            for (const i3 of t2) {
              const t3 = i3.getBucket(e2);
              t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), r2.addBucket(i3.tileID, t3, this.crossTileIDs) && (n3 = true), s4[t3.bucketInstanceId] = true);
            }
            return r2.removeStaleBuckets(s4) && (n3 = true), n3;
          }
          pruneUnusedLayers(e2) {
            const t2 = {};
            e2.forEach((e3) => {
              t2[e3] = true;
            });
            for (const e3 in this.layerIndexes)
              t2[e3] || delete this.layerIndexes[e3];
          }
        }
        const Xt = (t2, i2) => e.emitValidationErrors(t2, i2 && i2.filter((e2) => "source.canvas" !== e2.identifier)), qt = e.pick(Ge, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), $t = e.pick(Ge, ["setCenter", "setZoom", "setBearing", "setPitch"]), Ht = { version: 8, layers: [], sources: {} }, Yt = { fill: true, line: true, background: true, hillshade: true, raster: true };
        class Kt extends e.Evented {
          constructor(t2, i2 = {}) {
            super(), this.map = t2, this.dispatcher = new S(Ue(), this), this.imageManager = new y(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t2._requestManager, i2.localFontFamily ? e.LocalGlyphMode.all : i2.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i2.localFontFamily || i2.localIdeographFontFamily), this.crossTileSymbolIndex = new Wt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());
            const o2 = this;
            this._rtlTextPluginCallback = Kt.registerForPluginStateChange((t3) => {
              o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
                if (e.triggerPluginCompletionEvent(t4), i3 && i3.every((e2) => e2))
                  for (const e2 in o2._sourceCaches) {
                    const t5 = o2._sourceCaches[e2], i4 = t5.getSource().type;
                    "vector" !== i4 && "geojson" !== i4 || t5.reload();
                  }
              });
            }), this.on("data", (e2) => {
              if ("source" !== e2.dataType || "metadata" !== e2.sourceDataType)
                return;
              const t3 = this.getSource(e2.sourceId);
              if (t3 && t3.vectorLayerIds)
                for (const e3 in this._layers) {
                  const i3 = this._layers[e3];
                  i3.source === t3.id && this._validateLayer(i3);
                }
            });
          }
          loadURL(t2, i2 = {}) {
            this.fire(new e.Event("dataloading", { dataType: "style" }));
            const o2 = "boolean" == typeof i2.validate ? i2.validate : !e.isMapboxURL(t2);
            t2 = this.map._requestManager.normalizeStyleURL(t2, i2.accessToken);
            const r2 = this.map._requestManager.transformRequest(t2, e.ResourceType.Style);
            this._request = e.getJSON(r2, (t3, i3) => {
              this._request = null, t3 ? this.fire(new e.ErrorEvent(t3)) : i3 && this._load(i3, o2);
            });
          }
          loadJSON(t2, i2 = {}) {
            this.fire(new e.Event("dataloading", { dataType: "style" })), this._request = e.exported.frame(() => {
              this._request = null, this._load(t2, false !== i2.validate);
            });
          }
          loadEmpty() {
            this.fire(new e.Event("dataloading", { dataType: "style" })), this._load(Ht, false);
          }
          _updateLayerCount(e2, t2) {
            const i2 = t2 ? 1 : -1;
            e2.is3D() && (this._num3DLayers += i2), "circle" === e2.type && (this._numCircleLayers += i2), "symbol" === e2.type && (this._numSymbolLayers += i2);
          }
          _load(t2, i2) {
            if (i2 && Xt(this, e.validateStyle(t2)))
              return;
            this._loaded = true, this.stylesheet = e.clone$1(t2), this._updateMapProjection();
            for (const e2 in t2.sources)
              this.addSource(e2, t2.sources[e2], { validate: false });
            this._changed = false, t2.sprite ? this._loadSprite(t2.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(t2.glyphs);
            const o2 = je(this.stylesheet.layers);
            this._order = o2.map((e2) => e2.id), this._layers = {}, this._serializedLayers = {};
            for (const t3 of o2) {
              const i3 = e.createStyleLayer(t3);
              i3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = i3, this._serializedLayers[i3.id] = i3.serialize(), this._updateLayerCount(i3, true);
            }
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", { dataType: "style" })), this.fire(new e.Event("style.load"));
          }
          terrainSetForDrapingOnly() {
            return !!this.terrain && 0 === this.terrain.drapeRenderMode;
          }
          setProjection(e2) {
            e2 ? this.stylesheet.projection = e2 : delete this.stylesheet.projection, this._updateMapProjection();
          }
          applyProjectionUpdate() {
            this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
          }
          _updateMapProjection() {
            this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
          }
          _loadSprite(t2) {
            this._spriteRequest = function(t3, i2, o2) {
              let r2, n3, s4;
              const a2 = e.exported.devicePixelRatio > 1 ? "@2x" : "";
              let l3 = e.getJSON(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".json"), e.ResourceType.SpriteJSON), (e2, t4) => {
                l3 = null, s4 || (s4 = e2, r2 = t4, h3());
              }), c4 = e.getImage(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".png"), e.ResourceType.SpriteImage), (e2, t4) => {
                c4 = null, s4 || (s4 = e2, n3 = t4, h3());
              });
              function h3() {
                if (s4)
                  o2(s4);
                else if (r2 && n3) {
                  const t4 = e.exported.getImageData(n3), i3 = {};
                  for (const o3 in r2) {
                    const { width: n4, height: s5, x: a3, y: l4, sdf: c5, pixelRatio: h4, stretchX: u3, stretchY: _2, content: d3 } = r2[o3], p3 = new e.RGBAImage({ width: n4, height: s5 });
                    e.RGBAImage.copy(t4, p3, { x: a3, y: l4 }, { x: 0, y: 0 }, { width: n4, height: s5 }), i3[o3] = { data: p3, pixelRatio: h4, sdf: c5, stretchX: u3, stretchY: _2, content: d3 };
                  }
                  o2(null, i3);
                }
              }
              return { cancel() {
                l3 && (l3.cancel(), l3 = null), c4 && (c4.cancel(), c4 = null);
              } };
            }(t2, this.map._requestManager, (t3, i2) => {
              if (this._spriteRequest = null, t3)
                this.fire(new e.ErrorEvent(t3));
              else if (i2)
                for (const e2 in i2)
                  this.imageManager.addImage(e2, i2[e2]);
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new e.Event("data", { dataType: "style" }));
            });
          }
          _validateLayer(t2) {
            const i2 = this.getSource(t2.source);
            if (!i2)
              return;
            const o2 = t2.sourceLayer;
            o2 && ("geojson" === i2.type || i2.vectorLayerIds && -1 === i2.vectorLayerIds.indexOf(o2)) && this.fire(new e.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t2.id}"`)));
          }
          loaded() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._updatedSources).length)
              return false;
            for (const e2 in this._sourceCaches)
              if (!this._sourceCaches[e2].loaded())
                return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeLayers(e2) {
            const t2 = [];
            for (const i2 of e2) {
              const e3 = this._layers[i2];
              "custom" !== e3.type && t2.push(e3.serialize());
            }
            return t2;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition())
              return true;
            if (this.fog && this.fog.hasTransition())
              return true;
            for (const e2 in this._sourceCaches)
              if (this._sourceCaches[e2].hasTransition())
                return true;
            for (const e2 in this._layers)
              if (this._layers[e2].hasTransition())
                return true;
            return false;
          }
          get order() {
            return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
          }
          isLayerDraped(e2) {
            return !!this.terrain && ("function" == typeof e2.isLayerDraped ? e2.isLayerDraped() : Yt[e2.type]);
          }
          _checkLoaded() {
            if (!this._loaded)
              throw new Error("Style is not done loading");
          }
          update(t2) {
            if (!this._loaded)
              return;
            const i2 = this._changed;
            if (this._changed) {
              const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
              (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
              for (const e3 in this._updatedSources) {
                const t3 = this._updatedSources[e3];
                "reload" === t3 ? this._reloadSource(e3) : "clear" === t3 && this._clearSource(e3);
              }
              this._updateTilesForChangedImages();
              for (const e3 in this._updatedPaintProps)
                this._layers[e3].updateTransitions(t2);
              this.light.updateTransitions(t2), this.fog && this.fog.updateTransitions(t2), this._resetUpdates();
            }
            const o2 = {};
            for (const e2 in this._sourceCaches) {
              const t3 = this._sourceCaches[e2];
              o2[e2] = t3.used, t3.used = false;
            }
            for (const e2 of this._order) {
              const i3 = this._layers[e2];
              if (i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom)) {
                const e3 = this._getLayerSourceCache(i3);
                e3 && (e3.used = true);
              }
              const o3 = this.map.painter;
              if (o3) {
                const e3 = i3.getProgramIds();
                if (!e3)
                  continue;
                const r2 = i3.getProgramConfiguration(t2.zoom);
                for (const t3 of e3)
                  o3.useProgram(t3, r2);
              }
            }
            for (const t3 in o2) {
              const i3 = this._sourceCaches[t3];
              o2[t3] !== i3.used && i3.getSource().fire(new e.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
            }
            this.light.recalculate(t2), this.terrain && this.terrain.recalculate(t2), this.fog && this.fog.recalculate(t2), this.z = t2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i2 && this.fire(new e.Event("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e2 = Object.keys(this._changedImages);
            if (e2.length) {
              for (const t2 in this._sourceCaches)
                this._sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
              this._changedImages = {};
            }
          }
          _updateWorkerLayers(e2, t2) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e2), removedIds: t2 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
          }
          setState(i2) {
            if (this._checkLoaded(), Xt(this, e.validateStyle(i2)))
              return false;
            (i2 = e.clone$1(i2)).layers = je(i2.layers);
            const o2 = function(e2, i3) {
              if (!e2)
                return [{ command: Ge.setStyle, args: [i3] }];
              let o3 = [];
              try {
                if (!t(e2.version, i3.version))
                  return [{ command: Ge.setStyle, args: [i3] }];
                t(e2.center, i3.center) || o3.push({ command: Ge.setCenter, args: [i3.center] }), t(e2.zoom, i3.zoom) || o3.push({ command: Ge.setZoom, args: [i3.zoom] }), t(e2.bearing, i3.bearing) || o3.push({ command: Ge.setBearing, args: [i3.bearing] }), t(e2.pitch, i3.pitch) || o3.push({ command: Ge.setPitch, args: [i3.pitch] }), t(e2.sprite, i3.sprite) || o3.push({ command: Ge.setSprite, args: [i3.sprite] }), t(e2.glyphs, i3.glyphs) || o3.push({ command: Ge.setGlyphs, args: [i3.glyphs] }), t(e2.transition, i3.transition) || o3.push({ command: Ge.setTransition, args: [i3.transition] }), t(e2.light, i3.light) || o3.push({ command: Ge.setLight, args: [i3.light] }), t(e2.fog, i3.fog) || o3.push({ command: Ge.setFog, args: [i3.fog] }), t(e2.projection, i3.projection) || o3.push({ command: Ge.setProjection, args: [i3.projection] });
                const r3 = {}, n3 = [];
                !function(e3, i4, o4, r4) {
                  let n4;
                  for (n4 in i4 = i4 || {}, e3 = e3 || {})
                    e3.hasOwnProperty(n4) && (i4.hasOwnProperty(n4) || Ve(n4, o4, r4));
                  for (n4 in i4) {
                    if (!i4.hasOwnProperty(n4))
                      continue;
                    const s5 = i4[n4];
                    e3.hasOwnProperty(n4) ? t(e3[n4], s5) || ("geojson" === e3[n4].type && "geojson" === s5.type && Xe(e3, i4, n4) ? o4.push({ command: Ge.setGeoJSONSourceData, args: [n4, s5.data] }) : We(n4, i4, o4, r4)) : Ze(n4, i4, o4);
                  }
                }(e2.sources, i3.sources, n3, r3);
                const s4 = [];
                e2.layers && e2.layers.forEach((e3) => {
                  e3.source && r3[e3.source] ? o3.push({ command: Ge.removeLayer, args: [e3.id] }) : s4.push(e3);
                });
                let a2 = e2.terrain;
                a2 && r3[a2.source] && (o3.push({ command: Ge.setTerrain, args: [void 0] }), a2 = void 0), o3 = o3.concat(n3), t(a2, i3.terrain) || o3.push({ command: Ge.setTerrain, args: [i3.terrain] }), function(e3, i4, o4) {
                  i4 = i4 || [];
                  const r4 = (e3 = e3 || []).map($e), n4 = i4.map($e), s5 = e3.reduce(He, {}), a3 = i4.reduce(He, {}), l3 = r4.slice(), c4 = /* @__PURE__ */ Object.create(null);
                  let h3, u3, _2, d3, p3, m3, f2;
                  for (h3 = 0, u3 = 0; h3 < r4.length; h3++)
                    _2 = r4[h3], a3.hasOwnProperty(_2) ? u3++ : (o4.push({ command: Ge.removeLayer, args: [_2] }), l3.splice(l3.indexOf(_2, u3), 1));
                  for (h3 = 0, u3 = 0; h3 < n4.length; h3++)
                    _2 = n4[n4.length - 1 - h3], l3[l3.length - 1 - h3] !== _2 && (s5.hasOwnProperty(_2) ? (o4.push({ command: Ge.removeLayer, args: [_2] }), l3.splice(l3.lastIndexOf(_2, l3.length - u3), 1)) : u3++, m3 = l3[l3.length - h3], o4.push({ command: Ge.addLayer, args: [a3[_2], m3] }), l3.splice(l3.length - h3, 0, _2), c4[_2] = true);
                  for (h3 = 0; h3 < n4.length; h3++)
                    if (_2 = n4[h3], d3 = s5[_2], p3 = a3[_2], !c4[_2] && !t(d3, p3))
                      if (t(d3.source, p3.source) && t(d3["source-layer"], p3["source-layer"]) && t(d3.type, p3.type)) {
                        for (f2 in qe(d3.layout, p3.layout, o4, _2, null, Ge.setLayoutProperty), qe(d3.paint, p3.paint, o4, _2, null, Ge.setPaintProperty), t(d3.filter, p3.filter) || o4.push({ command: Ge.setFilter, args: [_2, p3.filter] }), t(d3.minzoom, p3.minzoom) && t(d3.maxzoom, p3.maxzoom) || o4.push({ command: Ge.setLayerZoomRange, args: [_2, p3.minzoom, p3.maxzoom] }), d3)
                          d3.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? qe(d3[f2], p3[f2], o4, _2, f2.slice(6), Ge.setPaintProperty) : t(d3[f2], p3[f2]) || o4.push({ command: Ge.setLayerProperty, args: [_2, f2, p3[f2]] }));
                        for (f2 in p3)
                          p3.hasOwnProperty(f2) && !d3.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? qe(d3[f2], p3[f2], o4, _2, f2.slice(6), Ge.setPaintProperty) : t(d3[f2], p3[f2]) || o4.push({ command: Ge.setLayerProperty, args: [_2, f2, p3[f2]] }));
                      } else
                        o4.push({ command: Ge.removeLayer, args: [_2] }), m3 = l3[l3.lastIndexOf(_2) + 1], o4.push({ command: Ge.addLayer, args: [p3, m3] });
                }(s4, i3.layers, o3);
              } catch (e3) {
                console.warn("Unable to compute style diff:", e3), o3 = [{ command: Ge.setStyle, args: [i3] }];
              }
              return o3;
            }(this.serialize(), i2).filter((e2) => !(e2.command in $t));
            if (0 === o2.length)
              return false;
            const r2 = o2.filter((e2) => !(e2.command in qt));
            if (r2.length > 0)
              throw new Error(`Unimplemented: ${r2.map((e2) => e2.command).join(", ")}.`);
            return o2.forEach((e2) => {
              "setTransition" !== e2.command && "setProjection" !== e2.command && this[e2.command].apply(this, e2.args);
            }), this.stylesheet = i2, this._updateMapProjection(), true;
          }
          addImage(t2, i2) {
            return this.getImage(t2) ? this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t2, i2), this._afterImageUpdated(t2), this);
          }
          updateImage(e2, t2) {
            this.imageManager.updateImage(e2, t2);
          }
          getImage(e2) {
            return this.imageManager.getImage(e2);
          }
          removeImage(t2) {
            return this.getImage(t2) ? (this.imageManager.removeImage(t2), this._afterImageUpdated(t2), this) : this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
          }
          _afterImageUpdated(t2) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this._availableImages.slice();
          }
          addSource(t2, i2, o2 = {}) {
            if (this._checkLoaded(), void 0 !== this.getSource(t2))
              throw new Error("There is already a source with this ID");
            if (!i2.type)
              throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.validateSource, `sources.${t2}`, i2, null, o2))
              return;
            this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
            const r2 = De(t2, i2, this.dispatcher, this);
            r2.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(t2), source: r2.serialize(), sourceId: t2 }));
            const n3 = (i3) => {
              const o3 = (i3 ? "symbol:" : "other:") + t2, n4 = this._sourceCaches[o3] = new e.SourceCache(o3, r2, i3);
              (i3 ? this._symbolSourceCaches : this._otherSourceCaches)[t2] = n4, n4.style = this, n4.onAdd(this.map);
            };
            n3(false), "vector" !== i2.type && "geojson" !== i2.type || n3(true), r2.onAdd && r2.onAdd(this.map), this._changed = true;
          }
          removeSource(t2) {
            this._checkLoaded();
            const i2 = this.getSource(t2);
            if (!i2)
              throw new Error("There is no source with this ID");
            for (const i3 in this._layers)
              if (this._layers[i3].source === t2)
                return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
            if (this.terrain && this.terrain.get().source === t2)
              return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while terrain is using it.`)));
            const o2 = this._getSourceCaches(t2);
            for (const t3 of o2)
              delete this._sourceCaches[t3.id], delete this._updatedSources[t3.id], t3.fire(new e.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
            return delete this._otherSourceCaches[t2], delete this._symbolSourceCaches[t2], i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changed = true, this;
          }
          setGeoJSONSourceData(e2, t2) {
            this._checkLoaded(), this.getSource(e2).setData(t2), this._changed = true;
          }
          getSource(e2) {
            const t2 = this._getSourceCache(e2);
            return t2 && t2.getSource();
          }
          _getSources() {
            const e2 = [];
            for (const t2 in this._otherSourceCaches) {
              const i2 = this._getSourceCache(t2);
              i2 && e2.push(i2.getSource());
            }
            return e2;
          }
          addLayer(t2, i2, o2 = {}) {
            this._checkLoaded();
            const r2 = t2.id;
            if (this.getLayer(r2))
              return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r2}" already exists on this map`)));
            let n3;
            if ("custom" === t2.type) {
              if (Xt(this, e.validateCustomStyleLayer(t2)))
                return;
              n3 = e.createStyleLayer(t2);
            } else {
              if ("object" == typeof t2.source && (this.addSource(r2, t2.source), t2 = e.clone$1(t2), t2 = e.extend(t2, { source: r2 })), this._validate(e.validateLayer, `layers.${r2}`, t2, { arrayIndex: -1 }, o2))
                return;
              n3 = e.createStyleLayer(t2), this._validateLayer(n3), n3.setEventedParent(this, { layer: { id: r2 } }), this._serializedLayers[n3.id] = n3.serialize(), this._updateLayerCount(n3, true);
            }
            const s4 = i2 ? this._order.indexOf(i2) : this._order.length;
            if (i2 && -1 === s4)
              return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`)));
            this._order.splice(s4, 0, r2), this._layerOrderChanged = true, this._layers[r2] = n3;
            const a2 = this._getLayerSourceCache(n3);
            if (this._removedLayers[r2] && n3.source && a2 && "custom" !== n3.type) {
              const e2 = this._removedLayers[r2];
              delete this._removedLayers[r2], e2.type !== n3.type ? this._updatedSources[n3.source] = "clear" : (this._updatedSources[n3.source] = "reload", a2.pause());
            }
            this._updateLayer(n3), n3.onAdd && n3.onAdd(this.map), this._updateDrapeFirstLayers();
          }
          moveLayer(t2, i2) {
            if (this._checkLoaded(), this._changed = true, !this._layers[t2])
              return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be moved.`)));
            if (t2 === i2)
              return;
            const o2 = this._order.indexOf(t2);
            this._order.splice(o2, 1);
            const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
            i2 && -1 === r2 ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`))) : (this._order.splice(r2, 0, t2), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
          }
          removeLayer(t2) {
            this._checkLoaded();
            const i2 = this._layers[t2];
            if (!i2)
              return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be removed.`)));
            i2.setEventedParent(null), this._updateLayerCount(i2, false);
            const o2 = this._order.indexOf(t2);
            this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t2] = i2, delete this._layers[t2], delete this._serializedLayers[t2], delete this._updatedLayers[t2], delete this._updatedPaintProps[t2], i2.onRemove && i2.onRemove(this.map), this._updateDrapeFirstLayers();
          }
          getLayer(e2) {
            return this._layers[e2];
          }
          hasLayer(e2) {
            return e2 in this._layers;
          }
          hasLayerType(e2) {
            for (const t2 in this._layers)
              if (this._layers[t2].type === e2)
                return true;
            return false;
          }
          setLayerZoomRange(t2, i2, o2) {
            this._checkLoaded();
            const r2 = this.getLayer(t2);
            r2 ? r2.minzoom === i2 && r2.maxzoom === o2 || (null != i2 && (r2.minzoom = i2), null != o2 && (r2.maxzoom = o2), this._updateLayer(r2)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot have zoom extent.`)));
          }
          setFilter(i2, o2, r2 = {}) {
            this._checkLoaded();
            const n3 = this.getLayer(i2);
            if (n3) {
              if (!t(n3.filter, o2))
                return null == o2 ? (n3.filter = void 0, void this._updateLayer(n3)) : void (this._validate(e.validateFilter, `layers.${n3.id}.filter`, o2, { layerType: n3.type }, r2) || (n3.filter = e.clone$1(o2), this._updateLayer(n3)));
            } else
              this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be filtered.`)));
          }
          getFilter(t2) {
            const i2 = this.getLayer(t2);
            return i2 && e.clone$1(i2.filter);
          }
          setLayoutProperty(i2, o2, r2, n3 = {}) {
            this._checkLoaded();
            const s4 = this.getLayer(i2);
            s4 ? t(s4.getLayoutProperty(o2), r2) || (s4.setLayoutProperty(o2, r2, n3), this._updateLayer(s4)) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
          }
          getLayoutProperty(t2, i2) {
            const o2 = this.getLayer(t2);
            if (o2)
              return o2.getLayoutProperty(i2);
            this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style.`)));
          }
          setPaintProperty(i2, o2, r2, n3 = {}) {
            this._checkLoaded();
            const s4 = this.getLayer(i2);
            s4 ? t(s4.getPaintProperty(o2), r2) || (s4.setPaintProperty(o2, r2, n3) && this._updateLayer(s4), this._changed = true, this._updatedPaintProps[i2] = true) : this.fire(new e.ErrorEvent(new Error(`The layer '${i2}' does not exist in the map's style and cannot be styled.`)));
          }
          getPaintProperty(e2, t2) {
            const i2 = this.getLayer(e2);
            return i2 && i2.getPaintProperty(t2);
          }
          setFeatureState(t2, i2) {
            this._checkLoaded();
            const o2 = t2.source, r2 = t2.sourceLayer, n3 = this.getSource(o2);
            if (!n3)
              return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            const s4 = n3.type;
            if ("geojson" === s4 && r2)
              return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
            if ("vector" === s4 && !r2)
              return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            void 0 === t2.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));
            const a2 = this._getSourceCaches(o2);
            for (const e2 of a2)
              e2.setFeatureState(r2, t2.id, i2);
          }
          removeFeatureState(t2, i2) {
            this._checkLoaded();
            const o2 = t2.source, r2 = this.getSource(o2);
            if (!r2)
              return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            const n3 = r2.type, s4 = "vector" === n3 ? t2.sourceLayer : void 0;
            if ("vector" === n3 && !s4)
              return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            if (i2 && "string" != typeof t2.id && "number" != typeof t2.id)
              return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
            const a2 = this._getSourceCaches(o2);
            for (const e2 of a2)
              e2.removeFeatureState(s4, t2.id, i2);
          }
          getFeatureState(t2) {
            this._checkLoaded();
            const i2 = t2.source, o2 = t2.sourceLayer, r2 = this.getSource(i2);
            if (r2) {
              if ("vector" !== r2.type || o2)
                return void 0 === t2.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i2)[0].getFeatureState(o2, t2.id);
              this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else
              this.fire(new e.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
          }
          getTransition() {
            return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            const t2 = {};
            for (const e2 in this._sourceCaches) {
              const i2 = this._sourceCaches[e2].getSource();
              t2[i2.id] || (t2[i2.id] = i2.serialize());
            }
            return e.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.getTerrain() || void 0, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: t2, layers: this._serializeLayers(this._order) }, (e2) => void 0 !== e2);
          }
          _updateLayer(e2) {
            this._updatedLayers[e2.id] = true;
            const t2 = this._getLayerSourceCache(e2);
            e2.source && !this._updatedSources[e2.source] && t2 && "raster" !== t2.getSource().type && (this._updatedSources[e2.source] = "reload", t2.pause()), this._changed = true, e2.invalidateCompiledFilter();
          }
          _flattenAndSortRenderedFeatures(e2) {
            const t2 = (e3) => "fill-extrusion" === this._layers[e3].type, i2 = {}, o2 = [];
            for (let r3 = this._order.length - 1; r3 >= 0; r3--) {
              const n3 = this._order[r3];
              if (t2(n3)) {
                i2[n3] = r3;
                for (const t3 of e2) {
                  const e3 = t3[n3];
                  if (e3)
                    for (const t4 of e3)
                      o2.push(t4);
                }
              }
            }
            o2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
            const r2 = [];
            for (let n3 = this._order.length - 1; n3 >= 0; n3--) {
              const s4 = this._order[n3];
              if (t2(s4))
                for (let e3 = o2.length - 1; e3 >= 0; e3--) {
                  const t3 = o2[e3].feature;
                  if (i2[t3.layer.id] < n3)
                    break;
                  r2.push(t3), o2.pop();
                }
              else
                for (const t3 of e2) {
                  const e3 = t3[s4];
                  if (e3)
                    for (const t4 of e3)
                      r2.push(t4.feature);
                }
            }
            return r2;
          }
          queryRenderedFeatures(t2, i2, o2) {
            i2 && i2.filter && this._validate(e.validateFilter, "queryRenderedFeatures.filter", i2.filter, null, i2);
            const r2 = {};
            if (i2 && i2.layers) {
              if (!Array.isArray(i2.layers))
                return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (const t3 of i2.layers) {
                const i3 = this._layers[t3];
                if (!i3)
                  return this.fire(new e.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
                r2[i3.source] = true;
              }
            }
            const n3 = [];
            i2.availableImages = this._availableImages;
            const s4 = i2 && i2.layers ? i2.layers.some((e2) => {
              const t3 = this.getLayer(e2);
              return t3 && t3.is3D();
            }) : this.has3DLayers(), a2 = L.createFromScreenPoints(t2, o2);
            for (const e2 in this._sourceCaches) {
              const t3 = this._sourceCaches[e2].getSource().id;
              i2.layers && !r2[t3] || n3.push(Ae(this._sourceCaches[e2], this._layers, this._serializedLayers, a2, i2, o2, s4, !!this.map._showQueryGeometry));
            }
            return this.placement && n3.push(function(e2, t3, i3, o3, r3, n4, s5) {
              const a3 = {}, l3 = n4.queryRenderedSymbols(o3), c4 = [];
              for (const e3 of Object.keys(l3).map(Number))
                c4.push(s5[e3]);
              c4.sort(Re);
              for (const i4 of c4) {
                const o4 = i4.featureIndex.lookupSymbolFeatures(l3[i4.bucketInstanceId], t3, i4.bucketIndex, i4.sourceLayerIndex, r3.filter, r3.layers, r3.availableImages, e2);
                for (const e3 in o4) {
                  const t4 = a3[e3] = a3[e3] || [], r4 = o4[e3];
                  r4.sort((e4, t5) => {
                    const o5 = i4.featureSortOrder;
                    if (o5) {
                      const i5 = o5.indexOf(e4.featureIndex);
                      return o5.indexOf(t5.featureIndex) - i5;
                    }
                    return t5.featureIndex - e4.featureIndex;
                  });
                  for (const e4 of r4)
                    t4.push(e4);
                }
              }
              for (const t4 in a3)
                a3[t4].forEach((o4) => {
                  const r4 = o4.feature, n5 = i3(e2[t4]);
                  if (!n5)
                    return;
                  const s6 = n5.getFeatureState(r4.layer["source-layer"], r4.id);
                  r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = s6;
                });
              return a3;
            }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a2.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n3);
          }
          querySourceFeatures(t2, i2) {
            i2 && i2.filter && this._validate(e.validateFilter, "querySourceFeatures.filter", i2.filter, null, i2);
            const o2 = this._getSourceCaches(t2);
            let r2 = [];
            for (const e2 of o2)
              r2 = r2.concat(ze(e2, i2));
            return r2;
          }
          addSourceType(e2, t2, i2) {
            return Kt.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (Kt.setSourceType(e2, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t2.workerSourceURL }, i2) : i2(null, null));
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e2, i2 = {}) {
            this._checkLoaded();
            const o2 = this.light.getLight();
            let r2 = false;
            for (const i3 in e2)
              if (!t(e2[i3], o2[i3])) {
                r2 = true;
                break;
              }
            if (!r2)
              return;
            const n3 = this._setTransitionParameters({ duration: 300, delay: 0 });
            this.light.setLight(e2, i2), this.light.updateTransitions(n3);
          }
          getTerrain() {
            return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
          }
          setTerrainForDraping() {
            this.setTerrain({ source: "", exaggeration: 0 }, 0);
          }
          setTerrain(i2, o2 = 1) {
            if (this._checkLoaded(), !i2)
              return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
            let r2 = i2;
            if (1 === o2) {
              if ("object" == typeof r2.source) {
                const t2 = "terrain-dem-src";
                this.addSource(t2, r2.source), r2 = e.clone$1(r2), r2 = e.extend(r2, { source: t2 });
              }
              if (this._validate(e.validateTerrain, "terrain", r2))
                return;
            }
            if (!this.terrain || this.terrain && o2 !== this.terrain.drapeRenderMode) {
              if (!r2)
                return;
              this._createTerrain(r2, o2);
            } else {
              const i3 = this.terrain, o3 = i3.get();
              for (const t2 of Object.keys(e.spec.terrain))
                !r2.hasOwnProperty(t2) && e.spec.terrain[t2].default && (r2[t2] = e.spec.terrain[t2].default);
              for (const e2 in r2)
                if (!t(r2[e2], o3[e2])) {
                  i3.set(r2), this.stylesheet.terrain = r2;
                  const e3 = this._setTransitionParameters({ duration: 0 });
                  i3.updateTransitions(e3);
                  break;
                }
            }
            this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
          }
          _createFog(e2) {
            const t2 = this.fog = new P2(e2, this.map.transform);
            this.stylesheet.fog = e2;
            const i2 = this._setTransitionParameters({ duration: 0 });
            t2.updateTransitions(i2);
          }
          _updateMarkersOpacity() {
            0 !== this.map._markers.length && this.map._requestDomTask(() => {
              for (const e2 of this.map._markers)
                e2._evaluateOpacity();
            });
          }
          getFog() {
            return this.fog ? this.fog.get() : null;
          }
          setFog(e2) {
            if (this._checkLoaded(), !e2)
              return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
            if (this.fog) {
              const i2 = this.fog, o2 = i2.get();
              0 === Object.keys(e2).length && i2.set(e2);
              for (const r2 in e2)
                if (!t(e2[r2], o2[r2])) {
                  i2.set(e2), this.stylesheet.fog = e2;
                  const t2 = this._setTransitionParameters({ duration: 0 });
                  i2.updateTransitions(t2);
                  break;
                }
            } else
              this._createFog(e2);
            this._markersNeedUpdate = true;
          }
          _setTransitionParameters(t2) {
            return { now: e.exported.now(), transition: e.extend(t2, this.stylesheet.transition) };
          }
          _updateDrapeFirstLayers() {
            if (!this.map._optimizeForTerrain || !this.terrain)
              return;
            const e2 = this._order.filter((e3) => this.isLayerDraped(this._layers[e3])), t2 = this._order.filter((e3) => !this.isLayerDraped(this._layers[e3]));
            this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t2);
          }
          _createTerrain(e2, t2) {
            const i2 = this.terrain = new E(e2, t2);
            this.stylesheet.terrain = e2, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
            const o2 = this._setTransitionParameters({ duration: 0 });
            i2.updateTransitions(o2);
          }
          _force3DLayerUpdate() {
            for (const e2 in this._layers) {
              const t2 = this._layers[e2];
              "fill-extrusion" === t2.type && this._updateLayer(t2);
            }
          }
          _forceSymbolLayerUpdate() {
            for (const e2 in this._layers) {
              const t2 = this._layers[e2];
              "symbol" === t2.type && this._updateLayer(t2);
            }
          }
          _validate(t2, i2, o2, r2, n3 = {}) {
            return (!n3 || false !== n3.validate) && Xt(this, t2.call(e.validateStyle, e.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: e.spec }, r2)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const e2 in this._layers)
              this._layers[e2].setEventedParent(null);
            for (const e2 in this._sourceCaches)
              this._sourceCaches[e2].clearTiles(), this._sourceCaches[e2].setEventedParent(null);
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
          }
          _clearSource(e2) {
            const t2 = this._getSourceCaches(e2);
            for (const e3 of t2)
              e3.clearTiles();
          }
          _reloadSource(e2) {
            const t2 = this._getSourceCaches(e2);
            for (const e3 of t2)
              e3.resume(), e3.reload();
          }
          _reloadSources() {
            for (const e2 of this._getSources())
              e2.reload && e2.reload();
          }
          _updateSources(e2) {
            for (const t2 in this._sourceCaches)
              this._sourceCaches[t2].update(e2);
          }
          _generateCollisionBoxes() {
            for (const e2 in this._sourceCaches) {
              const t2 = this._sourceCaches[e2];
              t2.resume(), t2.reload();
            }
          }
          _updatePlacement(t2, i2, o2, r2, n3 = false) {
            let s4 = false, a2 = false;
            const l3 = {};
            for (const e2 of this._order) {
              const i3 = this._layers[e2];
              if ("symbol" !== i3.type)
                continue;
              if (!l3[i3.source]) {
                const e3 = this._getLayerSourceCache(i3);
                if (!e3)
                  continue;
                l3[i3.source] = e3.getRenderableIds(true).map((t3) => e3.getTileByID(t3)).sort((e4, t3) => t3.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t3.tileID) ? -1 : 1));
              }
              const o3 = this.crossTileSymbolIndex.addLayer(i3, l3[i3.source], t2.center.lng, t2.projection);
              s4 = s4 || o3;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n3 = n3 || this._layerOrderChanged || 0 === o2, this._layerOrderChanged && this.fire(new e.Event("neworder")), (n3 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t2.zoom)) && (this.pauseablePlacement = new Nt(t2, this._order, n3, i2, o2, r2, this.placement, this.fog && t2.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), a2 = true), s4 && this.pauseablePlacement.placement.setStale()), a2 || s4)
              for (const e2 of this._order) {
                const t3 = this._layers[e2];
                "symbol" === t3.type && this.placement.updateLayerOpacities(t3, l3[t3.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e2 in this._sourceCaches)
              this._sourceCaches[e2].releaseSymbolFadeTiles();
          }
          getImages(e2, t2, i2) {
            this.imageManager.getImages(t2.icons, i2), this._updateTilesForChangedImages();
            const o2 = (e3) => {
              e3 && e3.setDependencies(t2.tileID.key, t2.type, t2.icons);
            };
            o2(this._otherSourceCaches[t2.source]), o2(this._symbolSourceCaches[t2.source]);
          }
          getGlyphs(e2, t2, i2) {
            this.glyphManager.getGlyphs(t2.stacks, i2);
          }
          getResource(t2, i2, o2) {
            return e.makeRequest(i2, o2);
          }
          _getSourceCache(e2) {
            return this._otherSourceCaches[e2];
          }
          _getLayerSourceCache(e2) {
            return "symbol" === e2.type ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
          }
          _getSourceCaches(e2) {
            const t2 = [];
            return this._otherSourceCaches[e2] && t2.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t2.push(this._symbolSourceCaches[e2]), t2;
          }
          _isSourceCacheLoaded(t2) {
            const i2 = this._getSourceCaches(t2);
            return 0 === i2.length ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t2}'`))), false) : i2.every((e2) => e2.loaded());
          }
          has3DLayers() {
            return this._num3DLayers > 0;
          }
          hasSymbolLayers() {
            return this._numSymbolLayers > 0;
          }
          hasCircleLayers() {
            return this._numCircleLayers > 0;
          }
          _clearWorkerCaches() {
            this.dispatcher.broadcast("clearCaches");
          }
          destroy() {
            this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
          }
        }
        Kt.getSourceType = function(e2) {
          return Se[e2];
        }, Kt.setSourceType = function(e2, t2) {
          Se[e2] = t2;
        }, Kt.registerForPluginStateChange = e.registerForPluginStateChange;
        var Jt = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", Qt = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ei = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", ti = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", ii = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
        let oi = {}, ri = {};
        const ni = [];
        hi(Jt, ni), hi(ei, ni), hi(ti, ni), hi(ii, ni), oi = ui("", ei), ri = ui(ii, ti);
        const si = ui("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), ai = Jt, li = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
        var ci = { background: ui("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: ui("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: ui("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: ui("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ui("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: ui("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: ui("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: ui("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ui("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"), fill: ui("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: ui("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: ui("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: ui("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: ui("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: ui("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: ui("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ui("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: ui("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: ui("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: ui("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: ui("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"), symbolSDF: ui("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"), symbolTextAndIcon: ui("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"), terrainRaster: ui("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"), terrainDepth: ui("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: ui("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Qt), skyboxGradient: ui("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Qt), skyboxCapture: ui("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: ui("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"), globeAtmosphere: ui("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}") };
        function hi(e2, t2) {
          const i2 = e2.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
          for (let e3 of i2)
            if (e3 = e3.trim(), "#" === e3[0] && e3.includes("if") && !e3.includes("endif")) {
              e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
              const i3 = e3.split(" ");
              for (const e4 of i3)
                t2.includes(e4) || t2.push(e4);
            }
        }
        function ui(e2, t2) {
          const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = t2.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), r2 = {}, n3 = [...ni];
          return hi(e2, n3), hi(t2, n3), { fragmentSource: e2 = e2.replace(i2, (e3, t3, i3, o3, n4) => (r2[n4] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${n4}
varying ${i3} ${o3} ${n4};
#else
uniform ${i3} ${o3} u_${n4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${n4}
    ${i3} ${o3} ${n4} = u_${n4};
#endif
`)), vertexSource: t2 = t2.replace(i2, (e3, t3, i3, o3, n4) => {
            const s4 = "float" === o3 ? "vec2" : "vec4", a2 = n4.match(/color/) ? "color" : s4;
            return r2[n4] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${n4}
uniform lowp float u_${n4}_t;
attribute ${i3} ${s4} a_${n4};
varying ${i3} ${o3} ${n4};
#else
uniform ${i3} ${o3} u_${n4};
#endif
` : "vec4" === a2 ? `
#ifndef HAS_UNIFORM_u_${n4}
    ${n4} = a_${n4};
#else
    ${i3} ${o3} ${n4} = u_${n4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n4}
    ${n4} = unpack_mix_${a2}(a_${n4}, u_${n4}_t);
#else
    ${i3} ${o3} ${n4} = u_${n4};
#endif
` : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${n4}
uniform lowp float u_${n4}_t;
attribute ${i3} ${s4} a_${n4};
#else
uniform ${i3} ${o3} u_${n4};
#endif
` : "vec4" === a2 ? `
#ifndef HAS_UNIFORM_u_${n4}
    ${i3} ${o3} ${n4} = a_${n4};
#else
    ${i3} ${o3} ${n4} = u_${n4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n4}
    ${i3} ${o3} ${n4} = unpack_mix_${a2}(a_${n4}, u_${n4}_t);
#else
    ${i3} ${o3} ${n4} = u_${n4};
#endif
`;
          }), staticAttributes: o2, usedDefines: n3 };
        }
        class _i {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
          }
          bind(e2, t2, i2, o2, r2, n3, s4) {
            this.context = e2;
            let a2 = this.boundPaintVertexBuffers.length !== o2.length;
            for (let e3 = 0; !a2 && e3 < o2.length; e3++)
              this.boundPaintVertexBuffers[e3] !== o2[e3] && (a2 = true);
            let l3 = this.boundDynamicVertexBuffers.length !== s4.length;
            for (let e3 = 0; !l3 && e3 < s4.length; e3++)
              this.boundDynamicVertexBuffers[e3] !== s4[e3] && (l3 = true);
            if (!e2.extVertexArrayObject || !this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || a2 || l3 || this.boundIndexBuffer !== r2 || this.boundVertexOffset !== n3)
              this.freshBind(t2, i2, o2, r2, n3, s4);
            else {
              e2.bindVertexArrayOES.set(this.vao);
              for (const e3 of s4)
                e3 && e3.bind();
              r2 && r2.dynamicDraw && r2.bind();
            }
          }
          freshBind(e2, t2, i2, o2, r2, n3) {
            let s4;
            const a2 = e2.numAttributes, l3 = this.context, c4 = l3.gl;
            if (l3.extVertexArrayObject)
              this.vao && this.destroy(), this.vao = l3.extVertexArrayObject.createVertexArrayOES(), l3.bindVertexArrayOES.set(this.vao), s4 = 0, this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffers = n3;
            else {
              s4 = l3.currentNumAttributes || 0;
              for (let e3 = a2; e3 < s4; e3++)
                c4.disableVertexAttribArray(e3);
            }
            t2.enableAttributes(c4, e2), t2.bind(), t2.setVertexAttribPointers(c4, e2, r2);
            for (const t3 of i2)
              t3.enableAttributes(c4, e2), t3.bind(), t3.setVertexAttribPointers(c4, e2, r2);
            for (const t3 of n3)
              t3 && (t3.enableAttributes(c4, e2), t3.bind(), t3.setVertexAttribPointers(c4, e2, r2));
            o2 && o2.bind(), l3.currentNumAttributes = a2;
          }
          destroy() {
            this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
          }
        }
        function di(t2, i2) {
          const o2 = Math.pow(2, i2.canonical.z), r2 = i2.canonical.y;
          return [new e.MercatorCoordinate(0, r2 / o2).toLngLat().lat, new e.MercatorCoordinate(0, (r2 + 1) / o2).toLngLat().lat];
        }
        function pi(t2, i2, o2, r2, n3, s4, a2) {
          const l3 = t2.context, c4 = l3.gl, h3 = o2.fbo;
          if (!h3)
            return;
          t2.prepareDrawTile();
          const u3 = t2.useProgram("hillshade");
          l3.activeTexture.set(c4.TEXTURE0), c4.bindTexture(c4.TEXTURE_2D, h3.colorAttachment.get());
          const _2 = ((e2, t3, i3, o3) => {
            const r3 = i3.paint.get("hillshade-shadow-color"), n4 = i3.paint.get("hillshade-highlight-color"), s5 = i3.paint.get("hillshade-accent-color");
            let a3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === i3.paint.get("hillshade-illumination-anchor") && (a3 -= e2.transform.angle);
            const l4 = !e2.options.moving;
            return { u_matrix: o3 || e2.transform.calculateProjMatrix(t3.tileID.toUnwrapped(), l4), u_image: 0, u_latrange: di(0, t3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), a3], u_shadow: r3, u_highlight: n4, u_accent: s5 };
          })(t2, o2, r2, t2.terrain ? i2.projMatrix : null);
          t2.prepareDrawProgram(l3, u3, i2.toUnwrapped());
          const { tileBoundsBuffer: d3, tileBoundsIndexBuffer: p3, tileBoundsSegments: m3 } = t2.getTileBoundsBuffers(o2);
          u3.draw(l3, c4.TRIANGLES, n3, s4, a2, e.CullFaceMode.disabled, _2, r2.id, d3, p3, m3);
        }
        function mi(t2, i2, o2) {
          if (!i2.needsDEMTextureUpload)
            return;
          const r2 = t2.context, n3 = r2.gl;
          r2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(o2.stride);
          const s4 = o2.getPixels();
          i2.demTexture ? i2.demTexture.update(s4, { premultiply: false }) : i2.demTexture = new e.Texture(r2, s4, n3.RGBA, { premultiply: false }), i2.needsDEMTextureUpload = false;
        }
        function fi(t2, i2, o2, r2, n3, s4) {
          const a2 = t2.context, l3 = a2.gl;
          if (!i2.dem)
            return;
          const c4 = i2.dem;
          if (a2.activeTexture.set(l3.TEXTURE1), mi(t2, i2, c4), !i2.demTexture)
            return;
          i2.demTexture.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
          const h3 = c4.dim;
          a2.activeTexture.set(l3.TEXTURE0);
          let u3 = i2.fbo;
          if (!u3) {
            const t3 = new e.Texture(a2, { width: h3, height: h3, data: null }, l3.RGBA);
            t3.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), u3 = i2.fbo = a2.createFramebuffer(h3, h3, true), u3.colorAttachment.set(t3.texture);
          }
          a2.bindFramebuffer.set(u3.framebuffer), a2.viewport.set([0, 0, h3, h3]);
          const { tileBoundsBuffer: _2, tileBoundsIndexBuffer: d3, tileBoundsSegments: p3 } = t2.getMercatorTileBoundsBuffers();
          t2.useProgram("hillshadePrepare").draw(a2, l3.TRIANGLES, r2, n3, s4, e.CullFaceMode.disabled, ((t3, i3) => {
            const o3 = i3.stride, r3 = e.create();
            return e.ortho(r3, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r3, r3, [0, -e.EXTENT, 0]), { u_matrix: r3, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ, u_unpack: i3.unpackVector };
          })(i2.tileID, c4), o2.id, _2, d3, p3), i2.needsHillshadePrepare = false;
        }
        const gi = (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image0: new e.Uniform1i(t2), u_skirt_height: new e.Uniform1f(t2) }), vi = (e2, t2) => ({ u_matrix: e2, u_image0: 0, u_skirt_height: t2 }), xi = (e2, t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3) => ({ u_proj_matrix: Float32Array.from(e2), u_globe_matrix: t2, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: r2, u_merc_center: n3, u_image0: 0, u_frustum_tl: s4, u_frustum_tr: a2, u_frustum_br: l3, u_frustum_bl: c4, u_globe_pos: h3, u_globe_radius: u3, u_viewport: _2, u_grid_matrix: p3 ? Float32Array.from(p3) : new Float32Array(9), u_skirt_height: d3 });
        function yi(e2, t2) {
          return null != e2 && null != t2 && !(!e2.hasData() || !t2.hasData()) && null != e2.demTexture && null != t2.demTexture && e2.tileID.key !== t2.tileID.key;
        }
        const bi = new class {
          constructor() {
            this.operations = {};
          }
          newMorphing(e2, t2, i2, o2, r2) {
            if (e2 in this.operations) {
              const t3 = this.operations[e2];
              t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
            } else
              this.operations[e2] = { startTime: o2, phase: 0, duration: r2, from: t2, to: i2, queued: null };
          }
          getMorphValuesForProxy(e2) {
            if (!(e2 in this.operations))
              return null;
            const t2 = this.operations[e2];
            return { from: t2.from, to: t2.to, phase: t2.phase };
          }
          update(e2) {
            for (const t2 in this.operations) {
              const i2 = this.operations[t2];
              for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
                if (!this._nextOp(i2, e2)) {
                  delete this.operations[t2];
                  break;
                }
            }
          }
          _nextOp(e2, t2) {
            return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t2, true);
          }
          _validOp(e2) {
            return e2.from.hasData() && e2.to.hasData();
          }
        }(), wi = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
        function Ti(e2) {
          return 6 * Math.pow(1.5, 22 - e2);
        }
        function Ei(e2, t2) {
          const i2 = 1 << e2.z;
          return !t2 && (0 === e2.x || e2.x === i2 - 1) || 0 === e2.y || e2.y === i2 - 1;
        }
        const Ci = (e2) => ({ u_matrix: e2 });
        function Mi(t2, i2, o2, r2, n3) {
          if (n3 > 0) {
            const s4 = e.exported.now(), a2 = (s4 - t2.timeAdded) / n3, l3 = i2 ? (s4 - i2.timeAdded) / n3 : -1, c4 = o2.getSource(), h3 = r2.coveringZoomLevel({ tileSize: c4.tileSize, roundZoom: c4.roundZoom }), u3 = !i2 || Math.abs(i2.tileID.overscaledZ - h3) > Math.abs(t2.tileID.overscaledZ - h3), _2 = u3 && t2.refreshedUponExpiration ? 1 : e.clamp(u3 ? a2 : 1 - l3, 0, 1);
            return t2.refreshedUponExpiration && a2 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        class Ii extends e.SourceCache {
          constructor(e2) {
            const t2 = { type: "raster-dem", maxzoom: e2.transform.maxZoom }, i2 = new S(Ue(), null), o2 = De("mock-dem", t2, i2, e2.style);
            super("mock-dem", o2, false), o2.setEventedParent(this), this._sourceLoaded = true;
          }
          _loadTile(e2, t2) {
            e2.state = "loaded", t2(null);
          }
        }
        class Pi extends e.SourceCache {
          constructor(e2) {
            const t2 = De("proxy", { type: "geojson", maxzoom: e2.transform.maxZoom }, new S(Ue(), null), e2.style);
            super("proxy", t2, false), t2.setEventedParent(this), this.map = this.getSource().map = e2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
          update(t2, i2, o2) {
            if (t2.freezeTileCoverage)
              return;
            this.transform = t2;
            const r2 = t2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i3, o3) => {
              if (i3[o3.key] = "", !this._tiles[o3.key]) {
                const i4 = new e.Tile(o3, this._source.tileSize * o3.overscaleFactor(), t2.tileZoom);
                i4.state = "loaded", this._tiles[o3.key] = i4;
              }
              return i3;
            }, {});
            for (const e2 in this._tiles)
              e2 in r2 || (this.freeFBO(e2), this._tiles[e2].unloadVectorData(), delete this._tiles[e2]);
          }
          freeFBO(e2) {
            const t2 = this.proxyCachedFBO[e2];
            if (void 0 !== t2) {
              const i2 = Object.values(t2);
              this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
            }
          }
          deallocRenderCache() {
            this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
        }
        class Si extends e.OverscaledTileID {
          constructor(e2, t2, i2) {
            super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
          }
        }
        class Di extends e.Elevation {
          constructor(t2, i2) {
            super(), this.painter = t2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
            const [o2, r2, n3] = function(t3) {
              const i3 = new e.StructArrayLayout2i4(), o3 = new e.StructArrayLayout3ui6(), r3 = 131;
              i3.reserve(17161), o3.reserve(33800);
              const n4 = e.EXTENT / 128, s5 = e.EXTENT + n4 / 2, a3 = s5 + n4;
              for (let t4 = -n4; t4 < a3; t4 += n4)
                for (let o4 = -n4; o4 < a3; o4 += n4) {
                  const r4 = o4 < 0 || o4 > s5 || t4 < 0 || t4 > s5 ? 24575 : 0, n5 = e.clamp(Math.round(o4), 0, e.EXTENT), a4 = e.clamp(Math.round(t4), 0, e.EXTENT);
                  i3.emplaceBack(n5 + r4, a4);
                }
              const l3 = (e2, t4) => {
                const i4 = t4 * r3 + e2;
                o3.emplaceBack(i4 + 1, i4, i4 + r3), o3.emplaceBack(i4 + r3, i4 + r3 + 1, i4 + 1);
              };
              for (let e2 = 1; e2 < 129; e2++)
                for (let t4 = 1; t4 < 129; t4++)
                  l3(t4, e2);
              return [0, 129].forEach((e2) => {
                for (let t4 = 0; t4 < 130; t4++)
                  l3(t4, e2), l3(e2, t4);
              }), [i3, o3, 32768];
            }(), s4 = t2.context;
            this.gridBuffer = s4.createVertexBuffer(o2, e.posAttributes.members), this.gridIndexBuffer = s4.createIndexBuffer(r2), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, r2.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, n3), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Pi(i2.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e.EXTENT, 0, e.EXTENT, 0, 1);
            const a2 = s4.gl;
            this._overlapStencilMode = new e.StencilMode({ func: a2.GEQUAL, mask: 255 }, 0, 255, a2.KEEP, a2.KEEP, a2.REPLACE), this._previousZoom = t2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new Ii(i2.map);
          }
          set style(e2) {
            e2.on("data", this._onStyleDataEvent.bind(this)), e2.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e2, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", () => {
              this._clearLineLayersFromRenderCache();
            });
          }
          update(t2, i2, o2) {
            if (t2 && t2.terrain) {
              this._style !== t2 && (this.style = t2), this.enabled = true;
              const r2 = t2.terrain.properties;
              this.sourceCache = 0 === t2.terrain.drapeRenderMode ? this._mockSourceCache : t2._getSourceCache(r2.get("source")), this._exaggeration = r2.get("exaggeration");
              const n3 = () => {
                this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                const t3 = this.getScaledDemTileSize();
                this.sourceCache.update(i2, t3, true), this.resetTileLookupCache(this.sourceCache.id);
              };
              this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, n3(), this._initializing = true), n3(), i2.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true;
            } else
              this._disable();
          }
          resetTileLookupCache(e2) {
            this._findCoveringTileCache[e2] = {};
          }
          getScaledDemTileSize() {
            return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
          }
          _checkRenderCacheEfficiency() {
            const t2 = this.renderCacheEfficiency(this._style);
            this._style.map._optimizeForTerrain || 100 !== t2.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t2.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${t2.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
          }
          _onStyleDataEvent(e2) {
            e2.coord && "source" === e2.dataType ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : "style" === e2.dataType && (this._invalidateRenderCache = true);
          }
          _disable() {
            if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
              for (const e2 in this._style._sourceCaches)
                this._style._sourceCaches[e2].usedForTerrain = false;
          }
          destroy() {
            this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
          }
          _source() {
            return this.enabled ? this.sourceCache : null;
          }
          isUsingMockSource() {
            return this.sourceCache === this._mockSourceCache;
          }
          exaggeration() {
            return this._exaggeration;
          }
          get visibleDemTiles() {
            return this._visibleDemTiles;
          }
          get drapeBufferSize() {
            const e2 = 2 * this.proxySourceCache.getSource().tileSize;
            return [e2, e2];
          }
          set useVertexMorphing(e2) {
            this._useVertexMorphing = e2;
          }
          updateTileBinding(t2) {
            if (!this.enabled)
              return;
            this.prevTerrainTileForTile = this.terrainTileForTile;
            const i2 = this.proxySourceCache, o2 = this.painter.transform;
            this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
            const r2 = this.proxyCoords = i2.getIds().map((e2) => {
              const t3 = i2.getTileByID(e2).tileID;
              return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
            });
            !function(t3, i3) {
              const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r3 = new e.Point(o3.x, o3.y);
              t3.sort((t4, i4) => {
                if (i4.overscaledZ - t4.overscaledZ)
                  return i4.overscaledZ - t4.overscaledZ;
                const o4 = new e.Point(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), n4 = new e.Point(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), s5 = r3.mult(1 << t4.canonical.z);
                return s5.x -= 0.5, s5.y -= 0.5, s5.distSqr(o4) - s5.distSqr(n4);
              });
            }(r2, this.painter), this._previousZoom = o2.zoom;
            const n3 = this.proxyToSource || {};
            this.proxyToSource = {}, r2.forEach((e2) => {
              this.proxyToSource[e2.key] = {};
            }), this.terrainTileForTile = {};
            const s4 = this._style._sourceCaches;
            for (const e2 in s4) {
              const i3 = s4[e2];
              if (!i3.used)
                continue;
              if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t2[e2], n3), i3.usedForTerrain)
                continue;
              const o3 = t2[e2];
              i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
            }
            this.proxiedCoords[i2.id] = r2.map((e2) => new Si(e2, e2.key, this.orthoMatrix)), this._assignTerrainTiles(r2), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n3), this.renderingToTexture = false, this._updateTimestamp = e.exported.now();
            const a2 = {};
            this._visibleDemTiles = [];
            for (const e2 of this.proxyCoords) {
              const t3 = this.terrainTileForTile[e2.key];
              if (!t3)
                continue;
              const i3 = t3.tileID.key;
              i3 in a2 || (this._visibleDemTiles.push(t3), a2[i3] = i3);
            }
          }
          _assignTerrainTiles(e2) {
            this._initializing || e2.forEach((e3) => {
              if (this.terrainTileForTile[e3.key])
                return;
              const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
              t2 && (this.terrainTileForTile[e3.key] = t2);
            });
          }
          _prepareDEMTextures() {
            const e2 = this.painter.context, t2 = e2.gl;
            for (const i2 in this.terrainTileForTile) {
              const o2 = this.terrainTileForTile[i2], r2 = o2.dem;
              !r2 || o2.demTexture && !o2.needsDEMTextureUpload || (e2.activeTexture.set(t2.TEXTURE1), mi(this.painter, o2, r2));
            }
          }
          _prepareDemTileUniforms(e2, t2, i2, o2) {
            if (!t2 || null == t2.demTexture)
              return false;
            const r2 = e2.tileID.canonical, n3 = Math.pow(2, t2.tileID.canonical.z - r2.z), s4 = o2 || "";
            return i2[`u_dem_tl${s4}`] = [r2.x * n3 % 1, r2.y * n3 % 1], i2[`u_dem_scale${s4}`] = n3, true;
          }
          get emptyDEMTexture() {
            return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
          }
          get emptyDepthBufferTexture() {
            const t2 = this.painter.context, i2 = t2.gl;
            if (!this._emptyDepthBufferTexture) {
              const o2 = new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
              this._emptyDepthBufferTexture = new e.Texture(t2, o2, i2.RGBA, { premultiply: false });
            }
            return this._emptyDepthBufferTexture;
          }
          _getLoadedAreaMinimum() {
            let e2 = 0;
            const t2 = this._visibleDemTiles.reduce((t3, i2) => {
              if (!i2.dem)
                return t3;
              const o2 = i2.dem.tree.minimums[0];
              return o2 > 0 && e2++, t3 + o2;
            }, 0);
            return e2 ? t2 / e2 : 0;
          }
          _updateEmptyDEMTexture() {
            const t2 = this.painter.context, i2 = t2.gl;
            t2.activeTexture.set(i2.TEXTURE2);
            const o2 = this._getLoadedAreaMinimum(), r2 = new e.RGBAImage({ width: 1, height: 1 }, new Uint8Array(e.DEMData.pack(o2, this.sourceCache.getSource().encoding)));
            this._emptyDEMTextureDirty = false;
            let n3 = this._emptyDEMTexture;
            return n3 ? n3.update(r2, { premultiply: false }) : n3 = this._emptyDEMTexture = new e.Texture(t2, r2, i2.RGBA, { premultiply: false }), n3;
          }
          setupElevationDraw(t2, i2, o2) {
            const r2 = this.painter.context, n3 = r2.gl, s4 = (a2 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e.DEMData.getUnpackVector(a2), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 });
            var a2;
            s4.u_dem_size = this.sourceCache.getSource().tileSize, s4.u_exaggeration = this.exaggeration();
            let l3 = null, c4 = null, h3 = 1;
            if (o2 && o2.morphing && this._useVertexMorphing) {
              const e2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
              h3 = o2.morphing.phase, e2 && i3 && (this._prepareDemTileUniforms(t2, e2, s4, "_prev") && (c4 = e2), this._prepareDemTileUniforms(t2, i3, s4) && (l3 = i3));
            }
            if (c4 && l3 ? (r2.activeTexture.set(n3.TEXTURE2), l3.demTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE, n3.NEAREST), r2.activeTexture.set(n3.TEXTURE4), c4.demTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE, n3.NEAREST), s4.u_dem_lerp = h3) : (l3 = this.terrainTileForTile[t2.tileID.key], r2.activeTexture.set(n3.TEXTURE2), (this._prepareDemTileUniforms(t2, l3, s4) ? l3.demTexture : this.emptyDEMTexture).bind(n3.NEAREST, n3.CLAMP_TO_EDGE)), r2.activeTexture.set(n3.TEXTURE3), o2 && o2.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE), this._depthFBO && (s4.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE), s4.u_depth_size_inv = [1, 1]), o2 && o2.useMeterToDem && l3) {
              const t3 = (1 << l3.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
              s4.u_meter_to_dem = t3;
            }
            if (o2 && o2.labelPlaneMatrixInv && (s4.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r2, s4), "globe" === this.painter.transform.projection.name) {
              const e2 = this.globeUniformValues(this.painter.transform, t2.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
              i2.setGlobeUniformValues(r2, e2);
            }
          }
          globeUniformValues(t2, i2, o2) {
            const r2 = t2.projection;
            return { u_tile_tl_up: r2.upVector(i2, 0, 0), u_tile_tr_up: r2.upVector(i2, e.EXTENT, 0), u_tile_br_up: r2.upVector(i2, e.EXTENT, e.EXTENT), u_tile_bl_up: r2.upVector(i2, 0, e.EXTENT), u_tile_up_scale: o2 ? e.globeMetersToEcef(1) : r2.upVectorScale(i2, t2.center.lat, t2.worldSize).metersToTile };
          }
          renderToBackBuffer(t2) {
            const i2 = this.painter, o2 = this.painter.context;
            0 !== t2.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, r2, n3) {
              if ("globe" === t3.transform.projection.name)
                !function(t4, i4, o4, r3, n4) {
                  const s4 = t4.context, a2 = s4.gl;
                  let l3, c4;
                  const h3 = t4.options.showTerrainWireframe ? 2 : 0, u3 = t4.transform, _2 = e.globeUseCustomAntiAliasing(t4, s4, u3), d3 = (e2, i5) => {
                    if (c4 === e2)
                      return;
                    const o5 = [wi[e2], "PROJECTION_GLOBE_VIEW"];
                    _2 && o5.push("CUSTOM_ANTIALIASING"), i5 && o5.push(wi[h3]), l3 = t4.useProgram("globeRaster", null, o5), c4 = e2;
                  }, p3 = t4.colorModeForRenderPass(), m3 = new e.DepthMode(a2.LEQUAL, e.DepthMode.ReadWrite, t4.depthRangeFor3D);
                  bi.update(n4);
                  const f2 = e.calculateGlobeMercatorMatrix(u3), g2 = [e.mercatorXfromLng(u3.center.lng), e.mercatorYfromLat(u3.center.lat)], v4 = h3 ? [false, true] : [false], x2 = t4.globeSharedBuffers, y2 = [u3.width * e.exported.devicePixelRatio, u3.height * e.exported.devicePixelRatio], b3 = Float32Array.from(u3.globeMatrix), w2 = { useDenormalizedUpVectorScale: true };
                  if (v4.forEach((h4) => {
                    const u4 = t4.transform, _3 = Ti(u4.zoom) * i4.exaggeration();
                    c4 = -1;
                    const v5 = h4 ? a2.LINES : a2.TRIANGLES;
                    for (const c5 of r3) {
                      const r4 = o4.getTile(c5), T3 = e.StencilMode.disabled, E2 = i4.prevTerrainTileForTile[c5.key], C3 = i4.terrainTileForTile[c5.key];
                      yi(E2, C3) && bi.newMorphing(c5.key, E2, C3, n4, 250), s4.activeTexture.set(a2.TEXTURE0), r4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                      const M2 = bi.getMorphValuesForProxy(c5.key), I2 = M2 ? 1 : 0;
                      M2 && e.extend$1(w2, { morphing: { srcDemTile: M2.from, dstDemTile: M2.to, phase: e.easeCubicInOut(M2.phase) } });
                      const P3 = e.tileCornersToBounds(c5.canonical), S2 = e.getLatitudinalLod(P3.getCenter().lat), D2 = e.getGridMatrix(c5.canonical, P3, S2, u4.worldSize / u4._pixelsPerMercatorPixel), L2 = e.globeNormalizeECEF(e.globeTileBounds(c5.canonical)), A2 = xi(u4.projMatrix, b3, f2, L2, e.globeToMercatorTransition(u4.zoom), g2, u4.frustumCorners.TL, u4.frustumCorners.TR, u4.frustumCorners.BR, u4.frustumCorners.BL, u4.globeCenterInViewSpace, u4.globeRadius, y2, _3, D2);
                      if (d3(I2, h4), i4.setupElevationDraw(r4, l3, w2), t4.prepareDrawProgram(s4, l3, c5.toUnwrapped()), x2) {
                        const [i5, o5, r5] = h4 ? x2.getWirefameBuffers(t4.context, S2) : x2.getGridBuffers(S2, 0 !== _3);
                        l3.draw(s4, v5, m3, T3, p3, e.CullFaceMode.backCCW, A2, "globe_raster", i5, o5, r5);
                      }
                    }
                  }), x2) {
                    const n5 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                    _2 && n5.push("CUSTOM_ANTIALIASING"), l3 = t4.useProgram("globeRaster", null, n5);
                    for (const n6 of r3) {
                      const { x: r4, y: c5, z: h4 } = n6.canonical, _3 = 0 === c5, d4 = c5 === (1 << h4) - 1, [f3, v5, b4, T3] = x2.getPoleBuffers(h4);
                      if (T3 && (_3 || d4)) {
                        const c6 = o4.getTile(n6);
                        s4.activeTexture.set(a2.TEXTURE0), c6.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                        let x3 = e.globePoleMatrixForTile(h4, r4, u3);
                        const E2 = e.globeNormalizeECEF(e.globeTileBounds(n6.canonical)), C3 = (t5, i5) => t5.draw(s4, a2.TRIANGLES, m3, e.StencilMode.disabled, p3, e.CullFaceMode.disabled, xi(u3.projMatrix, x3, x3, E2, 0, g2, u3.frustumCorners.TL, u3.frustumCorners.TR, u3.frustumCorners.BR, u3.frustumCorners.BL, u3.globeCenterInViewSpace, u3.globeRadius, y2, 0), "globe_pole_raster", i5, b4, T3);
                        i4.setupElevationDraw(c6, l3, w2), t4.prepareDrawProgram(s4, l3, n6.toUnwrapped()), _3 && C3(l3, f3), d4 && (x3 = e.scale(e.create(), x3, [1, -1, 1]), C3(l3, v5));
                      }
                    }
                  }
                }(t3, i3, o3, r2, n3);
              else {
                const s4 = t3.context, a2 = s4.gl;
                let l3, c4;
                const h3 = t3.options.showTerrainWireframe ? 2 : 0, u3 = (e2, i4) => {
                  if (c4 === e2)
                    return;
                  const o4 = [wi[e2]];
                  i4 && o4.push(wi[h3]), l3 = t3.useProgram("terrainRaster", null, o4), c4 = e2;
                }, _2 = t3.colorModeForRenderPass(), d3 = new e.DepthMode(a2.LEQUAL, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
                bi.update(n3);
                const p3 = t3.transform, m3 = Ti(p3.zoom) * i3.exaggeration();
                (h3 ? [false, true] : [false]).forEach((h4) => {
                  c4 = -1;
                  const f2 = h4 ? a2.LINES : a2.TRIANGLES, [g2, v4] = h4 ? i3.getWirefameBuffer() : [i3.gridIndexBuffer, i3.gridSegments];
                  for (const c5 of r2) {
                    const r3 = o3.getTile(c5), x2 = e.StencilMode.disabled, y2 = i3.prevTerrainTileForTile[c5.key], b3 = i3.terrainTileForTile[c5.key];
                    yi(y2, b3) && bi.newMorphing(c5.key, y2, b3, n3, 250), s4.activeTexture.set(a2.TEXTURE0), r3.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST);
                    const w2 = bi.getMorphValuesForProxy(c5.key), T3 = w2 ? 1 : 0;
                    let E2;
                    w2 && (E2 = { morphing: { srcDemTile: w2.from, dstDemTile: w2.to, phase: e.easeCubicInOut(w2.phase) } });
                    const C3 = vi(c5.projMatrix, Ei(c5.canonical, p3.renderWorldCopies) ? m3 / 10 : m3);
                    u3(T3, h4), i3.setupElevationDraw(r3, l3, E2), t3.prepareDrawProgram(s4, l3, c5.toUnwrapped()), l3.draw(s4, f2, d3, x2, _2, e.CullFaceMode.backCCW, C3, "terrain_raster", i3.gridBuffer, g2, v4);
                  }
                });
              }
            }(i2, this, this.proxySourceCache, t2, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t2.splice(0, t2.length));
          }
          renderBatch(t2) {
            if (0 === this._drapedRenderBatches.length)
              return t2 + 1;
            this.renderingToTexture = true;
            const i2 = this.painter, o2 = this.painter.context, r2 = this.proxySourceCache, n3 = this.proxiedCoords[r2.id], s4 = this._drapedRenderBatches.shift(), a2 = [], l3 = i2.style.order;
            let c4 = 0;
            for (const h3 of n3) {
              const n4 = r2.getTileByID(h3.proxyTileKey), u3 = r2.proxyCachedFBO[h3.key] ? r2.proxyCachedFBO[h3.key][t2] : void 0, _2 = void 0 !== u3 ? r2.renderCache[u3] : this.pool[c4++], d3 = void 0 !== u3;
              if (n4.texture = _2.tex, d3 && !_2.dirty) {
                a2.push(n4.tileID);
                continue;
              }
              let p3;
              o2.bindFramebuffer.set(_2.fb.framebuffer), this.renderedToTile = false, _2.dirty && (o2.clear({ color: e.Color.transparent, stencil: 0 }), _2.dirty = false);
              for (let e2 = s4.start; e2 <= s4.end; ++e2) {
                const t3 = i2.style._layers[l3[e2]];
                if (t3.isHidden(i2.transform.zoom))
                  continue;
                const r3 = i2.style._getLayerSourceCache(t3), n5 = r3 ? this.proxyToSource[h3.key][r3.id] : [h3];
                if (!n5)
                  continue;
                const s5 = n5;
                o2.viewport.set([0, 0, _2.fb.width, _2.fb.height]), p3 !== (r3 ? r3.id : null) && (this._setupStencil(_2, n5, t3, r3), p3 = r3 ? r3.id : null), i2.renderLayer(i2, r3, t3, s5);
              }
              this.renderedToTile ? (_2.dirty = true, a2.push(n4.tileID)) : d3 || --c4, 5 === c4 && (c4 = 0, this.renderToBackBuffer(a2));
            }
            return this.renderToBackBuffer(a2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), s4.end + 1;
          }
          postRender() {
          }
          renderCacheEfficiency(e2) {
            const t2 = e2.order.length;
            if (0 === t2)
              return { efficiency: 100 };
            let i2, o2 = 0, r2 = 0, n3 = false;
            for (let s4 = 0; s4 < t2; ++s4) {
              const t3 = e2._layers[e2.order[s4]];
              this._style.isLayerDraped(t3) ? (n3 && ++o2, ++r2) : n3 || (n3 = true, i2 = t3.id);
            }
            return 0 === r2 ? { efficiency: 100 } : { efficiency: 100 * (1 - o2 / r2), firstUndrapedLayer: i2 };
          }
          getMinElevationBelowMSL() {
            let e2 = 0;
            return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
              e2 = Math.min(e2, t2.dem.tree.minimums[0]);
            }), 0 === e2 ? e2 : (e2 - 30) * this._exaggeration;
          }
          raycast(e2, t2, i2) {
            if (!this._visibleDemTiles)
              return null;
            const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
              const r2 = o3.tileID, n3 = 1 << r2.overscaledZ, { x: s4, y: a2 } = r2.canonical, l3 = s4 / n3, c4 = (s4 + 1) / n3, h3 = a2 / n3, u3 = (a2 + 1) / n3;
              return { minx: l3, miny: h3, maxx: c4, maxy: u3, t: o3.dem.tree.raycastRoot(l3, h3, c4, u3, e2, t2, i2), tile: o3 };
            });
            o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
            for (const r2 of o2) {
              if (null == r2.t)
                return null;
              const o3 = r2.tile.dem.tree.raycast(r2.minx, r2.miny, r2.maxx, r2.maxy, e2, t2, i2);
              if (null != o3)
                return o3;
            }
            return null;
          }
          _createFBO() {
            const t2 = this.painter.context, i2 = t2.gl, o2 = this.drapeBufferSize;
            t2.activeTexture.set(i2.TEXTURE0);
            const r2 = new e.Texture(t2, { width: o2[0], height: o2[1], data: null }, i2.RGBA);
            r2.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
            const n3 = t2.createFramebuffer(o2[0], o2[1], false);
            return n3.colorAttachment.set(r2.texture), n3.depthAttachment = new we(t2, n3.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t2.createRenderbuffer(t2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, n3.depthAttachment.set(this._sharedDepthStencil), t2.clear({ stencil: 0 })) : n3.depthAttachment.set(this._sharedDepthStencil), t2.extTextureFilterAnisotropic && !t2.extTextureFilterAnisotropicForceOff && i2.texParameterf(i2.TEXTURE_2D, t2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t2.extTextureFilterAnisotropicMax), { fb: n3, tex: r2, dirty: false };
          }
          _initFBOPool() {
            for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
              this.pool.push(this._createFBO());
          }
          _shouldDisableRenderCache() {
            if (this._style.light && this._style.light.hasTransition())
              return true;
            for (const e2 in this._style._sourceCaches)
              if (this._style._sourceCaches[e2].hasTransition())
                return true;
            return this._style.order.some((e2) => {
              const t2 = this._style._layers[e2], i2 = t2.isHidden(this.painter.transform.zoom);
              return "custom" === t2.type ? !i2 && t2.shouldRedrape() : !i2 && t2.hasTransition();
            });
          }
          _clearLineLayersFromRenderCache() {
            let t2 = false;
            for (const e2 of this._style._getSources())
              if (e2 instanceof Ce) {
                t2 = true;
                break;
              }
            if (!t2)
              return;
            const i2 = {};
            for (let t3 = 0; t3 < this._style.order.length; ++t3) {
              const o2 = this._style._layers[this._style.order[t3]], r2 = this._style._getLayerSourceCache(o2);
              if (r2 && !i2[r2.id] && !o2.isHidden(this.painter.transform.zoom) && "line" === o2.type && o2.widthExpression() instanceof e.ZoomDependentExpression) {
                i2[r2.id] = true;
                for (const e2 of this.proxyCoords) {
                  const t4 = this.proxyToSource[e2.key][r2.id];
                  if (t4)
                    for (const e3 of t4)
                      this._clearRenderCacheForTile(r2.id, e3);
                }
              }
            }
          }
          _clearRasterLayersFromRenderCache() {
            let e2 = false;
            for (const t3 in this._style._sourceCaches)
              if (this._style._sourceCaches[t3]._source instanceof Me) {
                e2 = true;
                break;
              }
            if (!e2)
              return;
            const t2 = {};
            for (let e3 = 0; e3 < this._style.order.length; ++e3) {
              const i2 = this._style._layers[this._style.order[e3]], o2 = this._style._getLayerSourceCache(i2);
              if (!o2 || t2[o2.id])
                continue;
              if (i2.isHidden(this.painter.transform.zoom) || "raster" !== i2.type)
                continue;
              const r2 = i2.paint.get("raster-fade-duration");
              for (const e4 of this.proxyCoords) {
                const t3 = this.proxyToSource[e4.key][o2.id];
                if (t3)
                  for (const e5 of t3) {
                    const t4 = Mi(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, r2);
                    (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e5);
                  }
              }
            }
          }
          _setupDrapedRenderBatches() {
            const e2 = this._style.order, t2 = e2.length;
            if (0 === t2)
              return;
            const i2 = [];
            let o2, r2 = 0, n3 = this._style._layers[e2[r2]];
            for (; !this._style.isLayerDraped(n3) && n3.isHidden(this.painter.transform.zoom) && ++r2 < t2; )
              n3 = this._style._layers[e2[r2]];
            for (; r2 < t2; ++r2) {
              const t3 = this._style._layers[e2[r2]];
              t3.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t3) ? void 0 === o2 && (o2 = r2) : void 0 !== o2 && (i2.push({ start: o2, end: r2 - 1 }), o2 = void 0));
            }
            void 0 !== o2 && i2.push({ start: o2, end: r2 - 1 }), this._drapedRenderBatches = i2;
          }
          _setupRenderCache(e2) {
            const t2 = this.proxySourceCache;
            if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
              if (this._invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
                const e3 = Object.values(t2.proxyCachedFBO);
                t2.proxyCachedFBO = {};
                for (let i3 = 0; i3 < e3.length; ++i3) {
                  const o3 = Object.values(e3[i3]);
                  t2.renderCachePool.push(...o3);
                }
              }
              return;
            }
            this._clearRasterLayersFromRenderCache();
            const i2 = this.proxyCoords, o2 = this._tilesDirty;
            for (let r3 = i2.length - 1; r3 >= 0; r3--) {
              const n3 = i2[r3];
              if (t2.getTileByID(n3.key), void 0 !== t2.proxyCachedFBO[n3.key]) {
                const i3 = e2[n3.key], r4 = this.proxyToSource[n3.key];
                let s4 = 0;
                for (const e3 in r4) {
                  const t3 = r4[e3], n4 = i3[e3];
                  if (!n4 || n4.length !== t3.length || t3.some((t4, i4) => t4 !== n4[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                    s4 = -1;
                    break;
                  }
                  ++s4;
                }
                for (const e3 in t2.proxyCachedFBO[n3.key])
                  t2.renderCache[t2.proxyCachedFBO[n3.key][e3]].dirty = s4 < 0 || s4 !== Object.values(i3).length;
              }
            }
            const r2 = [...this._drapedRenderBatches];
            r2.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
            for (const e3 of r2)
              for (const o3 of i2) {
                if (t2.proxyCachedFBO[o3.key])
                  continue;
                let i3 = t2.renderCachePool.pop();
                void 0 === i3 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), void 0 !== i3 && (t2.proxyCachedFBO[o3.key] = {}, t2.proxyCachedFBO[o3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
              }
            this._tilesDirty = {};
          }
          _setupStencil(e2, t2, i2, o2) {
            if (!o2 || !this._sourceTilesOverlap[o2.id])
              return void (this._overlapStencilType && (this._overlapStencilType = false));
            const r2 = this.painter.context, n3 = r2.gl;
            if (t2.length <= 1)
              return void (this._overlapStencilType = false);
            let s4;
            if (i2.isTileClipped())
              s4 = t2.length, this._overlapStencilMode.test = { func: n3.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
            else {
              if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ))
                return void (this._overlapStencilType = false);
              s4 = 1, this._overlapStencilMode.test = { func: n3.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
            }
            this._stencilRef + s4 > 255 && (r2.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += s4, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
          }
          clipOrMaskOverlapStencilType() {
            return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
          }
          stencilModeForRTTOverlap(t2) {
            return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t2.key]), this._overlapStencilMode) : e.StencilMode.disabled;
          }
          _renderTileClippingMasks(t2, i2) {
            const o2 = this.painter, r2 = this.painter.context, n3 = r2.gl;
            o2._tileClippingMaskIDs = {}, r2.setColorMode(e.ColorMode.disabled), r2.setDepthMode(e.DepthMode.disabled);
            const s4 = o2.useProgram("clippingMask");
            for (const a2 of t2) {
              const t3 = o2._tileClippingMaskIDs[a2.key] = --i2;
              s4.draw(r2, n3.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n3.ALWAYS, mask: 0 }, t3, 255, n3.KEEP, n3.KEEP, n3.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ci(a2.projMatrix), "$clipping", o2.tileExtentBuffer, o2.quadTriangleIndexBuffer, o2.tileExtentSegments);
            }
          }
          pointCoordinate(t2) {
            const i2 = this.painter.transform;
            if (t2.x < 0 || t2.x > i2.width || t2.y < 0 || t2.y > i2.height)
              return null;
            const o2 = [t2.x, t2.y, 1, 1];
            e.transformMat4$1(o2, o2, i2.pixelMatrixInverse), e.scale$1(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
            const r2 = i2._camera.position, n3 = e.mercatorZfromAltitude(1, i2.center.lat), s4 = [r2[0], r2[1], r2[2] / n3, 0], a2 = e.subtract([], o2.slice(0, 3), s4);
            e.normalize(a2, a2);
            const l3 = this.raycast(s4, a2, this._exaggeration);
            return null !== l3 && l3 ? (e.scaleAndAdd(s4, s4, a2, l3), s4[3] = s4[2], s4[2] *= n3, s4) : null;
          }
          drawDepth() {
            const t2 = this.painter, i2 = t2.context, o2 = this.proxySourceCache, r2 = Math.ceil(t2.width), n3 = Math.ceil(t2.height);
            if (!this._depthFBO || this._depthFBO.width === r2 && this._depthFBO.height === n3 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
              const t3 = i2.gl, o3 = i2.createFramebuffer(r2, n3, true);
              i2.activeTexture.set(t3.TEXTURE0);
              const s4 = new e.Texture(i2, { width: r2, height: n3, data: null }, t3.RGBA);
              s4.bind(t3.NEAREST, t3.CLAMP_TO_EDGE), o3.colorAttachment.set(s4.texture);
              const a2 = i2.createRenderbuffer(i2.gl.DEPTH_COMPONENT16, r2, n3);
              o3.depthAttachment.set(a2), this._depthFBO = o3, this._depthTexture = s4;
            }
            i2.bindFramebuffer.set(this._depthFBO.framebuffer), i2.viewport.set([0, 0, r2, n3]), function(t3, i3, o3, r3) {
              if ("globe" === t3.transform.projection.name)
                return;
              const n4 = t3.context, s4 = n4.gl;
              n4.clear({ depth: 1 });
              const a2 = t3.useProgram("terrainDepth"), l3 = new e.DepthMode(s4.LESS, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
              for (const t4 of r3) {
                const r4 = o3.getTile(t4), c4 = vi(t4.projMatrix, 0);
                i3.setupElevationDraw(r4, a2), a2.draw(n4, s4.TRIANGLES, l3, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c4, "terrain_depth", i3.gridBuffer, i3.gridIndexBuffer, i3.gridNoSkirtSegments);
              }
            }(t2, this, o2, this.proxyCoords);
          }
          _setupProxiedCoordsForOrtho(e2, t2, i2) {
            if (e2.getSource() instanceof Pe)
              return this._setupProxiedCoordsForImageSource(e2, t2, i2);
            this._findCoveringTileCache[e2.id] = this._findCoveringTileCache[e2.id] || {};
            const o2 = this.proxiedCoords[e2.id] = [], r2 = this.proxyCoords;
            for (let t3 = 0; t3 < r2.length; t3++) {
              const n4 = r2[t3], s4 = this._findTileCoveringTileID(n4, e2);
              if (s4) {
                const t4 = this._createProxiedId(n4, s4, i2[n4.key] && i2[n4.key][e2.id]);
                o2.push(t4), this.proxyToSource[n4.key][e2.id] = [t4];
              }
            }
            let n3 = false;
            for (let r3 = 0; r3 < t2.length; r3++) {
              const s4 = e2.getTile(t2[r3]);
              if (!s4 || !s4.hasData())
                continue;
              const a2 = this._findTileCoveringTileID(s4.tileID, this.proxySourceCache);
              if (a2 && a2.tileID.canonical.z !== s4.tileID.canonical.z) {
                const t3 = this.proxyToSource[a2.tileID.key][e2.id], r4 = this._createProxiedId(a2.tileID, s4, i2[a2.tileID.key] && i2[a2.tileID.key][e2.id]);
                t3 ? t3.splice(t3.length - 1, 0, r4) : this.proxyToSource[a2.tileID.key][e2.id] = [r4], o2.push(r4), n3 = true;
              }
            }
            this._sourceTilesOverlap[e2.id] = n3;
          }
          _setupProxiedCoordsForImageSource(t2, i2, o2) {
            if (!t2.getSource().loaded())
              return;
            const r2 = this.proxiedCoords[t2.id] = [], n3 = this.proxyCoords, s4 = t2.getSource(), a2 = new e.Point(s4.tileID.x, s4.tileID.y)._div(1 << s4.tileID.z), l3 = s4.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e2, t3) => (e2.min.x = Math.min(e2.min.x, t3.x - a2.x), e2.min.y = Math.min(e2.min.y, t3.y - a2.y), e2.max.x = Math.max(e2.max.x, t3.x - a2.x), e2.max.y = Math.max(e2.max.y, t3.y - a2.y), e2), { min: new e.Point(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.Point(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c4 = (t3, i3) => {
              const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), r3 = t3.canonical.y / (1 << t3.canonical.z), n4 = e.EXTENT / (1 << t3.canonical.z), s5 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), a3 = i3.canonical.y / (1 << i3.canonical.z);
              return o3 + n4 < s5 + l3.min.x || o3 > s5 + l3.max.x || r3 + n4 < a3 + l3.min.y || r3 > a3 + l3.max.y;
            };
            for (let e2 = 0; e2 < n3.length; e2++) {
              const s5 = n3[e2];
              for (let e3 = 0; e3 < i2.length; e3++) {
                const n4 = t2.getTile(i2[e3]);
                if (!n4 || !n4.hasData())
                  continue;
                if (c4(s5, n4.tileID))
                  continue;
                const a3 = this._createProxiedId(s5, n4, o2[s5.key] && o2[s5.key][t2.id]), l4 = this.proxyToSource[s5.key][t2.id];
                l4 ? l4.push(a3) : this.proxyToSource[s5.key][t2.id] = [a3], r2.push(a3);
              }
            }
          }
          _createProxiedId(t2, i2, o2) {
            let r2 = this.orthoMatrix;
            if (o2) {
              const e2 = o2.find((e3) => e3.key === i2.tileID.key);
              if (e2)
                return e2;
            }
            if (i2.tileID.key !== t2.key) {
              const o3 = t2.canonical.z - i2.tileID.canonical.z;
              let n3, s4, a2;
              r2 = e.create();
              const l3 = i2.tileID.wrap - t2.wrap << t2.overscaledZ;
              o3 > 0 ? (n3 = e.EXTENT >> o3, s4 = n3 * ((i2.tileID.canonical.x << o3) - t2.canonical.x + l3), a2 = n3 * ((i2.tileID.canonical.y << o3) - t2.canonical.y)) : (n3 = e.EXTENT << -o3, s4 = e.EXTENT * (i2.tileID.canonical.x - (t2.canonical.x + l3 << -o3)), a2 = e.EXTENT * (i2.tileID.canonical.y - (t2.canonical.y << -o3))), e.ortho(r2, 0, n3, 0, n3, 0, 1), e.translate(r2, r2, [s4, a2, 0]);
            }
            return new Si(i2.tileID, t2.key, r2);
          }
          _findTileCoveringTileID(t2, i2) {
            let o2 = i2.getTile(t2);
            if (o2 && o2.hasData())
              return o2;
            const r2 = this._findCoveringTileCache[i2.id], n3 = r2[t2.key];
            if (o2 = n3 ? i2.getTileByID(n3) : null, o2 && o2.hasData() || null === n3)
              return o2;
            let s4 = o2 ? o2.tileID : t2, a2 = s4.overscaledZ;
            const l3 = i2.getSource().minzoom, c4 = [];
            if (!n3) {
              const r3 = i2.getSource().maxzoom;
              if (t2.canonical.z >= r3) {
                const o3 = t2.canonical.z - r3;
                i2.getSource().reparseOverscaled ? (a2 = Math.max(t2.canonical.z + 2, i2.transform.tileZoom), s4 = new e.OverscaledTileID(a2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3)) : 0 !== o3 && (a2 = r3, s4 = new e.OverscaledTileID(a2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3));
              }
              s4.key !== t2.key && (c4.push(s4.key), o2 = i2.getTile(s4));
            }
            const h3 = (e2) => {
              c4.forEach((t3) => {
                r2[t3] = e2;
              }), c4.length = 0;
            };
            for (a2 -= 1; a2 >= l3 && (!o2 || !o2.hasData()); a2--) {
              o2 && h3(o2.tileID.key);
              const e2 = s4.calculateScaledKey(a2);
              if (o2 = i2.getTileByID(e2), o2 && o2.hasData())
                break;
              const t3 = r2[e2];
              if (null === t3)
                break;
              void 0 === t3 ? c4.push(e2) : o2 = i2.getTileByID(t3);
            }
            return h3(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
          }
          findDEMTileFor(e2) {
            return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
          }
          prepareDrawTile() {
            this.renderedToTile = true;
          }
          _clearRenderCacheForTile(e2, t2) {
            let i2 = this._tilesDirty[e2];
            i2 || (i2 = this._tilesDirty[e2] = {}), i2[t2.key] = true;
          }
          getWirefameBuffer() {
            if (!this.wireframeSegments) {
              const t2 = function(t3) {
                let i2 = 0;
                const o2 = new e.StructArrayLayout2ui4(), r2 = 131;
                for (let e2 = 1; e2 < 129; e2++) {
                  for (let t4 = 1; t4 < 129; t4++)
                    i2 = e2 * r2 + t4, o2.emplaceBack(i2, i2 + 1), o2.emplaceBack(i2, i2 + r2), o2.emplaceBack(i2 + 1, i2 + r2), 128 === e2 && o2.emplaceBack(i2 + r2, i2 + r2 + 1);
                  o2.emplaceBack(i2 + 1, i2 + 1 + r2);
                }
                return o2;
              }();
              this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t2), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t2.length);
            }
            return [this.wireframeIndexBuffer, this.wireframeSegments];
          }
        }
        class Li {
          static cacheKey(e2, t2, i2, o2) {
            let r2 = `${t2}${o2 ? o2.cacheKey : ""}`;
            for (const t3 of i2)
              e2.usedDefines.includes(t3) && (r2 += `/${t3}`);
            return r2;
          }
          constructor(t2, i2, o2, r2, n3, s4) {
            const a2 = t2.gl;
            this.program = a2.createProgram();
            const l3 = function(e2) {
              const t3 = [];
              for (let i3 = 0; i3 < e2.length; i3++) {
                if (null === e2[i3])
                  continue;
                const o3 = e2[i3].split(" ");
                t3.push(o3.pop());
              }
              return t3;
            }(o2.staticAttributes), c4 = r2 ? r2.getBinderAttributes() : [], h3 = l3.concat(c4);
            let u3 = r2 ? r2.defines() : [];
            u3 = u3.concat(s4.map((e2) => `#define ${e2}`));
            const _2 = t2.isWebGL2 ? "#version 300 es\n" : "", d3 = _2 + u3.concat(t2.extStandardDerivatives && 0 === _2.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(li) : li, li, ai, si.fragmentSource, ri.fragmentSource, o2.fragmentSource).join("\n"), p3 = _2 + u3.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ai, si.vertexSource, ri.vertexSource, oi.vertexSource, o2.vertexSource).join("\n"), m3 = a2.createShader(a2.FRAGMENT_SHADER);
            if (a2.isContextLost())
              return void (this.failedToCreate = true);
            a2.shaderSource(m3, d3), a2.compileShader(m3), a2.attachShader(this.program, m3);
            const f2 = a2.createShader(a2.VERTEX_SHADER);
            if (a2.isContextLost())
              this.failedToCreate = true;
            else {
              a2.shaderSource(f2, p3), a2.compileShader(f2), a2.attachShader(this.program, f2), this.attributes = {}, this.numAttributes = h3.length;
              for (let e2 = 0; e2 < this.numAttributes; e2++)
                h3[e2] && (a2.bindAttribLocation(this.program, e2, h3[e2]), this.attributes[h3[e2]] = e2);
              a2.linkProgram(this.program), a2.deleteShader(f2), a2.deleteShader(m3), this.fixedUniforms = n3(t2), this.binderUniforms = r2 ? r2.getUniforms(t2) : [], s4.includes("TERRAIN") && (this.terrainUniforms = ((t3) => ({ u_dem: new e.Uniform1i(t3), u_dem_prev: new e.Uniform1i(t3), u_dem_unpack: new e.Uniform4f(t3), u_dem_tl: new e.Uniform2f(t3), u_dem_scale: new e.Uniform1f(t3), u_dem_tl_prev: new e.Uniform2f(t3), u_dem_scale_prev: new e.Uniform1f(t3), u_dem_size: new e.Uniform1f(t3), u_dem_lerp: new e.Uniform1f(t3), u_exaggeration: new e.Uniform1f(t3), u_depth: new e.Uniform1i(t3), u_depth_size_inv: new e.Uniform2f(t3), u_meter_to_dem: new e.Uniform1f(t3), u_label_plane_matrix_inv: new e.UniformMatrix4f(t3) }))(t2)), s4.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e.Uniform3f(t3), u_tile_tr_up: new e.Uniform3f(t3), u_tile_br_up: new e.Uniform3f(t3), u_tile_bl_up: new e.Uniform3f(t3), u_tile_up_scale: new e.Uniform1f(t3) }))(t2)), s4.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e.UniformMatrix4f(t3), u_fog_range: new e.Uniform2f(t3), u_fog_color: new e.Uniform4f(t3), u_fog_horizon_blend: new e.Uniform1f(t3), u_fog_temporal_offset: new e.Uniform1f(t3), u_frustum_tl: new e.Uniform3f(t3), u_frustum_tr: new e.Uniform3f(t3), u_frustum_br: new e.Uniform3f(t3), u_frustum_bl: new e.Uniform3f(t3), u_globe_pos: new e.Uniform3f(t3), u_globe_radius: new e.Uniform1f(t3), u_globe_transition: new e.Uniform1f(t3), u_is_globe: new e.Uniform1i(t3), u_viewport: new e.Uniform2f(t3) }))(t2));
            }
          }
          setTerrainUniformValues(e2, t2) {
            if (!this.terrainUniforms)
              return;
            const i2 = this.terrainUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2)
                i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          setGlobeUniformValues(e2, t2) {
            if (!this.globeUniforms)
              return;
            const i2 = this.globeUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2)
                i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          setFogUniformValues(e2, t2) {
            if (!this.fogUniforms)
              return;
            const i2 = this.fogUniforms;
            if (!this.failedToCreate) {
              e2.program.set(this.program);
              for (const e3 in t2)
                i2[e3].set(this.program, e3, t2[e3]);
            }
          }
          draw(e2, t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3) {
            const m3 = e2.gl;
            if (this.failedToCreate)
              return;
            e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(o2), e2.setColorMode(r2), e2.setCullFace(n3);
            for (const e3 of Object.keys(this.fixedUniforms))
              this.fixedUniforms[e3].set(this.program, e3, s4[e3]);
            d3 && d3.setUniforms(this.program, e2, this.binderUniforms, u3, { zoom: _2 });
            const f2 = { [m3.LINES]: 2, [m3.TRIANGLES]: 3, [m3.LINE_STRIP]: 1 }[t2];
            for (const i3 of h3.get()) {
              const o3 = i3.vaos || (i3.vaos = {});
              (o3[a2] || (o3[a2] = new _i())).bind(e2, this, l3, d3 ? d3.getPaintVertexBuffers() : [], c4, i3.vertexOffset, p3 || []), m3.drawElements(t2, i3.primitiveLength * f2, m3.UNSIGNED_SHORT, i3.primitiveOffset * f2 * 2);
            }
          }
        }
        function Ai(e2, t2) {
          const i2 = Math.pow(2, t2.tileID.overscaledZ), o2 = t2.tileSize * Math.pow(2, e2.transform.tileZoom) / i2, r2 = o2 * (t2.tileID.canonical.x + t2.tileID.wrap * i2), n3 = o2 * t2.tileID.canonical.y;
          return { u_image: 0, u_texsize: t2.imageAtlasTexture.size, u_tile_units_to_pixels: 1 / D(t2, 1, e2.transform.tileZoom), u_pixel_coord_upper: [r2 >> 16, n3 >> 16], u_pixel_coord_lower: [65535 & r2, 65535 & n3] };
        }
        const zi = e.create(), Ri = (t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3) => {
          const _2 = i2.style.light, d3 = _2.properties.get("position"), p3 = [d3.x, d3.y, d3.z], m3 = e.create$1();
          "viewport" === _2.properties.get("anchor") && (e.fromRotation(m3, -i2.transform.angle), e.transformMat3(p3, p3, m3));
          const f2 = _2.properties.get("color"), g2 = i2.transform, v4 = { u_matrix: t2, u_lightpos: p3, u_lightintensity: _2.properties.get("intensity"), u_lightcolor: [f2.r, f2.g, f2.b], u_vertical_gradient: +o2, u_opacity: r2, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: zi, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n3, u_edge_radius: s4 };
          return "globe" === g2.projection.name && (v4.u_tile_id = [a2.canonical.x, a2.canonical.y, 1 << a2.canonical.z], v4.u_zoom_transition = c4, v4.u_inv_rot_matrix = u3, v4.u_merc_center = h3, v4.u_up_dir = g2.projection.upVector(new e.CanonicalTileID(0, 0, 0), h3[0] * e.EXTENT, h3[1] * e.EXTENT), v4.u_height_lift = l3), v4;
        }, Oi = (t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2) => {
          const d3 = Ri(t2, i2, o2, r2, n3, s4, a2, c4, h3, u3, _2), p3 = { u_height_factor: -Math.pow(2, a2.overscaledZ) / l3.tileSize / 8 };
          return e.extend(d3, Ai(i2, l3), p3);
        }, Bi = (e2) => ({ u_matrix: e2 }), ki = (t2, i2, o2) => e.extend(Bi(t2), Ai(i2, o2)), Fi = (e2, t2) => ({ u_matrix: e2, u_world: t2 }), Ui = (t2, i2, o2, r2) => e.extend(ki(t2, i2, o2), { u_world: r2 }), Ni = e.create(), ji = (t2, i2, o2, r2, n3, s4) => {
          const a2 = t2.transform, l3 = "globe" === a2.projection.name;
          let c4;
          if ("map" === s4.paint.get("circle-pitch-alignment"))
            if (l3) {
              const t3 = e.globePixelsToTileUnits(a2.zoom, i2.canonical) * a2._pixelsPerMercatorPixel;
              c4 = Float32Array.from([t3, 0, 0, t3]);
            } else
              c4 = a2.calculatePixelsToTileUnitsMatrix(o2);
          else
            c4 = new Float32Array([a2.pixelsToGLUnits[0], 0, 0, a2.pixelsToGLUnits[1]]);
          const h3 = { u_camera_to_center_distance: a2.cameraToCenterDistance, u_matrix: t2.translatePosMatrix(i2.projMatrix, o2, s4.paint.get("circle-translate"), s4.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e.exported.devicePixelRatio, u_extrude_scale: c4, u_inv_rot_matrix: Ni, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (l3) {
            h3.u_inv_rot_matrix = r2, h3.u_merc_center = n3, h3.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], h3.u_zoom_transition = e.globeToMercatorTransition(a2.zoom);
            const t3 = n3[0] * e.EXTENT, o3 = n3[1] * e.EXTENT;
            h3.u_up_dir = a2.projection.upVector(new e.CanonicalTileID(0, 0, 0), t3, o3);
          }
          return h3;
        }, Gi = (e2) => {
          const t2 = [];
          return "map" === e2.paint.get("circle-pitch-alignment") && t2.push("PITCH_WITH_MAP"), "map" === e2.paint.get("circle-pitch-scale") && t2.push("SCALE_WITH_MAP"), t2;
        }, Zi = (t2, i2, o2, r2) => {
          const n3 = e.EXTENT / o2.tileSize;
          return { u_matrix: t2, u_camera_to_center_distance: i2.getCameraToCenterDistance(r2), u_extrude_scale: [i2.pixelsToGLUnits[0] / n3, i2.pixelsToGLUnits[1] / n3] };
        }, Vi = (e2, t2, i2 = 1) => ({ u_matrix: e2, u_color: t2, u_overlay: 0, u_overlay_scale: i2 }), Wi = e.create(), Xi = (t2, i2, o2, r2, n3, s4, a2) => {
          const l3 = t2.transform, c4 = "globe" === l3.projection.name, h3 = c4 ? e.globePixelsToTileUnits(l3.zoom, i2.canonical) * l3._pixelsPerMercatorPixel : D(o2, 1, s4), u3 = { u_matrix: i2.projMatrix, u_extrude_scale: h3, u_intensity: a2, u_inv_rot_matrix: Wi, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (c4) {
            u3.u_inv_rot_matrix = r2, u3.u_merc_center = n3, u3.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], u3.u_zoom_transition = e.globeToMercatorTransition(l3.zoom);
            const t3 = n3[0] * e.EXTENT, o3 = n3[1] * e.EXTENT;
            u3.u_up_dir = l3.projection.upVector(new e.CanonicalTileID(0, 0, 0), t3, o3);
          }
          return u3;
        }, qi = (e2, t2, i2, o2, r2, n3, s4) => {
          const a2 = e2.transform, l3 = a2.calculatePixelsToTileUnitsMatrix(t2);
          return { u_matrix: Yi(e2, t2, i2, o2), u_pixels_to_tile_units: l3, u_device_pixel_ratio: n3, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: r2, u_texsize: Ki(i2) ? t2.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Hi(t2, e2.transform), u_alpha_discard_threshold: 0, u_trim_offset: s4 };
        }, $i = (e2, t2, i2, o2, r2) => {
          const n3 = e2.transform;
          return { u_matrix: Yi(e2, t2, i2, o2), u_texsize: t2.imageAtlasTexture.size, u_pixels_to_tile_units: n3.calculatePixelsToTileUnitsMatrix(t2), u_device_pixel_ratio: r2, u_image: 0, u_tile_units_to_pixels: Hi(t2, n3), u_units_to_pixels: [1 / n3.pixelsToGLUnits[0], 1 / n3.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
        };
        function Hi(e2, t2) {
          return 1 / D(e2, 1, t2.tileZoom);
        }
        function Yi(e2, t2, i2, o2) {
          return e2.translatePosMatrix(o2 || t2.tileID.projMatrix, t2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
        }
        function Ki(e2) {
          const t2 = e2.paint.get("line-dasharray").value;
          return t2.value || "constant" !== t2.kind;
        }
        const Ji = (e2, t2, i2, o2, r2, n3) => {
          return { u_matrix: e2, u_tl_parent: t2, u_scale_parent: i2, u_fade_t: o2.mix, u_opacity: o2.opacity * r2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r2.paint.get("raster-brightness-min"), u_brightness_high: r2.paint.get("raster-brightness-max"), u_saturation_factor: (a2 = r2.paint.get("raster-saturation"), a2 > 0 ? 1 - 1 / (1.001 - a2) : -a2), u_contrast_factor: (s4 = r2.paint.get("raster-contrast"), s4 > 0 ? 1 / (1 - s4) : 1 + s4), u_spin_weights: Qi(r2.paint.get("raster-hue-rotate")), u_perspective_transform: n3 };
          var s4, a2;
        };
        function Qi(e2) {
          e2 *= Math.PI / 180;
          const t2 = Math.sin(e2), i2 = Math.cos(e2);
          return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
        }
        const eo = e.create(), to = (t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3, m3, f2) => {
          const g2 = n3.transform, v4 = { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: g2.cameraToCenterDistance, u_rotate_symbol: +o2, u_aspect_ratio: g2.width / g2.height, u_fade_change: n3.options.fadeDuration ? n3.symbolFadeChange : 1, u_matrix: s4, u_label_plane_matrix: a2, u_coord_matrix: l3, u_is_text: +c4, u_pitch_with_map: +r2, u_texsize: h3, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: eo, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: eo, u_up_vector: [0, -1, 0] };
          return "globe" === f2.name && (v4.u_tile_id = [u3.canonical.x, u3.canonical.y, 1 << u3.canonical.z], v4.u_zoom_transition = _2, v4.u_inv_rot_matrix = p3, v4.u_merc_center = d3, v4.u_camera_forward = g2._camera.forward(), v4.u_ecef_origin = e.globeECEFOrigin(g2.globeMatrix, u3.toUnwrapped()), v4.u_tile_matrix = Float32Array.from(g2.globeMatrix), v4.u_up_vector = m3), v4;
        }, io = (t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3, m3, f2, g2) => e.extend(to(t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, _2, d3, p3, m3, f2, g2), { u_gamma_scale: r2 ? n3.transform.cameraToCenterDistance * Math.cos(n3.terrain ? 0 : n3.transform._pitch) : 1, u_device_pixel_ratio: e.exported.devicePixelRatio, u_is_halo: +u3 }), oo = (t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2, d3, p3, m3, f2) => e.extend(io(t2, i2, o2, r2, n3, s4, a2, l3, true, c4, true, u3, _2, d3, p3, m3, f2), { u_texsize_icon: h3, u_texture_icon: 1 }), ro = (e2, t2, i2) => ({ u_matrix: e2, u_opacity: t2, u_color: i2 }), no = (t2, i2, o2, r2, n3) => e.extend(function(e2, t3, i3) {
          const o3 = t3.imageManager.getPattern(e2.toString()), { width: r3, height: n4 } = t3.imageManager.getPixelSize(), s4 = Math.pow(2, i3.tileID.overscaledZ), a2 = i3.tileSize * Math.pow(2, t3.transform.tileZoom) / s4, l3 = a2 * (i3.tileID.canonical.x + i3.tileID.wrap * s4), c4 = a2 * i3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl: o3.tl, u_pattern_br: o3.br, u_texsize: [r3, n4], u_pattern_size: o3.displaySize, u_tile_units_to_pixels: 1 / D(i3, 1, t3.transform.tileZoom), u_pixel_coord_upper: [l3 >> 16, c4 >> 16], u_pixel_coord_lower: [65535 & l3, 65535 & c4] };
        }(r2, o2, n3), { u_matrix: t2, u_opacity: i2 }), so = { fillExtrusion: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_lightpos: new e.Uniform3f(t2), u_lightintensity: new e.Uniform1f(t2), u_lightcolor: new e.Uniform3f(t2), u_vertical_gradient: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_edge_radius: new e.Uniform1f(t2), u_ao: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_up_dir: new e.Uniform3f(t2), u_height_lift: new e.Uniform1f(t2) }), fillExtrusionPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_lightpos: new e.Uniform3f(t2), u_lightintensity: new e.Uniform1f(t2), u_lightcolor: new e.Uniform3f(t2), u_vertical_gradient: new e.Uniform1f(t2), u_height_factor: new e.Uniform1f(t2), u_edge_radius: new e.Uniform1f(t2), u_ao: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_up_dir: new e.Uniform3f(t2), u_height_lift: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2) }), fill: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2) }), fillPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), fillOutline: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_world: new e.Uniform2f(t2) }), fillOutlinePattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_world: new e.Uniform2f(t2), u_image: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), circle: (t2) => ({ u_camera_to_center_distance: new e.Uniform1f(t2), u_extrude_scale: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_up_dir: new e.Uniform3f(t2) }), collisionBox: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_extrude_scale: new e.Uniform2f(t2) }), collisionCircle: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_inv_matrix: new e.UniformMatrix4f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_viewport_size: new e.Uniform2f(t2) }), debug: (t2) => ({ u_color: new e.UniformColor(t2), u_matrix: new e.UniformMatrix4f(t2), u_overlay: new e.Uniform1i(t2), u_overlay_scale: new e.Uniform1f(t2) }), clippingMask: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2) }), heatmap: (t2) => ({ u_extrude_scale: new e.Uniform1f(t2), u_intensity: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_up_dir: new e.Uniform3f(t2) }), heatmapTexture: (t2) => ({ u_image: new e.Uniform1i(t2), u_color_ramp: new e.Uniform1i(t2), u_opacity: new e.Uniform1f(t2) }), hillshade: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_latrange: new e.Uniform2f(t2), u_light: new e.Uniform2f(t2), u_shadow: new e.UniformColor(t2), u_highlight: new e.UniformColor(t2), u_accent: new e.UniformColor(t2) }), hillshadePrepare: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_image: new e.Uniform1i(t2), u_dimension: new e.Uniform2f(t2), u_zoom: new e.Uniform1f(t2), u_unpack: new e.Uniform4f(t2) }), line: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_pixels_to_tile_units: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_units_to_pixels: new e.Uniform2f(t2), u_dash_image: new e.Uniform1i(t2), u_gradient_image: new e.Uniform1i(t2), u_image_height: new e.Uniform1f(t2), u_texsize: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_alpha_discard_threshold: new e.Uniform1f(t2), u_trim_offset: new e.Uniform2f(t2) }), linePattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_texsize: new e.Uniform2f(t2), u_pixels_to_tile_units: new e.UniformMatrix2f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_units_to_pixels: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2), u_alpha_discard_threshold: new e.Uniform1f(t2) }), raster: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_tl_parent: new e.Uniform2f(t2), u_scale_parent: new e.Uniform1f(t2), u_fade_t: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_image0: new e.Uniform1i(t2), u_image1: new e.Uniform1i(t2), u_brightness_low: new e.Uniform1f(t2), u_brightness_high: new e.Uniform1f(t2), u_saturation_factor: new e.Uniform1f(t2), u_contrast_factor: new e.Uniform1f(t2), u_spin_weights: new e.Uniform3f(t2), u_perspective_transform: new e.Uniform2f(t2) }), symbolIcon: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_camera_forward: new e.Uniform3f(t2), u_tile_matrix: new e.UniformMatrix4f(t2), u_up_vector: new e.Uniform3f(t2), u_ecef_origin: new e.Uniform3f(t2), u_texture: new e.Uniform1i(t2) }), symbolSDF: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_texture: new e.Uniform1i(t2), u_gamma_scale: new e.Uniform1f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_tile_id: new e.Uniform3f(t2), u_zoom_transition: new e.Uniform1f(t2), u_inv_rot_matrix: new e.UniformMatrix4f(t2), u_merc_center: new e.Uniform2f(t2), u_camera_forward: new e.Uniform3f(t2), u_tile_matrix: new e.UniformMatrix4f(t2), u_up_vector: new e.Uniform3f(t2), u_ecef_origin: new e.Uniform3f(t2), u_is_halo: new e.Uniform1i(t2) }), symbolTextAndIcon: (t2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2), u_is_size_feature_constant: new e.Uniform1i(t2), u_size_t: new e.Uniform1f(t2), u_size: new e.Uniform1f(t2), u_camera_to_center_distance: new e.Uniform1f(t2), u_rotate_symbol: new e.Uniform1i(t2), u_aspect_ratio: new e.Uniform1f(t2), u_fade_change: new e.Uniform1f(t2), u_matrix: new e.UniformMatrix4f(t2), u_label_plane_matrix: new e.UniformMatrix4f(t2), u_coord_matrix: new e.UniformMatrix4f(t2), u_is_text: new e.Uniform1i(t2), u_pitch_with_map: new e.Uniform1i(t2), u_texsize: new e.Uniform2f(t2), u_texsize_icon: new e.Uniform2f(t2), u_texture: new e.Uniform1i(t2), u_texture_icon: new e.Uniform1i(t2), u_gamma_scale: new e.Uniform1f(t2), u_device_pixel_ratio: new e.Uniform1f(t2), u_is_halo: new e.Uniform1i(t2) }), background: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_opacity: new e.Uniform1f(t2), u_color: new e.UniformColor(t2) }), backgroundPattern: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_opacity: new e.Uniform1f(t2), u_image: new e.Uniform1i(t2), u_pattern_tl: new e.Uniform2f(t2), u_pattern_br: new e.Uniform2f(t2), u_texsize: new e.Uniform2f(t2), u_pattern_size: new e.Uniform2f(t2), u_pixel_coord_upper: new e.Uniform2f(t2), u_pixel_coord_lower: new e.Uniform2f(t2), u_tile_units_to_pixels: new e.Uniform1f(t2) }), terrainRaster: gi, terrainDepth: gi, skybox: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_sun_direction: new e.Uniform3f(t2), u_cubemap: new e.Uniform1i(t2), u_opacity: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2) }), skyboxGradient: (t2) => ({ u_matrix: new e.UniformMatrix4f(t2), u_color_ramp: new e.Uniform1i(t2), u_center_direction: new e.Uniform3f(t2), u_radius: new e.Uniform1f(t2), u_opacity: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2) }), skyboxCapture: (t2) => ({ u_matrix_3f: new e.UniformMatrix3f(t2), u_sun_direction: new e.Uniform3f(t2), u_sun_intensity: new e.Uniform1f(t2), u_color_tint_r: new e.Uniform4f(t2), u_color_tint_m: new e.Uniform4f(t2), u_luminance: new e.Uniform1f(t2) }), globeRaster: (t2) => ({ u_proj_matrix: new e.UniformMatrix4f(t2), u_globe_matrix: new e.UniformMatrix4f(t2), u_normalize_matrix: new e.UniformMatrix4f(t2), u_merc_matrix: new e.UniformMatrix4f(t2), u_zoom_transition: new e.Uniform1f(t2), u_merc_center: new e.Uniform2f(t2), u_image0: new e.Uniform1i(t2), u_grid_matrix: new e.UniformMatrix3f(t2), u_skirt_height: new e.Uniform1f(t2), u_frustum_tl: new e.Uniform3f(t2), u_frustum_tr: new e.Uniform3f(t2), u_frustum_br: new e.Uniform3f(t2), u_frustum_bl: new e.Uniform3f(t2), u_globe_pos: new e.Uniform3f(t2), u_globe_radius: new e.Uniform1f(t2), u_viewport: new e.Uniform2f(t2) }), globeAtmosphere: (t2) => ({ u_frustum_tl: new e.Uniform3f(t2), u_frustum_tr: new e.Uniform3f(t2), u_frustum_br: new e.Uniform3f(t2), u_frustum_bl: new e.Uniform3f(t2), u_horizon: new e.Uniform1f(t2), u_transition: new e.Uniform1f(t2), u_fadeout_range: new e.Uniform1f(t2), u_color: new e.Uniform4f(t2), u_high_color: new e.Uniform4f(t2), u_space_color: new e.Uniform4f(t2), u_star_intensity: new e.Uniform1f(t2), u_star_density: new e.Uniform1f(t2), u_star_size: new e.Uniform1f(t2), u_temporal_offset: new e.Uniform1f(t2), u_horizon_angle: new e.Uniform1f(t2), u_rotation_matrix: new e.UniformMatrix4f(t2) }) };
        let ao;
        function lo(t2, i2, o2, r2, n3, s4, a2) {
          const l3 = t2.context, c4 = l3.gl, h3 = t2.transform, u3 = t2.useProgram("collisionBox"), _2 = [];
          let d3 = 0, p3 = 0;
          for (let m4 = 0; m4 < r2.length; m4++) {
            const f3 = r2[m4], g3 = i2.getTile(f3), v5 = g3.getBucket(o2);
            if (!v5)
              continue;
            const x3 = vt(f3, v5, h3);
            let y3 = x3;
            0 === n3[0] && 0 === n3[1] || (y3 = t2.translatePosMatrix(x3, g3, n3, s4));
            const b3 = a2 ? v5.textCollisionBox : v5.iconCollisionBox, w2 = v5.collisionCircleArray;
            if (w2.length > 0) {
              const t3 = e.create(), i3 = y3;
              e.mul(t3, v5.placementInvProjMatrix, h3.glCoordMatrix), e.mul(t3, t3, v5.placementViewportMatrix), _2.push({ circleArray: w2, circleOffset: p3, transform: i3, invTransform: t3, projection: v5.getProjection() }), d3 += w2.length / 4, p3 = d3;
            }
            b3 && (t2.terrain && t2.terrain.setupElevationDraw(g3, u3), u3.draw(l3, c4.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, Zi(y3, h3, g3, v5.getProjection()), o2.id, b3.layoutVertexBuffer, b3.indexBuffer, b3.segments, null, h3.zoom, null, [b3.collisionVertexBuffer, b3.collisionVertexBufferExt]));
          }
          if (!a2 || !_2.length)
            return;
          const m3 = t2.useProgram("collisionCircle"), f2 = new e.StructArrayLayout2f1f2i16();
          f2.resize(4 * d3), f2._trim();
          let g2 = 0;
          for (const e2 of _2)
            for (let t3 = 0; t3 < e2.circleArray.length / 4; t3++) {
              const i3 = 4 * t3, o3 = e2.circleArray[i3 + 0], r3 = e2.circleArray[i3 + 1], n4 = e2.circleArray[i3 + 2], s5 = e2.circleArray[i3 + 3];
              f2.emplace(g2++, o3, r3, n4, s5, 0), f2.emplace(g2++, o3, r3, n4, s5, 1), f2.emplace(g2++, o3, r3, n4, s5, 2), f2.emplace(g2++, o3, r3, n4, s5, 3);
            }
          (!ao || ao.length < 2 * d3) && (ao = function(t3) {
            const i3 = 2 * t3, o3 = new e.StructArrayLayout3ui6();
            o3.resize(i3), o3._trim();
            for (let e2 = 0; e2 < i3; e2++) {
              const t4 = 6 * e2;
              o3.uint16[t4 + 0] = 4 * e2 + 0, o3.uint16[t4 + 1] = 4 * e2 + 1, o3.uint16[t4 + 2] = 4 * e2 + 2, o3.uint16[t4 + 3] = 4 * e2 + 2, o3.uint16[t4 + 4] = 4 * e2 + 3, o3.uint16[t4 + 5] = 4 * e2 + 0;
            }
            return o3;
          }(d3));
          const v4 = l3.createIndexBuffer(ao, true), x2 = l3.createVertexBuffer(f2, e.collisionCircleLayout.members, true);
          for (const i3 of _2) {
            const r3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (y2 = h3).getCameraToCenterDistance(i3.projection), u_viewport_size: [y2.width, y2.height] };
            m3.draw(l3, c4.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, r3, o2.id, x2, v4, e.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h3.zoom);
          }
          var y2;
          x2.destroy(), v4.destroy();
        }
        const co = e.create();
        function ho({ width: t2, height: i2, anchor: o2, textOffset: r2, textScale: n3 }, s4) {
          const { horizontalAlign: a2, verticalAlign: l3 } = e.getAnchorAlignment(o2), c4 = -(a2 - 0.5) * t2, h3 = -(l3 - 0.5) * i2, u3 = e.evaluateVariableOffset(o2, r2);
          return new e.Point((c4 / n3 + u3[0]) * s4, (h3 / n3 + u3[1]) * s4);
        }
        function uo(t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3) {
          const _2 = t2.text.placedSymbolArray, d3 = t2.text.dynamicLayoutVertexArray, p3 = t2.icon.dynamicLayoutVertexArray, m3 = {}, f2 = t2.getProjection(), g2 = xt(l3, f2, s4), v4 = s4.elevation, x2 = f2.upVectorScale(l3.canonical, s4.center.lat, s4.worldSize).metersToTile;
          d3.clear();
          for (let p4 = 0; p4 < _2.length; p4++) {
            const y2 = _2.get(p4), { tileAnchorX: b3, tileAnchorY: w2, numGlyphs: T3 } = y2, E2 = y2.hidden || !y2.crossTileID || t2.allowVerticalPlacement && !y2.placedOrientation ? null : r2[y2.crossTileID];
            if (E2) {
              let r3 = 0, _3 = 0, p5 = 0;
              if (v4) {
                const e2 = v4 ? v4.getAtTileOffset(l3, b3, w2) : 0, [t3, i3, o3] = f2.upVector(l3.canonical, b3, w2);
                r3 = e2 * t3 * x2, _3 = e2 * i3 * x2, p5 = e2 * o3 * x2;
              }
              let [C3, M2, I2, P3] = ot(y2.projectedAnchorX + r3, y2.projectedAnchorY + _3, y2.projectedAnchorZ + p5, o2 ? g2 : a2);
              const S2 = rt(s4.getCameraToCenterDistance(f2), P3);
              let D2 = n3.evaluateSizeForFeature(t2.textSizeData, h3, y2) * S2 / e.ONE_EM;
              o2 && (D2 *= t2.tilePixelRatio / c4);
              const L2 = ho(E2, D2);
              o2 ? ({ x: C3, y: M2, z: I2 } = f2.projectTilePoint(b3 + L2.x, w2 + L2.y, l3.canonical), [C3, M2, I2] = ot(C3 + r3, M2 + _3, I2 + p5, a2)) : (i2 && L2._rotate(-s4.angle), C3 += L2.x, M2 += L2.y, I2 = 0);
              const A2 = t2.allowVerticalPlacement && y2.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;
              for (let t3 = 0; t3 < T3; t3++)
                e.addDynamicAttributes(d3, C3, M2, I2, A2);
              u3 && y2.associatedIconIndex >= 0 && (m3[y2.associatedIconIndex] = { x: C3, y: M2, z: I2, angle: A2 });
            } else
              dt(T3, d3);
          }
          if (u3) {
            p3.clear();
            const i3 = t2.icon.placedSymbolArray;
            for (let t3 = 0; t3 < i3.length; t3++) {
              const o3 = i3.get(t3), { numGlyphs: r3 } = o3, n4 = m3[t3];
              if (o3.hidden || !n4)
                dt(r3, p3);
              else {
                const { x: t4, y: i4, z: o4, angle: s5 } = n4;
                for (let n5 = 0; n5 < r3; n5++)
                  e.addDynamicAttributes(p3, t4, i4, o4, s5);
              }
            }
            t2.icon.dynamicLayoutVertexBuffer.updateData(p3);
          }
          t2.text.dynamicLayoutVertexBuffer.updateData(d3);
        }
        function _o(e2, t2, i2) {
          return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
        }
        function po(t2, i2, o2, r2, n3, s4, a2, l3, c4, h3, u3, _2) {
          const d3 = t2.context, p3 = d3.gl, m3 = t2.transform, f2 = "map" === l3, g2 = "map" === c4, v4 = f2 && "point" !== o2.layout.get("symbol-placement"), x2 = f2 && !g2 && !v4, y2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
          let b3 = false;
          const w2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), T3 = [e.mercatorXfromLng(m3.center.lng), e.mercatorYfromLat(m3.center.lat)], E2 = o2.layout.get("text-variable-anchor"), C3 = "globe" === m3.projection.name, M2 = [], I2 = [0, -1, 0];
          let P3 = I2;
          !C3 && !m3.mercatorFromTransition || f2 || (P3 = function(t3) {
            const i3 = t3._camera.getWorldToCamera(t3.worldSize, 1), o3 = e.multiply([], i3, t3.globeMatrix);
            e.invert(o3, o3);
            const r3 = [0, 0, 0], n4 = [0, 1, 0, 0];
            return e.transformMat4$1(n4, n4, o3), r3[0] = n4[0], r3[1] = n4[1], r3[2] = n4[2], e.normalize(r3, r3), r3;
          }(m3));
          for (const l4 of r2) {
            const r3 = i2.getTile(l4), c5 = r3.getBucket(o2);
            if (!c5)
              continue;
            if ("mercator" === c5.projection.name && C3)
              continue;
            const u4 = n3 ? c5.text : c5.icon;
            if (!u4 || c5.fullyClipped || !u4.segments.get().length)
              continue;
            const _3 = u4.programConfigurations.get(o2.id), d4 = n3 || c5.sdfIcons, w3 = n3 ? c5.textSizeData : c5.iconSizeData, S2 = g2 || 0 !== m3.pitch, D2 = e.evaluateSizeForZoom(w3, m3.zoom);
            let L2, A2, z2, R2, O2 = [0, 0], B2 = null;
            if (n3)
              A2 = r3.glyphAtlasTexture, z2 = p3.LINEAR, L2 = r3.glyphAtlasTexture.size, c5.iconsInText && (O2 = r3.imageAtlasTexture.size, B2 = r3.imageAtlasTexture, R2 = S2 || t2.options.rotating || t2.options.zooming || "composite" === w3.kind || "camera" === w3.kind ? p3.LINEAR : p3.NEAREST);
            else {
              const e2 = 1 !== o2.layout.get("icon-size").constantOr(0) || c5.iconsNeedLinear;
              A2 = r3.imageAtlasTexture, z2 = d4 || t2.options.rotating || t2.options.zooming || e2 || S2 ? p3.LINEAR : p3.NEAREST, L2 = r3.imageAtlasTexture.size;
            }
            const k2 = "globe" === c5.projection.name, F2 = k2 ? P3 : I2, U2 = k2 ? e.globeToMercatorTransition(m3.zoom) : 0, N2 = xt(l4, c5.getProjection(), m3), j2 = m3.calculatePixelsToTileUnitsMatrix(r3), G2 = et(N2, r3.tileID.canonical, g2, f2, m3, c5.getProjection(), j2), Z2 = t2.terrain && g2 && v4 ? e.invert(e.create(), G2) : co, V2 = it(N2, r3.tileID.canonical, g2, f2, m3, c5.getProjection(), j2), W2 = E2 && c5.hasTextData(), X2 = "none" !== o2.layout.get("icon-text-fit") && W2 && c5.hasIconData();
            if (v4) {
              const e2 = m3.elevation, i3 = e2 ? e2.getAtTileOffsetFunc(l4, m3.center.lat, m3.worldSize, c5.getProjection()) : null, o3 = tt(N2, r3.tileID.canonical, g2, f2, m3, c5.getProjection(), j2);
              st(c5, N2, t2, n3, o3, V2, g2, h3, i3, l4);
            }
            const q2 = v4 || n3 && E2 || X2, $2 = t2.translatePosMatrix(N2, r3, s4, a2), H2 = q2 ? co : G2, Y2 = t2.translatePosMatrix(V2, r3, s4, a2, true), K2 = c5.getProjection().createInversionMatrix(m3, l4.canonical), J2 = [];
            t2.terrainRenderModeElevated() && g2 && J2.push("PITCH_WITH_MAP_TERRAIN"), k2 && J2.push("PROJECTION_GLOBE_VIEW"), q2 && J2.push("PROJECTED_POS_ON_VIEWPORT");
            const Q2 = d4 && 0 !== o2.paint.get(n3 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let ee2;
            ee2 = d4 ? c5.iconsInText ? oo(w3.kind, D2, x2, g2, t2, $2, H2, Y2, L2, O2, l4, U2, T3, K2, F2, c5.getProjection()) : io(w3.kind, D2, x2, g2, t2, $2, H2, Y2, n3, L2, true, l4, U2, T3, K2, F2, c5.getProjection()) : to(w3.kind, D2, x2, g2, t2, $2, H2, Y2, n3, L2, l4, U2, T3, K2, F2, c5.getProjection());
            const te2 = { program: t2.useProgram(_o(d4, n3, c5), _3, J2), buffers: u4, uniformValues: ee2, atlasTexture: A2, atlasTextureIcon: B2, atlasInterpolation: z2, atlasInterpolationIcon: R2, isSDF: d4, hasHalo: Q2, tile: r3, labelPlaneMatrixInv: Z2 };
            if (y2 && c5.canOverlap) {
              b3 = true;
              const t3 = u4.segments.get();
              for (const i3 of t3)
                M2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: te2 });
            } else
              M2.push({ segments: u4.segments, sortKey: 0, state: te2 });
          }
          b3 && M2.sort((e2, t3) => e2.sortKey - t3.sortKey);
          for (const e2 of M2) {
            const i3 = e2.state;
            if (t2.terrain && t2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: !C3, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }), d3.activeTexture.set(p3.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p3.CLAMP_TO_EDGE), i3.atlasTextureIcon && (d3.activeTexture.set(p3.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p3.CLAMP_TO_EDGE)), i3.isSDF) {
              const r3 = i3.uniformValues;
              i3.hasHalo && (r3.u_is_halo = 1, mo(i3.buffers, e2.segments, o2, t2, i3.program, w2, u3, _2, r3)), r3.u_is_halo = 0;
            }
            mo(i3.buffers, e2.segments, o2, t2, i3.program, w2, u3, _2, i3.uniformValues);
          }
        }
        function mo(t2, i2, o2, r2, n3, s4, a2, l3, c4) {
          const h3 = r2.context, u3 = [t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer, t2.globeExtVertexBuffer];
          n3.draw(h3, h3.gl.TRIANGLES, s4, a2, l3, e.CullFaceMode.disabled, c4, o2.id, t2.layoutVertexBuffer, t2.indexBuffer, i2, o2.paint, r2.transform.zoom, t2.programConfigurations.get(o2.id), u3);
        }
        function fo(t2, i2, o2, r2, n3, s4, a2) {
          const l3 = t2.context.gl, c4 = o2.paint.get("fill-pattern"), h3 = c4 && c4.constantOr(1);
          let u3, _2, d3, p3, m3;
          a2 ? (_2 = h3 && !o2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u3 = l3.LINES) : (_2 = h3 ? "fillPattern" : "fill", u3 = l3.TRIANGLES);
          for (const f2 of r2) {
            const r3 = i2.getTile(f2);
            if (h3 && !r3.patternsLoaded())
              continue;
            const g2 = r3.getBucket(o2);
            if (!g2)
              continue;
            t2.prepareDrawTile();
            const v4 = g2.programConfigurations.get(o2.id), x2 = t2.useProgram(_2, v4);
            h3 && (t2.context.activeTexture.set(l3.TEXTURE0), r3.imageAtlasTexture.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), v4.updatePaintBuffers());
            const y2 = c4.constantOr(null);
            if (y2 && r3.imageAtlas) {
              const e2 = r3.imageAtlas.patternPositions[y2.toString()];
              e2 && v4.setConstantPatternPositions(e2);
            }
            const b3 = t2.translatePosMatrix(f2.projMatrix, r3, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
            if (a2) {
              p3 = g2.indexBuffer2, m3 = g2.segments2;
              const e2 = t2.terrain && t2.terrain.renderingToTexture ? t2.terrain.drapeBufferSize : [l3.drawingBufferWidth, l3.drawingBufferHeight];
              d3 = "fillOutlinePattern" === _2 && h3 ? Ui(b3, t2, r3, e2) : Fi(b3, e2);
            } else
              p3 = g2.indexBuffer, m3 = g2.segments, d3 = h3 ? ki(b3, t2, r3) : Bi(b3);
            t2.prepareDrawProgram(t2.context, x2, f2.toUnwrapped()), x2.draw(t2.context, u3, n3, t2.stencilModeForClipping(f2), s4, e.CullFaceMode.disabled, d3, o2.id, g2.layoutVertexBuffer, p3, m3, o2.paint, t2.transform.zoom, v4);
          }
        }
        function go(t2, i2, o2, r2, n3, s4, a2) {
          const l3 = t2.context, c4 = l3.gl, h3 = t2.transform, u3 = o2.paint.get("fill-extrusion-pattern"), _2 = u3.constantOr(1), d3 = o2.paint.get("fill-extrusion-opacity"), p3 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), o2.paint.get("fill-extrusion-ambient-occlusion-radius")], m3 = o2.layout.get("fill-extrusion-edge-radius"), f2 = m3 > 0 && !o2.paint.get("fill-extrusion-rounded-roof"), g2 = f2 ? 0 : m3, v4 = "globe" === h3.projection.name ? e.fillExtrusionHeightLift() : 0, x2 = "globe" === h3.projection.name, y2 = x2 ? e.globeToMercatorTransition(h3.zoom) : 0, b3 = [e.mercatorXfromLng(h3.center.lng), e.mercatorYfromLat(h3.center.lat)], w2 = [];
          x2 && w2.push("PROJECTION_GLOBE_VIEW"), p3[0] > 0 && w2.push("FAUX_AO"), f2 && w2.push("ZERO_ROOF_RADIUS");
          for (const m4 of r2) {
            const r3 = i2.getTile(m4), f3 = r3.getBucket(o2);
            if (!f3 || f3.projection.name !== h3.projection.name)
              continue;
            const T3 = f3.programConfigurations.get(o2.id), E2 = t2.useProgram(_2 ? "fillExtrusionPattern" : "fillExtrusion", T3, w2);
            if (t2.terrain) {
              const e2 = t2.terrain;
              if (t2.style.terrainSetForDrapingOnly())
                e2.setupElevationDraw(r3, E2, { useMeterToDem: true });
              else {
                if (!f3.enableTerrain)
                  continue;
                if (e2.setupElevationDraw(r3, E2, { useMeterToDem: true }), vo(l3, i2, m4, f3, o2, e2), !f3.centroidVertexBuffer) {
                  const e3 = E2.attributes.a_centroid_pos;
                  void 0 !== e3 && c4.vertexAttrib2f(e3, 0, 0);
                }
              }
            }
            _2 && (t2.context.activeTexture.set(c4.TEXTURE0), r3.imageAtlasTexture.bind(c4.LINEAR, c4.CLAMP_TO_EDGE), T3.updatePaintBuffers());
            const C3 = u3.constantOr(null);
            if (C3 && r3.imageAtlas) {
              const e2 = r3.imageAtlas.patternPositions[C3.toString()];
              e2 && T3.setConstantPatternPositions(e2);
            }
            const M2 = t2.translatePosMatrix(m4.projMatrix, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), I2 = h3.projection.createInversionMatrix(h3, m4.canonical), P3 = o2.paint.get("fill-extrusion-vertical-gradient"), S2 = _2 ? Oi(M2, t2, P3, d3, p3, g2, m4, r3, v4, y2, b3, I2) : Ri(M2, t2, P3, d3, p3, g2, m4, v4, y2, b3, I2);
            t2.prepareDrawProgram(l3, E2, m4.toUnwrapped());
            const D2 = [];
            t2.terrain && D2.push(f3.centroidVertexBuffer), x2 && D2.push(f3.layoutVertexExtBuffer), E2.draw(l3, l3.gl.TRIANGLES, n3, s4, a2, e.CullFaceMode.backCCW, S2, o2.id, f3.layoutVertexBuffer, f3.indexBuffer, f3.segments, o2.paint, t2.transform.zoom, T3, D2);
          }
        }
        function vo(t2, i2, o2, r2, n3, s4) {
          const a2 = [(t3) => {
            let i3 = t3.canonical.x - 1, o3 = t3.wrap;
            return i3 < 0 && (i3 = (1 << t3.canonical.z) - 1, o3--), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
          }, (t3) => {
            let i3 = t3.canonical.x + 1, o3 = t3.wrap;
            return i3 === 1 << t3.canonical.z && (i3 = 0, o3++), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
          }, (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, (0 === t3.canonical.y ? 1 << t3.canonical.z : t3.canonical.y) - 1), (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y === (1 << t3.canonical.z) - 1 ? 0 : t3.canonical.y + 1)], l3 = (e2) => {
            const t3 = i2.getSource().minzoom, o3 = (e3) => {
              const t4 = i2.getTileByID(e3);
              if (t4 && t4.hasData())
                return t4.getBucket(n3);
            }, r3 = [0, -1, 1];
            for (const i3 of r3) {
              if (e2.overscaledZ + i3 < t3)
                continue;
              const r4 = o3(e2.calculateScaledKey(e2.overscaledZ + i3));
              if (r4)
                return r4;
            }
          }, c4 = [0, 0, 0], h3 = (t3, i3) => (c4[0] = Math.min(t3.min.y, i3.min.y), c4[1] = Math.max(t3.max.y, i3.max.y), c4[2] = e.EXTENT - i3.min.x > t3.max.x ? i3.min.x - e.EXTENT : t3.max.x, c4), u3 = (t3, i3) => (c4[0] = Math.min(t3.min.x, i3.min.x), c4[1] = Math.max(t3.max.x, i3.max.x), c4[2] = e.EXTENT - i3.min.y > t3.max.y ? i3.min.y - e.EXTENT : t3.max.y, c4), _2 = [(e2, t3) => h3(e2, t3), (e2, t3) => h3(t3, e2), (e2, t3) => u3(e2, t3), (e2, t3) => u3(t3, e2)], d3 = new e.Point(0, 0);
          let p3, m3, f2;
          const g2 = (t3, i3, r3, n4, a3) => {
            const l4 = [[n4 ? r3 : t3, n4 ? t3 : r3, 0], [n4 ? r3 : i3, n4 ? i3 : r3, 0]], c5 = a3 < 0 ? e.EXTENT + a3 : a3, h4 = [n4 ? c5 : (t3 + i3) / 2, n4 ? (t3 + i3) / 2 : c5, 0];
            return 0 === r3 && a3 < 0 || 0 !== r3 && a3 > 0 ? s4.getForTilePoints(f2, [h4], true, m3) : l4.push(h4), s4.getForTilePoints(o2, l4, true, p3), Math.max(l4[0][2], l4[1][2], h4[2]) / s4.exaggeration();
          };
          for (let t3 = 0; t3 < 4; t3++) {
            const i3 = (t3 < 2 ? 1 : 5) - t3, n4 = r2.borders[t3];
            if (0 === n4.length)
              continue;
            const c5 = f2 = a2[t3](o2), h4 = l3(c5);
            if (!(h4 && h4 instanceof e.FillExtrusionBucket && h4.enableTerrain))
              continue;
            if (r2.borderDoneWithNeighborZ[t3] === h4.canonical.z && h4.borderDoneWithNeighborZ[i3] === r2.canonical.z)
              continue;
            if (m3 = s4.findDEMTileFor(c5), !m3 || !m3.dem)
              continue;
            if (!p3) {
              const e2 = s4.findDEMTileFor(o2);
              if (!e2 || !e2.dem)
                return;
              p3 = e2;
            }
            const u4 = h4.borders[i3];
            let v4 = 0;
            const x2 = h4.borderDoneWithNeighborZ[i3] !== r2.canonical.z;
            if (r2.canonical.z === h4.canonical.z) {
              for (let o3 = 0; o3 < n4.length; o3++) {
                const s5 = r2.featuresOnBorder[n4[o3]], a3 = s5.borders[t3];
                let l4;
                for (; v4 < u4.length && (l4 = h4.featuresOnBorder[u4[v4]], !(l4.borders[i3][1] > a3[0] + 3)); )
                  x2 && h4.encodeCentroid(void 0, l4, false), v4++;
                if (l4 && v4 < u4.length) {
                  const o4 = v4;
                  let n5 = 0;
                  for (; !(l4.borders[i3][0] > a3[1] - 3) && (n5++, ++v4 !== u4.length); )
                    l4 = h4.featuresOnBorder[u4[v4]];
                  if (l4 = h4.featuresOnBorder[u4[o4]], s5.intersectsCount() > 1 || l4.intersectsCount() > 1 || 1 !== n5) {
                    1 !== n5 && (v4 = o4), r2.encodeCentroid(void 0, s5, false), x2 && h4.encodeCentroid(void 0, l4, false);
                    continue;
                  }
                  const c6 = _2[t3](s5, l4), p4 = t3 % 2 ? e.EXTENT - 1 : 0;
                  d3.x = g2(c6[0], Math.min(e.EXTENT - 1, c6[1]), p4, t3 < 2, c6[2]), d3.y = 0, r2.encodeCentroid(d3, s5, false), x2 && h4.encodeCentroid(d3, l4, false);
                } else
                  r2.encodeCentroid(void 0, s5, false);
              }
              r2.borderDoneWithNeighborZ[t3] = h4.canonical.z, r2.needsCentroidUpdate = true, x2 && (h4.borderDoneWithNeighborZ[i3] = r2.canonical.z, h4.needsCentroidUpdate = true);
            } else {
              for (const e2 of n4)
                r2.encodeCentroid(void 0, r2.featuresOnBorder[e2], false);
              if (x2) {
                for (const e2 of u4)
                  h4.encodeCentroid(void 0, h4.featuresOnBorder[e2], false);
                h4.borderDoneWithNeighborZ[i3] = r2.canonical.z, h4.needsCentroidUpdate = true;
              }
              r2.borderDoneWithNeighborZ[t3] = h4.canonical.z, r2.needsCentroidUpdate = true;
            }
          }
          (r2.needsCentroidUpdate || !r2.centroidVertexBuffer && 0 !== r2.centroidVertexArray.length) && r2.uploadCentroid(t2);
        }
        const xo = new e.Color(1, 0, 0, 1), yo = new e.Color(0, 1, 0, 1), bo = new e.Color(0, 0, 1, 1), wo = new e.Color(1, 0, 1, 1), To = new e.Color(0, 1, 1, 1);
        function Eo(t2, i2, o2) {
          const r2 = t2.context, n3 = t2.transform, s4 = r2.gl, a2 = "globe" === n3.projection.name, l3 = a2 ? ["PROJECTION_GLOBE_VIEW"] : null;
          let c4 = o2.projMatrix;
          if (a2 && e.globeToMercatorTransition(n3.zoom) > 0) {
            const t3 = e.transitionTileAABBinECEF(o2.canonical, n3), i3 = e.globeDenormalizeECEF(t3);
            c4 = e.multiply(new Float32Array(16), n3.globeMatrix, i3), e.multiply(c4, n3.projMatrix, c4);
          }
          const h3 = t2.useProgram("debug", null, l3), u3 = i2.getTileByID(o2.key);
          t2.terrain && t2.terrain.setupElevationDraw(u3, h3);
          const _2 = e.DepthMode.disabled, d3 = e.StencilMode.disabled, p3 = t2.colorModeForRenderPass(), m3 = "$debug";
          r2.activeTexture.set(s4.TEXTURE0), t2.emptyTexture.bind(s4.LINEAR, s4.CLAMP_TO_EDGE), a2 ? u3._makeGlobeTileDebugBuffers(t2.context, n3) : u3._makeDebugTileBoundsBuffers(t2.context, n3.projection);
          const f2 = u3._tileDebugBuffer || t2.debugBuffer, g2 = u3._tileDebugIndexBuffer || t2.debugIndexBuffer, v4 = u3._tileDebugSegments || t2.debugSegments;
          h3.draw(r2, s4.LINE_STRIP, _2, d3, p3, e.CullFaceMode.disabled, Vi(c4, e.Color.red), m3, f2, g2, v4, null, null, null, [u3._globeTileDebugBorderBuffer]);
          const x2 = u3.latestRawTileData, y2 = Math.floor((x2 && x2.byteLength || 0) / 1024), b3 = i2.getTile(o2).tileSize, w2 = 512 / Math.min(b3, 512) * (o2.overscaledZ / n3.zoom) * 0.5;
          let T3 = o2.canonical.toString();
          o2.overscaledZ !== o2.canonical.z && (T3 += ` => ${o2.overscaledZ}`), T3 += ` ${y2}kb`, function(e2, t3) {
            e2.initDebugOverlayCanvas();
            const i3 = e2.debugOverlayCanvas, o3 = e2.context.gl, r3 = e2.debugOverlayCanvas.getContext("2d");
            r3.clearRect(0, 0, i3.width, i3.height), r3.shadowColor = "white", r3.shadowBlur = 2, r3.lineWidth = 1.5, r3.strokeStyle = "white", r3.textBaseline = "top", r3.font = "bold 36px Open Sans, sans-serif", r3.fillText(t3, 5, 5), r3.strokeText(t3, 5, 5), e2.debugOverlayTexture.update(i3), e2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }(t2, T3);
          const E2 = u3._tileDebugTextBuffer || t2.debugBuffer, C3 = u3._tileDebugTextIndexBuffer || t2.quadTriangleIndexBuffer, M2 = u3._tileDebugTextSegments || t2.debugSegments;
          h3.draw(r2, s4.TRIANGLES, _2, d3, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Vi(c4, e.Color.transparent, w2), m3, E2, C3, M2, null, null, null, [u3._globeTileDebugTextBuffer]);
        }
        function Co(e2, t2, i2, o2) {
          Io(e2, 0, t2 + i2 / 2, e2.transform.width, i2, o2);
        }
        function Mo(e2, t2, i2, o2) {
          Io(e2, t2 - i2 / 2, 0, i2, e2.transform.height, o2);
        }
        function Io(t2, i2, o2, r2, n3, s4) {
          const a2 = t2.context, l3 = a2.gl;
          l3.enable(l3.SCISSOR_TEST), l3.scissor(i2 * e.exported.devicePixelRatio, o2 * e.exported.devicePixelRatio, r2 * e.exported.devicePixelRatio, n3 * e.exported.devicePixelRatio), a2.clear({ color: s4 }), l3.disable(l3.SCISSOR_TEST);
        }
        const Po = e.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: So } = Po;
        function Do(e2, t2, i2, o2) {
          e2.emplaceBack(t2, i2, o2);
        }
        class Lo {
          constructor(t2) {
            this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), Do(this.vertexArray, -1, -1, 1), Do(this.vertexArray, 1, -1, 1), Do(this.vertexArray, -1, 1, 1), Do(this.vertexArray, 1, 1, 1), Do(this.vertexArray, -1, -1, -1), Do(this.vertexArray, 1, -1, -1), Do(this.vertexArray, -1, 1, -1), Do(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, So), this.indexBuffer = t2.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);
          }
        }
        function Ao(t2, i2, o2, r2, n3, s4) {
          const a2 = t2.gl, l3 = i2.paint.get("sky-atmosphere-color"), c4 = i2.paint.get("sky-atmosphere-halo-color"), h3 = i2.paint.get("sky-atmosphere-sun-intensity"), u3 = ((e2, t3, i3, o3, r3) => ({ u_matrix_3f: e2, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r3.r, r3.g, r3.b, r3.a], u_luminance: 5e-5 }))(e.fromMat4(e.create$1(), r2), n3, h3, l3, c4);
          a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_CUBE_MAP_POSITIVE_X + s4, i2.skyboxTexture, 0), o2.draw(t2, a2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, u3, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
        }
        const zo = e.createLayout([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
        class Ro {
          constructor(t2) {
            const i2 = new e.StructArrayLayout5f20();
            i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
            const o2 = new e.StructArrayLayout3ui6();
            o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t2.createVertexBuffer(i2, zo.members), this.indexBuffer = t2.createIndexBuffer(o2), this.segments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
          }
        }
        const Oo = { symbol: function(t2, i2, o2, r2, n3) {
          if ("translucent" !== t2.renderPass)
            return;
          const s4 = e.StencilMode.disabled, a2 = t2.colorModeForRenderPass();
          o2.layout.get("text-variable-anchor") && function(t3, i3, o3, r3, n4, s5, a3) {
            const l3 = i3.transform, c4 = "map" === n4, h3 = "map" === s5;
            for (const i4 of t3) {
              const t4 = r3.getTile(i4), n5 = t4.getBucket(o3);
              if (!n5 || !n5.text || !n5.text.segments.get().length)
                continue;
              const s6 = e.evaluateSizeForZoom(n5.textSizeData, l3.zoom), u3 = xt(i4, n5.getProjection(), l3), _2 = l3.calculatePixelsToTileUnitsMatrix(t4), d3 = et(u3, t4.tileID.canonical, h3, c4, l3, n5.getProjection(), _2), p3 = "none" !== o3.layout.get("icon-text-fit") && n5.hasIconData();
              if (s6) {
                const o4 = Math.pow(2, l3.zoom - t4.tileID.overscaledZ);
                uo(n5, c4, h3, a3, e.symbolSize, l3, d3, i4, o4, s6, p3);
              }
            }
          }(r2, t2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), n3), 0 !== o2.paint.get("icon-opacity").constantOr(1) && po(t2, i2, o2, r2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), s4, a2), 0 !== o2.paint.get("text-opacity").constantOr(1) && po(t2, i2, o2, r2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), s4, a2), i2.map.showCollisionBoxes && (lo(t2, i2, o2, r2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), lo(t2, i2, o2, r2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
        }, circle: function(t2, i2, o2, r2) {
          if ("translucent" !== t2.renderPass)
            return;
          const n3 = o2.paint.get("circle-opacity"), s4 = o2.paint.get("circle-stroke-width"), a2 = o2.paint.get("circle-stroke-opacity"), l3 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1);
          if (0 === n3.constantOr(1) && (0 === s4.constantOr(1) || 0 === a2.constantOr(1)))
            return;
          const c4 = t2.context, h3 = c4.gl, u3 = t2.transform, _2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), d3 = e.StencilMode.disabled, p3 = t2.colorModeForRenderPass(), m3 = "globe" === u3.projection.name, f2 = [e.mercatorXfromLng(u3.center.lng), e.mercatorYfromLat(u3.center.lat)], g2 = [];
          for (let n4 = 0; n4 < r2.length; n4++) {
            const s5 = r2[n4], a3 = i2.getTile(s5), c5 = a3.getBucket(o2);
            if (!c5 || c5.projection.name !== u3.projection.name)
              continue;
            const h4 = c5.programConfigurations.get(o2.id), _3 = Gi(o2);
            m3 && _3.push("PROJECTION_GLOBE_VIEW");
            const d4 = t2.useProgram("circle", h4, _3), p4 = c5.layoutVertexBuffer, v5 = c5.globeExtVertexBuffer, x2 = c5.indexBuffer, y2 = u3.projection.createInversionMatrix(u3, s5.canonical), b3 = { programConfiguration: h4, program: d4, layoutVertexBuffer: p4, globeExtVertexBuffer: v5, indexBuffer: x2, uniformValues: ji(t2, s5, a3, y2, f2, o2), tile: a3 };
            if (l3) {
              const t3 = c5.segments.get();
              for (const i3 of t3)
                g2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: b3 });
            } else
              g2.push({ segments: c5.segments, sortKey: 0, state: b3 });
          }
          l3 && g2.sort((e2, t3) => e2.sortKey - t3.sortKey);
          const v4 = { useDepthForOcclusion: !m3 };
          for (const i3 of g2) {
            const { programConfiguration: r3, program: n4, layoutVertexBuffer: s5, globeExtVertexBuffer: a3, indexBuffer: l4, uniformValues: m4, tile: f3 } = i3.state, g3 = i3.segments;
            t2.terrain && t2.terrain.setupElevationDraw(f3, n4, v4), t2.prepareDrawProgram(c4, n4, f3.tileID.toUnwrapped()), n4.draw(c4, h3.TRIANGLES, _2, d3, p3, e.CullFaceMode.disabled, m4, o2.id, s5, l4, g3, o2.paint, u3.zoom, r3, [a3]);
          }
        }, heatmap: function(t2, i2, o2, r2) {
          if (0 !== o2.paint.get("heatmap-opacity"))
            if ("offscreen" === t2.renderPass) {
              const n3 = t2.context, s4 = n3.gl, a2 = e.StencilMode.disabled, l3 = new e.ColorMode([s4.ONE, s4.ONE], e.Color.transparent, [true, true, true, true]);
              !function(e2, t3, i3, o3) {
                const r3 = e2.gl, n4 = t3.width * o3, s5 = t3.height * o3;
                e2.activeTexture.set(r3.TEXTURE1), e2.viewport.set([0, 0, n4, s5]);
                let a3 = i3.heatmapFbo;
                if (!a3 || a3 && (a3.width !== n4 || a3.height !== s5)) {
                  a3 && a3.destroy();
                  const t4 = r3.createTexture();
                  r3.bindTexture(r3.TEXTURE_2D, t4), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, r3.LINEAR), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, r3.LINEAR), a3 = i3.heatmapFbo = e2.createFramebuffer(n4, s5, false), function(e3, t5, i4, o4, r4, n5) {
                    const s6 = e3.gl;
                    s6.texImage2D(s6.TEXTURE_2D, 0, e3.isWebGL2 && e3.extRenderToTextureHalfFloat ? s6.RGBA16F : s6.RGBA, r4, n5, 0, s6.RGBA, e3.extRenderToTextureHalfFloat ? e3.isWebGL2 ? s6.HALF_FLOAT : e3.extTextureHalfFloat.HALF_FLOAT_OES : s6.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                  }(e2, 0, t4, a3, n4, s5);
                } else
                  r3.bindTexture(r3.TEXTURE_2D, a3.colorAttachment.get()), e2.bindFramebuffer.set(a3.framebuffer);
              }(n3, t2, o2, "globe" === t2.transform.projection.name ? 0.5 : 0.25), n3.clear({ color: e.Color.transparent });
              const c4 = t2.transform, h3 = "globe" === c4.projection.name, u3 = h3 ? ["PROJECTION_GLOBE_VIEW"] : null, _2 = h3 ? e.CullFaceMode.frontCCW : e.CullFaceMode.disabled, d3 = [e.mercatorXfromLng(c4.center.lng), e.mercatorYfromLat(c4.center.lat)];
              for (let p3 = 0; p3 < r2.length; p3++) {
                const m3 = r2[p3];
                if (i2.hasRenderableParent(m3))
                  continue;
                const f2 = i2.getTile(m3), g2 = f2.getBucket(o2);
                if (!g2 || g2.projection.name !== c4.projection.name)
                  continue;
                const v4 = g2.programConfigurations.get(o2.id), x2 = t2.useProgram("heatmap", v4, u3), { zoom: y2 } = t2.transform;
                t2.terrain && t2.terrain.setupElevationDraw(f2, x2), t2.prepareDrawProgram(n3, x2, m3.toUnwrapped());
                const b3 = c4.projection.createInversionMatrix(c4, m3.canonical);
                x2.draw(n3, s4.TRIANGLES, e.DepthMode.disabled, a2, l3, _2, Xi(t2, m3, f2, b3, d3, y2, o2.paint.get("heatmap-intensity")), o2.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, o2.paint, t2.transform.zoom, v4, h3 ? [g2.globeExtVertexBuffer] : null);
              }
              n3.viewport.set([0, 0, t2.width, t2.height]);
            } else
              "translucent" === t2.renderPass && (t2.context.setColorMode(t2.colorModeForRenderPass()), function(t3, i3) {
                const o3 = t3.context, r3 = o3.gl, n3 = i3.heatmapFbo;
                if (!n3)
                  return;
                o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, n3.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
                let s4 = i3.colorRampTexture;
                s4 || (s4 = i3.colorRampTexture = new e.Texture(o3, i3.colorRamp, r3.RGBA)), s4.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), t3.useProgram("heatmapTexture").draw(o3, r3.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e2, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
              }(t2, o2));
        }, line: function(t2, i2, o2, r2) {
          if ("translucent" !== t2.renderPass)
            return;
          const n3 = o2.paint.get("line-opacity"), s4 = o2.paint.get("line-width");
          if (0 === n3.constantOr(1) || 0 === s4.constantOr(1))
            return;
          const a2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), l3 = t2.colorModeForRenderPass(), c4 = t2.terrain && t2.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio, h3 = o2.paint.get("line-dasharray"), u3 = h3.constantOr(1), _2 = o2.layout.get("line-cap"), d3 = o2.paint.get("line-pattern"), p3 = d3.constantOr(1), m3 = o2.paint.get("line-gradient"), f2 = p3 ? "linePattern" : "line", g2 = t2.context, v4 = g2.gl, x2 = ((e2) => {
            const t3 = [];
            Ki(e2) && t3.push("RENDER_LINE_DASH"), e2.paint.get("line-gradient") && t3.push("RENDER_LINE_GRADIENT");
            const i3 = e2.paint.get("line-trim-offset");
            0 === i3[0] && 0 === i3[1] || t3.push("RENDER_LINE_TRIM_OFFSET");
            const o3 = e2.paint.get("line-pattern").constantOr(1), r3 = 1 !== e2.paint.get("line-opacity").constantOr(1);
            return !o3 && r3 && t3.push("RENDER_LINE_ALPHA_DISCARD"), t3;
          })(o2);
          let y2 = x2.includes("RENDER_LINE_ALPHA_DISCARD");
          t2.terrain && t2.terrain.clipOrMaskOverlapStencilType() && (y2 = false);
          for (const n4 of r2) {
            const r3 = i2.getTile(n4);
            if (p3 && !r3.patternsLoaded())
              continue;
            const s5 = r3.getBucket(o2);
            if (!s5)
              continue;
            t2.prepareDrawTile();
            const b3 = s5.programConfigurations.get(o2.id), w2 = t2.useProgram(f2, b3, x2), T3 = d3.constantOr(null);
            if (T3 && r3.imageAtlas) {
              const e2 = r3.imageAtlas.patternPositions[T3.toString()];
              e2 && b3.setConstantPatternPositions(e2);
            }
            const E2 = h3.constantOr(null), C3 = _2.constantOr(null);
            if (!p3 && E2 && C3 && r3.lineAtlas) {
              const e2 = r3.lineAtlas.getDash(E2, C3);
              e2 && b3.setConstantPatternPositions(e2);
            }
            let [M2, I2] = o2.paint.get("line-trim-offset");
            if ("round" === C3 || "square" === C3) {
              const e2 = 1;
              M2 !== I2 && (0 === M2 && (M2 -= e2), 1 === I2 && (I2 += e2));
            }
            const P3 = t2.terrain ? n4.projMatrix : null, S2 = p3 ? $i(t2, r3, o2, P3, c4) : qi(t2, r3, o2, P3, s5.lineClipsArray.length, c4, [M2, I2]);
            if (m3) {
              const r4 = s5.gradients[o2.id];
              let a3 = r4.texture;
              if (o2.gradientVersion !== r4.version) {
                let l4 = 256;
                if (o2.stepInterpolant) {
                  const o3 = i2.getSource().maxzoom, r5 = n4.canonical.z === o3 ? Math.ceil(1 << t2.transform.maxZoom - n4.canonical.z) : 1;
                  l4 = e.clamp(e.nextPowerOfTwo(s5.maxLineLength / e.EXTENT * 1024 * r5), 256, g2.maxTextureSize);
                }
                r4.gradient = e.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l4, image: r4.gradient || void 0, clips: s5.lineClipsArray }), r4.texture ? r4.texture.update(r4.gradient) : r4.texture = new e.Texture(g2, r4.gradient, v4.RGBA), r4.version = o2.gradientVersion, a3 = r4.texture;
              }
              g2.activeTexture.set(v4.TEXTURE1), a3.bind(o2.stepInterpolant ? v4.NEAREST : v4.LINEAR, v4.CLAMP_TO_EDGE);
            }
            u3 && (g2.activeTexture.set(v4.TEXTURE0), r3.lineAtlasTexture.bind(v4.LINEAR, v4.REPEAT), b3.updatePaintBuffers()), p3 && (g2.activeTexture.set(v4.TEXTURE0), r3.imageAtlasTexture.bind(v4.LINEAR, v4.CLAMP_TO_EDGE), b3.updatePaintBuffers()), t2.prepareDrawProgram(g2, w2, n4.toUnwrapped());
            const D2 = (i3) => {
              w2.draw(g2, v4.TRIANGLES, a2, i3, l3, e.CullFaceMode.disabled, S2, o2.id, s5.layoutVertexBuffer, s5.indexBuffer, s5.segments, o2.paint, t2.transform.zoom, b3, [s5.layoutVertexBuffer2]);
            };
            if (y2) {
              const i3 = t2.stencilModeForClipping(n4).ref;
              0 === i3 && t2.terrain && g2.clear({ stencil: 0 });
              const o3 = { func: v4.EQUAL, mask: 255 };
              S2.u_alpha_discard_threshold = 0.8, D2(new e.StencilMode(o3, i3, 255, v4.KEEP, v4.KEEP, v4.INVERT)), S2.u_alpha_discard_threshold = 0, D2(new e.StencilMode(o3, i3, 255, v4.KEEP, v4.KEEP, v4.KEEP));
            } else
              D2(t2.stencilModeForClipping(n4));
          }
          y2 && (t2.resetStencilClippingMasks(), t2.terrain && g2.clear({ stencil: 0 }));
        }, fill: function(t2, i2, o2, r2) {
          const n3 = o2.paint.get("fill-color"), s4 = o2.paint.get("fill-opacity");
          if (0 === s4.constantOr(1))
            return;
          const a2 = t2.colorModeForRenderPass(), l3 = o2.paint.get("fill-pattern"), c4 = t2.opaquePassEnabledForLayer() && !l3.constantOr(1) && 1 === n3.constantOr(e.Color.transparent).a && 1 === s4.constantOr(0) ? "opaque" : "translucent";
          if (t2.renderPass === c4) {
            const n4 = t2.depthModeForSublayer(1, "opaque" === t2.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);
            fo(t2, i2, o2, r2, n4, a2, false);
          }
          if ("translucent" === t2.renderPass && o2.paint.get("fill-antialias")) {
            const n4 = t2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);
            fo(t2, i2, o2, r2, n4, a2, true);
          }
        }, "fill-extrusion": function(t2, i2, o2, r2) {
          const n3 = o2.paint.get("fill-extrusion-opacity");
          if (0 !== n3 && "translucent" === t2.renderPass) {
            const s4 = new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D);
            if (1 !== n3 || o2.paint.get("fill-extrusion-pattern").constantOr(1))
              go(t2, i2, o2, r2, s4, e.StencilMode.disabled, e.ColorMode.disabled), go(t2, i2, o2, r2, s4, t2.stencilModeFor3D(), t2.colorModeForRenderPass()), t2.resetStencilClippingMasks();
            else {
              const n4 = t2.colorModeForRenderPass();
              go(t2, i2, o2, r2, s4, e.StencilMode.disabled, n4);
            }
          }
        }, hillshade: function(t2, i2, o2, r2) {
          if ("offscreen" !== t2.renderPass && "translucent" !== t2.renderPass)
            return;
          const n3 = t2.context, s4 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), a2 = t2.colorModeForRenderPass(), l3 = t2.terrain && t2.terrain.renderingToTexture, [c4, h3] = "translucent" !== t2.renderPass || l3 ? [{}, r2] : t2.stencilConfigForOverlap(r2);
          for (const r3 of h3) {
            const n4 = i2.getTile(r3);
            if (n4.needsHillshadePrepare && "offscreen" === t2.renderPass)
              fi(t2, n4, o2, s4, e.StencilMode.disabled, a2);
            else if ("translucent" === t2.renderPass) {
              const e2 = l3 && t2.terrain ? t2.terrain.stencilModeForRTTOverlap(r3) : c4[r3.overscaledZ];
              pi(t2, r3, n4, o2, s4, e2, a2);
            }
          }
          n3.viewport.set([0, 0, t2.width, t2.height]), t2.resetStencilClippingMasks();
        }, raster: function(t2, i2, o2, r2, n3, s4) {
          if ("translucent" !== t2.renderPass)
            return;
          if (0 === o2.paint.get("raster-opacity"))
            return;
          if (!r2.length)
            return;
          const a2 = t2.context, l3 = a2.gl, c4 = i2.getSource(), h3 = t2.useProgram("raster"), u3 = t2.colorModeForRenderPass(), _2 = t2.terrain && t2.terrain.renderingToTexture, [d3, p3] = c4 instanceof Pe || _2 ? [{}, r2] : t2.stencilConfigForOverlap(r2), m3 = p3[p3.length - 1].overscaledZ, f2 = !t2.options.moving;
          for (const r3 of p3) {
            const n4 = _2 ? e.DepthMode.disabled : t2.depthModeForSublayer(r3.overscaledZ - m3, 1 === o2.paint.get("raster-opacity") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l3.LESS), p4 = r3.toUnwrapped(), g2 = i2.getTile(r3);
            if (_2 && (!g2 || !g2.hasData()))
              continue;
            const v4 = _2 ? r3.projMatrix : t2.transform.calculateProjMatrix(p4, f2), x2 = t2.terrain && _2 ? t2.terrain.stencilModeForRTTOverlap(r3) : d3[r3.overscaledZ], y2 = s4 ? 0 : o2.paint.get("raster-fade-duration");
            g2.registerFadeDuration(y2);
            const b3 = i2.findLoadedParent(r3, 0), w2 = Mi(g2, b3, i2, t2.transform, y2);
            let T3, E2;
            t2.terrain && t2.terrain.prepareDrawTile();
            const C3 = "nearest" === o2.paint.get("raster-resampling") ? l3.NEAREST : l3.LINEAR;
            a2.activeTexture.set(l3.TEXTURE0), g2.texture.bind(C3, l3.CLAMP_TO_EDGE), a2.activeTexture.set(l3.TEXTURE1), b3 ? (b3.texture.bind(C3, l3.CLAMP_TO_EDGE), T3 = Math.pow(2, b3.tileID.overscaledZ - g2.tileID.overscaledZ), E2 = [g2.tileID.canonical.x * T3 % 1, g2.tileID.canonical.y * T3 % 1]) : g2.texture.bind(C3, l3.CLAMP_TO_EDGE), g2.texture.useMipmap && a2.extTextureFilterAnisotropic && t2.transform.pitch > 20 && l3.texParameterf(l3.TEXTURE_2D, a2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a2.extTextureFilterAnisotropicMax);
            const M2 = Ji(v4, E2 || [0, 0], T3 || 1, w2, o2, c4 instanceof Pe ? c4.perspectiveTransform : [0, 0]);
            if (t2.prepareDrawProgram(a2, h3, p4), c4 instanceof Pe)
              c4.boundsBuffer && c4.boundsSegments && h3.draw(a2, l3.TRIANGLES, n4, e.StencilMode.disabled, u3, e.CullFaceMode.disabled, M2, o2.id, c4.boundsBuffer, t2.quadTriangleIndexBuffer, c4.boundsSegments);
            else {
              const { tileBoundsBuffer: i3, tileBoundsIndexBuffer: r4, tileBoundsSegments: s5 } = t2.getTileBoundsBuffers(g2);
              h3.draw(a2, l3.TRIANGLES, n4, x2, u3, e.CullFaceMode.disabled, M2, o2.id, i3, r4, s5);
            }
          }
          t2.resetStencilClippingMasks();
        }, background: function(t2, i2, o2, r2) {
          const n3 = o2.paint.get("background-color"), s4 = o2.paint.get("background-opacity");
          if (0 === s4)
            return;
          const a2 = t2.context, l3 = a2.gl, c4 = t2.transform, h3 = c4.tileSize, u3 = o2.paint.get("background-pattern");
          if (t2.isPatternMissing(u3))
            return;
          const _2 = !u3 && 1 === n3.a && 1 === s4 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (t2.renderPass !== _2)
            return;
          const d3 = e.StencilMode.disabled, p3 = t2.depthModeForSublayer(0, "opaque" === _2 ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly), m3 = t2.colorModeForRenderPass(), f2 = t2.useProgram(u3 ? "backgroundPattern" : "background");
          let g2, v4 = r2;
          v4 || (g2 = t2.getBackgroundTiles(), v4 = Object.values(g2).map((e2) => e2.tileID)), u3 && (a2.activeTexture.set(l3.TEXTURE0), t2.imageManager.bind(t2.context));
          for (const _3 of v4) {
            const v5 = _3.toUnwrapped(), x2 = r2 ? _3.projMatrix : t2.transform.calculateProjMatrix(v5);
            t2.prepareDrawTile();
            const y2 = i2 ? i2.getTile(_3) : g2 ? g2[_3.key] : new e.Tile(_3, h3, c4.zoom, t2), b3 = u3 ? no(x2, s4, t2, u3, { tileID: _3, tileSize: h3 }) : ro(x2, s4, n3);
            t2.prepareDrawProgram(a2, f2, v5);
            const { tileBoundsBuffer: w2, tileBoundsIndexBuffer: T3, tileBoundsSegments: E2 } = t2.getTileBoundsBuffers(y2);
            f2.draw(a2, l3.TRIANGLES, p3, d3, m3, e.CullFaceMode.disabled, b3, o2.id, w2, T3, E2);
          }
        }, sky: function(t2, i2, o2) {
          const r2 = t2.transform, n3 = "mercator" === r2.projection.name || "globe" === r2.projection.name ? 1 : e.smoothstep(7, 8, r2.zoom), s4 = o2.paint.get("sky-opacity") * n3;
          if (0 === s4)
            return;
          const a2 = t2.context, l3 = o2.paint.get("sky-type"), c4 = new e.DepthMode(a2.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), h3 = t2.frameCounter / 1e3 % 1;
          "atmosphere" === l3 ? "offscreen" === t2.renderPass ? o2.needsSkyboxCapture(t2) && (function(t3, i3, o3, r3) {
            const n4 = t3.context, s5 = n4.gl;
            let a3 = i3.skyboxFbo;
            if (!a3) {
              a3 = i3.skyboxFbo = n4.createFramebuffer(32, 32, false), i3.skyboxGeometry = new Lo(n4), i3.skyboxTexture = n4.gl.createTexture(), s5.bindTexture(s5.TEXTURE_CUBE_MAP, i3.skyboxTexture), s5.texParameteri(s5.TEXTURE_CUBE_MAP, s5.TEXTURE_WRAP_S, s5.CLAMP_TO_EDGE), s5.texParameteri(s5.TEXTURE_CUBE_MAP, s5.TEXTURE_WRAP_T, s5.CLAMP_TO_EDGE), s5.texParameteri(s5.TEXTURE_CUBE_MAP, s5.TEXTURE_MIN_FILTER, s5.LINEAR), s5.texParameteri(s5.TEXTURE_CUBE_MAP, s5.TEXTURE_MAG_FILTER, s5.LINEAR);
              for (let e2 = 0; e2 < 6; ++e2)
                s5.texImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + e2, 0, s5.RGBA, 32, 32, 0, s5.RGBA, s5.UNSIGNED_BYTE, null);
            }
            n4.bindFramebuffer.set(a3.framebuffer), n4.viewport.set([0, 0, 32, 32]);
            const l4 = i3.getCenter(t3, true), c5 = t3.useProgram("skyboxCapture"), h4 = new Float64Array(16);
            e.identity(h4), e.rotateY(h4, h4, 0.5 * -Math.PI), Ao(n4, i3, c5, h4, l4, 0), e.identity(h4), e.rotateY(h4, h4, 0.5 * Math.PI), Ao(n4, i3, c5, h4, l4, 1), e.identity(h4), e.rotateX(h4, h4, 0.5 * -Math.PI), Ao(n4, i3, c5, h4, l4, 2), e.identity(h4), e.rotateX(h4, h4, 0.5 * Math.PI), Ao(n4, i3, c5, h4, l4, 3), e.identity(h4), Ao(n4, i3, c5, h4, l4, 4), e.identity(h4), e.rotateY(h4, h4, Math.PI), Ao(n4, i3, c5, h4, l4, 5), n4.viewport.set([0, 0, t3.width, t3.height]);
          }(t2, o2), o2.markSkyboxValid(t2)) : "sky" === t2.renderPass && function(t3, i3, o3, r3, n4) {
            const s5 = t3.context, a3 = s5.gl, l4 = t3.transform, c5 = t3.useProgram("skybox");
            s5.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i3.skyboxTexture);
            const h4 = /* @__PURE__ */ ((e2, t4, i4, o4, r4) => ({ u_matrix: e2, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r4 }))(l4.skyboxMatrix, i3.getCenter(t3, false), 0, r3, n4);
            t3.prepareDrawProgram(s5, c5), c5.draw(s5, a3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, h4, "skybox", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
          }(t2, o2, c4, s4, h3) : "gradient" === l3 && "sky" === t2.renderPass && function(t3, i3, o3, r3, n4) {
            const s5 = t3.context, a3 = s5.gl, l4 = t3.transform, c5 = t3.useProgram("skyboxGradient");
            i3.skyboxGeometry || (i3.skyboxGeometry = new Lo(s5)), s5.activeTexture.set(a3.TEXTURE0);
            let h4 = i3.colorRampTexture;
            h4 || (h4 = i3.colorRampTexture = new e.Texture(s5, i3.colorRamp, a3.RGBA)), h4.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
            const u3 = ((t4, i4, o4, r4, n5) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e.degToRad(o4), u_opacity: r4, u_temporal_offset: n5 }))(l4.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), r3, n4);
            t3.prepareDrawProgram(s5, c5), c5.draw(s5, a3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, u3, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
          }(t2, o2, c4, s4, h3);
        }, debug: function(e2, t2, i2) {
          for (let o2 = 0; o2 < i2.length; o2++)
            Eo(e2, t2, i2[o2]);
        }, custom: function(t2, i2, o2, r2) {
          const n3 = t2.context, s4 = o2.implementation;
          if (!t2.transform.projection.unsupportedLayers || !t2.transform.projection.unsupportedLayers.includes("custom") || t2.terrain && (t2.terrain.renderingToTexture || "offscreen" === t2.renderPass) && o2.isLayerDraped()) {
            if ("offscreen" === t2.renderPass) {
              const i3 = s4.prerender;
              if (i3) {
                if (t2.setCustomLayerDefaults(), n3.setColorMode(t2.colorModeForRenderPass()), "globe" === t2.transform.projection.name) {
                  const o3 = t2.transform.pointMerc;
                  i3.call(s4, n3.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t2.transform.zoom), [o3.x, o3.y], t2.transform.pixelsPerMeterRatio);
                } else
                  i3.call(s4, n3.gl, t2.transform.customLayerMatrix());
                n3.setDirty(), t2.setBaseState();
              }
            } else if ("translucent" === t2.renderPass) {
              if (t2.terrain && t2.terrain.renderingToTexture) {
                const i4 = s4.renderToTile;
                if (i4) {
                  const o3 = r2[0].canonical, a2 = new e.MercatorCoordinate(o3.x + r2[0].wrap * (1 << o3.z), o3.y, o3.z);
                  n3.setDepthMode(e.DepthMode.disabled), n3.setStencilMode(e.StencilMode.disabled), n3.setColorMode(t2.colorModeForRenderPass()), t2.setCustomLayerDefaults(), i4.call(s4, n3.gl, a2), n3.setDirty(), t2.setBaseState();
                }
                return;
              }
              t2.setCustomLayerDefaults(), n3.setColorMode(t2.colorModeForRenderPass()), n3.setStencilMode(e.StencilMode.disabled);
              const i3 = "3d" === s4.renderingMode ? new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, e.DepthMode.ReadOnly);
              if (n3.setDepthMode(i3), "globe" === t2.transform.projection.name) {
                const i4 = t2.transform.pointMerc;
                s4.render(n3.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t2.transform.zoom), [i4.x, i4.y], t2.transform.pixelsPerMeterRatio);
              } else
                s4.render(n3.gl, t2.transform.customLayerMatrix());
              n3.setDirty(), t2.setBaseState(), n3.bindFramebuffer.set(null);
            }
          } else
            e.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
        } };
        class Bo {
          constructor(t2, i2, o2 = false) {
            this.context = new Ee(t2, o2), this.transform = i2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
          }
          updateTerrain(e2, t2) {
            const i2 = !!e2 && !!e2.terrain && this.transform.projection.supportsTerrain;
            if (!(i2 || this._terrain && this._terrain.enabled))
              return;
            this._terrain || (this._terrain = new Di(this, e2));
            const o2 = this._terrain;
            this.transform.elevation = i2 ? o2 : null, o2.update(e2, this.transform, t2);
          }
          _updateFog(e2) {
            const t2 = e2.fog;
            if (!t2 || "globe" === this.transform.projection.name || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03)
              return void (this.transform.fogCullDistSq = null);
            const [i2, o2] = t2.getFovAdjustedRange(this.transform._fov);
            if (i2 > o2)
              return void (this.transform.fogCullDistSq = null);
            const r2 = i2 + 0.78 * (o2 - i2);
            this.transform.fogCullDistSq = r2 * r2;
          }
          get terrain() {
            return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
          }
          resize(t2, i2) {
            if (this.width = t2 * e.exported.devicePixelRatio, this.height = i2 * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const e2 of this.style.order)
                this.style._layers[e2].resize();
          }
          setup() {
            const t2 = this.context, i2 = new e.StructArrayLayout2i4();
            i2.emplaceBack(0, 0), i2.emplaceBack(e.EXTENT, 0), i2.emplaceBack(0, e.EXTENT), i2.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t2.createVertexBuffer(i2, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            const o2 = new e.StructArrayLayout2i4();
            o2.emplaceBack(0, 0), o2.emplaceBack(e.EXTENT, 0), o2.emplaceBack(0, e.EXTENT), o2.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t2.createVertexBuffer(o2, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);
            const r2 = new e.StructArrayLayout2i4();
            r2.emplaceBack(-1, -1), r2.emplaceBack(1, -1), r2.emplaceBack(-1, 1), r2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(r2, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            const n3 = new e.StructArrayLayout4i8();
            n3.emplaceBack(0, 0, 0, 0), n3.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n3.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n3.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t2.createVertexBuffer(n3, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
            const s4 = new e.StructArrayLayout3ui6();
            s4.emplaceBack(0, 1, 2), s4.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(s4);
            const a2 = new e.StructArrayLayout1ui2();
            for (const e2 of [0, 1, 3, 2, 0])
              a2.emplaceBack(e2);
            this.debugIndexBuffer = t2.createIndexBuffer(a2), this.emptyTexture = new e.Texture(t2, new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t2.gl.RGBA), this.identityMat = e.create();
            const l3 = this.context.gl;
            this.stencilClearMode = new e.StencilMode({ func: l3.ALWAYS, mask: 0 }, 0, 255, l3.ZERO, l3.ZERO, l3.ZERO), this.loadTimeStamps.push(e.window.performance.now()), this.atmosphereBuffer = new Ro(this.context);
          }
          getMercatorTileBoundsBuffers() {
            return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
          }
          getTileBoundsBuffers(e2) {
            return e2._makeTileBoundsBuffers(this.context, this.transform.projection), e2._tileBoundsBuffer ? { tileBoundsBuffer: e2._tileBoundsBuffer, tileBoundsIndexBuffer: e2._tileBoundsIndexBuffer, tileBoundsSegments: e2._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
          }
          clearStencil() {
            const t2 = this.context, i2 = t2.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t2, i2.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, Ci(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          resetStencilClippingMasks() {
            this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
          }
          _renderTileClippingMasks(t2, i2, o2) {
            if (!i2 || this.currentStencilSource === i2.id || !t2.isTileClipped() || !o2 || 0 === o2.length)
              return;
            if (this._tileClippingMaskIDs && !this.terrain) {
              let e2 = false;
              for (const t3 of o2)
                if (void 0 === this._tileClippingMaskIDs[t3.key]) {
                  e2 = true;
                  break;
                }
              if (!e2)
                return;
            }
            this.currentStencilSource = i2.id;
            const r2 = this.context, n3 = r2.gl;
            this.nextStencilID + o2.length > 256 && this.clearStencil(), r2.setColorMode(e.ColorMode.disabled), r2.setDepthMode(e.DepthMode.disabled);
            const s4 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t3 of o2) {
              const o3 = i2.getTile(t3), a2 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, { tileBoundsBuffer: l3, tileBoundsIndexBuffer: c4, tileBoundsSegments: h3 } = this.getTileBoundsBuffers(o3);
              s4.draw(r2, n3.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n3.ALWAYS, mask: 0 }, a2, 255, n3.KEEP, n3.KEEP, n3.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ci(t3.projMatrix), "$clipping", l3, c4, h3);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t2 = this.nextStencilID++, i2 = this.context.gl;
            return new e.StencilMode({ func: i2.NOTEQUAL, mask: 255 }, t2, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
          }
          stencilModeForClipping(t2) {
            if (this.terrain)
              return this.terrain.stencilModeForRTTOverlap(t2);
            const i2 = this.context.gl;
            return new e.StencilMode({ func: i2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, i2.KEEP, i2.KEEP, i2.REPLACE);
          }
          stencilConfigForOverlap(t2) {
            const i2 = this.context.gl, o2 = t2.sort((e2, t3) => t3.overscaledZ - e2.overscaledZ), r2 = o2[o2.length - 1].overscaledZ, n3 = o2[0].overscaledZ - r2 + 1;
            if (n3 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + n3 > 256 && this.clearStencil();
              const t3 = {};
              for (let o3 = 0; o3 < n3; o3++)
                t3[o3 + r2] = new e.StencilMode({ func: i2.GEQUAL, mask: 255 }, o3 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
              return this.nextStencilID += n3, [t3, o2];
            }
            return [{ [r2]: e.StencilMode.disabled }, o2];
          }
          colorModeForRenderPass() {
            const t2 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i2 = 1 / 8;
              return new e.ColorMode([t2.CONSTANT_COLOR, t2.ONE], new e.Color(i2, i2, i2, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended;
          }
          depthModeForSublayer(t2, i2, o2) {
            if (!this.opaquePassEnabledForLayer())
              return e.DepthMode.disabled;
            const r2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
            return new e.DepthMode(o2 || this.context.gl.LEQUAL, i2, [r2, r2]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t2, i2) {
            this.style = t2, this.options = i2, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();
            const o2 = this.style.order, r2 = this.style._sourceCaches;
            for (const e2 in r2) {
              const t3 = r2[e2];
              t3.used && t3.prepare(this.context);
            }
            const n3 = {}, s4 = {}, a2 = {};
            for (const e2 in r2) {
              const t3 = r2[e2];
              n3[e2] = t3.getVisibleCoordinates(), s4[e2] = n3[e2].slice().reverse(), a2[e2] = t3.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e2 = 0; e2 < o2.length; e2++)
              if (this.style._layers[o2[e2]].is3D()) {
                this.opaquePassCutoff = e2;
                break;
              }
            if (this.terrain && (this.terrain.updateTileBinding(a2), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), !e.isMapAuthenticated(this.context.gl))
              return;
            this.renderPass = "offscreen";
            for (const e2 of o2) {
              const i3 = this.style._layers[e2], o3 = t2._getLayerSourceCache(i3);
              if (!i3.hasOffscreenPass() || i3.isHidden(this.transform.zoom))
                continue;
              const r3 = o3 ? s4[o3.id] : void 0;
              ("custom" === i3.type || i3.isSky() || r3 && r3.length) && this.renderLayer(this, o3, i3, r3);
            }
            this.depthRangeFor3D = [0, 1 - (t2.order.length + 2) * this.numSublayers * this.depthEpsilon];
            const l3 = this.terrain;
            if (l3 && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && l3.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: i2.showOverdrawInspector ? e.Color.black : e.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", !this.terrain)
              for (this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
                if (e2.isSky())
                  continue;
                const r3 = i3 ? s4[i3.id] : void 0;
                this._renderTileClippingMasks(e2, i3, r3), this.renderLayer(this, i3, e2, r3);
              }
            if (this.style.fog && this.transform.projection.supportsFog && function(t3, i3) {
              const o3 = t3.context, r3 = o3.gl, n4 = t3.transform, s5 = new e.DepthMode(r3.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), a3 = t3.useProgram("globeAtmosphere", null, "globe" === n4.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]), l4 = e.globeToMercatorTransition(n4.zoom), c4 = i3.properties.get("color").toArray01(), h3 = i3.properties.get("high-color").toArray01(), u3 = i3.properties.get("space-color").toArray01PremultipliedAlpha(), _2 = e.identity$1([]);
              e.rotateY$1(_2, _2, -e.degToRad(n4._center.lng)), e.rotateX$1(_2, _2, e.degToRad(n4._center.lat)), e.rotateZ$1(_2, _2, n4.angle), e.rotateX$1(_2, _2, -n4._pitch);
              const d3 = e.fromQuat(new Float32Array(16), _2), p3 = e.mapValue(i3.properties.get("star-intensity"), 0, 1, 0, 0.25), m3 = 5e-4, f2 = e.mapValue(i3.properties.get("horizon-blend"), 0, 1, m3, 0.25), g2 = e.globeUseCustomAntiAliasing(t3, o3, n4) && f2 === m3 ? n4.worldSize / (2 * Math.PI * 1.025) - 1 : n4.globeRadius, v4 = t3.frameCounter / 1e3 % 1, x2 = e.length(n4.globeCenterInViewSpace), y2 = Math.sqrt(Math.pow(x2, 2) - Math.pow(g2, 2)), b3 = Math.acos(y2 / x2), w2 = ((t4, i4, o4, r4, n5, s6, a4, l5, c5, h4, u4, _3, d4, p4) => ({ u_frustum_tl: t4, u_frustum_tr: i4, u_frustum_br: o4, u_frustum_bl: r4, u_horizon: n5, u_transition: s6, u_fadeout_range: a4, u_color: l5, u_high_color: c5, u_space_color: h4, u_star_intensity: u4, u_star_size: 5 * e.exported.devicePixelRatio, u_star_density: 0, u_temporal_offset: _3, u_horizon_angle: d4, u_rotation_matrix: p4 }))(n4.frustumCorners.TL, n4.frustumCorners.TR, n4.frustumCorners.BR, n4.frustumCorners.BL, n4.frustumCorners.horizon, l4, f2, c4, h3, u3, p3, v4, b3, d3);
              t3.prepareDrawProgram(o3, a3);
              const T3 = t3.atmosphereBuffer;
              T3 && a3.draw(o3, r3.TRIANGLES, s5, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, w2, "skybox", T3.vertexBuffer, T3.indexBuffer, T3.segments);
            }(this, this.style.fog), this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible())
              for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
                const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
                e2.isSky() && this.renderLayer(this, i3, e2, i3 ? s4[i3.id] : void 0);
              }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; ) {
              const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
              if (e2.isSky()) {
                ++this.currentLayer;
                continue;
              }
              if (this.terrain && this.style.isLayerDraped(e2)) {
                if (e2.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                continue;
              }
              const r3 = i3 ? ("symbol" === e2.type ? a2 : s4)[i3.id] : void 0;
              this._renderTileClippingMasks(e2, i3, i3 ? n3[i3.id] : void 0), this.renderLayer(this, i3, e2, r3), ++this.currentLayer;
            }
            if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let i3 = null;
              e.values(this.style._layers).forEach((e2) => {
                const o3 = t2._getLayerSourceCache(e2);
                o3 && !e2.isHidden(this.transform.zoom) && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
              }), i3 && this.options.showTileBoundaries && Oo.debug(this, i3, i3.getVisibleCoordinates());
            }
            this.options.showPadding && function(e2) {
              const t3 = e2.transform.padding;
              Co(e2, e2.transform.height - (t3.top || 0), 3, xo), Co(e2, t3.bottom || 0, 3, yo), Mo(e2, t3.left || 0, 3, bo), Mo(e2, e2.transform.width - (t3.right || 0), 3, wo);
              const i3 = e2.transform.centerPoint;
              !function(e3, t4, i4, o3) {
                Io(e3, t4 - 1, i4 - 10, 2, 20, o3), Io(e3, t4 - 10, i4 - 1, 20, 2, o3);
              }(e2, i3.x, e2.transform.height - i3.y, To);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());
          }
          renderLayer(e2, t2, i2, o2) {
            i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), (!e2.transform.projection.unsupportedLayers || !e2.transform.projection.unsupportedLayers.includes(i2.type) || e2.terrain && "custom" === i2.type) && Oo[i2.type](e2, t2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
          }
          gpuTimingStart(e2) {
            if (!this.options.gpuTiming)
              return;
            const t2 = this.context.extTimerQuery;
            let i2 = this.gpuTimers[e2.id];
            i2 || (i2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: t2.createQueryEXT() }), i2.calls++, t2.beginQueryEXT(t2.TIME_ELAPSED_EXT, i2.query);
          }
          gpuTimingDeferredRenderStart() {
            if (this.options.gpuTimingDeferredRender) {
              const e2 = this.context.extTimerQuery, t2 = e2.createQueryEXT();
              this.deferredRenderGpuTimeQueries.push(t2), e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, t2);
            }
          }
          gpuTimingDeferredRenderEnd() {
            if (!this.options.gpuTimingDeferredRender)
              return;
            const e2 = this.context.extTimerQuery;
            e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
          }
          gpuTimingEnd() {
            if (!this.options.gpuTiming)
              return;
            const e2 = this.context.extTimerQuery;
            e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const e2 = this.gpuTimers;
            return this.gpuTimers = {}, e2;
          }
          collectDeferredRenderGpuQueries() {
            const e2 = this.deferredRenderGpuTimeQueries;
            return this.deferredRenderGpuTimeQueries = [], e2;
          }
          queryGpuTimers(e2) {
            const t2 = {};
            for (const i2 in e2) {
              const o2 = e2[i2], r2 = this.context.extTimerQuery, n3 = r2.getQueryObjectEXT(o2.query, r2.QUERY_RESULT_EXT) / 1e6;
              r2.deleteQueryEXT(o2.query), t2[i2] = n3;
            }
            return t2;
          }
          queryGpuTimeDeferredRender(e2) {
            if (!this.options.gpuTimingDeferredRender)
              return 0;
            const t2 = this.context.extTimerQuery;
            let i2 = 0;
            for (const o2 of e2)
              i2 += t2.getQueryObjectEXT(o2, t2.QUERY_RESULT_EXT) / 1e6, t2.deleteQueryEXT(o2);
            return i2;
          }
          translatePosMatrix(t2, i2, o2, r2, n3) {
            if (!o2[0] && !o2[1])
              return t2;
            const s4 = n3 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
            if (s4) {
              const e2 = Math.sin(s4), t3 = Math.cos(s4);
              o2 = [o2[0] * t3 - o2[1] * e2, o2[0] * e2 + o2[1] * t3];
            }
            const a2 = [n3 ? o2[0] : D(i2, o2[0], this.transform.zoom), n3 ? o2[1] : D(i2, o2[1], this.transform.zoom), 0], l3 = new Float32Array(16);
            return e.translate(l3, t2, a2), l3;
          }
          saveTileTexture(e2) {
            const t2 = this._tileTextures[e2.size[0]];
            t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
          }
          getTileTexture(e2) {
            const t2 = this._tileTextures[e2];
            return t2 && t2.length > 0 ? t2.pop() : null;
          }
          isPatternMissing(e2) {
            return null === e2 || void 0 !== e2 && !this.imageManager.getPattern(e2.toString());
          }
          terrainRenderModeElevated() {
            return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
          }
          currentGlobalDefines() {
            const e2 = this.terrain && this.terrain.renderingToTexture, t2 = this.terrain && 0 === this.terrain.exaggeration(), i2 = this.style && this.style.fog, o2 = [];
            return this.terrainRenderModeElevated() && o2.push("TERRAIN"), "globe" === this.transform.projection.name && o2.push("GLOBE"), t2 && o2.push("ZERO_EXAGGERATION"), i2 && !e2 && 0 !== i2.getOpacity(this.transform.pitch) && o2.push("FOG"), e2 && o2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o2.push("OVERDRAW_INSPECTOR"), o2;
          }
          useProgram(e2, t2, i2) {
            this.cache = this.cache || {};
            const o2 = i2 || [], r2 = this.currentGlobalDefines().concat(o2), n3 = Li.cacheKey(ci[e2], e2, r2, t2);
            return this.cache[n3] || (this.cache[n3] = new Li(this.context, e2, ci[e2], t2, so[e2], r2)), this.cache[n3];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e2 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
          }
          prepareDrawTile() {
            this.terrain && this.terrain.prepareDrawTile();
          }
          prepareDrawProgram(t2, i2, o2) {
            if (this.terrain && this.terrain.renderingToTexture)
              return;
            const r2 = this.style.fog;
            if (r2) {
              const n3 = r2.getOpacity(this.transform.pitch), s4 = ((t3, i3, o3, r3, n4, s5, a2, l3, c4, h3, u3) => {
                const _2 = t3.transform, d3 = i3.properties.get("color").toArray01();
                d3[3] = r3;
                const p3 = t3.frameCounter / 1e3 % 1;
                return { u_fog_matrix: o3 ? _2.calculateFogTileMatrix(o3) : t3.identityMat, u_fog_range: i3.getFovAdjustedRange(_2._fov), u_fog_color: d3, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_temporal_offset: p3, u_frustum_tl: n4, u_frustum_tr: s5, u_frustum_br: a2, u_frustum_bl: l3, u_globe_pos: c4, u_globe_radius: h3, u_viewport: u3, u_globe_transition: e.globeToMercatorTransition(_2.zoom), u_is_globe: +("globe" === _2.projection.name) };
              })(this, r2, o2, n3, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.exported.devicePixelRatio, this.transform.height * e.exported.devicePixelRatio]);
              i2.setFogUniformValues(t2, s4);
            }
          }
          setTileLoadedFlag(e2) {
            this.tileLoaded = e2;
          }
          saveCanvasCopy() {
            const e2 = this.canvasCopy();
            e2 && (this.frameCopies.push(e2), this.tileLoaded = false);
          }
          canvasCopy() {
            const e2 = this.context.gl, t2 = e2.createTexture();
            return e2.bindTexture(e2.TEXTURE_2D, t2), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t2;
          }
          getCanvasCopiesAndTimestamps() {
            return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
          }
          averageElevationNeedsEasing() {
            if (!this.transform._elevation)
              return false;
            const e2 = this.style && this.style.fog;
            return !!e2 && 0 !== e2.getOpacity(this.transform.pitch);
          }
          getBackgroundTiles() {
            const t2 = this._backgroundTiles, i2 = this._backgroundTiles = {}, o2 = this.transform.coveringTiles({ tileSize: 512 });
            for (const r2 of o2)
              i2[r2.key] = t2[r2.key] || new e.Tile(r2, 512, this.transform.tileZoom, this);
            return i2;
          }
          clearBackgroundTiles() {
            this._backgroundTiles = {};
          }
        }
        class ko {
          constructor(e2 = 0, t2 = 0, i2 = 0, o2 = 0) {
            if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e2, this.bottom = t2, this.left = i2, this.right = o2;
          }
          interpolate(t2, i2, o2) {
            return null != i2.top && null != t2.top && (this.top = e.number(t2.top, i2.top, o2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.number(t2.bottom, i2.bottom, o2)), null != i2.left && null != t2.left && (this.left = e.number(t2.left, i2.left, o2)), null != i2.right && null != t2.right && (this.right = e.number(t2.right, i2.right, o2)), this;
          }
          getCenter(t2, i2) {
            const o2 = e.clamp((this.left + t2 - this.right) / 2, 0, t2), r2 = e.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
            return new e.Point(o2, r2);
          }
          equals(e2) {
            return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
          }
          clone() {
            return new ko(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Fo(t2, i2) {
          const o2 = e.getColumn(t2, 3);
          e.fromQuat(t2, i2), e.setColumn(t2, 3, o2);
        }
        function Uo(t2, i2) {
          const o2 = e.identity$1([]);
          return e.rotateZ$1(o2, o2, -i2), e.rotateX$1(o2, o2, -t2), o2;
        }
        function No(t2, i2) {
          const o2 = [t2[0], t2[1], 0], r2 = [i2[0], i2[1], 0];
          if (e.length(o2) >= 1e-15) {
            const t3 = e.normalize([], o2);
            e.scale$2(r2, t3, e.dot(r2, t3)), i2[0] = r2[0], i2[1] = r2[1];
          }
          const n3 = e.cross([], i2, t2);
          if (e.len(n3) < 1e-15)
            return null;
          const s4 = Math.atan2(-n3[1], n3[0]);
          return Uo(Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]), s4);
        }
        class jo {
          constructor(e2, t2) {
            this.position = e2, this.orientation = t2;
          }
          get position() {
            return this._position;
          }
          set position(t2) {
            if (t2) {
              const i2 = t2 instanceof e.MercatorCoordinate ? t2 : new e.MercatorCoordinate(t2[0], t2[1], t2[2]);
              this._renderWorldCopies && (i2.x = e.wrap(i2.x, 0, 1)), this._position = i2;
            } else
              this._position = null;
          }
          lookAtPoint(t2, i2) {
            if (this.orientation = null, !this.position)
              return;
            const o2 = this.position, r2 = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t2)) : 0, n3 = e.MercatorCoordinate.fromLngLat(t2, r2), s4 = [n3.x - o2.x, n3.y - o2.y, n3.z - o2.z];
            i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = No(s4, i2);
          }
          setPitchBearing(t2, i2) {
            this.orientation = Uo(e.degToRad(t2), e.degToRad(-i2));
          }
        }
        class Go {
          constructor(t2, i2) {
            this._transform = e.identity([]), this.orientation = i2, this.position = t2;
          }
          get mercatorPosition() {
            const t2 = this.position;
            return new e.MercatorCoordinate(t2[0], t2[1], t2[2]);
          }
          get position() {
            const t2 = e.getColumn(this._transform, 3);
            return [t2[0], t2[1], t2[2]];
          }
          set position(t2) {
            var i2;
            t2 && e.setColumn(this._transform, 3, [(i2 = t2)[0], i2[1], i2[2], 1]);
          }
          get orientation() {
            return this._orientation;
          }
          set orientation(t2) {
            this._orientation = t2 || e.identity$1([]), t2 && Fo(this._transform, this._orientation);
          }
          getPitchBearing() {
            const e2 = this.forward(), t2 = this.right();
            return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
          }
          setPitchBearing(e2, t2) {
            this._orientation = Uo(e2, t2), Fo(this._transform, this._orientation);
          }
          forward() {
            const t2 = e.getColumn(this._transform, 2);
            return [-t2[0], -t2[1], -t2[2]];
          }
          up() {
            const t2 = e.getColumn(this._transform, 1);
            return [-t2[0], -t2[1], -t2[2]];
          }
          right() {
            const t2 = e.getColumn(this._transform, 0);
            return [t2[0], t2[1], t2[2]];
          }
          getCameraToWorld(t2, i2) {
            const o2 = new Float64Array(16);
            return e.invert(o2, this.getWorldToCamera(t2, i2)), o2;
          }
          getWorldToCameraPosition(t2, i2, o2) {
            const r2 = this.position;
            e.scale$2(r2, r2, -t2);
            const n3 = new Float64Array(16);
            return e.fromScaling(n3, [o2, o2, o2]), e.translate(n3, n3, r2), n3[10] *= i2, n3;
          }
          getWorldToCamera(t2, i2) {
            const o2 = new Float64Array(16), r2 = new Float64Array(4), n3 = this.position;
            return e.conjugate(r2, this._orientation), e.scale$2(n3, n3, -t2), e.fromQuat(o2, r2), e.translate(o2, o2, n3), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
          }
          getCameraToClipPerspective(t2, i2, o2, r2) {
            const n3 = new Float64Array(16);
            return e.perspective(n3, t2, i2, o2, r2), n3;
          }
          getDistanceToElevation(t2, i2 = false) {
            const o2 = 0 === t2 ? 0 : e.mercatorZfromAltitude(t2, i2 ? e.latFromMercatorY(this.position[1]) : this.position[1]), r2 = this.forward();
            return (o2 - this.position[2]) / r2[2];
          }
          clone() {
            return new Go([...this.position], [...this.orientation]);
          }
        }
        function Zo(t2, i2) {
          const o2 = Wo(t2.projection, t2.zoom, t2.width, t2.height), r2 = function(t3, i3, o3, r3, n4) {
            const s4 = new e.LngLat(o3.lng - 180 * Xo, o3.lat), a2 = new e.LngLat(o3.lng + 180 * Xo, o3.lat), l3 = t3.project(s4.lng, s4.lat), c4 = t3.project(a2.lng, a2.lat), h3 = -Math.atan2(c4.y - l3.y, c4.x - l3.x), u3 = e.MercatorCoordinate.fromLngLat(o3);
            u3.y = e.clamp(u3.y, -1 + Xo, 1 - Xo);
            const _2 = u3.toLngLat(), d3 = t3.project(_2.lng, _2.lat), p3 = e.MercatorCoordinate.fromLngLat(_2);
            p3.x += Xo;
            const m3 = p3.toLngLat(), f2 = t3.project(m3.lng, m3.lat), g2 = $o(f2.x - d3.x, f2.y - d3.y, h3), v4 = e.MercatorCoordinate.fromLngLat(_2);
            v4.y += Xo;
            const x2 = v4.toLngLat(), y2 = t3.project(x2.lng, x2.lat), b3 = $o(y2.x - d3.x, y2.y - d3.y, h3), w2 = Math.abs(g2.x) / Math.abs(b3.y), T3 = e.identity([]);
            e.rotateZ(T3, T3, -h3 * (1 - (n4 ? 0 : r3)));
            const E2 = e.identity([]);
            return e.scale(E2, E2, [1, 1 - (1 - w2) * r3, 1]), E2[4] = -b3.x / b3.y * r3, e.rotateZ(E2, E2, h3), e.multiply(E2, T3, E2), E2;
          }(t2.projection, 0, t2.center, o2, i2), n3 = Vo(t2);
          return e.scale(r2, r2, [n3, n3, 1]), r2;
        }
        function Vo(t2) {
          const i2 = t2.projection, o2 = Wo(t2.projection, t2.zoom, t2.width, t2.height), r2 = qo(i2, t2.center), n3 = qo(i2, e.LngLat.convert(i2.center));
          return Math.pow(2, r2 * o2 + (1 - o2) * n3);
        }
        function Wo(t2, i2, o2, r2, n3 = 1 / 0) {
          const s4 = t2.range;
          if (!s4)
            return 0;
          const a2 = Math.min(n3, Math.max(o2, r2)), l3 = Math.log(a2 / 1024) / Math.LN2;
          return e.smoothstep(s4[0] + l3, s4[1] + l3, i2);
        }
        const Xo = 1 / 4e4;
        function qo(t2, i2) {
          const o2 = e.clamp(i2.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), r2 = new e.LngLat(i2.lng - 180 * Xo, o2), n3 = new e.LngLat(i2.lng + 180 * Xo, o2), s4 = t2.project(r2.lng, o2), a2 = t2.project(n3.lng, o2), l3 = e.MercatorCoordinate.fromLngLat(r2), c4 = e.MercatorCoordinate.fromLngLat(n3), h3 = a2.x - s4.x, u3 = a2.y - s4.y, _2 = c4.x - l3.x, d3 = c4.y - l3.y, p3 = Math.sqrt((_2 * _2 + d3 * d3) / (h3 * h3 + u3 * u3));
          return Math.log(p3) / Math.LN2;
        }
        function $o(e2, t2, i2) {
          const o2 = Math.cos(i2), r2 = Math.sin(i2);
          return { x: e2 * o2 - t2 * r2, y: e2 * r2 + t2 * o2 };
        }
        class Ho {
          constructor(t2, i2, o2, r2, n3, s4, a2) {
            this.tileSize = 512, this._renderWorldCopies = void 0 === n3 || n3, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == r2 ? 60 : r2, this.setProjection(s4), this.setMaxBounds(a2), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new ko(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Go(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1;
          }
          clone() {
            const e2 = new Ho(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
            return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e2.tileSize = this.tileSize, e2.mercatorFromTransition = this.mercatorFromTransition, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._seaLevelZoom = this._seaLevelZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._nearZ = this._nearZ, e2._farZ = this._farZ, e2._averageElevation = this._averageElevation, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2.frustumCorners = this.frustumCorners, e2;
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(e2) {
            this._elevation !== e2 && (this._elevation = e2, this._updateCameraOnTerrain(), this._calcMatrices());
          }
          updateElevation(e2, t2 = false) {
            const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
            (null == this._seaLevelZoom || i2) && this._updateCameraOnTerrain(), (e2 || i2) && this._constrainCamera(t2), this._calcMatrices();
          }
          getProjection() {
            return e.pick(this.projection, ["name", "center", "parallels"]);
          }
          setProjection(i2) {
            this.projectionOptions = i2 || { name: "mercator" };
            const o2 = this.projection ? this.getProjection() : void 0;
            this.projection = e.getProjection(this.projectionOptions);
            const r2 = !t(o2, this.getProjection());
            return r2 && this._calcMatrices(), this.mercatorFromTransition = false, r2;
          }
          setMercatorFromTransition() {
            const t2 = this.projection.name;
            this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e.getProjection({ name: "mercator" });
            const i2 = t2 !== this.projection.name;
            return i2 && this._calcMatrices(), i2;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(e2) {
            this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(e2) {
            this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(e2) {
            this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(e2) {
            this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
          }
          set renderWorldCopies(e2) {
            void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get cameraWorldSizeForFog() {
            const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
          }
          get cameraWorldSize() {
            const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
          }
          get pixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
          }
          get cameraPixelsPerMeter() {
            return e.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e.Point(this.width, this.height);
          }
          get bearing() {
            return e.wrap(this.rotation, -180, 180);
          }
          set bearing(e2) {
            this.rotation = e2;
          }
          get rotation() {
            return -this.angle / Math.PI * 180;
          }
          set rotation(t2) {
            const i2 = -t2 * Math.PI / 180;
            var o2;
            this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = (o2 = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(e2, t3, i3) {
              var o3 = t3[0], r2 = t3[1], n3 = t3[2], s4 = t3[3], a2 = Math.sin(i3), l3 = Math.cos(i3);
              e2[0] = o3 * l3 + n3 * a2, e2[1] = r2 * l3 + s4 * a2, e2[2] = o3 * -a2 + n3 * l3, e2[3] = r2 * -a2 + s4 * l3;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t2) {
            const i2 = e.clamp(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
          }
          get aspect() {
            return this.width / this.height;
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          get fovX() {
            return this._fov;
          }
          get fovY() {
            const e2 = 1 / Math.tan(0.5 * this.fovX);
            return 2 * Math.atan(1 / this.aspect / e2);
          }
          set fov(t2) {
            t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = e.degToRad(t2), this._calcMatrices());
          }
          get averageElevation() {
            return this._averageElevation;
          }
          set averageElevation(e2) {
            this._averageElevation = e2, this._calcFogMatrices(), this._distanceTileDataCache = {};
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(e2) {
            const t2 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
            this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
          }
          _setZoom(e2) {
            this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
          }
          _updateCameraOnTerrain() {
            if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
              return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
            const e2 = this._elevation;
            this._centerAltitude = e2.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e2.exaggeration(), this._updateSeaLevelZoom();
          }
          _updateSeaLevelZoom() {
            void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
          }
          sampleAverageElevation() {
            if (!this._elevation)
              return 0;
            const t2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
            let r2 = 0, n3 = 0;
            for (let s4 = 0; s4 < i2.length; s4++) {
              const a2 = new e.Point(i2[s4][0] * this.width, o2 + i2[s4][1] * (this.height - o2)), l3 = t2.pointCoordinate(a2);
              if (!l3)
                continue;
              const c4 = 1 / Math.hypot(l3[0] - this._camera.position[0], l3[1] - this._camera.position[1]);
              r2 += l3[3] * c4, n3 += c4;
            }
            return 0 === n3 ? NaN : r2 / n3;
          }
          get center() {
            return this._center;
          }
          set center(e2) {
            e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
          }
          _updateZoomFromElevation() {
            if (null == this._seaLevelZoom || !this._elevation)
              return;
            const e2 = this._seaLevelZoom, t2 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t2, o2 = this._mercatorZfromZoom(e2), r2 = this._mercatorZfromZoom(this._maxZoom), n3 = Math.max(o2 - i2, r2);
            this._setZoom(this._zoomFromMercatorZ(n3));
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(e2) {
            this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
          }
          computeZoomRelativeTo(t2) {
            const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t2.toAltitude()));
            let o2;
            o2 = t2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t2.x, t2.y, t2.z];
            const r2 = e.length(e.sub([], this._camera.position, o2));
            return e.clamp(this._zoomFromMercatorZ(r2), this._minZoom, this._maxZoom);
          }
          setFreeCameraOptions(t2) {
            if (!this.height)
              return;
            if (!t2.position && !t2.orientation)
              return;
            this._updateCameraState();
            let i2 = false;
            if (t2.orientation && !e.exactEquals(t2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t2.orientation)), t2.position) {
              const o2 = [t2.position.x, t2.position.y, t2.position.z];
              e.exactEquals$1(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
            }
            i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
          }
          getFreeCameraOptions() {
            this._updateCameraState();
            const t2 = this._camera.position, i2 = new jo();
            return i2.position = new e.MercatorCoordinate(t2[0], t2[1], t2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
          }
          _setCameraOrientation(t2) {
            if (!e.length$1(t2))
              return false;
            e.normalize$1(t2, t2);
            const i2 = e.transformQuat([], [0, 0, -1], t2), o2 = e.transformQuat([], [0, -1, 0], t2);
            if (o2[2] < 0)
              return false;
            const r2 = No(i2, o2);
            return !!r2 && (this._camera.orientation = r2, true);
          }
          _setCameraPosition(t2) {
            const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r2 = this.cameraToCenterDistance;
            t2[2] = e.clamp(t2[2], r2 / o2, r2 / i2), this._camera.position = t2;
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          get fovAboveCenter() {
            return this._fov * (0.5 + this.centerOffset.y / this.height);
          }
          isPaddingEqual(e2) {
            return this._edgeInsets.equals(e2);
          }
          interpolatePadding(e2, t2, i2) {
            this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(e2) {
            const t2 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
            return Math.max(0, t2);
          }
          getVisibleUnwrappedCoordinates(t2) {
            const i2 = [new e.UnwrappedTileID(0, t2)];
            if (this.renderWorldCopies) {
              const o2 = this.pointCoordinate(new e.Point(0, 0)), r2 = this.pointCoordinate(new e.Point(this.width, 0)), n3 = this.pointCoordinate(new e.Point(this.width, this.height)), s4 = this.pointCoordinate(new e.Point(0, this.height)), a2 = Math.floor(Math.min(o2.x, r2.x, n3.x, s4.x)), l3 = Math.floor(Math.max(o2.x, r2.x, n3.x, s4.x)), c4 = 1;
              for (let o3 = a2 - c4; o3 <= l3 + c4; o3++)
                0 !== o3 && i2.push(new e.UnwrappedTileID(o3, t2));
            }
            return i2;
          }
          coveringTiles(t2) {
            let i2 = this.coveringZoomLevel(t2);
            const o2 = i2, r2 = this.elevation && !t2.isTerrainDEM, n3 = "mercator" === this.projection.name;
            if (void 0 !== t2.minzoom && i2 < t2.minzoom)
              return [];
            void 0 !== t2.maxzoom && i2 > t2.maxzoom && (i2 = t2.maxzoom);
            const s4 = this.locationCoordinate(this.center), a2 = this.center.lat, l3 = 1 << i2, c4 = [l3 * s4.x, l3 * s4.y, 0], h3 = "globe" === this.projection.name, u3 = !h3, _2 = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, u3), d3 = h3 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), p3 = l3 * e.mercatorZfromAltitude(1, this.center.lat), m3 = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat), f2 = [l3 * d3.x, l3 * d3.y, m3 * (u3 ? 1 : p3)], g2 = this.cameraToCenterDistance / t2.tileSize * (t2.roundZoom ? 1 : 0.502), v4 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i2 : 0, x2 = t2.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, y2 = t2.isTerrainDEM ? -x2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b3 = this.projection.isReprojectedInTileSpace ? Vo(this) : 1, w2 = (t3) => {
              const i3 = 1 / 4e4, o3 = new e.MercatorCoordinate(t3.x + i3, t3.y, t3.z), r3 = new e.MercatorCoordinate(t3.x, t3.y + i3, t3.z), n4 = t3.toLngLat(), s5 = o3.toLngLat(), a3 = r3.toLngLat(), l4 = this.locationCoordinate(n4), c5 = this.locationCoordinate(s5), h4 = this.locationCoordinate(a3), u4 = Math.hypot(c5.x - l4.x, c5.y - l4.y), _3 = Math.hypot(h4.x - l4.x, h4.y - l4.y);
              return Math.sqrt(u4 * _3) * b3 / i3;
            }, T3 = (t3) => {
              const i3 = x2, o3 = y2;
              return { aabb: e.tileAABB(this, l3, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
            }, E2 = [];
            let C3 = [];
            const M2 = i2, I2 = t2.reparseOverscaled ? o2 : i2, P3 = (e2) => e2 * e2, S2 = P3((m3 - this._centerAltitude) * p3), D2 = (e2) => {
              if (!this._elevation || !e2.tileID || !n3)
                return;
              const t3 = this._elevation.getMinMaxForTile(e2.tileID), i3 = e2.aabb;
              t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e2.shouldSplit = L2(e2), e2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
            }, L2 = (t3) => {
              if (t3.zoom < v4)
                return true;
              if (t3.zoom === M2)
                return false;
              if (null != t3.shouldSplit)
                return t3.shouldSplit;
              const i3 = t3.aabb.distanceX(f2), n4 = t3.aabb.distanceY(f2);
              let s5 = S2, l4 = 1;
              if (h3) {
                s5 = P3(t3.aabb.distanceZ(f2));
                const i4 = Math.pow(2, t3.zoom), o3 = e.latFromMercatorY((t3.y + 1) / i4), r3 = e.latFromMercatorY(t3.y / i4), n5 = Math.min(Math.max(a2, o3), r3), c6 = e.circumferenceAtLatitude(n5) / e.circumferenceAtLatitude(a2);
                if (l4 = n5 === a2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c6 / this._mercatorScaleRatio), this.zoom <= e.GLOBE_ZOOM_THRESHOLD_MIN && t3.zoom === M2 - 1 && c6 >= 0.9)
                  return true;
              } else if (r2 && (s5 = P3(t3.aabb.distanceZ(f2) * p3)), this.projection.isReprojectedInTileSpace && o2 <= 5) {
                const i4 = Math.pow(2, t3.zoom), o3 = w2(new e.MercatorCoordinate((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
                l4 = o3 > 0.85 ? 1 : o3;
              }
              const c5 = i3 * i3 + n4 * n4 + s5, u4 = P3((1 << M2 - t3.zoom) * g2 * l4 * ((e2, t4) => {
                if (t4 * P3(0.707) < e2)
                  return 1;
                const i4 = Math.sqrt(t4 / e2);
                return i4 / (1.4144271570014144 + (Math.pow(1.1, i4 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
              })(Math.max(s5, S2), c5));
              return c5 < u4;
            };
            if (this.renderWorldCopies)
              for (let e2 = 1; e2 <= 3; e2++)
                E2.push(T3(-e2)), E2.push(T3(e2));
            for (E2.push(T3(0)); E2.length > 0; ) {
              const o3 = E2.pop(), s5 = o3.x, a3 = o3.y;
              let u4 = o3.fullyVisible;
              if (!u4) {
                const e2 = o3.aabb.intersects(_2);
                if (0 === e2)
                  continue;
                u4 = 2 === e2;
              }
              if (o3.zoom !== M2 && L2(o3))
                for (let t3 = 0; t3 < 4; t3++) {
                  const i3 = (s5 << 1) + t3 % 2, c5 = (a3 << 1) + (t3 >> 1), _3 = { aabb: n3 ? o3.aabb.quadrant(t3) : e.tileAABB(this, l3, o3.zoom + 1, i3, c5, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: c5, wrap: o3.wrap, fullyVisible: u4, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                  r2 && !h3 && (_3.tileID = new e.OverscaledTileID(o3.zoom + 1 === M2 ? I2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, c5), D2(_3)), E2.push(_3);
                }
              else {
                const r3 = o3.zoom === M2 ? I2 : o3.zoom;
                if (t2.minzoom && t2.minzoom > r3)
                  continue;
                const n4 = c4[0] - (0.5 + s5 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), l4 = c4[1] - 0.5 - a3, h4 = o3.tileID ? o3.tileID : new e.OverscaledTileID(r3, o3.wrap, o3.zoom, s5, a3);
                C3.push({ tileID: h4, distanceSq: n4 * n4 + l4 * l4 });
              }
            }
            if (this.fogCullDistSq) {
              const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
              C3 = C3.filter((r3) => {
                const n4 = [0, 0, 0, 1], s5 = [e.EXTENT, e.EXTENT, 0, 1], a3 = this.calculateFogTileMatrix(r3.tileID.toUnwrapped());
                e.transformMat4$1(n4, n4, a3), e.transformMat4$1(s5, s5, a3);
                const l4 = e.getAABBPointSquareDist(n4, s5);
                if (0 === l4)
                  return true;
                let c5 = false;
                const h4 = this._elevation;
                if (h4 && l4 > i3 && 0 !== o3) {
                  const i4 = this.calculateProjMatrix(r3.tileID.toUnwrapped());
                  let n5;
                  t2.isTerrainDEM || (n5 = h4.getMinMaxForTile(r3.tileID)), n5 || (n5 = { min: y2, max: x2 });
                  const s6 = e.furthestTileCorner(this.rotation), a4 = [s6[0] * e.EXTENT, s6[1] * e.EXTENT, n5.max];
                  e.transformMat4(a4, a4, i4), c5 = (1 - a4[1]) * this.height * 0.5 < o3;
                }
                return l4 < i3 || c5;
              });
            }
            return C3.sort((e2, t3) => e2.distanceSq - t3.distanceSq).map((e2) => e2.tileID);
          }
          resize(e2, t2) {
            this.width = e2, this.height = t2, this.pixelsToGLUnits = [2 / e2, -2 / t2], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(e2) {
            return Math.pow(2, e2);
          }
          scaleZoom(e2) {
            return Math.log(e2) / Math.LN2;
          }
          project(t2) {
            const i2 = e.clamp(t2.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), o2 = this.projection.project(t2.lng, i2);
            return new e.Point(o2.x * this.worldSize, o2.y * this.worldSize);
          }
          unproject(e2) {
            return this.projection.unproject(e2.x / this.worldSize, e2.y / this.worldSize);
          }
          get point() {
            return this.project(this.center);
          }
          get pointMerc() {
            return this.point._div(this.worldSize);
          }
          get pixelsPerMeterRatio() {
            return this.pixelsPerMeter / e.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
          }
          setLocationAtPoint(t2, i2) {
            let o2, r2;
            const n3 = this.centerPoint;
            if ("globe" === this.projection.name) {
              const e2 = this.worldSize;
              o2 = (i2.x - n3.x) / e2, r2 = (i2.y - n3.y) / e2;
            } else {
              const e2 = this.pointCoordinate(i2), t3 = this.pointCoordinate(n3);
              o2 = e2.x - t3.x, r2 = e2.y - t3.y;
            }
            const s4 = this.locationCoordinate(t2);
            this.setLocation(new e.MercatorCoordinate(s4.x - o2, s4.y - r2));
          }
          setLocation(e2) {
            this.center = this.coordinateLocation(e2), this.projection.wrap && (this.center = this.center.wrap());
          }
          locationPoint(e2) {
            return this.projection.locationPoint(this, e2);
          }
          locationPoint3D(e2) {
            return this.projection.locationPoint(this, e2, true);
          }
          pointLocation(e2) {
            return this.coordinateLocation(this.pointCoordinate(e2));
          }
          pointLocation3D(e2) {
            return this.coordinateLocation(this.pointCoordinate3D(e2));
          }
          locationCoordinate(t2, i2) {
            const o2 = i2 ? e.mercatorZfromAltitude(i2, t2.lat) : void 0, r2 = this.projection.project(t2.lng, t2.lat);
            return new e.MercatorCoordinate(r2.x, r2.y, o2);
          }
          coordinateLocation(e2) {
            return this.projection.unproject(e2.x, e2.y);
          }
          pointRayIntersection(t2, i2) {
            const o2 = null != i2 ? i2 : this._centerAltitude, r2 = [t2.x, t2.y, 0, 1], n3 = [t2.x, t2.y, 1, 1];
            e.transformMat4$1(r2, r2, this.pixelMatrixInverse), e.transformMat4$1(n3, n3, this.pixelMatrixInverse);
            const s4 = n3[3];
            e.scale$1(r2, r2, 1 / r2[3]), e.scale$1(n3, n3, 1 / s4);
            const a2 = r2[2], l3 = n3[2];
            return { p0: r2, p1: n3, t: a2 === l3 ? 0 : (o2 - a2) / (l3 - a2) };
          }
          screenPointToMercatorRay(t2) {
            const i2 = [t2.x, t2.y, 0, 1], o2 = [t2.x, t2.y, 1, 1];
            return e.transformMat4$1(i2, i2, this.pixelMatrixInverse), e.transformMat4$1(o2, o2, this.pixelMatrixInverse), e.scale$1(i2, i2, 1 / i2[3]), e.scale$1(o2, o2, 1 / o2[3]), i2[2] = e.mercatorZfromAltitude(i2[2], this._center.lat) * this.worldSize, o2[2] = e.mercatorZfromAltitude(o2[2], this._center.lat) * this.worldSize, e.scale$1(i2, i2, 1 / this.worldSize), e.scale$1(o2, o2, 1 / this.worldSize), new e.Ray([i2[0], i2[1], i2[2]], e.normalize([], e.sub([], o2, i2)));
          }
          rayIntersectionCoordinate(t2) {
            const { p0: i2, p1: o2, t: r2 } = t2, n3 = e.mercatorZfromAltitude(i2[2], this._center.lat), s4 = e.mercatorZfromAltitude(o2[2], this._center.lat);
            return new e.MercatorCoordinate(e.number(i2[0], o2[0], r2) / this.worldSize, e.number(i2[1], o2[1], r2) / this.worldSize, e.number(n3, s4, r2));
          }
          pointCoordinate(e2, t2 = this._centerAltitude) {
            return this.projection.pointCoordinate(this, e2.x, e2.y, t2);
          }
          pointCoordinate3D(t2) {
            if (!this.elevation)
              return this.pointCoordinate(t2);
            let i2 = this.projection.pointCoordinate3D(this, t2.x, t2.y);
            if (i2)
              return new e.MercatorCoordinate(i2[0], i2[1], i2[2]);
            let o2 = 0, r2 = this.horizonLineFromTop();
            if (t2.y > r2)
              return this.pointCoordinate(t2);
            const n3 = 0.02 * r2, s4 = t2.clone();
            for (let t3 = 0; t3 < 10 && r2 - o2 > n3; t3++) {
              s4.y = e.number(o2, r2, 0.66);
              const t4 = this.projection.pointCoordinate3D(this, s4.x, s4.y);
              t4 ? (r2 = s4.y, i2 = t4) : o2 = s4.y;
            }
            return i2 ? new e.MercatorCoordinate(i2[0], i2[1], i2[2]) : this.pointCoordinate(t2);
          }
          isPointAboveHorizon(e2) {
            return this.projection.isPointAboveHorizon(this, e2);
          }
          isPointOnSurface(t2) {
            if (t2.y < 0 || t2.y > this.height || t2.x < 0 || t2.x > this.width)
              return false;
            if (this.elevation || this.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX)
              return !this.isPointAboveHorizon(t2);
            const i2 = this.pointCoordinate(t2);
            return i2.y >= 0 && i2.y <= 1;
          }
          _coordinatePoint(t2, i2) {
            const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t2, this._centerAltitude) : this._centerAltitude, r2 = [t2.x * this.worldSize, t2.y * this.worldSize, o2 + t2.toAltitude(), 1];
            return e.transformMat4$1(r2, r2, this.pixelMatrix), r2[3] > 0 ? new e.Point(r2[0] / r2[3], r2[1] / r2[3]) : new e.Point(Number.MAX_VALUE, Number.MAX_VALUE);
          }
          _getBoundsNonRectangular() {
            const { top: t2, left: i2 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, r2 = this.width - this._edgeInsets.right, n3 = this.pointLocation3D(new e.Point(i2, t2)), s4 = this.pointLocation3D(new e.Point(r2, t2)), a2 = this.pointLocation3D(new e.Point(r2, o2)), l3 = this.pointLocation3D(new e.Point(i2, o2));
            let c4 = Math.min(n3.lng, s4.lng, a2.lng, l3.lng), h3 = Math.max(n3.lng, s4.lng, a2.lng, l3.lng), u3 = Math.min(n3.lat, s4.lat, a2.lat, l3.lat), _2 = Math.max(n3.lat, s4.lat, a2.lat, l3.lat);
            const d3 = Math.pow(2, -this.zoom) / 16 * 270, p3 = "globe" === this.projection.name ? 1 : 4, m3 = (t3, i3, o3, r3, n4) => {
              const s5 = (t3 + o3) / 2, a3 = (i3 + r3) / 2, l4 = new e.Point(s5, a3), { lng: f2, lat: g2 } = this.pointLocation3D(l4), v4 = Math.max(0, c4 - f2, u3 - g2, f2 - h3, g2 - _2);
              c4 = Math.min(c4, f2), h3 = Math.max(h3, f2), u3 = Math.min(u3, g2), _2 = Math.max(_2, g2), (n4 < p3 || v4 > d3) && (m3(t3, i3, s5, a3, n4 + 1), m3(s5, a3, o3, r3, n4 + 1));
            };
            if (m3(i2, t2, r2, t2, 1), m3(r2, t2, r2, o2, 1), m3(r2, o2, i2, o2, 1), m3(i2, o2, i2, t2, 1), "globe" === this.projection.name) {
              const [t3, i3] = e.polesInViewport(this);
              t3 ? (_2 = 90, h3 = 180, c4 = -180) : i3 && (u3 = -90, h3 = 180, c4 = -180);
            }
            return new e.LngLatBounds(new e.LngLat(c4, u3), new e.LngLat(h3, _2));
          }
          _getBoundsRectangular(t2, i2) {
            const { top: o2, left: r2 } = this._edgeInsets, n3 = this.height - this._edgeInsets.bottom, s4 = this.width - this._edgeInsets.right, a2 = new e.Point(r2, o2), l3 = new e.Point(s4, o2), c4 = new e.Point(s4, n3), h3 = new e.Point(r2, n3);
            let u3 = this.pointCoordinate(a2, t2), _2 = this.pointCoordinate(l3, t2);
            const d3 = this.pointCoordinate(c4, i2), p3 = this.pointCoordinate(h3, i2), m3 = (e2, t3) => (t3.y - e2.y) / (t3.x - e2.x);
            return u3.y > 1 && _2.y >= 0 ? u3 = new e.MercatorCoordinate((1 - p3.y) / m3(p3, u3) + p3.x, 1) : u3.y < 0 && _2.y <= 1 && (u3 = new e.MercatorCoordinate(-p3.y / m3(p3, u3) + p3.x, 0)), _2.y > 1 && u3.y >= 0 ? _2 = new e.MercatorCoordinate((1 - d3.y) / m3(d3, _2) + d3.x, 1) : _2.y < 0 && u3.y <= 1 && (_2 = new e.MercatorCoordinate(-d3.y / m3(d3, _2) + d3.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(u3)).extend(this.coordinateLocation(_2)).extend(this.coordinateLocation(p3)).extend(this.coordinateLocation(d3));
          }
          _getBoundsRectangularTerrain() {
            const e2 = this.elevation;
            if (!e2.visibleDemTiles.length || e2.isUsingMockSource())
              return this._getBoundsRectangular(0, 0);
            const t2 = e2.visibleDemTiles.reduce((e3, t3) => {
              if (t3.dem) {
                const i2 = t3.dem.tree;
                e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
              }
              return e3;
            }, { min: Number.MAX_VALUE, max: 0 });
            return this._getBoundsRectangular(t2.min * e2.exaggeration(), t2.max * e2.exaggeration());
          }
          getBounds() {
            return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
          }
          horizonLineFromTop(e2 = true) {
            const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
            return e2 ? Math.max(0, i2) : i2;
          }
          getMaxBounds() {
            return this.maxBounds;
          }
          setMaxBounds(t2) {
            this.maxBounds = t2, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t2 && (this.minLat = t2.getSouth(), this.maxLat = t2.getNorth(), this.minLng = t2.getWest(), this.maxLng = t2.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
          }
          calculatePosMatrix(e2, t2) {
            return this.projection.createTileMatrix(this, t2, e2);
          }
          calculateDistanceTileData(t2) {
            const i2 = t2.key, o2 = this._distanceTileDataCache;
            if (o2[i2])
              return o2[i2];
            const r2 = t2.canonical, n3 = 1 / this.height, s4 = this.cameraWorldSize, a2 = s4 / this.zoomScale(r2.z), l3 = (r2.x + Math.pow(2, r2.z) * t2.wrap) * a2, c4 = r2.y * a2, h3 = this.point;
            h3.x *= s4 / this.worldSize, h3.y *= s4 / this.worldSize;
            const u3 = this.angle, _2 = Math.sin(-u3), d3 = -Math.cos(-u3);
            return o2[i2] = { bearing: [_2, d3], center: [(h3.x - l3) * n3, (h3.y - c4) * n3], scale: a2 / e.EXTENT * n3 }, o2[i2];
          }
          calculateFogTileMatrix(t2) {
            const i2 = t2.key, o2 = this._fogTileMatrixCache;
            if (o2[i2])
              return o2[i2];
            const r2 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t2);
            return e.multiply(r2, this.worldToFogMatrix, r2), o2[i2] = new Float32Array(r2), o2[i2];
          }
          calculateProjMatrix(t2, i2 = false) {
            const o2 = t2.key, r2 = i2 ? this._alignedProjMatrixCache : this._projMatrixCache;
            if (r2[o2])
              return r2[o2];
            const n3 = this.calculatePosMatrix(t2, this.worldSize);
            return e.multiply(n3, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, n3), r2[o2] = new Float32Array(n3), r2[o2];
          }
          calculatePixelsToTileUnitsMatrix(t2) {
            const i2 = t2.tileID.key, o2 = this._pixelsToTileUnitsCache;
            if (o2[i2])
              return o2[i2];
            const r2 = function(t3, i3) {
              const { scale: o3 } = t3.tileTransform, r3 = o3 * e.EXTENT / (t3.tileSize * Math.pow(2, i3.zoom - t3.tileID.overscaledZ + t3.tileID.canonical.z));
              return n3 = new Float32Array(4), l3 = (s4 = i3.inverseAdjustmentMatrix)[1], c4 = s4[2], h3 = s4[3], _2 = (a2 = [r3, r3])[1], n3[0] = s4[0] * (u3 = a2[0]), n3[1] = l3 * u3, n3[2] = c4 * _2, n3[3] = h3 * _2, n3;
              var n3, s4, a2, l3, c4, h3, u3, _2;
            }(t2, this);
            return o2[i2] = r2, o2[i2];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          globeToMercatorMatrix() {
            if ("globe" === this.projection.name) {
              const t2 = 1 / this.worldSize, i2 = e.fromScaling([], [t2, t2, t2]);
              return e.multiply(i2, i2, this.globeMatrix), i2;
            }
          }
          recenterOnTerrain() {
            if (!this._elevation || "globe" === this.projection.name)
              return;
            const t2 = this._elevation;
            this._updateCameraState();
            const i2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), r2 = this._camera.forward(), n3 = e.mercatorZfromAltitude(1, this._center.lat);
            o2[2] /= n3, r2[2] /= n3, e.normalize(r2, r2);
            const s4 = t2.raycast(o2, r2, t2.exaggeration());
            if (s4) {
              const t3 = e.scaleAndAdd([], o2, r2, s4), i3 = new e.MercatorCoordinate(t3[0], t3[1], e.mercatorZfromAltitude(t3[2], e.latFromMercatorY(t3[1]))), a2 = (i3.z + e.length([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * n3])) * this._pixelsPerMercatorPixel;
              this._seaLevelZoom = this._zoomFromMercatorZ(a2), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
            }
          }
          _constrainCamera(t2 = false) {
            if (!this._elevation)
              return;
            const i2 = this._elevation, o2 = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, r2 = this._computeCameraPosition(o2), n3 = i2.getAtPointOrZero(new e.MercatorCoordinate(...r2)), s4 = this.pixelsPerMeter / this.worldSize * n3, a2 = this._minimumHeightOverTerrain(), l3 = r2[2] - s4;
            if (l3 <= a2)
              if (l3 < 0 || t2) {
                const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [r2[0], r2[1], t3.z - r2[2]], o3 = e.length(i3);
                i3[2] -= (a2 - l3) / this._pixelsPerMercatorPixel;
                const n4 = e.length(i3);
                if (0 === n4)
                  return;
                e.scale$2(i3, i3, o3 / n4 * this._pixelsPerMercatorPixel), this._camera.position = [r2[0], r2[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
              } else
                this._isCameraConstrained = true;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining)
              return;
            this._constraining = true;
            const t2 = "globe" === this.projection.name || this.mercatorFromTransition;
            if (this.projection.isReprojectedInTileSpace || t2) {
              const i3 = this.center;
              return i3.lat = e.clamp(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t2) && (i3.lng = e.clamp(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
            }
            const i2 = this._unmodified, { x: o2, y: r2 } = this.point;
            let n3 = 0, s4 = o2, a2 = r2;
            const l3 = this.width / 2, c4 = this.height / 2, h3 = this.worldMinY * this.scale, u3 = this.worldMaxY * this.scale;
            if (r2 - c4 < h3 && (a2 = h3 + c4), r2 + c4 > u3 && (a2 = u3 - c4), u3 - h3 < this.height && (n3 = Math.max(n3, this.height / (u3 - h3)), a2 = (u3 + h3) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
              const e2 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e2 + t3) / 2;
              s4 = (o2 + i3 + this.worldSize) % this.worldSize - i3, s4 - l3 < e2 && (s4 = e2 + l3), s4 + l3 > t3 && (s4 = t3 - l3), t3 - e2 < this.width && (n3 = Math.max(n3, this.width / (t3 - e2)), s4 = (t3 + e2) / 2);
            }
            s4 === o2 && a2 === r2 || (this.center = this.unproject(new e.Point(s4, a2))), n3 && (this.zoom += this.scaleZoom(n3)), this._constrainCamera(), this._unmodified = i2, this._constraining = false;
          }
          _minZoomForBounds() {
            let e2 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
            return this.maxBounds && (e2 = Math.max(e2, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e2;
          }
          _maxCameraBoundsDistance() {
            return this._mercatorZfromZoom(this._minZoomForBounds());
          }
          _calcMatrices() {
            if (!this.height)
              return;
            const t2 = this.centerOffset, i2 = this.pixelsPerMeter;
            "globe" === this.projection.name && (this._mercatorScaleRatio = e.mercatorZfromAltitude(1, this.center.lat) / e.mercatorZfromAltitude(1, e.GLOBE_SCALE_MATCH_LATITUDE));
            const o2 = Wo(this.projection, this.zoom, this.width, this.height, 1024);
            this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
            const r2 = "meters" === this.projection.zAxisUnit ? i2 : 1, n3 = this._camera.getWorldToCamera(this.worldSize, r2), s4 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
            s4[8] = 2 * -t2.x / this.width, s4[9] = 2 * t2.y / this.height;
            let a2 = e.mul([], s4, n3);
            if (this.projection.isReprojectedInTileSpace) {
              const t3 = this.locationCoordinate(this.center), i3 = e.identity([]);
              e.translate(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e.multiply(i3, i3, Zo(this)), e.translate(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e.multiply(a2, a2, i3), this.inverseAdjustmentMatrix = function(e2) {
                const t4 = Zo(e2, true);
                return v3([], [t4[0], t4[1], t4[4], t4[5]]);
              }(this);
            } else
              this.inverseAdjustmentMatrix = [1, 0, 0, 1];
            this.mercatorMatrix = e.scale([], a2, [this.worldSize, this.worldSize, this.worldSize / r2, 1]), this.projMatrix = a2, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);
            const l3 = e.invert([], s4);
            this.frustumCorners = e.FrustumCorners.fromInvProjectionMatrix(l3, this.horizonLineFromTop(), this.height);
            const c4 = new Float32Array(16);
            e.identity(c4), e.scale(c4, c4, [1, -1, 1]), e.rotateX(c4, c4, this._pitch), e.rotateZ(c4, c4, this.angle);
            const h3 = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), u3 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
            h3[8] = 2 * -t2.x / this.width, h3[9] = 2 * (t2.y + u3) / this.height, this.skyboxMatrix = e.multiply(c4, h3, c4);
            const _2 = this.point, d3 = _2.x, p3 = _2.y, m3 = this.width % 2 / 2, f2 = this.height % 2 / 2, g2 = Math.cos(this.angle), x2 = Math.sin(this.angle), y2 = d3 - Math.round(d3) + g2 * m3 + x2 * f2, b3 = p3 - Math.round(p3) + g2 * f2 + x2 * m3, w2 = new Float64Array(a2);
            if (e.translate(w2, w2, [y2 > 0.5 ? y2 - 1 : y2, b3 > 0.5 ? b3 - 1 : b3, 0]), this.alignedProjMatrix = w2, a2 = e.create(), e.scale(a2, a2, [this.width / 2, -this.height / 2, 1]), e.translate(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = e.create(), e.scale(a2, a2, [1, -1, 1]), e.translate(a2, a2, [-1, -1, 0]), e.scale(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a2 = e.invert(new Float64Array(16), this.pixelMatrix), !a2)
              throw new Error("failed to invert matrix");
            if (this.pixelMatrixInverse = a2, "globe" === this.projection.name || this.mercatorFromTransition) {
              this.globeMatrix = e.calculateGlobeMatrix(this);
              const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
              this.globeCenterInViewSpace = e.transformMat4(t3, t3, n3), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
            } else
              this.globeMatrix = a2;
            this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
          }
          _calcFogMatrices() {
            this._fogTileMatrixCache = {};
            const t2 = this.cameraWorldSizeForFog, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r2 = 1 / this.height / this._pixelsPerMercatorPixel, n3 = [t2, t2, i2];
            e.scale$2(n3, n3, r2), e.scale$2(o2, o2, -1), e.multiply$2(o2, o2, n3);
            const s4 = e.create();
            e.translate(s4, s4, o2), e.scale(s4, s4, n3), this.mercatorFogMatrix = s4, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t2, i2, r2);
          }
          _computeCameraPosition(e2) {
            const t2 = (e2 = e2 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, r2 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t2 - e2 / this.worldSize * this._centerAltitude;
            return [o2.x / this.worldSize - i2[0] * r2, o2.y / this.worldSize - i2[1] * r2, e2 / this.worldSize * this._centerAltitude - i2[2] * r2];
          }
          _updateCameraState() {
            this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
          }
          _translateCameraConstrained(t2) {
            const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], r2 = t2[2];
            let n3 = 1;
            this.projection.wrap && (this.center = this.center.wrap()), r2 > 0 && (n3 = Math.min((i2 - o2) / r2, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t2, n3), this._updateStateFromCamera();
          }
          _updateStateFromCamera() {
            const t2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r2 } = this._camera.getPitchBearing(), n3 = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, s4 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)), a2 = Math.max((t2[2] - n3) / Math.cos(o2), s4), l3 = this._zoomFromMercatorZ(a2);
            e.scaleAndAdd(t2, t2, i2, a2), this._pitch = e.clamp(o2, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r2, -Math.PI, Math.PI), this._setZoom(e.clamp(l3, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t2[0], t2[1], t2[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
          }
          _worldSizeFromZoom(e2) {
            return Math.pow(2, e2) * this.tileSize;
          }
          _mercatorZfromZoom(e2) {
            return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
          }
          _minimumHeightOverTerrain() {
            const e2 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
            return this._mercatorZfromZoom(e2);
          }
          _zoomFromMercatorZ(e2) {
            return this.scaleZoom(this.cameraToCenterDistance / (e2 * this.tileSize));
          }
          zoomFromMercatorZAdjusted(t2) {
            let i2 = 0, o2 = e.GLOBE_ZOOM_THRESHOLD_MAX, r2 = 0, n3 = 1 / 0;
            for (; o2 - i2 > 1e-6 && o2 > i2; ) {
              const e2 = i2 + 0.5 * (o2 - i2), s4 = this.tileSize * Math.pow(2, e2), a2 = this.getCameraToCenterDistance(this.projection, e2, s4), l3 = this.scaleZoom(a2 / (t2 * this.tileSize)), c4 = Math.abs(e2 - l3);
              c4 < n3 && (n3 = c4, r2 = e2), e2 < l3 ? i2 = e2 : o2 = e2;
            }
            return r2;
          }
          _terrainEnabled() {
            return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
          }
          anyCornerOffEdge(t2, i2) {
            const o2 = Math.min(t2.x, i2.x), r2 = Math.max(t2.x, i2.x), n3 = Math.min(t2.y, i2.y), s4 = Math.max(t2.y, i2.y);
            if (n3 < this.horizonLineFromTop(false))
              return true;
            if ("mercator" !== this.projection.name)
              return false;
            const a2 = [new e.Point(o2, n3), new e.Point(r2, s4), new e.Point(o2, s4), new e.Point(r2, n3)], l3 = this.renderWorldCopies ? -3 : 0, c4 = this.renderWorldCopies ? 4 : 1;
            for (const e2 of a2) {
              const t3 = this.pointRayIntersection(e2);
              if (t3.t < 0)
                return true;
              const i3 = this.rayIntersectionCoordinate(t3);
              if (i3.x < l3 || i3.y < 0 || i3.x > c4 || i3.y > 1)
                return true;
            }
            return false;
          }
          isHorizonVisible() {
            return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.Point(0, 0), new e.Point(this.width, this.height));
          }
          zoomDeltaToMovement(t2, i2) {
            const o2 = e.length(e.sub([], this._camera.position, t2)), r2 = this._zoomFromMercatorZ(o2) + i2;
            return o2 - this._mercatorZfromZoom(r2);
          }
          getCameraPoint() {
            if ("globe" === this.projection.name) {
              const t2 = function([t3, i2, o2], r2) {
                const n3 = [t3, i2, o2, 1];
                e.transformMat4$1(n3, n3, r2);
                const s4 = n3[3] = Math.max(n3[3], 1e-6);
                return n3[0] /= s4, n3[1] /= s4, n3[2] /= s4, n3;
              }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
              return new e.Point(t2[0], t2[1]);
            }
            {
              const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new e.Point(0, t2));
            }
          }
          getCameraToCenterDistance(e2, t2 = this.zoom, i2 = this.worldSize) {
            const o2 = Wo(e2, t2, this.width, this.height, 1024), r2 = e2.pixelSpaceConversion(this.center.lat, i2, o2);
            return 0.5 / Math.tan(0.5 * this._fov) * this.height * r2;
          }
          getWorldToCameraMatrix() {
            const t2 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
            return "globe" === this.projection.name && e.multiply(t2, t2, this.globeMatrix), t2;
          }
        }
        function Yo(e2, t2) {
          let i2 = false, o2 = null;
          const r2 = () => {
            o2 = null, i2 && (e2(), o2 = setTimeout(r2, t2), i2 = false);
          };
          return () => (i2 = true, o2 || r2(), o2);
        }
        class Ko {
          constructor(t2) {
            this._hashName = t2 && encodeURIComponent(t2), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Yo(this._updateHashUnthrottled.bind(this), 300);
          }
          addTo(t2) {
            return this._map = t2, e.window.addEventListener("hashchange", this._onHashChange, false), t2.on("moveend", this._updateHash), this;
          }
          remove() {
            return this._map ? (this._map.off("moveend", this._updateHash), e.window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
          }
          getHashString() {
            const t2 = this._map;
            if (!t2)
              return "";
            const i2 = Jo(t2);
            if (this._hashName) {
              const t3 = this._hashName;
              let o2 = false;
              const r2 = e.window.location.hash.slice(1).split("&").map((e2) => {
                const r3 = e2.split("=")[0];
                return r3 === t3 ? (o2 = true, `${r3}=${i2}`) : e2;
              }).filter((e2) => e2);
              return o2 || r2.push(`${t3}=${i2}`), `#${r2.join("&")}`;
            }
            return `#${i2}`;
          }
          _getCurrentHash() {
            const t2 = e.window.location.hash.replace("#", "");
            if (this._hashName) {
              let e2;
              return t2.split("&").map((e3) => e3.split("=")).forEach((t3) => {
                t3[0] === this._hashName && (e2 = t3);
              }), (e2 && e2[1] || "").split("/");
            }
            return t2.split("/");
          }
          _onHashChange() {
            const e2 = this._map;
            if (!e2)
              return false;
            const t2 = this._getCurrentHash();
            if (t2.length >= 3 && !t2.some((e3) => isNaN(e3))) {
              const i2 = e2.dragRotate.isEnabled() && e2.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : e2.getBearing();
              return e2.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: i2, pitch: +(t2[4] || 0) }), true;
            }
            return false;
          }
          _updateHashUnthrottled() {
            const t2 = e.window.location.href.replace(/(#.+)?$/, this.getHashString());
            e.window.history.replaceState(e.window.history.state, null, t2);
          }
        }
        function Jo(e2, t2) {
          const i2 = e2.getCenter(), o2 = Math.round(100 * e2.getZoom()) / 100, r2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), n3 = Math.pow(10, r2), s4 = Math.round(i2.lng * n3) / n3, a2 = Math.round(i2.lat * n3) / n3, l3 = e2.getBearing(), c4 = e2.getPitch();
          let h3 = t2 ? `/${s4}/${a2}/${o2}` : `${o2}/${a2}/${s4}`;
          return (l3 || c4) && (h3 += "/" + Math.round(10 * l3) / 10), c4 && (h3 += `/${Math.round(c4)}`), h3;
        }
        const Qo = { linearity: 0.3, easing: e.bezier(0, 0, 0.3, 1) }, er = e.extend({ deceleration: 2500, maxSpeed: 1400 }, Qo), tr = e.extend({ deceleration: 20, maxSpeed: 1400 }, Qo), ir = e.extend({ deceleration: 1e3, maxSpeed: 360 }, Qo), or = e.extend({ deceleration: 1e3, maxSpeed: 90 }, Qo);
        class rr {
          constructor(e2) {
            this._map = e2, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.exported.now(), settings: t2 });
          }
          _drainInertiaBuffer() {
            const t2 = this._inertiaBuffer, i2 = e.exported.now();
            for (; t2.length > 0 && i2 - t2[0].time > 160; )
              t2.shift();
          }
          _onMoveEnd(t2) {
            if (this._map._prefersReducedMotion())
              return;
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
              return;
            const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.Point(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: e2 } of this._inertiaBuffer)
              i2.zoom += e2.zoomDelta || 0, i2.bearing += e2.bearingDelta || 0, i2.pitch += e2.pitchDelta || 0, e2.panDelta && i2.pan._add(e2.panDelta), e2.around && (i2.around = e2.around), e2.pinchAround && (i2.pinchAround = e2.pinchAround);
            const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r2 = {};
            if (i2.pan.mag()) {
              const n3 = sr(i2.pan.mag(), o2, e.extend({}, er, t2 || {}));
              r2.offset = i2.pan.mult(n3.amount / i2.pan.mag()), r2.center = this._map.transform.center, nr(r2, n3);
            }
            if (i2.zoom) {
              const e2 = sr(i2.zoom, o2, tr);
              r2.zoom = this._map.transform.zoom + e2.amount, nr(r2, e2);
            }
            if (i2.bearing) {
              const t3 = sr(i2.bearing, o2, ir);
              r2.bearing = this._map.transform.bearing + e.clamp(t3.amount, -179, 179), nr(r2, t3);
            }
            if (i2.pitch) {
              const e2 = sr(i2.pitch, o2, or);
              r2.pitch = this._map.transform.pitch + e2.amount, nr(r2, e2);
            }
            if (r2.zoom || r2.bearing) {
              const e2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
              r2.around = e2 ? this._map.unproject(e2) : this._map.getCenter();
            }
            return this.clear(), r2.noMoveStart = true, r2;
          }
        }
        function nr(e2, t2) {
          (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
        }
        function sr(t2, i2, o2) {
          const { maxSpeed: r2, linearity: n3, deceleration: s4 } = o2, a2 = e.clamp(t2 * n3 / (i2 / 1e3), -r2, r2), l3 = Math.abs(a2) / (s4 * n3);
          return { easing: o2.easing, duration: 1e3 * l3, amount: a2 * (l3 / 2) };
        }
        class ar extends e.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, i2, o2, r2 = {}) {
            const n3 = p2(i2.getCanvasContainer(), o2), s4 = i2.unproject(n3);
            super(t2, e.extend({ point: n3, lngLat: s4, originalEvent: o2 }, r2)), this._defaultPrevented = false, this.target = i2;
          }
        }
        class lr extends e.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, i2, o2) {
            const r2 = "touchend" === t2 ? o2.changedTouches : o2.touches, n3 = m2(i2.getCanvasContainer(), r2), s4 = n3.map((e2) => i2.unproject(e2)), a2 = n3.reduce((e2, t3, i3, o3) => e2.add(t3.div(o3.length)), new e.Point(0, 0));
            super(t2, { points: n3, point: a2, lngLats: s4, lngLat: i2.unproject(a2), originalEvent: o2 }), this._defaultPrevented = false;
          }
        }
        class cr extends e.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, t2, i2) {
            super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
          }
        }
        class hr {
          constructor(e2, t2) {
            this._map = e2, this._clickTolerance = t2.clickTolerance;
          }
          reset() {
            this._mousedownPos = void 0;
          }
          wheel(e2) {
            return this._firePreventable(new cr(e2.type, this._map, e2));
          }
          mousedown(e2, t2) {
            return this._mousedownPos = t2, this._firePreventable(new ar(e2.type, this._map, e2));
          }
          mouseup(e2) {
            this._map.fire(new ar(e2.type, this._map, e2));
          }
          preclick(t2) {
            const i2 = e.extend({}, t2);
            i2.type = "preclick", this._map.fire(new ar(i2.type, this._map, i2));
          }
          click(e2, t2) {
            this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new ar(e2.type, this._map, e2)));
          }
          dblclick(e2) {
            return this._firePreventable(new ar(e2.type, this._map, e2));
          }
          mouseover(e2) {
            this._map.fire(new ar(e2.type, this._map, e2));
          }
          mouseout(e2) {
            this._map.fire(new ar(e2.type, this._map, e2));
          }
          touchstart(e2) {
            return this._firePreventable(new lr(e2.type, this._map, e2));
          }
          touchmove(e2) {
            this._map.fire(new lr(e2.type, this._map, e2));
          }
          touchend(e2) {
            this._map.fire(new lr(e2.type, this._map, e2));
          }
          touchcancel(e2) {
            this._map.fire(new lr(e2.type, this._map, e2));
          }
          _firePreventable(e2) {
            if (this._map.fire(e2), e2.defaultPrevented)
              return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class ur {
          constructor(e2) {
            this._map = e2;
          }
          reset() {
            this._delayContextMenu = false, this._contextMenuEvent = void 0;
          }
          mousemove(e2) {
            this._map.fire(new ar(e2.type, this._map, e2));
          }
          mousedown() {
            this._delayContextMenu = true;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ar("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e2) {
            this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new ar(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class _r {
          constructor(e2, t2) {
            this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e2, t2) {
            this.isEnabled() && e2.shiftKey && 0 === e2.button && (h2(), this._startPos = this._lastPos = t2, this._active = true);
          }
          mousemoveWindow(e2, t2) {
            if (!this._active)
              return;
            const i2 = t2, o2 = this._startPos, r2 = this._lastPos;
            if (!o2 || !r2 || r2.equals(i2) || !this._box && i2.dist(o2) < this._clickTolerance)
              return;
            this._lastPos = i2, this._box || (this._box = n2("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
            const s4 = Math.min(o2.x, i2.x), a2 = Math.max(o2.x, i2.x), l3 = Math.min(o2.y, i2.y), c4 = Math.max(o2.y, i2.y);
            this._map._requestDomTask(() => {
              this._box && (this._box.style.transform = `translate(${s4}px,${l3}px)`, this._box.style.width = a2 - s4 + "px", this._box.style.height = c4 - l3 + "px");
            });
          }
          mouseupWindow(t2, i2) {
            if (!this._active)
              return;
            const o2 = this._startPos, r2 = i2;
            if (o2 && 0 === t2.button) {
              if (this.reset(), d2(), o2.x !== r2.x || o2.y !== r2.y)
                return this._map.fire(new e.Event("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (e2) => e2.fitScreenCoordinates(o2, r2, this._map.getBearing(), { linear: false }) };
              this._fireEvent("boxzoomcancel", t2);
            }
          }
          keydown(e2) {
            this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u2(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t2, i2) {
            return this._map.fire(new e.Event(t2, { originalEvent: i2 }));
          }
        }
        function dr(e2, t2) {
          const i2 = {};
          for (let o2 = 0; o2 < e2.length; o2++)
            i2[e2[o2].identifier] = t2[o2];
          return i2;
        }
        class pr {
          constructor(e2) {
            this.reset(), this.numTouches = e2.numTouches;
          }
          reset() {
            this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
          }
          touchstart(t2, i2, o2) {
            (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t2.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
              const i3 = new e.Point(0, 0);
              for (const e2 of t3)
                i3._add(e2);
              return i3.div(t3.length);
            }(i2), this.touches = dr(o2, i2)));
          }
          touchmove(e2, t2, i2) {
            if (this.aborted || !this.centroid)
              return;
            const o2 = dr(i2, t2);
            for (const e3 in this.touches) {
              const t3 = o2[e3];
              (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
            }
          }
          touchend(e2, t2, i2) {
            if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
              const e3 = !this.aborted && this.centroid;
              if (this.reset(), e3)
                return e3;
            }
          }
        }
        class mr {
          constructor(e2) {
            this.singleTap = new pr(e2), this.numTaps = e2.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
          }
          touchstart(e2, t2, i2) {
            this.singleTap.touchstart(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            this.singleTap.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            const o2 = this.singleTap.touchend(e2, t2, i2);
            if (o2) {
              const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
              if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                return this.reset(), o2;
            }
          }
        }
        class fr {
          constructor() {
            this._zoomIn = new mr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new mr({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e2, t2, i2) {
            this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
          }
          touchmove(e2, t2, i2) {
            this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            const o2 = this._zoomIn.touchend(e2, t2, i2), r2 = this._zoomOut.touchend(e2, t2, i2);
            return o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e2 }) }) : r2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(r2) }, { originalEvent: e2 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const gr = { 0: 1, 2: 2 };
        class vr {
          constructor(e2) {
            this.reset(), this._clickTolerance = e2.clickTolerance || 1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
          }
          _correctButton(e2, t2) {
            return false;
          }
          _move(e2, t2) {
            return {};
          }
          mousedown(e2, t2) {
            if (this._lastPoint)
              return;
            const i2 = f(e2);
            this._correctButton(e2, i2) && (this._lastPoint = t2, this._eventButton = i2);
          }
          mousemoveWindow(e2, t2) {
            const i2 = this._lastPoint;
            if (i2) {
              if (e2.preventDefault(), null != this._eventButton && function(e3, t3) {
                const i3 = gr[t3];
                return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
              }(e2, this._eventButton))
                this.reset();
              else if (this._moved || !(t2.dist(i2) < this._clickTolerance))
                return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
            }
          }
          mouseupWindow(e2) {
            this._lastPoint && f(e2) === this._eventButton && (this._moved && d2(), this.reset());
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class xr extends vr {
          mousedown(e2, t2) {
            super.mousedown(e2, t2), this._lastPoint && (this._active = true);
          }
          _correctButton(e2, t2) {
            return 0 === t2 && !e2.ctrlKey;
          }
          _move(e2, t2) {
            return { around: t2, panDelta: t2.sub(e2) };
          }
        }
        class yr extends vr {
          _correctButton(e2, t2) {
            return 0 === t2 && e2.ctrlKey || 2 === t2;
          }
          _move(e2, t2) {
            const i2 = 0.8 * (t2.x - e2.x);
            if (i2)
              return this._active = true, { bearingDelta: i2 };
          }
          contextmenu(e2) {
            e2.preventDefault();
          }
        }
        class br extends vr {
          _correctButton(e2, t2) {
            return 0 === t2 && e2.ctrlKey || 2 === t2;
          }
          _move(e2, t2) {
            const i2 = -0.5 * (t2.y - e2.y);
            if (i2)
              return this._active = true, { pitchDelta: i2 };
          }
          contextmenu(e2) {
            e2.preventDefault();
          }
        }
        class wr {
          constructor(t2, i2) {
            this._map = t2, this._el = t2.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e.Point(0, 0);
          }
          touchstart(e2, t2, i2) {
            return this._calculateTransform(e2, t2, i2);
          }
          touchmove(t2, i2, o2) {
            if (this._active && !(o2.length < this._minTouches)) {
              if (this._map._cooperativeGestures && !this._map.isMoving()) {
                if (1 === o2.length && !e.isFullscreen())
                  return void this._showTouchPanBlockerAlert();
                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              return t2.cancelable && t2.preventDefault(), this._calculateTransform(t2, i2, o2);
            }
          }
          touchend(e2, t2, i2) {
            this._calculateTransform(e2, t2, i2), this._active && i2.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t2, i2, o2) {
            o2.length > 0 && (this._active = true);
            const r2 = dr(o2, i2), n3 = new e.Point(0, 0), s4 = new e.Point(0, 0);
            let a2 = 0;
            for (const e2 in r2) {
              const t3 = r2[e2], i3 = this._touches[e2];
              i3 && (n3._add(t3), s4._add(t3.sub(i3)), a2++, r2[e2] = t3);
            }
            if (this._touches = r2, a2 < this._minTouches || !s4.mag())
              return;
            const l3 = s4.div(a2);
            return this._sum._add(l3), this._sum.mag() < this._clickTolerance ? void 0 : { around: n3.div(a2), panDelta: l3 };
          }
          enable() {
            this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
          }
          disable() {
            this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          _addTouchPanBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = n2("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showTouchPanBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
            }, 500);
          }
        }
        class Tr {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, this._firstTwoTouches = void 0;
          }
          _start(e2) {
          }
          _move(e2, t2, i2) {
            return {};
          }
          touchstart(e2, t2, i2) {
            this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
          }
          touchmove(e2, t2, i2) {
            const o2 = this._firstTwoTouches;
            if (!o2)
              return;
            e2.preventDefault();
            const [r2, n3] = o2, s4 = Er(i2, t2, r2), a2 = Er(i2, t2, n3);
            if (!s4 || !a2)
              return;
            const l3 = this._aroundCenter ? null : s4.add(a2).div(2);
            return this._move([s4, a2], l3, e2);
          }
          touchend(e2, t2, i2) {
            if (!this._firstTwoTouches)
              return;
            const [o2, r2] = this._firstTwoTouches, n3 = Er(i2, t2, o2), s4 = Er(i2, t2, r2);
            n3 && s4 || (this._active && d2(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e2) {
            this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function Er(e2, t2, i2) {
          for (let o2 = 0; o2 < e2.length; o2++)
            if (e2[o2].identifier === i2)
              return t2[o2];
        }
        function Cr(e2, t2) {
          return Math.log(e2 / t2) / Math.LN2;
        }
        class Mr extends Tr {
          reset() {
            super.reset(), this._distance = 0, this._startDistance = 0;
          }
          _start(e2) {
            this._startDistance = this._distance = e2[0].dist(e2[1]);
          }
          _move(e2, t2) {
            const i2 = this._distance;
            if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(Cr(this._distance, this._startDistance)) < 0.1))
              return this._active = true, { zoomDelta: Cr(this._distance, i2), pinchAround: t2 };
          }
        }
        function Ir(e2, t2) {
          return 180 * e2.angleWith(t2) / Math.PI;
        }
        class Pr extends Tr {
          reset() {
            super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
          }
          _start(e2) {
            this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
          }
          _move(e2, t2) {
            const i2 = this._vector;
            if (this._vector = e2[0].sub(e2[1]), i2 && (this._active || !this._isBelowThreshold(this._vector)))
              return this._active = true, { bearingDelta: Ir(this._vector, i2), pinchAround: t2 };
          }
          _isBelowThreshold(e2) {
            this._minDiameter = Math.min(this._minDiameter, e2.mag());
            const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
            if (!i2)
              return false;
            const o2 = Ir(e2, i2);
            return Math.abs(o2) < t2;
          }
        }
        function Sr(e2) {
          return Math.abs(e2.y) > Math.abs(e2.x);
        }
        class Dr extends Tr {
          constructor(e2) {
            super(), this._map = e2;
          }
          reset() {
            super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
          }
          _start(e2) {
            this._lastPoints = e2, Sr(e2[0].sub(e2[1])) && (this._valid = false);
          }
          _move(t2, i2, o2) {
            const r2 = this._lastPoints;
            if (!r2)
              return;
            const n3 = t2[0].sub(r2[0]), s4 = t2[1].sub(r2[1]);
            return this._map._cooperativeGestures && !e.isFullscreen() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n3, s4, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t2, this._active = true, { pitchDelta: (n3.y + s4.y) / 2 * -0.5 });
          }
          gestureBeginsVertically(e2, t2, i2) {
            if (void 0 !== this._valid)
              return this._valid;
            const o2 = e2.mag() >= 2, r2 = t2.mag() >= 2;
            if (!o2 && !r2)
              return;
            if (!o2 || !r2)
              return null == this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
            const n3 = e2.y > 0 == t2.y > 0;
            return Sr(e2) && Sr(t2) && n3;
          }
        }
        const Lr = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Ar {
          constructor() {
            const e2 = Lr;
            this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          keydown(e2) {
            if (e2.altKey || e2.ctrlKey || e2.metaKey)
              return;
            let t2 = 0, i2 = 0, o2 = 0, r2 = 0, n3 = 0;
            switch (e2.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                t2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                t2 = -1;
                break;
              case 37:
                e2.shiftKey ? i2 = -1 : (e2.preventDefault(), r2 = -1);
                break;
              case 39:
                e2.shiftKey ? i2 = 1 : (e2.preventDefault(), r2 = 1);
                break;
              case 38:
                e2.shiftKey ? o2 = 1 : (e2.preventDefault(), n3 = -1);
                break;
              case 40:
                e2.shiftKey ? o2 = -1 : (e2.preventDefault(), n3 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (s4) => {
              const a2 = s4.getZoom();
              s4.easeTo({ duration: 300, easeId: "keyboardHandler", easing: zr, zoom: t2 ? Math.round(a2) + t2 * (e2.shiftKey ? 2 : 1) : a2, bearing: s4.getBearing() + i2 * this._bearingStep, pitch: s4.getPitch() + o2 * this._pitchStep, offset: [-r2 * this._panStep, -n3 * this._panStep], center: s4.getCenter() }, { originalEvent: e2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function zr(e2) {
          return e2 * (2 - e2);
        }
        const Rr = 4.000244140625;
        class Or {
          constructor(t2, i2) {
            this._map = t2, this._el = t2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
          }
          setZoomRate(e2) {
            this._defaultZoomRate = e2;
          }
          setWheelZoomRate(e2) {
            this._wheelZoomRate = e2;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e2) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
          }
          disable() {
            this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
          }
          wheel(t2) {
            if (!this.isEnabled())
              return;
            if (this._map._cooperativeGestures) {
              if (!(t2.ctrlKey || t2.metaKey || this.isZooming() || e.isFullscreen()))
                return void this._showBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            let i2 = t2.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
            const o2 = e.exported.now(), r2 = o2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o2, 0 !== i2 && i2 % Rr == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(r2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
          }
          _onTimeout(e2) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
          }
          _start(e2) {
            if (!this._delta)
              return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const t2 = p2(this._el, e2);
            this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId)
              return;
            if (this._frameId = null, !this.isActive())
              return;
            const t2 = this._map.transform;
            "wheel" === this._type && t2.projection.wrap && (t2._center.lng >= 180 || t2._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
            const i2 = () => t2._terrainEnabled() && this._aroundCoord ? t2.computeZoomRelativeTo(this._aroundCoord) : t2.zoom;
            if (0 !== this._delta) {
              const e2 = "wheel" === this._type && Math.abs(this._delta) > Rr ? this._wheelZoomRate : this._defaultZoomRate;
              let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
              this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
              const r3 = i2(), n4 = Math.pow(2, r3), s5 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : n4;
              this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(s5 * o3))), "wheel" === this._type && (this._startZoom = r3, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i2(), r2 = this._startZoom, n3 = this._easing;
            let s4, a2 = false;
            if ("wheel" === this._type && r2 && n3) {
              const t3 = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1), i3 = n3(t3);
              s4 = e.number(r2, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : a2 = true;
            } else
              s4 = o2, a2 = true;
            return this._active = true, a2 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !a2, zoomDelta: s4 - i2(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t2) {
            let i2 = e.ease;
            if (this._prevEase) {
              const t3 = this._prevEase, o2 = (e.exported.now() - t3.start) / t3.duration, r2 = t3.easing(o2 + 0.01) - t3.easing(o2), n3 = 0.27 / Math.sqrt(r2 * r2 + 1e-4) * 0.01, s4 = Math.sqrt(0.0729 - n3 * n3);
              i2 = e.bezier(n3, s4, 0.25, 1);
            }
            return this._prevEase = { start: e.exported.now(), duration: t2, easing: i2 }, i2;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          _addScrollZoomBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = n2("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
            }, 200);
          }
        }
        class Br {
          constructor(e2, t2) {
            this._clickZoom = e2, this._tapZoom = t2;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class kr {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          blur() {
            this.reset();
          }
          dblclick(e2, t2) {
            return e2.preventDefault(), { cameraAnimation: (i2) => {
              i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Fr {
          constructor() {
            this._tap = new mr({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
          }
          touchstart(e2, t2, i2) {
            this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t2, i2));
          }
          touchmove(e2, t2, i2) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i2[0].identifier !== this._swipeTouch)
                  return;
                const o2 = t2[0], r2 = o2.y - this._swipePoint.y;
                return this._swipePoint = o2, e2.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
              }
            } else
              this._tap.touchmove(e2, t2, i2);
          }
          touchend(e2, t2, i2) {
            this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e2, t2, i2) && (this._tapTime = e2.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ur {
          constructor(e2, t2, i2) {
            this._el = e2, this._mousePan = t2, this._touchPan = i2;
          }
          enable(e2) {
            this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Nr {
          constructor(e2, t2, i2) {
            this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class jr {
          constructor(e2, t2, i2, o2) {
            this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e2) {
            this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const Gr = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
        class Zr extends e.Event {
        }
        class Vr {
          constructor() {
            this.constants = [1, 1, 0.01], this.radius = 0;
          }
          setup(t2, i2) {
            const o2 = e.sub([], i2, t2);
            this.radius = e.length(o2[2] < 0 ? e.div([], o2, this.constants) : [o2[0], o2[1], 0]);
          }
          projectRay(t2) {
            e.div(t2, t2, this.constants), e.normalize(t2, t2), e.mul$1(t2, t2, this.constants);
            const i2 = e.scale$2([], t2, this.radius);
            if (i2[2] > 0) {
              const t3 = e.scale$2([], [0, 0, 1], e.dot(i2, [0, 0, 1])), o2 = e.scale$2([], e.normalize([], [i2[0], i2[1], 0]), this.radius), r2 = e.add([], i2, e.scale$2([], e.sub([], e.add([], o2, t3), i2), 2));
              i2[0] = r2[0], i2[1] = r2[1];
            }
            return i2;
          }
        }
        function Wr(e2) {
          return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
        }
        class Xr {
          constructor(t2, i2) {
            this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new rr(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Vr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.bindAll(["handleEvent", "handleWindowEvent"], this);
            const o2 = this._el;
            this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [e.window.document, "mousemove", { capture: true }], [e.window.document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [e.window, "blur", void 0]];
            for (const [t3, i3, o3] of this._listeners)
              t3.addEventListener(i3, t3 === e.window.document ? this.handleWindowEvent : this.handleEvent, o3);
          }
          destroy() {
            for (const [t2, i2, o2] of this._listeners)
              t2.removeEventListener(i2, t2 === e.window.document ? this.handleWindowEvent : this.handleEvent, o2);
          }
          _addDefaultHandlers(e2) {
            const t2 = this._map, i2 = t2.getCanvasContainer();
            this._add("mapEvent", new hr(t2, e2));
            const o2 = t2.boxZoom = new _r(t2, e2);
            this._add("boxZoom", o2);
            const r2 = new fr(), n3 = new kr();
            t2.doubleClickZoom = new Br(n3, r2), this._add("tapZoom", r2), this._add("clickZoom", n3);
            const s4 = new Fr();
            this._add("tapDragZoom", s4);
            const a2 = t2.touchPitch = new Dr(t2);
            this._add("touchPitch", a2);
            const l3 = new yr(e2), c4 = new br(e2);
            t2.dragRotate = new Nr(e2, l3, c4), this._add("mouseRotate", l3, ["mousePitch"]), this._add("mousePitch", c4, ["mouseRotate"]);
            const h3 = new xr(e2), u3 = new wr(t2, e2);
            t2.dragPan = new Ur(i2, h3, u3), this._add("mousePan", h3), this._add("touchPan", u3, ["touchZoom", "touchRotate"]);
            const _2 = new Pr(), d3 = new Mr();
            t2.touchZoomRotate = new jr(i2, d3, _2, s4), this._add("touchRotate", _2, ["touchPan", "touchZoom"]), this._add("touchZoom", d3, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new ur(t2));
            const p3 = t2.scrollZoom = new Or(t2, this);
            this._add("scrollZoom", p3, ["mousePan"]);
            const m3 = t2.keyboard = new Ar();
            this._add("keyboard", m3);
            for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
              e2.interactive && e2[i3] && t2[i3].enable(e2[i3]);
          }
          _add(e2, t2, i2) {
            this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
          }
          stop(e2) {
            if (!this._updatingCamera) {
              for (const { handler: e3 } of this._handlers)
                e3.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e2 } of this._handlers)
              if (e2.isActive())
                return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Gr(this._eventsInProgress) || this.isZooming();
          }
          _isDragging() {
            return !!this._eventsInProgress.drag;
          }
          _blockedByActive(e2, t2, i2) {
            for (const o2 in e2)
              if (o2 !== i2 && (!t2 || t2.indexOf(o2) < 0))
                return true;
            return false;
          }
          handleWindowEvent(e2) {
            this.handleEvent(e2, `${e2.type}Window`);
          }
          _getMapTouches(e2) {
            const t2 = [];
            for (const i2 of e2)
              this._el.contains(i2.target) && t2.push(i2);
            return t2;
          }
          handleEvent(e2, t2) {
            this._updatingCamera = true;
            const i2 = "renderFrame" === e2.type, o2 = i2 ? void 0 : e2, r2 = { needsRenderFrame: false }, n3 = {}, s4 = {}, a2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, l3 = a2 ? m2(this._el, a2) : i2 ? void 0 : p2(this._el, e2);
            for (const { handlerName: i3, handler: c5, allowed: h4 } of this._handlers) {
              if (!c5.isEnabled())
                continue;
              let u3;
              this._blockedByActive(s4, h4, i3) ? c5.reset() : c5[t2 || e2.type] && (u3 = c5[t2 || e2.type](e2, l3, a2), this.mergeHandlerResult(r2, n3, u3, i3, o2), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || c5.isActive()) && (s4[i3] = c5);
            }
            const c4 = {};
            for (const e3 in this._previousActiveHandlers)
              s4[e3] || (c4[e3] = o2);
            this._previousActiveHandlers = s4, (Object.keys(c4).length || Wr(r2)) && (this._changes.push([r2, n3, c4]), this._triggerRenderFrame()), (Object.keys(s4).length || Wr(r2)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: h3 } = r2;
            h3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h3(this._map));
          }
          mergeHandlerResult(t2, i2, o2, r2, n3) {
            if (!o2)
              return;
            e.extend(t2, o2);
            const s4 = { handlerName: r2, originalEvent: o2.originalEvent || n3 };
            void 0 !== o2.zoomDelta && (i2.zoom = s4), void 0 !== o2.panDelta && (i2.drag = s4), void 0 !== o2.pitchDelta && (i2.pitch = s4), void 0 !== o2.bearingDelta && (i2.rotate = s4);
          }
          _applyChanges() {
            const t2 = {}, i2 = {}, o2 = {};
            for (const [r2, n3, s4] of this._changes)
              r2.panDelta && (t2.panDelta = (t2.panDelta || new e.Point(0, 0))._add(r2.panDelta)), r2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + r2.zoomDelta), r2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + r2.bearingDelta), r2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + r2.pitchDelta), void 0 !== r2.around && (t2.around = r2.around), void 0 !== r2.aroundCoord && (t2.aroundCoord = r2.aroundCoord), void 0 !== r2.pinchAround && (t2.pinchAround = r2.pinchAround), r2.noInertia && (t2.noInertia = r2.noInertia), e.extend(i2, n3), e.extend(o2, s4);
            this._updateMapTransform(t2, i2, o2), this._changes = [];
          }
          _updateMapTransform(t2, i2, o2) {
            const r2 = this._map, n3 = r2.transform, s4 = (e2) => [e2.x, e2.y, e2.z];
            if (((e2) => {
              const t3 = this._eventsInProgress.drag;
              return t3 && !this._handlersById[t3.handlerName].isActive();
            })() && !Wr(t2)) {
              const e2 = n3.zoom;
              n3.cameraElevationReference = "sea", n3.recenterOnTerrain(), n3.cameraElevationReference = "ground", e2 !== n3.zoom && this._map._update(true);
            }
            if (n3._isCameraConstrained && r2._stop(true), !Wr(t2))
              return void this._fireEvents(i2, o2, true);
            let { panDelta: a2, zoomDelta: l3, bearingDelta: c4, pitchDelta: h3, around: u3, aroundCoord: _2, pinchAround: d3 } = t2;
            n3._isCameraConstrained && (l3 > 0 && (l3 = 0), n3._isCameraConstrained = false), void 0 !== d3 && (u3 = d3), (l3 || ((e2) => i2[e2] && !this._eventsInProgress[e2])("drag")) && u3 && (this._dragOrigin = s4(n3.pointCoordinate3D(u3)), this._trackingEllipsoid.setup(n3._camera.position, this._dragOrigin)), n3.cameraElevationReference = "sea", r2._stop(true), u3 = u3 || r2.transform.centerPoint, c4 && (n3.bearing += c4), h3 && (n3.pitch += h3), n3._updateCameraState();
            const p3 = [0, 0, 0];
            if (a2)
              if ("mercator" === n3.projection.name) {
                const e2 = this._trackingEllipsoid.projectRay(n3.screenPointToMercatorRay(u3).dir), t3 = this._trackingEllipsoid.projectRay(n3.screenPointToMercatorRay(u3.sub(a2)).dir);
                p3[0] = t3[0] - e2[0], p3[1] = t3[1] - e2[1];
              } else {
                const t3 = n3.pointCoordinate(u3);
                if ("globe" === n3.projection.name) {
                  a2 = a2.rotate(-n3.angle);
                  const i3 = n3._pixelsPerMercatorPixel / n3.worldSize;
                  p3[0] = -a2.x * e.mercatorScale(e.latFromMercatorY(t3.y)) * i3, p3[1] = -a2.y * e.mercatorScale(n3.center.lat) * i3;
                } else {
                  const e2 = n3.pointCoordinate(u3.sub(a2));
                  t3 && e2 && (p3[0] = e2.x - t3.x, p3[1] = e2.y - t3.y);
                }
              }
            const m3 = n3.zoom, f2 = [0, 0, 0];
            if (l3) {
              const t3 = s4(_2 || n3.pointCoordinate3D(u3)), i3 = { dir: e.normalize([], e.sub([], t3, n3._camera.position)) };
              if (i3.dir[2] < 0) {
                const o3 = n3.zoomDeltaToMovement(t3, l3);
                e.scale$2(f2, i3.dir, o3);
              }
            }
            const g2 = e.add(p3, p3, f2);
            n3._translateCameraConstrained(g2), l3 && Math.abs(n3.zoom - m3) > 1e-4 && n3.recenterOnTerrain(), n3.cameraElevationReference = "ground", this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(i2, o2, true);
          }
          _fireEvents(t2, i2, o2) {
            const r2 = Gr(this._eventsInProgress), n3 = Gr(t2), s4 = {};
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._eventsInProgress[e2] || (s4[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
            }
            !r2 && n3 && this._fireEvent("movestart", n3.originalEvent);
            for (const e2 in s4)
              this._fireEvent(e2, s4[e2]);
            n3 && this._fireEvent("move", n3.originalEvent);
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._fireEvent(e2, i3);
            }
            const a2 = {};
            let l3;
            for (const e2 in this._eventsInProgress) {
              const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e2];
              this._handlersById[t3].isActive() || (delete this._eventsInProgress[e2], l3 = i2[t3] || o3, a2[`${e2}end`] = l3);
            }
            for (const e2 in a2)
              this._fireEvent(e2, a2[e2]);
            const c4 = Gr(this._eventsInProgress);
            if (o2 && (r2 || n3) && !c4) {
              this._updatingCamera = true;
              const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e2) => 0 !== e2 && -this._bearingSnap < e2 && e2 < this._bearingSnap;
              t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l3 })) : (this._map.fire(new e.Event("moveend", { originalEvent: l3 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
            }
          }
          _fireEvent(t2, i2) {
            this._map.fire(new e.Event(t2, i2 ? { originalEvent: i2 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
              this._frameId = void 0, this.handleEvent(new Zr("renderFrame", { timeStamp: e2 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        const qr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class $r extends e.Evented {
          constructor(t2, i2) {
            super(), this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = i2.bearingSnap, this._respectPrefersReducedMotion = false !== i2.respectPrefersReducedMotion, e.bindAll(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new e.LngLat(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e2, t2) {
            return this.jumpTo({ center: e2 }, t2);
          }
          panBy(t2, i2, o2) {
            return t2 = e.Point.convert(t2).mult(-1), this.panTo(this.transform.center, e.extend({ offset: t2 }, i2), o2);
          }
          panTo(t2, i2, o2) {
            return this.easeTo(e.extend({ center: t2 }, i2), o2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e2, t2) {
            return this.jumpTo({ zoom: e2 }, t2), this;
          }
          zoomTo(t2, i2, o2) {
            return this.easeTo(e.extend({ zoom: t2 }, i2), o2);
          }
          zoomIn(e2, t2) {
            return this.zoomTo(this.getZoom() + 1, e2, t2), this;
          }
          zoomOut(e2, t2) {
            return this.zoomTo(this.getZoom() - 1, e2, t2), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e2, t2) {
            return this.jumpTo({ bearing: e2 }, t2), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e2, t2) {
            return this.jumpTo({ padding: e2 }, t2), this;
          }
          rotateTo(t2, i2, o2) {
            return this.easeTo(e.extend({ bearing: t2 }, i2), o2);
          }
          resetNorth(t2, i2) {
            return this.rotateTo(0, e.extend({ duration: 1e3 }, t2), i2), this;
          }
          resetNorthPitch(t2, i2) {
            return this.easeTo(e.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
          }
          snapToNorth(e2, t2) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e2, t2) {
            return this.jumpTo({ pitch: e2 }, t2), this;
          }
          cameraForBounds(t2, i2) {
            t2 = e.LngLatBounds.convert(t2);
            const o2 = i2 && i2.bearing || 0, r2 = i2 && i2.pitch || 0, n3 = t2.getNorthWest(), s4 = t2.getSouthEast();
            return this._cameraForBounds(this.transform, n3, s4, o2, r2, i2);
          }
          _extendCameraOptions(t2) {
            const i2 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (t2 = e.extend({ padding: i2, offset: [0, 0], maxZoom: this.transform.maxZoom }, t2)).padding) {
              const e2 = t2.padding;
              t2.padding = { top: e2, bottom: e2, right: e2, left: e2 };
            }
            return t2.padding = e.extend(i2, t2.padding), t2;
          }
          _minimumAABBFrustumDistance(e2, t2) {
            const i2 = t2.max[0] - t2.min[0], o2 = t2.max[1] - t2.min[1];
            return i2 / o2 > e2.aspect ? i2 / (2 * Math.tan(0.5 * e2.fovX) * e2.aspect) : o2 / (2 * Math.tan(0.5 * e2.fovY) * e2.aspect);
          }
          _cameraForBoundsOnGlobe(t2, i2, o2, r2, n3, s4) {
            const a2 = t2.clone(), l3 = this._extendCameraOptions(s4);
            a2.bearing = r2, a2.pitch = n3;
            const c4 = e.LngLat.convert(i2), h3 = e.LngLat.convert(o2), u3 = 0.5 * (c4.lat + h3.lat), _2 = 0.5 * (c4.lng + h3.lng), d3 = e.latLngToECEF(u3, _2), p3 = e.normalize([], d3), m3 = e.normalize([], e.cross([], p3, [0, 1, 0])), f2 = e.cross([], m3, p3), g2 = [m3[0], m3[1], m3[2], 0, f2[0], f2[1], f2[2], 0, p3[0], p3[1], p3[2], 0, 0, 0, 0, 1], v4 = [d3, e.latLngToECEF(c4.lat, c4.lng), e.latLngToECEF(h3.lat, c4.lng), e.latLngToECEF(h3.lat, h3.lng), e.latLngToECEF(c4.lat, h3.lng), e.latLngToECEF(u3, c4.lng), e.latLngToECEF(u3, h3.lng), e.latLngToECEF(c4.lat, _2), e.latLngToECEF(h3.lat, _2)];
            let x2 = e.Aabb.fromPoints(v4.map((t3) => [e.dot(m3, t3), e.dot(f2, t3), e.dot(p3, t3)]));
            const y2 = e.transformMat4([], x2.center, g2);
            0 === e.squaredLength(y2) && e.set(y2, 0, 0, 1), e.normalize(y2, y2), e.scale$2(y2, y2, e.GLOBE_RADIUS), a2.center = e.ecefToLatLng(y2);
            const b3 = a2.getWorldToCameraMatrix(), w2 = e.invert(new Float64Array(16), b3);
            x2 = e.Aabb.applyTransform(x2, e.multiply([], b3, g2)), e.transformMat4(y2, y2, b3);
            const T3 = 0.5 * (x2.max[2] - x2.min[2]), E2 = this._minimumAABBFrustumDistance(a2, x2), C3 = e.scale$2([], [0, 0, 1], T3), M2 = e.add(C3, y2, C3), I2 = E2 + (0 === a2.pitch ? 0 : e.distance(y2, M2)), P3 = a2.globeCenterInViewSpace, S2 = e.sub([], y2, [P3[0], P3[1], P3[2]]);
            e.normalize(S2, S2), e.scale$2(S2, S2, I2);
            const D2 = e.add([], y2, S2);
            e.transformMat4(D2, D2, w2);
            const L2 = e.earthRadius / e.GLOBE_RADIUS, A2 = e.length(D2), z2 = e.mercatorZfromAltitude(Math.max(A2 * L2 - e.earthRadius, Number.EPSILON), 0), R2 = Math.min(a2.zoomFromMercatorZAdjusted(z2), l3.maxZoom);
            return R2 > 0.5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a2.setProjection({ name: "mercator" }), a2.zoom = R2, this._cameraForBounds(a2, i2, o2, r2, n3, s4)) : { center: a2.center, zoom: R2, bearing: r2, pitch: n3 };
          }
          queryTerrainElevation(t2, i2) {
            const o2 = this.transform.elevation;
            return o2 ? (i2 = e.extend({}, { exaggerated: true }, i2), o2.getAtPoint(e.MercatorCoordinate.fromLngLat(t2), null, i2.exaggerated)) : null;
          }
          _cameraForBounds(t2, i2, o2, r2, n3, s4) {
            if ("globe" === t2.projection.name)
              return this._cameraForBoundsOnGlobe(t2, i2, o2, r2, n3, s4);
            const a2 = t2.clone(), l3 = this._extendCameraOptions(s4), c4 = a2.padding;
            a2.bearing = r2, a2.pitch = n3;
            const h3 = e.LngLat.convert(i2), u3 = e.LngLat.convert(o2), _2 = new e.LngLat(h3.lng, u3.lat), d3 = new e.LngLat(u3.lng, h3.lat), p3 = a2.project(h3), m3 = a2.project(u3), f2 = this.queryTerrainElevation(h3), g2 = this.queryTerrainElevation(u3), v4 = this.queryTerrainElevation(_2), x2 = this.queryTerrainElevation(d3), y2 = [[p3.x, p3.y, Math.min(f2 || 0, g2 || 0, v4 || 0, x2 || 0)], [m3.x, m3.y, Math.max(f2 || 0, g2 || 0, v4 || 0, x2 || 0)]];
            let b3 = e.Aabb.fromPoints(y2);
            const w2 = a2.getWorldToCameraMatrix(), T3 = e.invert(new Float64Array(16), w2);
            b3 = e.Aabb.applyTransform(b3, w2);
            const E2 = e.sub([], b3.max, b3.min), C3 = c4.left || 0, M2 = c4.right || 0, I2 = c4.bottom || 0, P3 = c4.top || 0, { left: S2, right: D2, top: L2, bottom: A2 } = l3.padding, z2 = 0.5 * (C3 + M2), R2 = 0.5 * (P3 + I2), O2 = Math.min(a2.scaleZoom(a2.scale * Math.min((a2.width - (C3 + M2 + S2 + D2)) / E2[0], (a2.height - (I2 + P3 + A2 + L2)) / E2[1])), l3.maxZoom), B2 = a2.scale / a2.zoomScale(O2);
            b3 = new e.Aabb([b3.min[0] - (S2 + z2) * B2, b3.min[1] - (A2 + R2) * B2, b3.min[2]], [b3.max[0] + (D2 + z2) * B2, b3.max[1] + (L2 + R2) * B2, b3.max[2]]);
            const k2 = 0.5 * E2[2], F2 = this._minimumAABBFrustumDistance(a2, b3), U2 = [0, 0, 1, 0];
            e.transformMat4$1(U2, U2, w2), e.normalize$2(U2, U2);
            const N2 = e.scale$2([], U2, F2 + k2), j2 = e.add([], b3.center, N2), G2 = ("number" == typeof l3.offset.x && "number" == typeof l3.offset.y ? new e.Point(l3.offset.x, l3.offset.y) : e.Point.convert(l3.offset)).rotate(-e.degToRad(r2));
            b3.center[0] -= G2.x * B2, b3.center[1] += G2.y * B2, e.transformMat4(b3.center, b3.center, T3), e.transformMat4(j2, j2, T3);
            const Z2 = [b3.center[0], b3.center[1], j2[2] * a2.pixelsPerMeter];
            e.scale$2(Z2, Z2, 1 / a2.worldSize);
            const V2 = e.lngFromMercatorX(Z2[0]), W2 = e.latFromMercatorY(Z2[1]), X2 = Math.min(a2._zoomFromMercatorZ(Z2[2]), l3.maxZoom), q2 = new e.LngLat(V2, W2);
            return a2.mercatorFromTransition && X2 < 0.5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a2.setProjection({ name: "globe" }), a2.zoom = X2, this._cameraForBounds(a2, i2, o2, r2, n3, s4)) : { center: q2, zoom: X2, bearing: r2, pitch: n3 };
          }
          fitBounds(e2, t2, i2) {
            const o2 = this.cameraForBounds(e2, t2);
            return this._fitInternal(o2, t2, i2);
          }
          fitScreenCoordinates(t2, i2, o2, r2, n3) {
            const s4 = e.Point.convert(t2), a2 = e.Point.convert(i2), l3 = new e.Point(Math.min(s4.x, a2.x), Math.min(s4.y, a2.y)), c4 = new e.Point(Math.max(s4.x, a2.x), Math.max(s4.y, a2.y));
            if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s4, a2))
              return this;
            const h3 = this.transform.pointLocation3D(l3), u3 = this.transform.pointLocation3D(c4), _2 = this.transform.pointLocation3D(new e.Point(l3.x, c4.y)), d3 = this.transform.pointLocation3D(new e.Point(c4.x, l3.y)), p3 = [Math.min(h3.lng, u3.lng, _2.lng, d3.lng), Math.min(h3.lat, u3.lat, _2.lat, d3.lat)], m3 = [Math.max(h3.lng, u3.lng, _2.lng, d3.lng), Math.max(h3.lat, u3.lat, _2.lat, d3.lat)], f2 = r2 && r2.pitch ? r2.pitch : this.getPitch(), g2 = this._cameraForBounds(this.transform, p3, m3, o2, f2, r2);
            return this._fitInternal(g2, r2, n3);
          }
          _fitInternal(t2, i2, o2) {
            return t2 ? (delete (i2 = e.extend(t2, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
          }
          jumpTo(t2, i2) {
            this.stop();
            const o2 = t2.preloadOnly ? this.transform.clone() : this.transform;
            let r2 = false, n3 = false, s4 = false;
            return "zoom" in t2 && o2.zoom !== +t2.zoom && (r2 = true, o2.zoom = +t2.zoom), void 0 !== t2.center && (o2.center = e.LngLat.convert(t2.center)), "bearing" in t2 && o2.bearing !== +t2.bearing && (n3 = true, o2.bearing = +t2.bearing), "pitch" in t2 && o2.pitch !== +t2.pitch && (s4 = true, o2.pitch = +t2.pitch), null == t2.padding || o2.isPaddingEqual(t2.padding) || (o2.padding = t2.padding), t2.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), r2 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), n3 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), s4 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)));
          }
          getFreeCameraOptions() {
            return this.transform.projection.supportsFreeCamera || e.warnOnce(qr), this.transform.getFreeCameraOptions();
          }
          setFreeCameraOptions(t2, i2) {
            const o2 = this.transform;
            if (!o2.projection.supportsFreeCamera)
              return e.warnOnce(qr), this;
            this.stop();
            const r2 = o2.zoom, n3 = o2.pitch, s4 = o2.bearing;
            o2.setFreeCameraOptions(t2);
            const a2 = r2 !== o2.zoom, l3 = n3 !== o2.pitch, c4 = s4 !== o2.bearing;
            return this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), a2 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), c4 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), l3 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)), this;
          }
          easeTo(t2, i2) {
            this._stop(false, t2.easeId), (false === (t2 = e.extend({ offset: [0, 0], duration: 500, easing: e.ease }, t2)).animate || this._prefersReducedMotion(t2)) && (t2.duration = 0);
            const o2 = this.transform, r2 = this.getZoom(), n3 = this.getBearing(), s4 = this.getPitch(), a2 = this.getPadding(), l3 = "zoom" in t2 ? +t2.zoom : r2, c4 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n3) : n3, h3 = "pitch" in t2 ? +t2.pitch : s4, u3 = "padding" in t2 ? t2.padding : o2.padding, _2 = e.Point.convert(t2.offset);
            let d3, p3, m3;
            if ("globe" === o2.projection.name) {
              const i3 = e.MercatorCoordinate.fromLngLat(o2.center), r3 = _2.rotate(-o2.angle);
              i3.x += r3.x / o2.worldSize, i3.y += r3.y / o2.worldSize;
              const n4 = i3.toLngLat(), s5 = e.LngLat.convert(t2.center || n4);
              this._normalizeCenter(s5), d3 = o2.centerPoint.add(r3), p3 = new e.Point(i3.x, i3.y).mult(o2.worldSize), m3 = new e.Point(e.mercatorXfromLng(s5.lng), e.mercatorYfromLat(s5.lat)).mult(o2.worldSize).sub(p3);
            } else {
              d3 = o2.centerPoint.add(_2);
              const i3 = o2.pointLocation(d3), r3 = e.LngLat.convert(t2.center || i3);
              this._normalizeCenter(r3), p3 = o2.project(i3), m3 = o2.project(r3).sub(p3);
            }
            const f2 = o2.zoomScale(l3 - r2);
            let g2, v4;
            t2.around && (g2 = e.LngLat.convert(t2.around), v4 = o2.locationPoint(g2));
            const x2 = this._zooming || l3 !== r2, y2 = this._rotating || n3 !== c4, b3 = this._pitching || h3 !== s4, w2 = !o2.isPaddingEqual(u3), T3 = (o3) => (T4) => {
              if (x2 && (o3.zoom = e.number(r2, l3, T4)), y2 && (o3.bearing = e.number(n3, c4, T4)), b3 && (o3.pitch = e.number(s4, h3, T4)), w2 && (o3.interpolatePadding(a2, u3, T4), d3 = o3.centerPoint.add(_2)), g2)
                o3.setLocationAtPoint(g2, v4);
              else {
                const e2 = o3.zoomScale(o3.zoom - r2), t3 = l3 > r2 ? Math.min(2, f2) : Math.max(0.5, f2), i3 = Math.pow(t3, 1 - T4), n4 = o3.unproject(p3.add(m3.mult(T4 * i3)).mult(e2));
                o3.setLocationAtPoint(o3.renderWorldCopies ? n4.wrap() : n4, d3);
              }
              return t2.preloadOnly || this._fireMoveEvents(i2), o3;
            };
            if (t2.preloadOnly) {
              const e2 = this._emulate(T3, t2.duration, o2);
              return this._preloadTiles(e2), this;
            }
            const E2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = x2, this._rotating = y2, this._pitching = b3, this._padding = w2, this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, E2), this._ease(T3(o2), (e2) => {
              o2.recenterOnTerrain(), this._afterEase(i2, e2);
            }, t2), this;
          }
          _prepareEase(t2, i2, o2 = {}) {
            this._moving = true, this.transform.cameraElevationReference = "sea", i2 || o2.moving || this.fire(new e.Event("movestart", t2)), this._zooming && !o2.zooming && this.fire(new e.Event("zoomstart", t2)), this._rotating && !o2.rotating && this.fire(new e.Event("rotatestart", t2)), this._pitching && !o2.pitching && this.fire(new e.Event("pitchstart", t2));
          }
          _fireMoveEvents(t2) {
            this.fire(new e.Event("move", t2)), this._zooming && this.fire(new e.Event("zoom", t2)), this._rotating && this.fire(new e.Event("rotate", t2)), this._pitching && this.fire(new e.Event("pitch", t2));
          }
          _afterEase(t2, i2) {
            if (this._easeId && i2 && this._easeId === i2)
              return;
            this._easeId = void 0, this.transform.cameraElevationReference = "ground";
            const o2 = this._zooming, r2 = this._rotating, n3 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e.Event("zoomend", t2)), r2 && this.fire(new e.Event("rotateend", t2)), n3 && this.fire(new e.Event("pitchend", t2)), this.fire(new e.Event("moveend", t2));
          }
          flyTo(t2, i2) {
            if (this._prefersReducedMotion(t2)) {
              const o3 = e.pick(t2, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(o3, i2);
            }
            this.stop(), t2 = e.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease }, t2);
            const o2 = this.transform, r2 = this.getZoom(), n3 = this.getBearing(), s4 = this.getPitch(), a2 = this.getPadding(), l3 = "zoom" in t2 ? e.clamp(+t2.zoom, o2.minZoom, o2.maxZoom) : r2, c4 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n3) : n3, h3 = "pitch" in t2 ? +t2.pitch : s4, u3 = "padding" in t2 ? t2.padding : o2.padding, _2 = o2.zoomScale(l3 - r2), d3 = e.Point.convert(t2.offset);
            let p3 = o2.centerPoint.add(d3);
            const m3 = o2.pointLocation(p3), f2 = e.LngLat.convert(t2.center || m3);
            this._normalizeCenter(f2);
            const g2 = o2.project(m3), v4 = o2.project(f2).sub(g2);
            let x2 = t2.curve;
            const y2 = Math.max(o2.width, o2.height), b3 = y2 / _2, w2 = v4.mag();
            if ("minZoom" in t2) {
              const i3 = e.clamp(Math.min(t2.minZoom, r2, l3), o2.minZoom, o2.maxZoom), n4 = y2 / o2.zoomScale(i3 - r2);
              x2 = Math.sqrt(n4 / w2 * 2);
            }
            const T3 = x2 * x2;
            function E2(e2) {
              const t3 = (b3 * b3 - y2 * y2 + (e2 ? -1 : 1) * T3 * T3 * w2 * w2) / (2 * (e2 ? b3 : y2) * T3 * w2);
              return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
            }
            function C3(e2) {
              return (Math.exp(e2) - Math.exp(-e2)) / 2;
            }
            function M2(e2) {
              return (Math.exp(e2) + Math.exp(-e2)) / 2;
            }
            const I2 = E2(0);
            let P3 = function(e2) {
              return M2(I2) / M2(I2 + x2 * e2);
            }, S2 = function(e2) {
              return y2 * ((M2(I2) * (C3(t3 = I2 + x2 * e2) / M2(t3)) - C3(I2)) / T3) / w2;
              var t3;
            }, D2 = (E2(1) - I2) / x2;
            if (Math.abs(w2) < 1e-6 || !isFinite(D2)) {
              if (Math.abs(y2 - b3) < 1e-6)
                return this.easeTo(t2, i2);
              const e2 = b3 < y2 ? -1 : 1;
              D2 = Math.abs(Math.log(b3 / y2)) / x2, S2 = function() {
                return 0;
              }, P3 = function(t3) {
                return Math.exp(e2 * x2 * t3);
              };
            }
            t2.duration = "duration" in t2 ? +t2.duration : 1e3 * D2 / ("screenSpeed" in t2 ? +t2.screenSpeed / x2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0);
            const L2 = n3 !== c4, A2 = h3 !== s4, z2 = !o2.isPaddingEqual(u3), R2 = (o3) => (_3) => {
              const m4 = _3 * D2, x3 = 1 / P3(m4);
              o3.zoom = 1 === _3 ? l3 : r2 + o3.scaleZoom(x3), L2 && (o3.bearing = e.number(n3, c4, _3)), A2 && (o3.pitch = e.number(s4, h3, _3)), z2 && (o3.interpolatePadding(a2, u3, _3), p3 = o3.centerPoint.add(d3));
              const y3 = 1 === _3 ? f2 : o3.unproject(g2.add(v4.mult(S2(m4))).mult(x3));
              return o3.setLocationAtPoint(o3.renderWorldCopies ? y3.wrap() : y3, p3), o3._updateCameraOnTerrain(), t2.preloadOnly || this._fireMoveEvents(i2), o3;
            };
            if (t2.preloadOnly) {
              const e2 = this._emulate(R2, t2.duration, o2);
              return this._preloadTiles(e2), this;
            }
            return this._zooming = true, this._rotating = L2, this._pitching = A2, this._padding = z2, this._prepareEase(i2, false), this._ease(R2(o2), () => this._afterEase(i2), t2), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e2, t2) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
              const e3 = this._onEaseEnd;
              this._onEaseEnd = void 0, e3.call(this, t2);
            }
            if (!e2) {
              const e3 = this.handlers;
              e3 && e3.stop(false);
            }
            return this;
          }
          _ease(t2, i2, o2) {
            false === o2.animate || 0 === o2.duration ? (t2(1), i2()) : (this._easeStart = e.exported.now(), this._easeOptions = o2, this._onEaseFrame = t2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const t2 = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
            i2 && i2(this._easeOptions.easing(t2)), t2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(t2, i2) {
            t2 = e.wrap(t2, -180, 180);
            const o2 = Math.abs(t2 - i2);
            return Math.abs(t2 - 360 - i2) < o2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < o2 && (t2 += 360), t2;
          }
          _normalizeCenter(e2) {
            const t2 = this.transform;
            if (!t2.renderWorldCopies || t2.maxBounds)
              return;
            const i2 = e2.lng - t2.center.lng;
            e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
          }
          _prefersReducedMotion(t2) {
            return this._respectPrefersReducedMotion && e.exported.prefersReducedMotion && !(t2 && t2.essential);
          }
          _emulate(e2, t2, i2) {
            const o2 = Math.ceil(15 * t2 / 1e3), r2 = [], n3 = e2(i2.clone());
            for (let e3 = 0; e3 <= o2; e3++) {
              const t3 = n3(e3 / o2);
              r2.push(t3.clone());
            }
            return r2;
          }
        }
        class Hr {
          constructor(t2 = {}) {
            this.options = t2, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e2) {
            const t2 = this.options && this.options.compact;
            return this._map = e2, this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n2("button", "mapboxgl-ctrl-attrib-button", this._container), n2("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n2("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e2, t2) {
            const i2 = this._map._getUIString(`AttributionControl.${t2}`);
            e2.setAttribute("aria-label", i2), e2.removeAttribute("title"), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
          }
          _toggleAttribution() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
          }
          _updateEditLink() {
            let t2 = this._editLink;
            t2 || (t2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN }];
            if (t2) {
              const o2 = i2.reduce((e2, t3, o3) => (t3.value && (e2 += `${t3.key}=${t3.value}${o3 < i2.length - 1 ? "&" : ""}`), e2), "?");
              t2.href = `${e.config.FEEDBACK_URL}/${o2}#${Jo(this._map, true)}`, t2.rel = "noopener nofollow", this._setElementTitle(t2, "MapFeedback");
            }
          }
          _updateData(e2) {
            !e2 || "metadata" !== e2.sourceDataType && "visibility" !== e2.sourceDataType && "style" !== e2.dataType || (this._updateAttributions(), this._updateEditLink());
          }
          _updateAttributions() {
            if (!this._map.style)
              return;
            let e2 = [];
            if (this._map.style.stylesheet) {
              const e3 = this._map.style.stylesheet;
              this.styleOwner = e3.owner, this.styleId = e3.id;
            }
            const t2 = this._map.style._sourceCaches;
            for (const i3 in t2) {
              const o2 = t2[i3];
              if (o2.used) {
                const t3 = o2.getSource();
                t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
              }
            }
            e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
              for (let o2 = i3 + 1; o2 < e2.length; o2++)
                if (e2[o2].indexOf(t3) >= 0)
                  return false;
              return true;
            }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = [...this.options.customAttribution, ...e2] : e2.unshift(this.options.customAttribution));
            const i2 = e2.join(" | ");
            i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          }
        }
        class Yr {
          constructor() {
            e.bindAll(["_updateLogo", "_updateCompact"], this);
          }
          onAdd(e2) {
            this._map = e2, this._container = n2("div", "mapboxgl-ctrl");
            const t2 = n2("a", "mapboxgl-ctrl-logo");
            return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _updateLogo(e2) {
            e2 && "metadata" !== e2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }
          _logoRequired() {
            if (!this._map.style)
              return true;
            const e2 = this._map.style._sourceCaches;
            if (0 === Object.entries(e2).length)
              return true;
            for (const t2 in e2) {
              const i2 = e2[t2].getSource();
              if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
                return false;
            }
            return true;
          }
          _updateCompact() {
            const e2 = this._container.children;
            if (e2.length) {
              const t2 = e2[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
            }
          }
        }
        class Kr {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e2) {
            const t2 = ++this._id;
            return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
          }
          remove(e2) {
            const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
            for (const t3 of i2)
              if (t3.id === e2)
                return void (t3.cancelled = true);
          }
          run(e2 = 0) {
            const t2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i2 of t2)
              if (!i2.cancelled && (i2.callback(e2), this._cleared))
                break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        function Jr(t2, i2, o2) {
          if (t2 = new e.LngLat(t2.lng, t2.lat), i2) {
            const r2 = new e.LngLat(t2.lng - 360, t2.lat), n3 = new e.LngLat(t2.lng + 360, t2.lat), s4 = 360 * Math.ceil(Math.abs(t2.lng - o2.center.lng) / 360), a2 = o2.locationPoint(t2).distSqr(i2), l3 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
            o2.locationPoint(r2).distSqr(i2) < a2 && (l3 || Math.abs(r2.lng - o2.center.lng) < s4) ? t2 = r2 : o2.locationPoint(n3).distSqr(i2) < a2 && (l3 || Math.abs(n3.lng - o2.center.lng) < s4) && (t2 = n3);
          }
          for (; Math.abs(t2.lng - o2.center.lng) > 180; ) {
            const e2 = o2.locationPoint(t2);
            if (e2.x >= 0 && e2.y >= 0 && e2.x <= o2.width && e2.y <= o2.height)
              break;
            t2.lng > o2.center.lng ? t2.lng -= 360 : t2.lng += 360;
          }
          return t2;
        }
        const Qr = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        class en extends e.Evented {
          constructor(t2, i2) {
            if (super(), (t2 instanceof e.window.HTMLElement || i2) && (t2 = e.extend({ element: t2 }, i2)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && t2.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t2 && t2.occludedOpacity || 0.2, t2 && t2.element)
              this._element = t2.element, this._offset = e.Point.convert(t2 && t2.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = n2("div");
              const i3 = 41, o3 = 27, r2 = s3("svg", { display: "block", height: i3 * this._scale + "px", width: o3 * this._scale + "px", viewBox: `0 0 ${o3} ${i3}` }, this._element), a2 = s3("radialGradient", { id: "shadowGradient" }, s3("defs", {}, r2));
              s3("stop", { offset: "10%", "stop-opacity": 0.4 }, a2), s3("stop", { offset: "100%", "stop-opacity": 0.05 }, a2), s3("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r2), s3("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r2), s3("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r2), s3("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r2), this._offset = e.Point.convert(t2 && t2.offset || [0, -14]);
            }
            this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
              e2.preventDefault();
            }), this._element.addEventListener("mousedown", (e2) => {
              e2.preventDefault();
            });
            const o2 = this._element.classList;
            for (const e2 in Qr)
              o2.remove(`mapboxgl-marker-anchor-${e2}`);
            o2.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
          }
          addTo(e2) {
            return e2 === this._map || (this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._updateMoving), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), e2.on("click", this._onMapClick)), this;
          }
          remove() {
            const e2 = this._map;
            return e2 && (e2.off("click", this._onMapClick), e2.off("move", this._updateMoving), e2.off("moveend", this._update), e2.off("mousedown", this._addDragHandler), e2.off("touchstart", this._addDragHandler), e2.off("mouseup", this._onUp), e2.off("touchend", this._onUp), e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove), e2.off("remove", this._clearFadeTimer), e2._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            return this._lngLat = e.LngLat.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e2) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
              if (!("offset" in e2.options)) {
                const t2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [o2, -1 * (t2 - i2 + o2)], "bottom-right": [-o2, -1 * (t2 - i2 + o2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
              }
              this._popup = e2, e2._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
            }
            return this;
          }
          _onKeyPress(e2) {
            const t2 = e2.code, i2 = e2.charCode || e2.keyCode;
            "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
          }
          _onMapClick(e2) {
            const t2 = e2.originalEvent.target, i2 = this._element;
            this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e2 = this._popup;
            return e2 ? (e2.isOpen() ? (e2.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e2.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
          }
          _behindTerrain() {
            const e2 = this._map, t2 = this._pos;
            if (!e2 || !t2)
              return false;
            const i2 = e2.unproject(t2), o2 = e2.getFreeCameraOptions();
            if (!o2.position)
              return false;
            const r2 = o2.position.toLngLat();
            return r2.distanceTo(i2) < 0.9 * r2.distanceTo(this._lngLat);
          }
          _evaluateOpacity() {
            const t2 = this._map;
            if (!t2)
              return;
            const i2 = this._pos;
            if (!i2 || i2.x < 0 || i2.x > t2.transform.width || i2.y < 0 || i2.y > t2.transform.height)
              return void this._clearFadeTimer();
            const o2 = t2.unproject(i2);
            let r2;
            t2._showingGlobe() && e.isLngLatBehindGlobe(t2.transform, this._lngLat) ? r2 = 0 : (r2 = 1 - t2._queryFogOpacity(o2), t2.transform._terrainEnabled() && t2.getTerrain() && this._behindTerrain() && (r2 *= this._occludedOpacity)), this._element.style.opacity = `${r2}`, this._element.style.pointerEvents = r2 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r2), this._fadeTimer = null;
          }
          _clearFadeTimer() {
            this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
          }
          _updateDOM() {
            const e2 = this._pos;
            if (!e2 || !this._map)
              return;
            const t2 = this._offset.mult(this._scale);
            this._element.style.transform = `
            translate(${e2.x}px,${e2.y}px)
            ${Qr[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t2.x}px,${t2.y}px)
        `;
          }
          _calculateXYTransform() {
            const t2 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
            if (!i2 || !t2 || "map" !== o2)
              return "";
            if (!i2._showingGlobe()) {
              const e2 = i2.getPitch();
              return e2 ? `rotateX(${e2}deg)` : "";
            }
            const r2 = e.radToDeg(e.globeTiltAtLngLat(i2.transform, this._lngLat)), n3 = t2.sub(e.globeCenterToScreenPoint(i2.transform)), s4 = Math.abs(n3.x) + Math.abs(n3.y);
            if (0 === s4)
              return "";
            const a2 = r2 / s4;
            return `rotateX(${-n3.y * a2}deg) rotateY(${n3.x * a2}deg)`;
          }
          _calculateZTransform() {
            const t2 = this._pos, i2 = this._map;
            if (!i2 || !t2)
              return "";
            let o2 = 0;
            const r2 = this.getRotationAlignment();
            if ("map" === r2)
              if (i2._showingGlobe()) {
                const t3 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat + 1e-3)), r3 = i2.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t3);
                o2 = e.radToDeg(Math.atan2(r3.y, r3.x)) - 90;
              } else
                o2 = -i2.getBearing();
            else if ("horizon" === r2) {
              const r3 = e.smoothstep(4, 6, i2.getZoom()), n3 = e.globeCenterToScreenPoint(i2.transform);
              n3.y += r3 * i2.transform.height;
              const s4 = t2.sub(n3), a2 = e.radToDeg(Math.atan2(s4.y, s4.x));
              o2 = (a2 > 90 ? a2 - 270 : a2 + 90) * (1 - r3);
            }
            return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
          }
          _update(t2) {
            e.window.cancelAnimationFrame(this._updateFrameId);
            const i2 = this._map;
            i2 && (i2.transform.renderWorldCopies && (this._lngLat = Jr(this._lngLat, this._pos, i2.transform)), this._pos = i2.project(this._lngLat), true === t2 ? this._updateFrameId = e.window.requestAnimationFrame(() => {
              this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
            }) : this._pos = this._pos.round(), i2._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i2._showingGlobe() || i2.getTerrain() || i2.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t2) {
            return this._offset = e.Point.convert(t2), this._update(), this;
          }
          _onMove(t2) {
            const i2 = this._map;
            if (!i2)
              return;
            const o2 = this._pointerdownPos, r2 = this._positionDelta;
            if (o2 && r2) {
              if (!this._isDragging) {
                const e2 = this._clickTolerance || i2._clickTolerance;
                if (t2.point.dist(o2) < e2)
                  return;
                this._isDragging = true;
              }
              this._pos = t2.point.sub(r2), this._lngLat = i2.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag"));
            }
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
            const t2 = this._map;
            t2 && (t2.off("mousemove", this._onMove), t2.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.Event("dragend")), this._state = "inactive";
          }
          _addDragHandler(e2) {
            const t2 = this._map, i2 = this._pos;
            t2 && i2 && this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(i2), this._pointerdownPos = e2.point, this._state = "pending", t2.on("mousemove", this._onMove), t2.on("touchmove", this._onMove), t2.once("mouseup", this._onUp), t2.once("touchend", this._onUp));
          }
          setDraggable(e2) {
            this._draggable = !!e2;
            const t2 = this._map;
            return t2 && (e2 ? (t2.on("mousedown", this._addDragHandler), t2.on("touchstart", this._addDragHandler)) : (t2.off("mousedown", this._addDragHandler), t2.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e2) {
            return this._rotation = e2 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e2) {
            return this._rotationAlignment = e2 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
          }
          setPitchAlignment(e2) {
            return this._pitchAlignment = e2 || "auto", this._update(), this;
          }
          getPitchAlignment() {
            return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
          }
          setOccludedOpacity(e2) {
            return this._occludedOpacity = e2 || 0.2, this._update(), this;
          }
          getOccludedOpacity() {
            return this._occludedOpacity;
          }
        }
        const tn = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, on = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function rn(t2 = new e.Point(0, 0), i2 = "bottom") {
          if ("number" == typeof t2) {
            const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t2, 2)));
            switch (i2) {
              case "top":
                return new e.Point(0, t2);
              case "top-left":
                return new e.Point(o2, o2);
              case "top-right":
                return new e.Point(-o2, o2);
              case "bottom":
                return new e.Point(0, -t2);
              case "bottom-left":
                return new e.Point(o2, -o2);
              case "bottom-right":
                return new e.Point(-o2, -o2);
              case "left":
                return new e.Point(t2, 0);
              case "right":
                return new e.Point(-t2, 0);
            }
            return new e.Point(0, 0);
          }
          return t2 instanceof e.Point || Array.isArray(t2) ? e.Point.convert(t2) : e.Point.convert(t2[i2] || [0, 0]);
        }
        class nn {
          constructor(e2) {
            this.jumpTo(e2);
          }
          getValue(t2) {
            if (t2 <= this._startTime)
              return this._start;
            if (t2 >= this._endTime)
              return this._end;
            const i2 = e.easeCubicInOut((t2 - this._startTime) / (this._endTime - this._startTime));
            return this._start * (1 - i2) + this._end * i2;
          }
          isEasing(e2) {
            return e2 >= this._startTime && e2 <= this._endTime;
          }
          jumpTo(e2) {
            this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
          }
          easeTo(e2, t2, i2) {
            this._start = this.getValue(t2), this._end = e2, this._startTime = t2, this._endTime = t2 + i2;
          }
        }
        const sn = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, an = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true }, ln = { showCompass: true, showZoom: true, visualizePitch: false };
        class cn {
          constructor(t2, i2, o2 = false) {
            this._clickTolerance = 10, this.element = i2, this.mouseRotate = new yr({ clickTolerance: t2.dragRotate._mouseRotate._clickTolerance }), this.map = t2, o2 && (this.mousePitch = new br({ clickTolerance: t2.dragRotate._mousePitch._clickTolerance })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
          }
          down(e2, t2) {
            this.mouseRotate.mousedown(e2, t2), this.mousePitch && this.mousePitch.mousedown(e2, t2), h2();
          }
          move(e2, t2) {
            const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e2, t2), r2 = o2 && o2.bearingDelta;
            if (r2 && i2.setBearing(i2.getBearing() + r2), this.mousePitch) {
              const o3 = this.mousePitch.mousemoveWindow(e2, t2), r3 = o3 && o3.pitchDelta;
              r3 && i2.setPitch(i2.getPitch() + r3);
            }
          }
          off() {
            const e2 = this.element;
            e2.removeEventListener("mousedown", this.mousedown), e2.removeEventListener("touchstart", this.touchstart, { passive: false }), e2.removeEventListener("touchmove", this.touchmove), e2.removeEventListener("touchend", this.touchend), e2.removeEventListener("touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            u2(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup);
          }
          mousedown(t2) {
            this.down(e.extend({}, t2, { ctrlKey: true, preventDefault: () => t2.preventDefault() }), p2(this.element, t2)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup);
          }
          mousemove(e2) {
            this.move(e2, p2(this.element, e2));
          }
          mouseup(e2) {
            this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
          }
          touchstart(e2) {
            1 !== e2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m2(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
          }
          touchmove(e2) {
            1 !== e2.targetTouches.length ? this.reset() : (this._lastPos = m2(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
          }
          touchend(e2) {
            0 === e2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        const hn = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, un = { maxWidth: 100, unit: "metric" }, _n = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, dn = { version: e.version, supported: i, setRTLTextPlugin: e.setRTLTextPlugin, getRTLTextPluginStatus: e.getRTLTextPluginStatus, Map: class extends $r {
          constructor(t2) {
            if (e.LivePerformanceUtils.mark(e.PerformanceMarkers.create), null != (t2 = e.extend({}, an, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != t2.minPitch && t2.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (null != t2.maxPitch && t2.maxPitch > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t2.antialias && e.isSafariWithAntialiasingBug(e.window) && (t2.antialias = false, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ho(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies), t2), this._interactive = t2.interactive, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._useWebGL2 = t2.useWebGL2, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._collectResourceTiming = t2.collectResourceTiming, this._optimizeForTerrain = t2.optimizeForTerrain, this._language = this._parseLanguage(t2.language), this._worldview = t2.worldview, this._renderTaskQueue = new Kr(), this._domRenderTaskQueue = new Kr(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, sn, t2.locale), this._clickTolerance = t2.clickTolerance, this._cooperativeGestures = t2.cooperativeGestures, this._performanceMetricsCollection = t2.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new nn(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new e.RequestManager(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, "string" == typeof t2.container) {
              if (this._container = e.window.document.getElementById(t2.container), !this._container)
                throw new Error(`Container '${t2.container}' not found.`);
            } else {
              if (!(t2.container instanceof e.window.HTMLElement))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = t2.container;
            }
            if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t2.maxBounds && this.setMaxBounds(t2.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
              throw new Error("Failed to initialize WebGL.");
            this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), void 0 !== e.window && (e.window.addEventListener("online", this._onWindowOnline, false), e.window.addEventListener("resize", this._onWindowResize, false), e.window.addEventListener("orientationchange", this._onWindowResize, false), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.addEventListener("visibilitychange", this._onVisibilityChange, false)), this.handlers = new Xr(this, t2), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, t2.style && this.setStyle(t2.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.projection && this.setProjection(t2.projection), this._hash = t2.hash && new Ko("string" == typeof t2.hash && t2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch }), t2.bounds && (this.resize(), this.fitBounds(t2.bounds, e.extend({}, t2.fitBoundsOptions, { duration: 0 })))), this.resize(), t2.attributionControl && this.addControl(new Hr({ customAttribution: t2.customAttribution })), this._logoControl = new Yr(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (t3) => {
              this._update("style" === t3.dataType), this.fire(new e.Event(`${t3.dataType}data`, t3));
            }), this.on("dataloading", (t3) => {
              this.fire(new e.Event(`${t3.dataType}dataloading`, t3));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t2, i2) {
            if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd)
              return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const o2 = t2.onAdd(this);
            this._controls.push(t2);
            const r2 = this._controlPositions[i2];
            return -1 !== i2.indexOf("bottom") ? r2.insertBefore(o2, r2.firstChild) : r2.appendChild(o2), this;
          }
          removeControl(t2) {
            if (!t2 || !t2.onRemove)
              return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i2 = this._controls.indexOf(t2);
            return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
          }
          hasControl(e2) {
            return this._controls.indexOf(e2) > -1;
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          resize(t2) {
            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
              return this;
            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
            const i2 = !this._moving;
            return i2 && this.fire(new e.Event("movestart", t2)).fire(new e.Event("move", t2)), this.fire(new e.Event("resize", t2)), i2 && this.fire(new e.Event("moveend", t2)), this;
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds() || null;
          }
          setMaxBounds(t2) {
            return this.transform.setMaxBounds(e.LngLatBounds.convert(t2)), this._update();
          }
          setMinZoom(t2) {
            if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
              return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 ? this.setZoom(t2) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t2) {
            if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom)
              return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 ? this.setZoom(t2) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t2) {
            if ((t2 = null == t2 ? 0 : t2) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t2 >= 0 && t2 <= this.transform.maxPitch)
              return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 ? this.setPitch(t2) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t2) {
            if ((t2 = null == t2 ? 85 : t2) > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t2 >= this.transform.minPitch)
              return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 ? this.setPitch(t2) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
            throw new Error("maxPitch must be greater than or equal to minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e2) {
            return this.transform.renderWorldCopies = e2, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
          }
          getLanguage() {
            return this._language;
          }
          _parseLanguage(t2) {
            return "auto" === t2 ? e.window.navigator.language : Array.isArray(t2) ? 0 === t2.length ? void 0 : t2.map((t3) => "auto" === t3 ? e.window.navigator.language : t3) : t2;
          }
          setLanguage(e2) {
            const t2 = this._parseLanguage(e2);
            if (!this.style || t2 === this._language)
              return this;
            this._language = t2, this.style._reloadSources();
            for (const e3 of this._controls)
              e3._setLanguage && e3._setLanguage(this._language);
            return this;
          }
          getWorldview() {
            return this._worldview;
          }
          setWorldview(e2) {
            return this.style && e2 !== this._worldview ? (this._worldview = e2, this.style._reloadSources(), this) : this;
          }
          getProjection() {
            return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
          }
          _showingGlobe() {
            return "globe" === this.transform.projection.name;
          }
          setProjection(e2) {
            return this._lazyInitEmptyStyle(), e2 ? "string" == typeof e2 && (e2 = { name: e2 }) : e2 = null, this._useExplicitProjection = !!e2, this._prioritizeAndUpdateProjection(e2, this.style.stylesheet ? this.style.stylesheet.projection : null);
          }
          _updateProjectionTransition() {
            if ("globe" !== this.getProjection().name)
              return;
            const t2 = this.transform, i2 = t2.projection.name;
            let o2;
            "globe" === i2 && t2.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? (t2.setMercatorFromTransition(), o2 = true) : "mercator" === i2 && t2.zoom < e.GLOBE_ZOOM_THRESHOLD_MAX && (t2.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
          }
          _prioritizeAndUpdateProjection(e2, t2) {
            return this._updateProjection(e2 || t2 || { name: "mercator" });
          }
          _updateProjection(t2) {
            let i2;
            if (i2 = "globe" === t2.name && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t2), this.style.applyProjectionUpdate(), i2) {
              this.painter.clearBackgroundTiles();
              for (const e2 in this.style._sourceCaches)
                this.style._sourceCaches[e2].clearTiles();
              this._update(true), this._forceMarkerAndPopupUpdate(true);
            }
            return this;
          }
          project(t2) {
            return this.transform.locationPoint3D(e.LngLat.convert(t2));
          }
          unproject(t2) {
            return this.transform.pointLocation3D(e.Point.convert(t2));
          }
          isMoving() {
            return this._moving || this.handlers && this.handlers.isMoving() || false;
          }
          isZooming() {
            return this._zooming || this.handlers && this.handlers.isZooming() || false;
          }
          isRotating() {
            return this._rotating || this.handlers && this.handlers.isRotating() || false;
          }
          _isDragging() {
            return this.handlers && this.handlers._isDragging() || false;
          }
          _createDelegatedListener(e2, t2, i2) {
            if ("mouseenter" === e2 || "mouseover" === e2) {
              let o2 = false;
              const r2 = (r3) => {
                const n4 = t2.filter((e3) => this.getLayer(e3)), s4 = n4.length ? this.queryRenderedFeatures(r3.point, { layers: n4 }) : [];
                s4.length ? o2 || (o2 = true, i2.call(this, new ar(e2, this, r3.originalEvent, { features: s4 }))) : o2 = false;
              }, n3 = () => {
                o2 = false;
              };
              return { layers: new Set(t2), listener: i2, delegates: { mousemove: r2, mouseout: n3 } };
            }
            if ("mouseleave" === e2 || "mouseout" === e2) {
              let o2 = false;
              const r2 = (r3) => {
                const n4 = t2.filter((e3) => this.getLayer(e3));
                (n4.length ? this.queryRenderedFeatures(r3.point, { layers: n4 }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new ar(e2, this, r3.originalEvent)));
              }, n3 = (t3) => {
                o2 && (o2 = false, i2.call(this, new ar(e2, this, t3.originalEvent)));
              };
              return { layers: new Set(t2), listener: i2, delegates: { mousemove: r2, mouseout: n3 } };
            }
            {
              const o2 = (e3) => {
                const o3 = t2.filter((e4) => this.getLayer(e4)), r2 = o3.length ? this.queryRenderedFeatures(e3.point, { layers: o3 }) : [];
                r2.length && (e3.features = r2, i2.call(this, e3), delete e3.features);
              };
              return { layers: new Set(t2), listener: i2, delegates: { [e2]: o2 } };
            }
          }
          on(e2, t2, i2) {
            if (void 0 === i2)
              return super.on(e2, t2);
            Array.isArray(t2) || (t2 = [t2]);
            const o2 = this._createDelegatedListener(e2, t2, i2);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(o2);
            for (const e3 in o2.delegates)
              this.on(e3, o2.delegates[e3]);
            return this;
          }
          once(e2, t2, i2) {
            if (void 0 === i2)
              return super.once(e2, t2);
            Array.isArray(t2) || (t2 = [t2]);
            const o2 = this._createDelegatedListener(e2, t2, i2);
            for (const e3 in o2.delegates)
              this.once(e3, o2.delegates[e3]);
            return this;
          }
          off(e2, t2, i2) {
            if (void 0 === i2)
              return super.off(e2, t2);
            t2 = new Set(Array.isArray(t2) ? t2 : [t2]);
            const o2 = (e3, t3) => {
              if (e3.size !== t3.size)
                return false;
              for (const i3 of e3)
                if (!t3.has(i3))
                  return false;
              return true;
            }, r2 = this._delegatedListeners ? this._delegatedListeners[e2] : void 0;
            return r2 && ((e3) => {
              for (let r3 = 0; r3 < e3.length; r3++) {
                const n3 = e3[r3];
                if (n3.listener === i2 && o2(n3.layers, t2)) {
                  for (const e4 in n3.delegates)
                    this.off(e4, n3.delegates[e4]);
                  return e3.splice(r3, 1), this;
                }
              }
            })(r2), this;
          }
          queryRenderedFeatures(t2, i2) {
            return this.style ? (void 0 !== i2 || void 0 === t2 || t2 instanceof e.Point || Array.isArray(t2) || (i2 = t2, t2 = void 0), this.style.queryRenderedFeatures(t2 = t2 || [[0, 0], [this.transform.width, this.transform.height]], i2 = i2 || {}, this.transform)) : [];
          }
          querySourceFeatures(e2, t2) {
            return this.style.querySourceFeatures(e2, t2);
          }
          isPointOnSurface(t2) {
            const { name: i2 } = this.transform.projection;
            return "globe" !== i2 && "mercator" !== i2 && e.warnOnce(`${i2} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.Point.convert(t2));
          }
          setStyle(t2, i2) {
            return false !== (i2 = e.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && i2.localFontFamily === this._localFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t2, i2));
          }
          _getUIString(e2) {
            const t2 = this._locale[e2];
            if (null == t2)
              throw new Error(`Missing UI string '${e2}'`);
            return t2;
          }
          _updateStyle(e2, t2) {
            return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e2 && (this.style = new Kt(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e2 ? this.style.loadURL(e2) : this.style.loadJSON(e2)), this._updateTerrain(), this;
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Kt(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(t2, i2) {
            if ("string" == typeof t2) {
              const o2 = this._requestManager.normalizeStyleURL(t2), r2 = this._requestManager.transformRequest(o2, e.ResourceType.Style);
              e.getJSON(r2, (t3, o3) => {
                t3 ? this.fire(new e.ErrorEvent(t3)) : o3 && this._updateDiff(o3, i2);
              });
            } else
              "object" == typeof t2 && this._updateDiff(t2, i2);
          }
          _updateDiff(t2, i2) {
            try {
              this.style.setState(t2) && this._update(true);
            } catch (o2) {
              e.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
            }
          }
          getStyle() {
            if (this.style)
              return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : (e.warnOnce("There is no style added to the map."), false);
          }
          addSource(e2, t2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
          }
          isSourceLoaded(e2) {
            return !!this.style && this.style._isSourceCacheLoaded(e2);
          }
          areTilesLoaded() {
            const e2 = this.style && this.style._sourceCaches;
            for (const t2 in e2) {
              const i2 = e2[t2]._tiles;
              for (const e3 in i2) {
                const t3 = i2[e3];
                if ("loaded" !== t3.state && "errored" !== t3.state)
                  return false;
              }
            }
            return true;
          }
          addSourceType(e2, t2, i2) {
            this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t2, i2);
          }
          removeSource(e2) {
            return this.style.removeSource(e2), this._updateTerrain(), this._update(true);
          }
          getSource(e2) {
            return this.style.getSource(e2);
          }
          addImage(t2, i2, { pixelRatio: o2 = 1, sdf: r2 = false, stretchX: n3, stretchY: s4, content: a2 } = {}) {
            if (this._lazyInitEmptyStyle(), i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap) {
              const { width: l3, height: c4, data: h3 } = e.exported.getImageData(i2);
              this.style.addImage(t2, { data: new e.RGBAImage({ width: l3, height: c4 }, h3), pixelRatio: o2, stretchX: n3, stretchY: s4, content: a2, sdf: r2, version: 0 });
            } else if (void 0 === i2.width || void 0 === i2.height)
              this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            else {
              const { width: l3, height: c4 } = i2, h3 = i2;
              this.style.addImage(t2, { data: new e.RGBAImage({ width: l3, height: c4 }, new Uint8Array(h3.data)), pixelRatio: o2, stretchX: n3, stretchY: s4, content: a2, sdf: r2, version: 0, userImage: h3 }), h3.onAdd && h3.onAdd(this, t2);
            }
          }
          updateImage(t2, i2) {
            const o2 = this.style.getImage(t2);
            if (!o2)
              return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const r2 = i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap ? e.exported.getImageData(i2) : i2, { width: n3, height: s4 } = r2;
            void 0 !== n3 && void 0 !== s4 ? n3 === o2.data.width && s4 === o2.data.height ? (o2.data.replace(r2.data, !(i2 instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i2 instanceof e.window.ImageBitmap)), this.style.updateImage(t2, o2)) : this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${n3}, ${s4})
                must be that same as the previous version of the image
                (${o2.data.width}, ${o2.data.height})`))) : this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          }
          hasImage(t2) {
            return t2 ? !!this.style.getImage(t2) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), false);
          }
          removeImage(e2) {
            this.style.removeImage(e2);
          }
          loadImage(t2, i2) {
            e.getImage(this._requestManager.transformRequest(t2, e.ResourceType.Image), (t3, o2) => {
              i2(t3, o2 instanceof e.window.HTMLImageElement ? e.exported.getImageData(o2) : o2);
            });
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(e2, t2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
          }
          moveLayer(e2, t2) {
            return this.style.moveLayer(e2, t2), this._update(true);
          }
          removeLayer(e2) {
            return this.style.removeLayer(e2), this._update(true);
          }
          getLayer(e2) {
            return this.style.getLayer(e2);
          }
          setLayerZoomRange(e2, t2, i2) {
            return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
          }
          setFilter(e2, t2, i2 = {}) {
            return this.style.setFilter(e2, t2, i2), this._update(true);
          }
          getFilter(e2) {
            return this.style.getFilter(e2);
          }
          setPaintProperty(e2, t2, i2, o2 = {}) {
            return this.style.setPaintProperty(e2, t2, i2, o2), this._update(true);
          }
          getPaintProperty(e2, t2) {
            return this.style.getPaintProperty(e2, t2);
          }
          setLayoutProperty(e2, t2, i2, o2 = {}) {
            return this.style.setLayoutProperty(e2, t2, i2, o2), this._update(true);
          }
          getLayoutProperty(e2, t2) {
            return this.style.getLayoutProperty(e2, t2);
          }
          setLight(e2, t2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setTerrain(e2) {
            return this._lazyInitEmptyStyle(), !e2 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
          }
          getTerrain() {
            return this.style ? this.style.getTerrain() : null;
          }
          setFog(e2) {
            return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
          }
          getFog() {
            return this.style ? this.style.getFog() : null;
          }
          _queryFogOpacity(t2) {
            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t2), this.transform) : 0;
          }
          setFeatureState(e2, t2) {
            return this.style.setFeatureState(e2, t2), this._update();
          }
          removeFeatureState(e2, t2) {
            return this.style.removeFeatureState(e2, t2), this._update();
          }
          getFeatureState(e2) {
            return this.style.getFeatureState(e2);
          }
          _updateContainerDimensions() {
            if (!this._container)
              return;
            const t2 = this._container.getBoundingClientRect().width || 400, i2 = this._container.getBoundingClientRect().height || 300;
            let o2, r2, n3, s4 = this._container;
            for (; s4 && (!r2 || !n3); ) {
              const t3 = e.window.getComputedStyle(s4).transform;
              t3 && "none" !== t3 && (o2 = t3.match(/matrix.*\((.+)\)/)[1].split(", "), o2[0] && "0" !== o2[0] && "1" !== o2[0] && (r2 = o2[0]), o2[3] && "0" !== o2[3] && "1" !== o2[3] && (n3 = o2[3])), s4 = s4.parentElement;
            }
            this._containerWidth = r2 ? Math.abs(t2 / r2) : t2, this._containerHeight = n3 ? Math.abs(i2 / n3) : i2;
          }
          _detectMissingCSS() {
            "rgb(250, 128, 114)" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }
          _setupContainer() {
            const e2 = this._container;
            e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = n2("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
            const t2 = this._canvasContainer = n2("div", "mapboxgl-canvas-container", e2);
            this._interactive && t2.classList.add("mapboxgl-interactive"), this._canvas = n2("canvas", "mapboxgl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
            const i2 = this._controlContainer = n2("div", "mapboxgl-control-container", e2), o2 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
              o2[e3] = n2("div", `mapboxgl-ctrl-${e3}`, i2);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t2, i2) {
            const o2 = e.exported.devicePixelRatio || 1;
            this._canvas.width = o2 * Math.ceil(t2), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${i2}px`;
          }
          _addMarker(e2) {
            this._markers.push(e2);
          }
          _removeMarker(e2) {
            const t2 = this._markers.indexOf(e2);
            -1 !== t2 && this._markers.splice(t2, 1);
          }
          _addPopup(e2) {
            this._popups.push(e2);
          }
          _removePopup(e2) {
            const t2 = this._popups.indexOf(e2);
            -1 !== t2 && this._popups.splice(t2, 1);
          }
          _setupPainter() {
            const t2 = e.extend({}, i.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._useWebGL2 && this._canvas.getContext("webgl2", t2), r2 = o2 || this._canvas.getContext("webgl", t2) || this._canvas.getContext("experimental-webgl", t2);
            r2 ? (this._useWebGL2 && !o2 && e.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e.storeAuthState(r2, true), this.painter = new Bo(r2, this.transform, !!o2), this.on("data", (e2) => {
              "source" === e2.dataType && this.painter.setTileLoadedFlag(true);
            }), e.exported$1.testSupport(r2)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));
          }
          _contextLost(t2) {
            t2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", { originalEvent: t2 }));
          }
          _contextRestored(t2) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", { originalEvent: t2 }));
          }
          _onMapScroll(e2) {
            if (e2.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(e2) {
            return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(e2) {
            return this._update(), this._renderTaskQueue.add(e2);
          }
          _cancelRenderFrame(e2) {
            this._renderTaskQueue.remove(e2);
          }
          _requestDomTask(e2) {
            !this.loaded() || this.loaded() && !this.isMoving() ? e2() : this._domRenderTaskQueue.add(e2);
          }
          _render(t2) {
            let i2;
            const o2 = this.painter.context.extTimerQuery, r2 = e.exported.now();
            if (this.listens("gpu-timing-frame") && (i2 = o2.createQueryEXT(), o2.beginQueryEXT(o2.TIME_ELAPSED_EXT, i2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e.window.performance.now())), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed)
              return;
            this._updateProjectionTransition();
            const n3 = this._isInitialLoad ? 0 : this._fadeDuration;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t3 = this.transform.zoom, i3 = this.transform.pitch, o3 = e.exported.now(), r3 = new e.EvaluationParameters(t3, { now: o3, fadeDuration: n3, pitch: i3, transition: this.style.getTransition() });
              this.style.update(r3);
            }
            this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
            let s4 = false;
            if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), s4 = this._updateAverageElevation(r2), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s4 = this._updateAverageElevation(r2), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n3, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n3, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i2) {
              const t3 = e.exported.now() - r2;
              o2.endQueryEXT(o2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
                const n4 = o2.getQueryObjectEXT(i2, o2.QUERY_RESULT_EXT) / 1e6;
                o2.deleteQueryEXT(i2), this.fire(new e.Event("gpu-timing-frame", { cpuTime: t3, gpuTime: n4 })), e.window.performance.mark("frame-gpu", { startTime: r2, detail: { gpuTime: n4 } });
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const t3 = this.painter.collectGpuTimers();
              setTimeout(() => {
                const i3 = this.painter.queryGpuTimers(t3);
                this.fire(new e.Event("gpu-timing-layer", { layerTimes: i3 }));
              }, 50);
            }
            if (this.listens("gpu-timing-deferred-render")) {
              const t3 = this.painter.collectDeferredRenderGpuQueries();
              setTimeout(() => {
                const i3 = this.painter.queryGpuTimeDeferredRender(t3);
                this.fire(new e.Event("gpu-timing-deferred-render", { gpuTime: i3 }));
              }, 50);
            }
            const a2 = this._sourcesDirty || this._styleDirty || this._placementDirty || s4;
            if (a2 || this._repaint)
              this.triggerRepaint();
            else {
              const t3 = !this.isMoving() && this.loaded();
              if (t3 && (s4 = this._updateAverageElevation(r2, true)), s4)
                this.triggerRepaint();
              else if (this._triggerFrame(false), t3 && (this.fire(new e.Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                const t4 = this._calculateSpeedIndex();
                this.fire(new e.Event("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
              }
            }
            !this._loaded || this._fullyLoaded || a2 || (this._fullyLoaded = true, e.LivePerformanceUtils.mark(e.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e.postPerformanceEvent(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
          }
          _forceMarkerAndPopupUpdate(e2) {
            for (const t2 of this._markers)
              e2 && !this.getRenderWorldCopies() && (t2._lngLat = t2._lngLat.wrap()), t2._update();
            for (const t2 of this._popups)
              !e2 || this.getRenderWorldCopies() || t2._trackPointer || (t2._lngLat = t2._lngLat.wrap()), t2._update();
          }
          _updateAverageElevation(e2, t2 = false) {
            const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
            if (!this.painter.averageElevationNeedsEasing())
              return 0 !== this.transform.averageElevation && i2(0);
            if ((t2 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
              const t3 = this.transform.averageElevation;
              let o2 = this.transform.sampleAverageElevation(), r2 = false;
              this.transform.elevation && (r2 = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o2) ? o2 = 0 : this._averageElevationLastSampledAt = e2;
              const n3 = Math.abs(t3 - o2);
              if (n3 > 1) {
                if (this._isInitialLoad || r2)
                  return this._averageElevation.jumpTo(o2), i2(o2);
                this._averageElevation.easeTo(o2, e2, 300);
              } else if (n3 > 1e-4)
                return this._averageElevation.jumpTo(o2), i2(o2);
            }
            return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
          }
          _authenticate() {
            e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t2) => {
              if (t2 && (t2.message === e.AUTH_ERR_MSG || 401 === t2.status)) {
                const t3 = this.painter.context.gl;
                e.storeAuthState(t3, false), this._logoControl instanceof Yr && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
              }
            }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
            });
          }
          _updateTerrain() {
            const e2 = this._isDragging();
            this.painter.updateTerrain(this.style, e2);
          }
          _calculateSpeedIndex() {
            const e2 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
            t2.timeStamps.push(performance.now());
            const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
            function r2(e3) {
              i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
              const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
              return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
            }
            return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r2(e2), t2.canvasCopies.map(r2), t2.timeStamps);
          }
          _canvasPixelComparison(e2, t2, i2) {
            let o2 = i2[1] - i2[0];
            const r2 = e2.length / 4;
            for (let n3 = 0; n3 < t2.length; n3++) {
              const s4 = t2[n3];
              let a2 = 0;
              for (let t3 = 0; t3 < s4.length; t3 += 4)
                s4[t3] === e2[t3] && s4[t3 + 1] === e2[t3 + 1] && s4[t3 + 2] === e2[t3 + 2] && s4[t3 + 3] === e2[t3 + 3] && (a2 += 1);
              o2 += (i2[n3 + 2] - i2[n3 + 1]) * (1 - a2 / r2);
            }
            return o2;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const e2 of this._controls)
              e2.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener("resize", this._onWindowResize, false), e.window.removeEventListener("orientationchange", this._onWindowResize, false), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.removeEventListener("online", this._onWindowOnline, false), e.window.removeEventListener("visibilitychange", this._onVisibilityChange, false));
            const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            t2 && t2.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), e.removeAuthState(this.painter.context.gl), this._removed = true, this.fire(new e.Event("remove"));
          }
          triggerRepaint() {
            this._triggerFrame(true);
          }
          _triggerFrame(t2) {
            this._renderNextFrame = this._renderNextFrame || t2, this.style && !this._frame && (this._frame = e.exported.frame((e2) => {
              const t3 = !!this._renderNextFrame;
              this._frame = null, this._renderNextFrame = null, t3 && this._render(e2);
            }));
          }
          _preloadTiles(t2) {
            const i2 = this.style ? Object.values(this.style._sourceCaches) : [];
            return e.asyncAll(i2, (e2, i3) => e2._preloadTiles(t2, i3), () => {
              this.triggerRepaint();
            }), this;
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(e2) {
            this._trackResize && this.resize({ originalEvent: e2 })._update();
          }
          _onVisibilityChange() {
            "hidden" === e.window.document.visibilityState && this._visibilityHidden++;
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e2) {
            this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
          }
          get showTerrainWireframe() {
            return !!this._showTerrainWireframe;
          }
          set showTerrainWireframe(e2) {
            this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._update());
          }
          get speedIndexTiming() {
            return !!this._speedIndexTiming;
          }
          set speedIndexTiming(e2) {
            this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e2) {
            this._showPadding !== e2 && (this._showPadding = e2, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e2) {
            this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e2) {
            this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e2) {
            this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e2) {
            this._vertices = e2, this._update();
          }
          get showTileAABBs() {
            return !!this._showTileAABBs;
          }
          set showTileAABBs(e2) {
            this._showTileAABBs !== e2 && (this._showTileAABBs = e2, e2 && this._update());
          }
          _setCacheLimits(t2, i2) {
            e.setCacheLimits(t2, i2);
          }
          get version() {
            return e.version;
          }
        }, NavigationControl: class {
          constructor(t2) {
            this.options = e.extend({}, ln, t2), this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e2) => {
              this._map && this._map.zoomIn({}, { originalEvent: e2 });
            }), n2("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e2) => {
              this._map && this._map.zoomOut({}, { originalEvent: e2 });
            }), n2("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e2) => {
              const t3 = this._map;
              t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e2 }) : t3.resetNorth({}, { originalEvent: e2 }));
            }), this._compassIcon = n2("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            const e2 = this._map;
            if (!e2)
              return;
            const t2 = e2.getZoom(), i2 = t2 === e2.getMaxZoom(), o2 = t2 === e2.getMinZoom();
            this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
          }
          _rotateCompassArrow() {
            const e2 = this._map;
            if (!e2)
              return;
            const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e2.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e2.transform.pitch}deg) rotateZ(${e2.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e2.transform.angle * (180 / Math.PI)}deg)`;
            e2._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = t2);
            });
          }
          onAdd(e2) {
            return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e2.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e2.on("pitch", this._rotateCompassArrow), e2.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new cn(e2, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            const e2 = this._map;
            e2 && (this._container.remove(), this.options.showZoom && e2.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e2.off("pitch", this._rotateCompassArrow), e2.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
          }
          _createButton(e2, t2) {
            const i2 = n2("button", e2, this._container);
            return i2.type = "button", i2.addEventListener("click", t2), i2;
          }
          _setButtonTitle(e2, t2) {
            if (!this._map)
              return;
            const i2 = this._map._getUIString(`NavigationControl.${t2}`);
            e2.setAttribute("aria-label", i2), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
          }
        }, GeolocateControl: class extends e.Evented {
          constructor(t2) {
            super(), this.options = e.extend({ geolocation: e.window.navigator.geolocation }, hn, t2), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Yo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
          }
          onAdd(e2) {
            return this._map = e2, this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
          }
          _checkGeolocationSupport(t2) {
            const i2 = (e2 = !!this.options.geolocation) => {
              this._supportsGeolocation = e2, t2(e2);
            };
            void 0 !== this._supportsGeolocation ? t2(this._supportsGeolocation) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({ name: "geolocation" }).then((e2) => i2("denied" !== e2.state)).catch(() => i2()) : i2();
          }
          _isOutOfMapMaxBounds(e2) {
            const t2 = this._map.getMaxBounds(), i2 = e2.coords;
            return !!t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(t2) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t2))
                return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t2)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = t2, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                }
              this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t2), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t2)), this._finish();
            }
          }
          _updateCamera(t2) {
            const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude), o2 = t2.coords.accuracy, r2 = this._map.getBearing(), n3 = e.extend({ bearing: r2 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i2.toBounds(o2), n3, { geolocateSource: true });
          }
          _updateMarker(t2) {
            if (t2) {
              const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const t2 = this._map.transform, i2 = e.mercatorZfromAltitude(1, t2._center.lat) * t2.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
            this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _updateMarkerRotation() {
            this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
          }
          _onError(t2) {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (1 === t2.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const e2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === t2.code && this._noTimeout)
                    return;
                  this._setErrorState();
                }
              "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t2)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(t2) {
            if (void 0 !== this._map) {
              if (this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this._geolocateButton = n2("button", "mapboxgl-ctrl-geolocate", this._container), n2("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t2) {
                e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
              } else {
                const e2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n2("div", "mapboxgl-user-location"), this._dotElement.appendChild(n2("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n2("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new en({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = n2("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new en({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
                t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")));
              });
            }
          }
          _onDeviceOrientation(e2) {
            this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : true === e2.absolute && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
          }
          trigger() {
            if (!this._setup)
              return e.warnOnce("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let e2;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e2 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e2), this.options.showUserHeading && this._addDeviceOrientationListener();
              }
            } else
              this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _addDeviceOrientationListener() {
            const t2 = () => {
              e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
            };
            void 0 !== e.window.DeviceMotionEvent && "function" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e2) => {
              "granted" === e2 && t2();
            }).catch(console.error) : t2();
          }
          _clearWatch() {
            this.options.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: Hr, ScaleControl: class {
          constructor(t2) {
            this.options = e.extend({}, un, t2), this._isNumberFormatSupported = function() {
              try {
                return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
              } catch (e2) {
                return false;
              }
            }(), e.bindAll(["_update", "_setScale", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _update() {
            const e2 = this.options.maxWidth || 100, t2 = this._map, i2 = t2._containerHeight / 2, o2 = t2._containerWidth / 2 - e2 / 2, r2 = t2.unproject([o2, i2]), n3 = t2.unproject([o2 + e2, i2]), s4 = r2.distanceTo(n3);
            if ("imperial" === this.options.unit) {
              const t3 = 3.2808 * s4;
              t3 > 5280 ? this._setScale(e2, t3 / 5280, "mile") : this._setScale(e2, t3, "foot");
            } else
              "nautical" === this.options.unit ? this._setScale(e2, s4 / 1852, "nautical-mile") : s4 >= 1e3 ? this._setScale(e2, s4 / 1e3, "kilometer") : this._setScale(e2, s4, "meter");
          }
          _setScale(e2, t2, i2) {
            this._map._requestDomTask(() => {
              const o2 = function(e3) {
                const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
                let i3 = e3 / t3;
                return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
                  const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
                  return Math.round(e4 * t4) / t4;
                }(i3), t3 * i3;
              }(t2), r2 = o2 / t2;
              this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i2 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i2 }).format(o2) : `${o2}&nbsp;${_n[i2]}`, this._container.style.width = e2 * r2 + "px";
            });
          }
          onAdd(e2) {
            return this._map = e2, this._language = e2.getLanguage(), this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("move", this._update), this._map = void 0;
          }
          _setLanguage(e2) {
            this._language = e2, this._update();
          }
          setUnit(e2) {
            this.options.unit = e2, this._update();
          }
        }, FullscreenControl: class {
          constructor(t2) {
            this._fullscreen = false, t2 && t2.container && (t2.container instanceof e.window.HTMLElement ? this._container = t2.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange");
          }
          onAdd(t2) {
            return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const t2 = this._fullscreenButton = n2("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            n2("span", "mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const e2 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e2);
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, Popup: class extends e.Evented {
          constructor(t2) {
            super(), this.options = e.extend(Object.create(tn), t2), e.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t2 && t2.className ? t2.className.trim().split(/\s+/) : []);
          }
          addTo(t2) {
            return this._map && this.remove(), this._map = t2, this.options.closeOnClick && t2.on("preclick", this._onClose), this.options.closeOnMove && t2.on("move", this._onClose), t2.on("remove", this.remove), this._update(), t2._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t2.on("mousemove", this._onMouseEvent), t2.on("mouseup", this._onMouseEvent), t2._canvasContainer.classList.add("mapboxgl-track-pointer")) : t2.on("move", this._update), this.fire(new e.Event("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
            const t2 = this._map;
            return t2 && (t2.off("move", this._update), t2.off("move", this._onClose), t2.off("preclick", this._onClose), t2.off("click", this._onClose), t2.off("remove", this.remove), t2.off("mousemove", this._onMouseEvent), t2.off("mouseup", this._onMouseEvent), t2.off("drag", this._onMouseEvent), t2._canvasContainer && t2._canvasContainer.classList.remove("mapboxgl-track-pointer"), t2._removePopup(this), this._map = void 0), this.fire(new e.Event("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            this._lngLat = e.LngLat.convert(t2), this._pos = null, this._trackPointer = false, this._update();
            const i2 = this._map;
            return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            this._trackPointer = true, this._pos = null, this._update();
            const e2 = this._map;
            return e2 && (e2.off("move", this._update), e2.on("mousemove", this._onMouseEvent), e2.on("drag", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t2) {
            return this.setDOMContent(e.window.document.createTextNode(t2));
          }
          setHTML(t2) {
            const i2 = e.window.document.createDocumentFragment(), o2 = e.window.document.createElement("body");
            let r2;
            for (o2.innerHTML = t2; r2 = o2.firstChild, r2; )
              i2.appendChild(r2);
            return this.setDOMContent(i2);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(e2) {
            return this.options.maxWidth = e2, this._update(), this;
          }
          setDOMContent(e2) {
            let t2 = this._content;
            if (t2)
              for (; t2.hasChildNodes(); )
                t2.firstChild && t2.removeChild(t2.firstChild);
            else
              t2 = this._content = n2("div", "mapboxgl-popup-content", this._container || void 0);
            if (t2.appendChild(e2), this.options.closeButton) {
              const e3 = this._closeButton = n2("button", "mapboxgl-popup-close-button", t2);
              e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.setAttribute("aria-hidden", "true"), e3.innerHTML = "&#215;", e3.addEventListener("click", this._onClose);
            }
            return this._update(), this._focusFirstElement(), this;
          }
          addClassName(e2) {
            return this._classList.add(e2), this._updateClassList(), this;
          }
          removeClassName(e2) {
            return this._classList.delete(e2), this._updateClassList(), this;
          }
          setOffset(e2) {
            return this.options.offset = e2, this._update(), this;
          }
          toggleClassName(e2) {
            let t2;
            return this._classList.delete(e2) ? t2 = false : (this._classList.add(e2), t2 = true), this._updateClassList(), t2;
          }
          _onMouseEvent(e2) {
            this._update(e2.point);
          }
          _getAnchor(e2) {
            if (this.options.anchor)
              return this.options.anchor;
            const t2 = this._map, i2 = this._container, o2 = this._pos;
            if (!t2 || !i2 || !o2)
              return "bottom";
            const r2 = i2.offsetWidth, n3 = i2.offsetHeight, s4 = o2.x < r2 / 2, a2 = o2.x > t2.transform.width - r2 / 2;
            if (o2.y + e2 < n3)
              return s4 ? "top-left" : a2 ? "top-right" : "top";
            if (o2.y > t2.transform.height - n3) {
              if (s4)
                return "bottom-left";
              if (a2)
                return "bottom-right";
            }
            return s4 ? "left" : a2 ? "right" : "bottom";
          }
          _updateClassList() {
            const e2 = this._container;
            if (!e2)
              return;
            const t2 = [...this._classList];
            t2.push("mapboxgl-popup"), this._anchor && t2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t2.push("mapboxgl-popup-track-pointer"), e2.className = t2.join(" ");
          }
          _update(t2) {
            const i2 = this._map, o2 = this._content;
            if (!i2 || !this._lngLat && !this._trackPointer || !o2)
              return;
            let r2 = this._container;
            if (r2 || (r2 = this._container = n2("div", "mapboxgl-popup", i2.getContainer()), this._tip = n2("div", "mapboxgl-popup-tip", r2), r2.appendChild(o2)), this.options.maxWidth && r2.style.maxWidth !== this.options.maxWidth && (r2.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Jr(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t2) {
              const e2 = this._pos = this._trackPointer && t2 ? t2 : i2.project(this._lngLat), o3 = rn(this.options.offset), r3 = this._anchor = this._getAnchor(o3.y), n3 = rn(this.options.offset, r3), s4 = e2.add(n3).round();
              i2._requestDomTask(() => {
                this._container && r3 && (this._container.style.transform = `${Qr[r3]} translate(${s4.x}px,${s4.y}px)`);
              });
            }
            if (!this._marker && i2._showingGlobe()) {
              const t3 = e.isLngLatBehindGlobe(i2.transform, this._lngLat) ? 0 : 1;
              this._setOpacity(t3);
            }
            this._updateClassList();
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container)
              return;
            const e2 = this._container.querySelector(on);
            e2 && e2.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(e2) {
            this._container && (this._container.style.opacity = `${e2}`), this._content && (this._content.style.pointerEvents = e2 ? "auto" : "none");
          }
        }, Marker: en, Style: Kt, LngLat: e.LngLat, LngLatBounds: e.LngLatBounds, Point: e.Point, MercatorCoordinate: e.MercatorCoordinate, FreeCameraOptions: jo, Evented: e.Evented, config: e.config, prewarm: function() {
          Ue().acquire(Be);
        }, clearPrewarmedResources: function() {
          const e2 = Fe;
          e2 && (e2.isPreloaded() && 1 === e2.numActive() ? (e2.release(Be), Fe = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, get accessToken() {
          return e.config.ACCESS_TOKEN;
        }, set accessToken(t2) {
          e.config.ACCESS_TOKEN = t2;
        }, get baseApiUrl() {
          return e.config.API_URL;
        }, set baseApiUrl(t2) {
          e.config.API_URL = t2;
        }, get workerCount() {
          return ke.workerCount;
        }, set workerCount(e2) {
          ke.workerCount = e2;
        }, get maxParallelImageRequests() {
          return e.config.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(t2) {
          e.config.MAX_PARALLEL_IMAGE_REQUESTS = t2;
        }, clearStorage(t2) {
          e.clearTileCache(t2);
        }, workerUrl: "", workerClass: null, setNow: e.exported.setNow, restoreNow: e.exported.restoreNow };
        return dn;
      });
      var mapboxgl$1 = mapboxgl;
      return mapboxgl$1;
    });
  }
});

// node_modules/dxf-writer/src/Handle.js
var require_Handle = __commonJS({
  "node_modules/dxf-writer/src/Handle.js"(exports, module) {
    var _Handle = class _Handle {
      static next() {
        return (++_Handle.seed).toString(16).toUpperCase();
      }
      static peek() {
        return (_Handle.seed + 1).toString(16).toUpperCase();
      }
    };
    __publicField(_Handle, "seed", 0);
    var Handle2 = _Handle;
    module.exports = Handle2;
  }
});

// node_modules/dxf-writer/src/DatabaseObject.js
var require_DatabaseObject = __commonJS({
  "node_modules/dxf-writer/src/DatabaseObject.js"(exports, module) {
    var Handle2 = require_Handle();
    var DatabaseObject = class {
      constructor(subclass = null) {
        this.handle = Handle2.next();
        this.ownerObjectHandle = "0";
        this.subclassMarkers = [];
        if (subclass) {
          if (Array.isArray(subclass)) {
            this.subclassMarkers.push(...subclass);
          } else {
            this.subclassMarkers.push(subclass);
          }
        }
      }
      /**
       *
       * @param {TagsManager} manager
       */
      tags(manager) {
        manager.push(5, this.handle);
        manager.push(330, this.ownerObjectHandle);
        for (const s3 of this.subclassMarkers) {
          manager.push(100, s3);
        }
      }
    };
    module.exports = DatabaseObject;
  }
});

// node_modules/dxf-writer/src/LineType.js
var require_LineType = __commonJS({
  "node_modules/dxf-writer/src/LineType.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var LineType = class extends DatabaseObject {
      /**
       * @param {string} name
       * @param {string} description
       * @param {array} elements - if elem > 0 it is a line, if elem < 0 it is gap, if elem == 0.0 it is a
       */
      constructor(name, description, elements) {
        super(["AcDbSymbolTableRecord", "AcDbLinetypeTableRecord"]);
        this.name = name;
        this.description = description;
        this.elements = elements;
      }
      tags(manager) {
        manager.push(0, "LTYPE");
        super.tags(manager);
        manager.push(2, this.name);
        manager.push(3, this.description);
        manager.push(70, 0);
        manager.push(72, 65);
        manager.push(73, this.elements.length);
        manager.push(40, this.getElementsSum());
        this.elements.forEach((element) => {
          manager.push(49, element);
          manager.push(74, 0);
        });
      }
      getElementsSum() {
        return this.elements.reduce((sum, element) => {
          return sum + Math.abs(element);
        }, 0);
      }
    };
    module.exports = LineType;
  }
});

// node_modules/dxf-writer/src/Layer.js
var require_Layer = __commonJS({
  "node_modules/dxf-writer/src/Layer.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Layer = class extends DatabaseObject {
      constructor(name, colorNumber, lineTypeName = null) {
        super(["AcDbSymbolTableRecord", "AcDbLayerTableRecord"]);
        this.name = name;
        this.colorNumber = colorNumber;
        this.lineTypeName = lineTypeName;
        this.shapes = [];
        this.trueColor = -1;
      }
      tags(manager) {
        manager.push(0, "LAYER");
        super.tags(manager);
        manager.push(2, this.name);
        if (this.trueColor !== -1)
          manager.push(420, this.trueColor);
        else
          manager.push(62, this.colorNumber);
        manager.push(70, 0);
        if (this.lineTypeName)
          manager.push(6, this.lineTypeName);
        manager.push(390, 1);
      }
      setTrueColor(color2) {
        this.trueColor = color2;
      }
      addShape(shape) {
        this.shapes.push(shape);
        shape.layer = this;
      }
      getShapes() {
        return this.shapes;
      }
      shapesTags(space, manager) {
        for (const shape of this.shapes) {
          shape.ownerObjectHandle = space.handle;
          shape.tags(manager);
        }
      }
    };
    module.exports = Layer;
  }
});

// node_modules/dxf-writer/src/Table.js
var require_Table = __commonJS({
  "node_modules/dxf-writer/src/Table.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Table2 = class extends DatabaseObject {
      constructor(name) {
        super("AcDbSymbolTable");
        this.name = name;
        this.elements = [];
      }
      add(element) {
        element.ownerObjectHandle = this.handle;
        this.elements.push(element);
      }
      tags(manager) {
        manager.push(0, "TABLE");
        manager.push(2, this.name);
        super.tags(manager);
        manager.push(70, this.elements.length);
        this.elements.forEach((element) => {
          element.tags(manager);
        });
        manager.push(0, "ENDTAB");
      }
    };
    module.exports = Table2;
  }
});

// node_modules/dxf-writer/src/DimStyleTable.js
var require_DimStyleTable = __commonJS({
  "node_modules/dxf-writer/src/DimStyleTable.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Table2 = require_Table();
    var DimStyleTable = class extends Table2 {
      constructor(name) {
        super(name);
        this.subclassMarkers.push("AcDbDimStyleTable");
      }
      tags(manager) {
        manager.push(0, "TABLE");
        manager.push(2, this.name);
        DatabaseObject.prototype.tags.call(this, manager);
        manager.push(70, this.elements.length);
        manager.push(71, 1);
        for (const e of this.elements) {
          e.tags(manager);
        }
        manager.push(0, "ENDTAB");
      }
    };
    module.exports = DimStyleTable;
  }
});

// node_modules/dxf-writer/src/TextStyle.js
var require_TextStyle = __commonJS({
  "node_modules/dxf-writer/src/TextStyle.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var TextStyle = class extends DatabaseObject {
      constructor(name) {
        super(["AcDbSymbolTableRecord", "AcDbTextStyleTableRecord"]);
        __publicField(this, "fontFileName", "txt");
        this.name = name;
      }
      tags(manager) {
        manager.push(0, "STYLE");
        super.tags(manager);
        manager.push(2, this.name);
        manager.push(70, 0);
        manager.push(40, 0);
        manager.push(41, 1);
        manager.push(50, 0);
        manager.push(71, 0);
        manager.push(42, 1);
        manager.push(3, this.fontFileName);
        manager.push(4, "");
      }
    };
    module.exports = TextStyle;
  }
});

// node_modules/dxf-writer/src/Viewport.js
var require_Viewport = __commonJS({
  "node_modules/dxf-writer/src/Viewport.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Viewport = class extends DatabaseObject {
      constructor(name, height) {
        super(["AcDbSymbolTableRecord", "AcDbViewportTableRecord"]);
        this.name = name;
        this.height = height;
      }
      tags(manager) {
        manager.push(0, "VPORT");
        super.tags(manager);
        manager.push(2, this.name);
        manager.push(40, this.height);
        manager.push(70, 0);
      }
    };
    module.exports = Viewport;
  }
});

// node_modules/dxf-writer/src/AppId.js
var require_AppId = __commonJS({
  "node_modules/dxf-writer/src/AppId.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var AppId = class extends DatabaseObject {
      constructor(name) {
        super(["AcDbSymbolTableRecord", "AcDbRegAppTableRecord"]);
        this.name = name;
      }
      tags(manager) {
        manager.push(0, "APPID");
        super.tags(manager);
        manager.push(2, this.name);
        manager.push(70, 0);
      }
    };
    module.exports = AppId;
  }
});

// node_modules/dxf-writer/src/Block.js
var require_Block = __commonJS({
  "node_modules/dxf-writer/src/Block.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Block = class extends DatabaseObject {
      constructor(name) {
        super(["AcDbEntity", "AcDbBlockBegin"]);
        this.name = name;
        this.end = new DatabaseObject(["AcDbEntity", "AcDbBlockEnd"]);
        this.recordHandle = null;
      }
      tags(manager) {
        manager.push(0, "BLOCK");
        super.tags(manager);
        manager.push(2, this.name);
        manager.push(70, 0);
        manager.point(0, 0);
        manager.push(3, this.name);
        manager.push(1, "");
        manager.push(0, "ENDBLK");
        this.end.tags(manager);
      }
    };
    module.exports = Block;
  }
});

// node_modules/dxf-writer/src/BlockRecord.js
var require_BlockRecord = __commonJS({
  "node_modules/dxf-writer/src/BlockRecord.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var BlockRecord = class extends DatabaseObject {
      constructor(name) {
        super(["AcDbSymbolTableRecord", "AcDbBlockTableRecord"]);
        this.name = name;
      }
      tags(manager) {
        manager.push(0, "BLOCK_RECORD");
        super.tags(manager);
        manager.push(2, this.name);
        manager.push(70, 0);
        manager.push(280, 0);
        manager.push(281, 1);
      }
    };
    module.exports = BlockRecord;
  }
});

// node_modules/dxf-writer/src/Dictionary.js
var require_Dictionary = __commonJS({
  "node_modules/dxf-writer/src/Dictionary.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Dictionary = class extends DatabaseObject {
      constructor() {
        super("AcDbDictionary");
        this.children = {};
      }
      /**
       *
       * @param {*} name
       * @param {DatabaseObject} dictionary
       */
      addChildDictionary(name, dictionary) {
        dictionary.ownerObjectHandle = this.handle;
        this.children[name] = dictionary;
      }
      tags(manager) {
        manager.push(0, "DICTIONARY");
        super.tags(manager);
        manager.push(281, 1);
        const entries = Object.entries(this.children);
        for (const entry of entries) {
          const [name, dic] = entry;
          manager.push(3, name);
          manager.push(350, dic.handle);
        }
        const children = Object.values(this.children);
        for (const c3 of children) {
          c3.tags(manager);
        }
      }
    };
    module.exports = Dictionary;
  }
});

// node_modules/dxf-writer/src/Line.js
var require_Line = __commonJS({
  "node_modules/dxf-writer/src/Line.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Line4 = class extends DatabaseObject {
      constructor(x1, y1, x2, y2) {
        super(["AcDbEntity", "AcDbLine"]);
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
      }
      tags(manager) {
        manager.push(0, "LINE");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x1, this.y1);
        manager.push(11, this.x2);
        manager.push(21, this.y2);
        manager.push(31, 0);
      }
    };
    module.exports = Line4;
  }
});

// node_modules/dxf-writer/src/Line3d.js
var require_Line3d = __commonJS({
  "node_modules/dxf-writer/src/Line3d.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Line3d = class extends DatabaseObject {
      constructor(x1, y1, z1, x2, y2, z2) {
        super(["AcDbEntity", "AcDbLine"]);
        this.x1 = x1;
        this.y1 = y1;
        this.z1 = z1;
        this.x2 = x2;
        this.y2 = y2;
        this.z2 = z2;
      }
      tags(manager) {
        manager.push(0, "LINE");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x1, this.y1, this.z1);
        manager.push(11, this.x2);
        manager.push(21, this.y2);
        manager.push(31, this.z2);
      }
    };
    module.exports = Line3d;
  }
});

// node_modules/dxf-writer/src/Arc.js
var require_Arc = __commonJS({
  "node_modules/dxf-writer/src/Arc.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Arc = class extends DatabaseObject {
      /**
       * @param {number} x - Center x
       * @param {number} y - Center y
       * @param {number} r - radius
       * @param {number} startAngle - degree
       * @param {number} endAngle - degree
       */
      constructor(x, y, r, startAngle, endAngle) {
        super(["AcDbEntity", "AcDbCircle"]);
        this.x = x;
        this.y = y;
        this.r = r;
        this.startAngle = startAngle;
        this.endAngle = endAngle;
      }
      tags(manager) {
        manager.push(0, "ARC");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x, this.y);
        manager.push(40, this.r);
        manager.push(100, "AcDbArc");
        manager.push(50, this.startAngle);
        manager.push(51, this.endAngle);
      }
    };
    module.exports = Arc;
  }
});

// node_modules/dxf-writer/src/Circle.js
var require_Circle = __commonJS({
  "node_modules/dxf-writer/src/Circle.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Circle = class extends DatabaseObject {
      /**
       * @param {number} x - Center x
       * @param {number} y - Center y
       * @param {number} r - radius
       */
      constructor(x, y, r) {
        super(["AcDbEntity", "AcDbCircle"]);
        this.x = x;
        this.y = y;
        this.r = r;
      }
      tags(manager) {
        manager.push(0, "CIRCLE");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x, this.y);
        manager.push(40, this.r);
      }
    };
    module.exports = Circle;
  }
});

// node_modules/dxf-writer/src/Cylinder.js
var require_Cylinder = __commonJS({
  "node_modules/dxf-writer/src/Cylinder.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Cylinder = class extends DatabaseObject {
      /**
       * @param {number} x - Center x
       * @param {number} y - Center y
       * @param {number} z - Center z
       * @param {number} r - radius
       * @param {number} thickness - thickness
       * @param {number} extrusionDirectionX - Extrusion Direction x
       * @param {number} extrusionDirectionY - Extrusion Direction y
       * @param {number} extrusionDirectionZ - Extrusion Direction z
       */
      constructor(x, y, z, r, thickness, extrusionDirectionX, extrusionDirectionY, extrusionDirectionZ) {
        super(["AcDbEntity", "AcDbCircle"]);
        this.x = x;
        this.y = y;
        this.z = z;
        this.r = r;
        this.thickness = thickness;
        this.extrusionDirectionX = extrusionDirectionX, this.extrusionDirectionY = extrusionDirectionY, this.extrusionDirectionZ = extrusionDirectionZ;
      }
      tags(manager) {
        manager.push(0, "CIRCLE");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x, this.y, this.z);
        manager.push(40, this.r);
        manager.push(39, this.thickness);
        manager.push(210, this.extrusionDirectionX);
        manager.push(220, this.extrusionDirectionY);
        manager.push(230, this.extrusionDirectionZ);
      }
    };
    module.exports = Cylinder;
  }
});

// node_modules/dxf-writer/src/Text.js
var require_Text = __commonJS({
  "node_modules/dxf-writer/src/Text.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var H_ALIGN_CODES = ["left", "center", "right"];
    var V_ALIGN_CODES = ["baseline", "bottom", "middle", "top"];
    var Text = class extends DatabaseObject {
      /**
       * @param {number} x - x
       * @param {number} y - y
       * @param {number} height - Text height
       * @param {number} rotation - Text rotation
       * @param {string} value - the string itself
       * @param {string} [horizontalAlignment="left"] left | center | right
       * @param {string} [verticalAlignment="baseline"] baseline | bottom | middle | top
       */
      constructor(x, y, height, rotation, value, horizontalAlignment = "left", verticalAlignment = "baseline") {
        super(["AcDbEntity", "AcDbText"]);
        this.x = x;
        this.y = y;
        this.height = height;
        this.rotation = rotation;
        this.value = value;
        this.hAlign = horizontalAlignment;
        this.vAlign = verticalAlignment;
      }
      tags(manager) {
        manager.push(0, "TEXT");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x, this.y);
        manager.push(40, this.height);
        manager.push(1, this.value);
        manager.push(50, this.rotation);
        if (H_ALIGN_CODES.includes(this.hAlign, 1) || V_ALIGN_CODES.includes(this.vAlign, 1)) {
          manager.push(72, Math.max(H_ALIGN_CODES.indexOf(this.hAlign), 0));
          manager.push(11, this.x);
          manager.push(21, this.y);
          manager.push(31, 0);
          manager.push(100, "AcDbText");
          manager.push(73, Math.max(V_ALIGN_CODES.indexOf(this.vAlign), 0));
        } else {
          manager.push(100, "AcDbText");
        }
      }
    };
    module.exports = Text;
  }
});

// node_modules/dxf-writer/src/Polyline.js
var require_Polyline = __commonJS({
  "node_modules/dxf-writer/src/Polyline.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Polyline = class extends DatabaseObject {
      /**
       * @param {array} points - Array of points like [ [x1, y1], [x2, y2, bulge]... ]
       * @param {boolean} closed
       * @param {number} startWidth
       * @param {number} endWidth
       */
      constructor(points, closed = false, startWidth = 0, endWidth = 0) {
        super(["AcDbEntity", "AcDbPolyline"]);
        this.points = points;
        this.closed = closed;
        this.startWidth = startWidth;
        this.endWidth = endWidth;
      }
      tags(manager) {
        manager.push(0, "LWPOLYLINE");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.push(6, "ByLayer");
        manager.push(62, 256);
        manager.push(370, -1);
        manager.push(90, this.points.length);
        manager.push(70, this.closed ? 1 : 0);
        this.points.forEach((point) => {
          const [x, y, z] = point;
          manager.push(10, x);
          manager.push(20, y);
          if (this.startWidth !== 0 || this.endWidth !== 0) {
            manager.push(40, this.startWidth);
            manager.push(41, this.endWidth);
          }
          if (z !== void 0)
            manager.push(42, z);
        });
      }
    };
    module.exports = Polyline;
  }
});

// node_modules/dxf-writer/src/Vertex.js
var require_Vertex = __commonJS({
  "node_modules/dxf-writer/src/Vertex.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Vertex = class extends DatabaseObject {
      /**
       *
       * @param {number} x The X coordinate
       * @param {number} y The Y coordinate
       * @param {number} z The Z coordinate
       */
      constructor(x, y, z) {
        super(["AcDbEntity", "AcDbVertex", "AcDb3dPolylineVertex"]);
        this.x = x;
        this.y = y;
        this.z = z;
      }
      tags(manager) {
        manager.push(0, "VERTEX");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x, this.y, this.z);
        manager.push(70, 32);
      }
    };
    module.exports = Vertex;
  }
});

// node_modules/dxf-writer/src/Polyline3d.js
var require_Polyline3d = __commonJS({
  "node_modules/dxf-writer/src/Polyline3d.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Handle2 = require_Handle();
    var Vertex = require_Vertex();
    var Polyline3d = class extends DatabaseObject {
      /**
       * @param {[number, number, number][]} points - Array of points like [ [x1, y1, z1], [x2, y2, z2]... ]
       */
      constructor(points) {
        super(["AcDbEntity", "AcDb3dPolyline"]);
        this.verticies = points.map((point) => {
          const [x, y, z] = point;
          const vertex = new Vertex(x, y, z);
          vertex.ownerObjectHandle = this.handle;
          return vertex;
        });
        this.seqendHandle = Handle2.next();
      }
      tags(manager) {
        manager.push(0, "POLYLINE");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.push(66, 1);
        manager.push(70, 0);
        manager.point(0, 0);
        this.verticies.forEach((vertex) => {
          vertex.layer = this.layer;
          vertex.tags(manager);
        });
        manager.push(0, "SEQEND");
        manager.push(5, this.seqendHandle);
        manager.push(100, "AcDbEntity");
        manager.push(8, this.layer.name);
      }
    };
    module.exports = Polyline3d;
  }
});

// node_modules/dxf-writer/src/Face.js
var require_Face = __commonJS({
  "node_modules/dxf-writer/src/Face.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Face = class extends DatabaseObject {
      constructor(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
        super(["AcDbEntity", "AcDbFace"]);
        this.x1 = x1;
        this.y1 = y1;
        this.z1 = z1;
        this.x2 = x2;
        this.y2 = y2;
        this.z2 = z2;
        this.x3 = x3;
        this.y3 = y3;
        this.z3 = z3;
        this.x4 = x4;
        this.y4 = y4;
        this.z4 = z4;
      }
      tags(manager) {
        manager.push(0, "3DFACE");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x1, this.y1, this.z1);
        manager.push(11, this.x2);
        manager.push(21, this.y2);
        manager.push(31, this.z2);
        manager.push(12, this.x3);
        manager.push(22, this.y3);
        manager.push(32, this.z3);
        manager.push(13, this.x4);
        manager.push(23, this.y4);
        manager.push(33, this.z4);
      }
    };
    module.exports = Face;
  }
});

// node_modules/dxf-writer/src/Point.js
var require_Point = __commonJS({
  "node_modules/dxf-writer/src/Point.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Point = class extends DatabaseObject {
      constructor(x, y) {
        super(["AcDbEntity", "AcDbPoint"]);
        this.x = x;
        this.y = y;
      }
      tags(manager) {
        manager.push(0, "POINT");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x, this.y);
      }
    };
    module.exports = Point;
  }
});

// node_modules/dxf-writer/src/Spline.js
var require_Spline = __commonJS({
  "node_modules/dxf-writer/src/Spline.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Spline = class extends DatabaseObject {
      /**
       * Creates a spline. See https://www.autodesk.com/techpubs/autocad/acad2000/dxf/spline_dxf_06.htm
       * @param {[Array]} controlPoints - Array of control points like [ [x1, y1], [x2, y2]... ]
       * @param {number} degree - Degree of spline: 2 for quadratic, 3 for cubic. Default is 3
       * @param {[number]} knots - Knot vector array. If null, will use a uniform knot vector. Default is null
       * @param {[number]} weights - Control point weights. If provided, must be one weight for each control point. Default is null
       * @param {[Array]} fitPoints - Array of fit points like [ [x1, y1], [x2, y2]... ]
       */
      constructor(controlPoints, degree = 3, knots = null, weights = null, fitPoints = []) {
        super(["AcDbEntity", "AcDbSpline"]);
        if (controlPoints.length < degree + 1) {
          throw new Error(
            `For degree ${degree} spline, expected at least ${degree + 1} control points, but received only ${controlPoints.length}`
          );
        }
        if (knots == null) {
          knots = [];
          for (let i = 0; i < degree + 1; i++) {
            knots.push(0);
          }
          for (let i = 1; i < controlPoints.length - degree; i++) {
            knots.push(i);
          }
          for (let i = 0; i < degree + 1; i++) {
            knots.push(controlPoints.length - degree);
          }
        }
        if (knots.length !== controlPoints.length + degree + 1) {
          throw new Error(
            `Invalid knot vector length. Expected ${controlPoints.length + degree + 1} but received ${knots.length}.`
          );
        }
        this.controlPoints = controlPoints;
        this.knots = knots;
        this.fitPoints = fitPoints;
        this.degree = degree;
        this.weights = weights;
        const closed = 0;
        const periodic = 0;
        const rational = this.weights ? 1 : 0;
        const planar = 1;
        const linear = 0;
        this.type = closed * 1 + periodic * 2 + rational * 4 + planar * 8 + linear * 16;
      }
      tags(manager) {
        manager.push(0, "SPLINE");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.push(210, 0);
        manager.push(220, 0);
        manager.push(230, 1);
        manager.push(70, this.type);
        manager.push(71, this.degree);
        manager.push(72, this.knots.length);
        manager.push(73, this.controlPoints.length);
        manager.push(74, this.fitPoints.length);
        manager.push(42, 1e-7);
        manager.push(43, 1e-7);
        manager.push(44, 1e-10);
        this.knots.forEach((knot) => {
          manager.push(40, knot);
        });
        if (this.weights) {
          this.weights.forEach((weight) => {
            manager.push(41, weight);
          });
        }
        this.controlPoints.forEach((point) => {
          manager.point(point[0], point[1]);
        });
      }
    };
    module.exports = Spline;
  }
});

// node_modules/dxf-writer/src/Ellipse.js
var require_Ellipse = __commonJS({
  "node_modules/dxf-writer/src/Ellipse.js"(exports, module) {
    var DatabaseObject = require_DatabaseObject();
    var Ellipse = class extends DatabaseObject {
      /**
       * Creates an ellipse.
       * @param {number} x - Center x
       * @param {number} y - Center y
       * @param {number} majorAxisX - Endpoint x of major axis, relative to center
       * @param {number} majorAxisY - Endpoint y of major axis, relative to center
       * @param {number} axisRatio - Ratio of minor axis to major axis
       * @param {number} startAngle - Start angle
       * @param {number} endAngle - End angle
       */
      constructor(x, y, majorAxisX, majorAxisY, axisRatio, startAngle, endAngle) {
        super(["AcDbEntity", "AcDbEllipse"]);
        this.x = x;
        this.y = y;
        this.majorAxisX = majorAxisX;
        this.majorAxisY = majorAxisY;
        this.axisRatio = axisRatio;
        this.startAngle = startAngle;
        this.endAngle = endAngle;
      }
      tags(manager) {
        manager.push(0, "ELLIPSE");
        super.tags(manager);
        manager.push(8, this.layer.name);
        manager.point(this.x, this.y);
        manager.push(11, this.majorAxisX);
        manager.push(21, this.majorAxisY);
        manager.push(31, 0);
        manager.push(40, this.axisRatio);
        manager.push(41, this.startAngle);
        manager.push(42, this.endAngle);
      }
    };
    module.exports = Ellipse;
  }
});

// node_modules/dxf-writer/src/TagsManager.js
var require_TagsManager = __commonJS({
  "node_modules/dxf-writer/src/TagsManager.js"(exports, module) {
    var TagsManager = class {
      constructor() {
        this.lines = [];
      }
      /**
       *
       * @param {number} x
       * @param {number} y
       * @param {number} z
       */
      point(x, y, z = 0) {
        this.push(10, x);
        this.push(20, y);
        this.push(30, z);
      }
      /**
       *
       * @param {string} name The name of the section
       */
      start(name) {
        this.push(0, "SECTION");
        this.push(2, name);
      }
      end() {
        this.push(0, "ENDSEC");
      }
      addHeaderVariable(name, tagsElements) {
        this.push(9, `$${name}`);
        tagsElements.forEach((tagElement) => {
          this.push(tagElement[0], tagElement[1]);
        });
      }
      push(code, value) {
        this.lines.push(code, value);
      }
      toDxfString() {
        return this.lines.join("\n");
      }
    };
    module.exports = TagsManager;
  }
});

// node_modules/dxf-writer/src/Drawing.js
var require_Drawing = __commonJS({
  "node_modules/dxf-writer/src/Drawing.js"(exports, module) {
    var LineType = require_LineType();
    var Layer = require_Layer();
    var Table2 = require_Table();
    var DimStyleTable = require_DimStyleTable();
    var TextStyle = require_TextStyle();
    var Viewport = require_Viewport();
    var AppId = require_AppId();
    var Block = require_Block();
    var BlockRecord = require_BlockRecord();
    var Dictionary = require_Dictionary();
    var Line4 = require_Line();
    var Line3d = require_Line3d();
    var Arc = require_Arc();
    var Circle = require_Circle();
    var Cylinder = require_Cylinder();
    var Text = require_Text();
    var Polyline = require_Polyline();
    var Polyline3d = require_Polyline3d();
    var Face = require_Face();
    var Point = require_Point();
    var Spline = require_Spline();
    var Ellipse = require_Ellipse();
    var TagsManager = require_TagsManager();
    var Handle2 = require_Handle();
    var Drawing2 = class _Drawing {
      constructor() {
        this.layers = {};
        this.activeLayer = null;
        this.lineTypes = {};
        this.headers = {};
        this.tables = {};
        this.blocks = {};
        this.dictionary = new Dictionary();
        this.setUnits("Unitless");
        for (const ltype of _Drawing.LINE_TYPES) {
          this.addLineType(ltype.name, ltype.description, ltype.elements);
        }
        for (const l2 of _Drawing.LAYERS) {
          this.addLayer(l2.name, l2.colorNumber, l2.lineTypeName);
        }
        this.setActiveLayer("0");
        this.generateAutocadExtras();
      }
      /**
       * @param {string} name
       * @param {string} description
       * @param {array} elements - if elem > 0 it is a line, if elem < 0 it is gap, if elem == 0.0 it is a
       */
      addLineType(name, description, elements) {
        this.lineTypes[name] = new LineType(name, description, elements);
        return this;
      }
      addLayer(name, colorNumber, lineTypeName) {
        this.layers[name] = new Layer(name, colorNumber, lineTypeName);
        return this;
      }
      setActiveLayer(name) {
        this.activeLayer = this.layers[name];
        return this;
      }
      addTable(name) {
        const table = new Table2(name);
        this.tables[name] = table;
        return table;
      }
      /**
       *
       * @param {string} name The name of the block.
       * @returns {Block}
       */
      addBlock(name) {
        const block = new Block(name);
        this.blocks[name] = block;
        return block;
      }
      drawLine(x1, y1, x2, y2) {
        this.activeLayer.addShape(new Line4(x1, y1, x2, y2));
        return this;
      }
      drawLine3d(x1, y1, z1, x2, y2, z2) {
        this.activeLayer.addShape(new Line3d(x1, y1, z1, x2, y2, z2));
        return this;
      }
      drawPoint(x, y) {
        this.activeLayer.addShape(new Point(x, y));
        return this;
      }
      drawRect(x1, y1, x2, y2, cornerLength, cornerBulge) {
        const w = x2 - x1;
        const h2 = y2 - y1;
        cornerBulge = cornerBulge || 0;
        let p2 = null;
        if (!cornerLength) {
          p2 = new Polyline(
            [
              [x1, y1],
              [x1, y1 + h2],
              [x1 + w, y1 + h2],
              [x1 + w, y1]
            ],
            true
          );
        } else {
          p2 = new Polyline(
            [
              [x1 + w - cornerLength, y1, cornerBulge],
              // 1
              [x1 + w, y1 + cornerLength],
              // 2
              [x1 + w, y1 + h2 - cornerLength, cornerBulge],
              // 3
              [x1 + w - cornerLength, y1 + h2],
              // 4
              [x1 + cornerLength, y1 + h2, cornerBulge],
              // 5
              [x1, y1 + h2 - cornerLength],
              // 6
              [x1, y1 + cornerLength, cornerBulge],
              // 7
              [x1 + cornerLength, y1]
              // 8
            ],
            true
          );
        }
        this.activeLayer.addShape(p2);
        return this;
      }
      /**
       * Draw a regular convex polygon as a polyline entity.
       *
       * @see [Regular polygon | Wikipedia](https://en.wikipedia.org/wiki/Regular_polygon)
       *
       * @param {number} x - The X coordinate of the center of the polygon.
       * @param {number} y - The Y coordinate of the center of the polygon.
       * @param {number} numberOfSides - The number of sides.
       * @param {number} radius - The radius.
       * @param {number} rotation - The  rotation angle (in Degrees) of the polygon. By default 0.
       * @param {boolean} circumscribed - If `true` is a polygon in which each side is a tangent to a circle.
       * If `false` is a polygon in which all vertices lie on a circle. By default `false`.
       *
       * @returns {Drawing} - The current object of {@link Drawing}.
       */
      drawPolygon(x, y, numberOfSides, radius, rotation = 0, circumscribed = false) {
        const angle = 2 * Math.PI / numberOfSides;
        const vertices = [];
        let d2 = radius;
        const rotationRad = rotation * Math.PI / 180;
        if (circumscribed)
          d2 = radius / Math.cos(Math.PI / numberOfSides);
        for (let i = 0; i < numberOfSides; i++) {
          vertices.push([
            x + d2 * Math.sin(rotationRad + i * angle),
            y + d2 * Math.cos(rotationRad + i * angle)
          ]);
        }
        this.activeLayer.addShape(new Polyline(vertices, true));
        return this;
      }
      /**
       * @param {number} x1 - Center x
       * @param {number} y1 - Center y
       * @param {number} r - radius
       * @param {number} startAngle - degree
       * @param {number} endAngle - degree
       */
      drawArc(x1, y1, r, startAngle, endAngle) {
        this.activeLayer.addShape(new Arc(x1, y1, r, startAngle, endAngle));
        return this;
      }
      /**
       * @param {number} x1 - Center x
       * @param {number} y1 - Center y
       * @param {number} r - radius
       */
      drawCircle(x1, y1, r) {
        this.activeLayer.addShape(new Circle(x1, y1, r));
        return this;
      }
      /**
       * @param {number} x1 - Center x
       * @param {number} y1 - Center y
       * @param {number} z1 - Center z
       * @param {number} r - radius
       * @param {number} thickness - thickness
       * @param {number} extrusionDirectionX - Extrusion Direction x
       * @param {number} extrusionDirectionY - Extrusion Direction y
       * @param {number} extrusionDirectionZ - Extrusion Direction z
       */
      drawCylinder(x1, y1, z1, r, thickness, extrusionDirectionX, extrusionDirectionY, extrusionDirectionZ) {
        this.activeLayer.addShape(
          new Cylinder(
            x1,
            y1,
            z1,
            r,
            thickness,
            extrusionDirectionX,
            extrusionDirectionY,
            extrusionDirectionZ
          )
        );
        return this;
      }
      /**
       * @param {number} x1 - x
       * @param {number} y1 - y
       * @param {number} height - Text height
       * @param {number} rotation - Text rotation
       * @param {string} value - the string itself
       * @param {string} [horizontalAlignment="left"] left | center | right
       * @param {string} [verticalAlignment="baseline"] baseline | bottom | middle | top
       */
      drawText(x1, y1, height, rotation, value, horizontalAlignment = "left", verticalAlignment = "baseline") {
        this.activeLayer.addShape(
          new Text(
            x1,
            y1,
            height,
            rotation,
            value,
            horizontalAlignment,
            verticalAlignment
          )
        );
        return this;
      }
      /**
       * @param {[number, number][]} points - Array of points like [ [x1, y1], [x2, y2]... ]
       * @param {boolean} closed - Closed polyline flag
       * @param {number} startWidth - Default start width
       * @param {number} endWidth - Default end width
       */
      drawPolyline(points, closed = false, startWidth = 0, endWidth = 0) {
        this.activeLayer.addShape(
          new Polyline(points, closed, startWidth, endWidth)
        );
        return this;
      }
      /**
       * @param {[number, number, number][]} points - Array of points like [ [x1, y1, z1], [x2, y2, z1]... ]
       */
      drawPolyline3d(points) {
        points.forEach((point) => {
          if (point.length !== 3) {
            throw "Require 3D coordinates";
          }
        });
        this.activeLayer.addShape(new Polyline3d(points));
        return this;
      }
      /**
       *
       * @param {number} trueColor - Integer representing the true color, can be passed as an hexadecimal value of the form 0xRRGGBB
       */
      setTrueColor(trueColor) {
        this.activeLayer.setTrueColor(trueColor);
        return this;
      }
      /**
       * Draw a spline.
       * @param {[Array]} controlPoints - Array of control points like [ [x1, y1], [x2, y2]... ]
       * @param {number} degree - Degree of spline: 2 for quadratic, 3 for cubic. Default is 3
       * @param {[number]} knots - Knot vector array. If null, will use a uniform knot vector. Default is null
       * @param {[number]} weights - Control point weights. If provided, must be one weight for each control point. Default is null
       * @param {[Array]} fitPoints - Array of fit points like [ [x1, y1], [x2, y2]... ]
       */
      drawSpline(controlPoints, degree = 3, knots = null, weights = null, fitPoints = []) {
        this.activeLayer.addShape(
          new Spline(controlPoints, degree, knots, weights, fitPoints)
        );
        return this;
      }
      /**
       * Draw an ellipse.
       * @param {number} x1 - Center x
       * @param {number} y1 - Center y
       * @param {number} majorAxisX - Endpoint x of major axis, relative to center
       * @param {number} majorAxisY - Endpoint y of major axis, relative to center
       * @param {number} axisRatio - Ratio of minor axis to major axis
       * @param {number} startAngle - Start angle
       * @param {number} endAngle - End angle
       */
      drawEllipse(x1, y1, majorAxisX, majorAxisY, axisRatio, startAngle = 0, endAngle = 2 * Math.PI) {
        this.activeLayer.addShape(
          new Ellipse(
            x1,
            y1,
            majorAxisX,
            majorAxisY,
            axisRatio,
            startAngle,
            endAngle
          )
        );
        return this;
      }
      /**
       * @param {number} x1 - x
       * @param {number} y1 - y
       * @param {number} z1 - z
       * @param {number} x2 - x
       * @param {number} y2 - y
       * @param {number} z2 - z
       * @param {number} x3 - x
       * @param {number} y3 - y
       * @param {number} z3 - z
       * @param {number} x4 - x
       * @param {number} y4 - y
       * @param {number} z4 - z
       */
      drawFace(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
        this.activeLayer.addShape(
          new Face(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)
        );
        return this;
      }
      _ltypeTable() {
        const t = new Table2("LTYPE");
        const ltypes = Object.values(this.lineTypes);
        for (const lt of ltypes)
          t.add(lt);
        return t;
      }
      _layerTable(manager) {
        const t = new Table2("LAYER");
        const layers = Object.values(this.layers);
        for (const l2 of layers)
          t.add(l2);
        return t;
      }
      /**
       * @see https://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm
       * @see https://www.autodesk.com/techpubs/autocad/acad2000/dxf/header_section_group_codes_dxf_02.htm
       *
       * @param {string} variable
       * @param {array} values Array of "two elements arrays". [  [value1_GroupCode, value1_value], [value2_GroupCode, value2_value]  ]
       */
      header(variable, values) {
        this.headers[variable] = values;
        return this;
      }
      /**
       *
       * @param {string} unit see Drawing.UNITS
       */
      setUnits(unit) {
        let value = typeof _Drawing.UNITS[unit] != "undefined" ? _Drawing.UNITS[unit] : _Drawing.UNITS["Unitless"];
        this.header("INSUNITS", [[70, _Drawing.UNITS[unit]]]);
        return this;
      }
      /** Generate additional DXF metadata which are required to successfully open resulted document
       * in AutoDesk products. Call this method before serializing the drawing to get the most
       * compatible result.
       */
      generateAutocadExtras() {
        if (!this.headers["ACADVER"]) {
          this.header("ACADVER", [[1, "AC1021"]]);
        }
        if (!this.lineTypes["ByBlock"]) {
          this.addLineType("ByBlock", "", []);
        }
        if (!this.lineTypes["ByLayer"]) {
          this.addLineType("ByLayer", "", []);
        }
        let vpTable = this.tables["VPORT"];
        if (!vpTable) {
          vpTable = this.addTable("VPORT");
        }
        let styleTable = this.tables["STYLE"];
        if (!styleTable) {
          styleTable = this.addTable("STYLE");
        }
        if (!this.tables["VIEW"]) {
          this.addTable("VIEW");
        }
        if (!this.tables["UCS"]) {
          this.addTable("UCS");
        }
        let appIdTable = this.tables["APPID"];
        if (!appIdTable) {
          appIdTable = this.addTable("APPID");
        }
        if (!this.tables["DIMSTYLE"]) {
          const t = new DimStyleTable("DIMSTYLE");
          this.tables["DIMSTYLE"] = t;
        }
        vpTable.add(new Viewport("*ACTIVE", 1e3));
        styleTable.add(new TextStyle("standard"));
        appIdTable.add(new AppId("ACAD"));
        this.modelSpace = this.addBlock("*Model_Space");
        this.addBlock("*Paper_Space");
        const d2 = new Dictionary();
        this.dictionary.addChildDictionary("ACAD_GROUP", d2);
      }
      _tagsManager() {
        const manager = new TagsManager();
        const blockRecordTable = new Table2("BLOCK_RECORD");
        const blocks = Object.values(this.blocks);
        for (const b2 of blocks) {
          const r = new BlockRecord(b2.name);
          blockRecordTable.add(r);
        }
        const ltypeTable = this._ltypeTable();
        const layerTable = this._layerTable();
        manager.start("HEADER");
        manager.addHeaderVariable("HANDSEED", [[5, Handle2.peek()]]);
        const variables = Object.entries(this.headers);
        for (const v3 of variables) {
          const [name, values] = v3;
          manager.addHeaderVariable(name, values);
        }
        manager.end();
        manager.start("CLASSES");
        manager.end();
        manager.start("TABLES");
        ltypeTable.tags(manager);
        layerTable.tags(manager);
        const tables = Object.values(this.tables);
        for (const t of tables) {
          t.tags(manager);
        }
        blockRecordTable.tags(manager);
        manager.end();
        manager.start("BLOCKS");
        for (const b2 of blocks) {
          b2.tags(manager);
        }
        manager.end();
        manager.start("ENTITIES");
        const layers = Object.values(this.layers);
        for (const l2 of layers) {
          l2.shapesTags(this.modelSpace, manager);
        }
        manager.end();
        manager.start("OBJECTS");
        this.dictionary.tags(manager);
        manager.end();
        manager.push(0, "EOF");
        return manager;
      }
      toDxfString() {
        return this._tagsManager().toDxfString();
      }
    };
    Drawing2.ACI = {
      LAYER: 0,
      RED: 1,
      YELLOW: 2,
      GREEN: 3,
      CYAN: 4,
      BLUE: 5,
      MAGENTA: 6,
      WHITE: 7
    };
    Drawing2.LINE_TYPES = [
      { name: "CONTINUOUS", description: "______", elements: [] },
      { name: "DASHED", description: "_ _ _ ", elements: [5, -5] },
      { name: "DOTTED", description: ". . . ", elements: [0, -5] }
    ];
    Drawing2.LAYERS = [
      { name: "0", colorNumber: Drawing2.ACI.WHITE, lineTypeName: "CONTINUOUS" }
    ];
    Drawing2.UNITS = {
      Unitless: 0,
      Inches: 1,
      Feet: 2,
      Miles: 3,
      Millimeters: 4,
      Centimeters: 5,
      Meters: 6,
      Kilometers: 7,
      Microinches: 8,
      Mils: 9,
      Yards: 10,
      Angstroms: 11,
      Nanometers: 12,
      Microns: 13,
      Decimeters: 14,
      Decameters: 15,
      Hectometers: 16,
      Gigameters: 17,
      "Astronomical units": 18,
      "Light years": 19,
      Parsecs: 20
    };
    module.exports = Drawing2;
  }
});

// node_modules/dxf-writer/index.js
var require_dxf_writer = __commonJS({
  "node_modules/dxf-writer/index.js"(exports, module) {
    module.exports = require_Drawing();
  }
});

// node_modules/openbim-components/base-types/component.js
var Component = class {
  constructor(components) {
    this.components = components;
    this.isDisposeable = () => {
      return "dispose" in this;
    };
    this.isResizeable = () => {
      return "resize" in this && "getSize" in this;
    };
    this.isUpdateable = () => {
      return "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this;
    };
    this.isHideable = () => {
      return "visible" in this;
    };
    this.hasUI = () => {
      return "uiElement" in this;
    };
  }
};

// node_modules/openbim-components/base-types/base-types.js
var Event = class {
  constructor() {
    this.trigger = async (data) => {
      const handlers = this.handlers.slice(0);
      for (const handler of handlers) {
        await handler(data);
      }
    };
    this.handlers = [];
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(handler) {
    this.handlers.push(handler);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(handler) {
    this.handlers = this.handlers.filter((h2) => h2 !== handler);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};

// node_modules/openbim-components/base-types/base-renderer.js
var BaseRenderer = class extends Component {
  constructor() {
    super(...arguments);
    this.onResize = new Event();
    this.onClippingPlanesUpdated = new Event();
    this.clippingPlanes = [];
  }
  /**
   * Forces the update of the clipping planes and all components that depend
   * on them that are subscribed to `onClippingPlanesUpdated`.
   */
  async updateClippingPlanes() {
    await this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Adds or removes a
   * [clipping plane](https://threejs.org/docs/#api/en/renderers/WebGLRenderer.clippingPlanes)
   * to the renderer.
   */
  togglePlane(active, plane, isLocal) {
    plane.isLocal = isLocal;
    const index = this.clippingPlanes.indexOf(plane);
    if (active && index === -1) {
      this.clippingPlanes.push(plane);
    } else if (!active && index > -1) {
      this.clippingPlanes.splice(index, 1);
    }
    const renderer = this.get();
    renderer.clippingPlanes = this.clippingPlanes.filter((plane2) => !plane2.isLocal);
  }
};

// node_modules/openbim-components/base-types/mouse.js
var Mouse = class {
  constructor(dom) {
    this.dom = dom;
    this._position = new Vector2();
    this.updateMouseInfo = (event) => {
      this._event = event;
    };
    this.setupEvents(true);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const bounds = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(bounds, this._event);
      this._position.y = this.getPositionY(bounds, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.setupEvents(false);
  }
  getPositionY(bound, event) {
    return -((event.clientY - bound.top) / (bound.bottom - bound.top)) * 2 + 1;
  }
  getPositionX(bound, event) {
    return (event.clientX - bound.left) / (bound.right - bound.left) * 2 - 1;
  }
  setupEvents(active) {
    if (active) {
      this.dom.addEventListener("mousemove", this.updateMouseInfo);
    } else {
      this.dom.removeEventListener("mousemove", this.updateMouseInfo);
    }
  }
};

// node_modules/openbim-components/utils/Misc/index.js
function numberOfDigits(x) {
  return Math.max(Math.floor(Math.log10(Math.abs(x))), 0) + 1;
}
function toCompositeID(id, count) {
  const factor = 0.1 ** numberOfDigits(count);
  id += count * factor;
  let idString = id.toString();
  if (count % 10 === 0) {
    for (let i = 0; i < factor; i++) {
      idString += "0";
    }
  }
  return idString;
}
function tooeenRandomId() {
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let id = "";
  for (let i = 0; i < 10; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    id += characters.charAt(randomIndex);
  }
  return id;
}
function generateExpressIDFragmentIDMap(fragmentsList) {
  const map = {};
  fragmentsList.forEach((fragment) => {
    map[fragment.id] = new Set(fragment.items);
  });
  return map;
}
function generateIfcGUID() {
  const base64Chars = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "_",
    "$"
  ];
  const guid = MathUtils.generateUUID();
  const tailBytes = ((guid2) => {
    const bytes = [];
    guid2.split("-").map((number) => {
      const bytesInChar = number.match(/.{1,2}/g);
      if (bytesInChar) {
        return bytesInChar.map((byte) => bytes.push(parseInt(byte, 16)));
      }
      return null;
    });
    return bytes;
  })(guid);
  const headBytes = ((guid2) => {
    const bytes = [];
    guid2.split("-").map((number) => {
      const bytesInChar = number.match(/.{1,2}/g);
      if (bytesInChar) {
        return bytesInChar.map((byte) => bytes.push(byte));
      }
      return null;
    });
    return bytes;
  })(guid);
  const cvTo64 = (number, result, start2, len) => {
    let num2 = number;
    const n3 = len;
    let i2;
    for (i2 = 0; i2 < n3; i2 += 1) {
      result[start2 + len - i2 - 1] = base64Chars[parseInt((num2 % 64).toString(), 10)];
      num2 /= 64;
    }
    return result;
  };
  const toUInt16 = (bytes, index) => (
    // eslint-disable-next-line no-bitwise
    parseInt(bytes.slice(index, index + 2).reduce((str2, v3) => str2 + v3, ""), 16) >>> 0
  );
  const toUInt32 = (bytes, index) => (
    // eslint-disable-next-line no-bitwise
    parseInt(bytes.slice(index, index + 4).reduce((str2, v3) => str2 + v3, ""), 16) >>> 0
  );
  const num = [];
  let str = [];
  let i;
  let n2 = 2;
  let pos = 0;
  num[0] = toUInt32(headBytes, 0) / 16777216;
  num[1] = toUInt32(headBytes, 0) % 16777216;
  num[2] = toUInt16(headBytes, 4) * 256 + toUInt16(headBytes, 6) / 256 >>> 0;
  num[3] = // eslint-disable-next-line no-bitwise
  toUInt16(headBytes, 6) % 256 * 65536 + tailBytes[8] * 256 + tailBytes[9] >>> 0;
  num[4] = tailBytes[10] * 65536 + tailBytes[11] * 256 + tailBytes[12] >>> 0;
  num[5] = tailBytes[13] * 65536 + tailBytes[14] * 256 + tailBytes[15] >>> 0;
  for (i = 0; i < 6; i++) {
    str = cvTo64(num[i], str, pos, n2);
    pos += n2;
    n2 = 4;
  }
  return str.join("");
}
function bufferGeometryToIndexed(geometry) {
  const bufferAttribute = geometry.getAttribute("position");
  const size = bufferAttribute.itemSize;
  const positions = bufferAttribute.array;
  const indices = [];
  const vertices = [];
  const outVertices = [];
  for (let i = 0; i < positions.length; i += size) {
    const x = positions[i];
    const y = positions[i + 1];
    let vertex = `${x},${y}`;
    const z = positions[i + 2];
    if (size >= 3) {
      vertex += `,${z}`;
    } else {
      vertex += `,0`;
    }
    const w = positions[i + 3];
    if (size === 4) {
      vertex += `,${w}`;
    }
    if (vertices.indexOf(vertex) === -1) {
      vertices.push(vertex);
      indices.push(vertices.length - 1);
      const split = vertex.split(",");
      split.forEach((component) => outVertices.push(Number(component)));
    } else {
      const index = vertices.indexOf(vertex);
      indices.push(index);
    }
  }
  const outIndices = new Uint16Array(indices);
  const realVertices = new Float32Array(outVertices);
  geometry.setAttribute("position", new BufferAttribute(realVertices, size === 2 ? 3 : size));
  geometry.setIndex(new BufferAttribute(outIndices, 1));
  geometry.getAttribute("position").needsUpdate = true;
}

// node_modules/openbim-components/base-types/base-svg-annotation.js
var BaseSVGAnnotation = class extends Component {
  constructor() {
    super(...arguments);
    this.id = tooeenRandomId();
    this._enabled = false;
    this._isDrawing = false;
    this._svgViewport = null;
    this.start = (_event) => {
    };
    this.draw = (_event) => {
    };
    this.end = (_event) => {
    };
    this.cancel = (event) => {
      if (event) {
        event.stopImmediatePropagation();
        if (event.key === "Escape") {
          this.cancel(event);
        }
      }
    };
  }
  set svgViewport(value) {
    this._svgViewport = value;
  }
  get svgViewport() {
    var _a2;
    return (_a2 = this._svgViewport) !== null && _a2 !== void 0 ? _a2 : void 0;
  }
  set enabled(value) {
    const main2 = this.uiElement.get("main");
    if (!this._svgViewport) {
      main2.active = false;
      this._enabled = false;
      return;
    }
    if (value === this._enabled)
      return;
    this._enabled = value;
    main2.active = value;
    this.setupEvents(value);
  }
  get enabled() {
    return this._enabled;
  }
  get canDraw() {
    return this.enabled && this._svgViewport;
  }
  set drawManager(manager) {
    this._drawManager = manager;
    if (manager) {
      manager.addDrawingTool(this.id, this);
      const main2 = this.uiElement.get("main");
      manager.uiElement.get("drawingTools").addChild(main2);
      this.svgViewport = manager.viewport.get();
    } else {
      this.svgViewport = null;
    }
  }
  get drawManager() {
    return this._drawManager;
  }
  get() {
    return null;
  }
  async dispose() {
    if (this._drawManager) {
      this._drawManager.dispose();
    }
    if (this._svgViewport) {
      this._svgViewport.remove();
    }
    this.setupEvents(false);
    this.uiElement.dispose();
    if (this.svgViewport) {
      this.svgViewport.remove();
    }
  }
  setupEvents(active) {
    if (active) {
      document.addEventListener("keydown", this.cancel);
      if (!this._svgViewport)
        return;
      this._svgViewport.addEventListener("mousemove", this.draw);
      this._svgViewport.addEventListener("mousedown", this.start);
      this._svgViewport.addEventListener("mouseup", this.end);
    } else {
      document.removeEventListener("keydown", this.cancel);
      if (!this._svgViewport)
        return;
      this._svgViewport.removeEventListener("mousemove", this.draw);
      this._svgViewport.removeEventListener("mousedown", this.start);
      this._svgViewport.removeEventListener("mouseup", this.end);
    }
  }
};

// node_modules/openbim-components/base-types/ui-element.js
var UIElement = class {
  constructor() {
    this._data = null;
    this.initError = "UI Components not initialized.";
  }
  /**
   * Gets the UI Component with the given name. If it doesn't exist, it will
   * throw an error.
   *
   * @param name the identifier of the UI component.
   */
  get(name) {
    if (!this._data) {
      throw new Error(this.initError);
    }
    return this._data[name];
  }
  /**
   * Sets all the UI components of this instance.
   *
   * @param data all the UI components sorted by name in an object.
   */
  set(data) {
    this._data = data;
  }
  /**
   * Release all the memory used by this instance deleting all the UI components
   * inside.
   */
  async dispose() {
    if (!this._data)
      return;
    for (const name in this._data) {
      const uiComponent = this._data[name];
      await uiComponent.dispose();
    }
    this._data = null;
  }
};

// node_modules/top-tool-package-reader/reader.js
var n = new Int32Array(2);
var b = new Float32Array(n.buffer);
var c = new Float64Array(n.buffer);
var h = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var d;
(function(s3) {
  s3[s3.UTF8_BYTES = 1] = "UTF8_BYTES", s3[s3.UTF16_STRING = 2] = "UTF16_STRING";
})(d || (d = {}));
var l = class s {
  constructor(t) {
    this.bytes_ = t, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  static allocate(t) {
    return new s(new Uint8Array(t));
  }
  clear() {
    this.position_ = 0;
  }
  bytes() {
    return this.bytes_;
  }
  position() {
    return this.position_;
  }
  setPosition(t) {
    this.position_ = t;
  }
  capacity() {
    return this.bytes_.length;
  }
  readInt8(t) {
    return this.readUint8(t) << 24 >> 24;
  }
  readUint8(t) {
    return this.bytes_[t];
  }
  readInt16(t) {
    return this.readUint16(t) << 16 >> 16;
  }
  readUint16(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8;
  }
  readInt32(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24;
  }
  readUint32(t) {
    return this.readInt32(t) >>> 0;
  }
  readInt64(t) {
    return BigInt.asIntN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
  }
  readUint64(t) {
    return BigInt.asUintN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
  }
  readFloat32(t) {
    return n[0] = this.readInt32(t), b[0];
  }
  readFloat64(t) {
    return n[h ? 0 : 1] = this.readInt32(t), n[h ? 1 : 0] = this.readInt32(t + 4), c[0];
  }
  writeInt8(t, e) {
    this.bytes_[t] = e;
  }
  writeUint8(t, e) {
    this.bytes_[t] = e;
  }
  writeInt16(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;
  }
  writeUint16(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;
  }
  writeInt32(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;
  }
  writeUint32(t, e) {
    this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;
  }
  writeInt64(t, e) {
    this.writeInt32(t, Number(BigInt.asIntN(32, e))), this.writeInt32(t + 4, Number(BigInt.asIntN(32, e >> BigInt(32))));
  }
  writeUint64(t, e) {
    this.writeUint32(t, Number(BigInt.asUintN(32, e))), this.writeUint32(t + 4, Number(BigInt.asUintN(32, e >> BigInt(32))));
  }
  writeFloat32(t, e) {
    b[0] = e, this.writeInt32(t, n[0]);
  }
  writeFloat64(t, e) {
    c[0] = e, this.writeInt32(t, n[h ? 0 : 1]), this.writeInt32(t + 4, n[h ? 1 : 0]);
  }
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + 4 + 4)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let t = "";
    for (let e = 0; e < 4; e++)
      t += String.fromCharCode(this.readInt8(this.position_ + 4 + e));
    return t;
  }
  __offset(t, e) {
    let i = t - this.readInt32(t);
    return e < this.readInt16(i) ? this.readInt16(i + e) : 0;
  }
  __union(t, e) {
    return t.bb_pos = e + this.readInt32(e), t.bb = this, t;
  }
  __string(t, e) {
    t += this.readInt32(t);
    let i = this.readInt32(t);
    t += 4;
    let r = this.bytes_.subarray(t, t + i);
    return e === d.UTF8_BYTES ? r : this.text_decoder_.decode(r);
  }
  __union_with_string(t, e) {
    return typeof t == "string" ? this.__string(e) : this.__union(t, e);
  }
  __indirect(t) {
    return t + this.readInt32(t);
  }
  __vector(t) {
    return t + this.readInt32(t) + 4;
  }
  __vector_len(t) {
    return this.readInt32(t + this.readInt32(t));
  }
  __has_identifier(t) {
    if (t.length != 4)
      throw new Error("FlatBuffers: file identifier must be length 4");
    for (let e = 0; e < 4; e++)
      if (t.charCodeAt(e) != this.readInt8(this.position() + 4 + e))
        return false;
    return true;
  }
  createScalarList(t, e) {
    let i = [];
    for (let r = 0; r < e; ++r) {
      let a = t(r);
      a !== null && i.push(a);
    }
    return i;
  }
  createObjList(t, e) {
    let i = [];
    for (let r = 0; r < e; ++r) {
      let a = t(r);
      a !== null && i.push(a.unpack());
    }
    return i;
  }
};
var u = class s2 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(t, e) {
    return this.bb_pos = t, this.bb = e, this;
  }
  static getRootAsToolBuffer(t, e) {
    return (e || new s2()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsToolBuffer(t, e) {
    return t.setPosition(t.position() + 4), (e || new s2()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  id(t) {
    let e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__string(this.bb_pos + e, t) : null;
  }
  js(t) {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__string(this.bb_pos + e, t) : null;
  }
  static startToolBuffer(t) {
    t.startObject(2);
  }
  static addId(t, e) {
    t.addFieldOffset(0, e, 0);
  }
  static addJs(t, e) {
    t.addFieldOffset(1, e, 0);
  }
  static endToolBuffer(t) {
    return t.endObject();
  }
  static finishToolBufferBuffer(t, e) {
    t.finish(e);
  }
  static finishSizePrefixedToolBufferBuffer(t, e) {
    t.finish(e, void 0, true);
  }
  static createToolBuffer(t, e, i) {
    return s2.startToolBuffer(t), s2.addId(t, e), s2.addJs(t, i), s2.endToolBuffer(t);
  }
};
var p = class {
  constructor() {
  }
  read(t) {
    let e = new l(t), i = u.getRootAsToolBuffer(e), r = (g) => {
      throw new Error(`Failed to parse tool. '${g}' field missing from package.`);
    }, a = i.id(), w = i.js();
    return { id: a, js: w };
  }
};

// node_modules/openbim-components/core/ToolsComponent/index.js
var ToolComponent = class _ToolComponent extends Component {
  constructor() {
    super(...arguments);
    this.list = /* @__PURE__ */ new Map();
    this.token = "";
    this.uuid = "ToolComponent";
    this.enabled = true;
    this._reader = new p();
    this._urls = {
      base: "https://api.platform.thatopen.com/v1/tools/",
      baseDev: "https://dev.api.dev.platform.thatopen.com/v1/tools/",
      path: "/download?accessToken="
    };
  }
  /** Pass the whole library object as argument.
   * @param ORB: `import * as OBC from "openbim-components"`.
   */
  init(OBC) {
    this._OBC = OBC;
  }
  /**
   * Adds a new tool. Use this in the constructor of your tools.
   *
   * @param uuid The UUID of your tool.
   * @param instance The instance of your tool (`this` inside the constructor).
   */
  add(uuid, instance) {
    if (!this.list.has(uuid)) {
      this.list.set(uuid, instance);
    }
  }
  /**
   * Retrieves a tool component. If it already exists in this app, it returns the instance of the component. If it
   * doesn't exist, it will instance it automatically.
   *
   * @param ToolClass - The component to get or create.
   */
  async get(ToolClass) {
    const id = ToolClass.uuid;
    if (!this.list.has(id)) {
      const isLibraryComponent = _ToolComponent.libraryUUIDs.has(id);
      if (isLibraryComponent) {
        const newLibraryComponent = new ToolClass(this.components);
        this.list.set(id, newLibraryComponent);
        return newLibraryComponent;
      }
      return this.getPlatformComponent(id);
    }
    return this.list.get(id);
  }
  /**
   * Updates all the registered tool components. Only the components where the
   * property {@link Component.enabled} is true will be updated.
   * @param delta - The
   * [delta time](https://threejs.org/docs/#api/en/core/Clock) of the loop.
   */
  async update(delta) {
    const tools = this.list.values();
    for (const tool of tools) {
      if (tool.enabled && tool.isUpdateable()) {
        await tool.update(delta);
      }
    }
  }
  /**
   * Disposes all the MEMORY used by all the tools.
   */
  async dispose() {
    const tools = this.list.values();
    for (const tool of tools) {
      tool.enabled = false;
      if (tool.isDisposeable()) {
        await tool.dispose();
      }
    }
  }
  async getPlatformComponent(id) {
    if (!this._OBC) {
      console.log("Tools component not initialized! Call the init method.");
    }
    const { base, baseDev, path } = this._urls;
    const currentUrl = window.location.href;
    const devPattern = /(https:\/\/qa.)|(localhost)/;
    const isDev = currentUrl.match(devPattern);
    const baseUrl = isDev ? baseDev : base;
    const url = baseUrl + id + path + this.token;
    const fetched = await fetch(url);
    const rawBuffer = await fetched.arrayBuffer();
    const buffer = new Uint8Array(rawBuffer);
    const code = this._reader.read(buffer);
    const script = document.createElement("script");
    script.textContent = code.js;
    document.body.appendChild(script);
    const win = window;
    if (!win.ThatOpenTool) {
      throw new Error(`There was a problem fetching the tool ${id}.`);
    }
    const ToolClass = win.ThatOpenTool(this._OBC, three_module_exports);
    win.ThatOpenTool = void 0;
    script.remove();
    return new ToolClass(this.components);
  }
};
ToolComponent.libraryUUIDs = /* @__PURE__ */ new Set();

// node_modules/openbim-components/core/Disposer/index.js
var Disposer = class _Disposer extends Component {
  constructor(components) {
    super(components);
    this._disposedComponents = /* @__PURE__ */ new Set();
    this.enabled = true;
    components.tools.add(_Disposer.uuid, this);
  }
  /**
   * {@link Component.uuid}.
   * @return the list of UUIDs of deleted components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param mesh - the [mesh](https://threejs.org/docs/#api/en/objects/Mesh)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(mesh, materials = true, recursive = true) {
    mesh.removeFromParent();
    this.disposeGeometryAndMaterials(mesh, materials);
    if (recursive && mesh.children.length) {
      this.disposeChildren(mesh);
    }
    mesh.material = [];
    mesh.geometry = null;
    mesh.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(geometry) {
    if (geometry.boundsTree) {
      geometry.disposeBoundsTree();
    }
    geometry.dispose();
  }
  disposeGeometryAndMaterials(mesh, materials) {
    if (mesh.geometry) {
      this.disposeGeometry(mesh.geometry);
    }
    if (materials) {
      _Disposer.disposeMaterial(mesh);
    }
  }
  disposeChildren(mesh) {
    for (const child of mesh.children) {
      this.destroy(child);
    }
  }
  static disposeMaterial(mesh) {
    if (mesh.material) {
      if (Array.isArray(mesh.material)) {
        for (const mat of mesh.material) {
          mat.dispose();
        }
      } else {
        mesh.material.dispose();
      }
    }
  }
};
Disposer.uuid = "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe";
ToolComponent.libraryUUIDs.add(Disposer.uuid);

// node_modules/openbim-components/core/SimpleScene/index.js
var SimpleScene = class extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this._scene = new Scene();
    this._scene.background = new Color(2107698);
  }
  /** {@link Component.get} */
  get() {
    return this._scene;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    const disposer = await this.components.tools.get(Disposer);
    for (const child of this._scene.children) {
      const mesh = child;
      if (mesh.geometry) {
        disposer.destroy(mesh);
      }
    }
    this._scene.children = [];
  }
  /** Creates a simple and nice default set up for the scene (e.g. lighting). */
  setup() {
    const directionalLight = new DirectionalLight();
    directionalLight.position.set(5, 10, 3);
    directionalLight.intensity = 0.5;
    this._scene.add(directionalLight);
    const ambientLight = new AmbientLight();
    ambientLight.intensity = 0.5;
    this._scene.add(ambientLight);
  }
};

// node_modules/three/examples/jsm/renderers/CSS2DRenderer.js
var CSS2DObject = class extends Object3D {
  constructor(element = document.createElement("div")) {
    super();
    this.isCSS2DObject = true;
    this.element = element;
    this.element.style.position = "absolute";
    this.element.style.userSelect = "none";
    this.element.setAttribute("draggable", false);
    this.center = new Vector2(0.5, 0.5);
    this.addEventListener("removed", function() {
      this.traverse(function(object) {
        if (object.element instanceof Element && object.element.parentNode !== null) {
          object.element.parentNode.removeChild(object.element);
        }
      });
    });
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.element = source.element.cloneNode(true);
    this.center = source.center;
    return this;
  }
};
var _vector = new Vector3();
var _viewMatrix = new Matrix4();
var _viewProjectionMatrix = new Matrix4();
var _a = new Vector3();
var _b = new Vector3();
var CSS2DRenderer = class {
  constructor(parameters = {}) {
    const _this = this;
    let _width, _height;
    let _widthHalf, _heightHalf;
    const cache = {
      objects: /* @__PURE__ */ new WeakMap()
    };
    const domElement = parameters.element !== void 0 ? parameters.element : document.createElement("div");
    domElement.style.overflow = "hidden";
    this.domElement = domElement;
    this.getSize = function() {
      return {
        width: _width,
        height: _height
      };
    };
    this.render = function(scene, camera) {
      if (scene.matrixWorldAutoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
        camera.updateMatrixWorld();
      _viewMatrix.copy(camera.matrixWorldInverse);
      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
      renderObject(scene, scene, camera);
      zOrder(scene);
    };
    this.setSize = function(width, height) {
      _width = width;
      _height = height;
      _widthHalf = _width / 2;
      _heightHalf = _height / 2;
      domElement.style.width = width + "px";
      domElement.style.height = height + "px";
    };
    function renderObject(object, scene, camera) {
      if (object.isCSS2DObject) {
        _vector.setFromMatrixPosition(object.matrixWorld);
        _vector.applyMatrix4(_viewProjectionMatrix);
        const visible = object.visible === true && (_vector.z >= -1 && _vector.z <= 1) && object.layers.test(camera.layers) === true;
        object.element.style.display = visible === true ? "" : "none";
        if (visible === true) {
          object.onBeforeRender(_this, scene, camera);
          const element = object.element;
          element.style.transform = "translate(" + -100 * object.center.x + "%," + -100 * object.center.y + "%)translate(" + (_vector.x * _widthHalf + _widthHalf) + "px," + (-_vector.y * _heightHalf + _heightHalf) + "px)";
          if (element.parentNode !== domElement) {
            domElement.appendChild(element);
          }
          object.onAfterRender(_this, scene, camera);
        }
        const objectData = {
          distanceToCameraSquared: getDistanceToSquared(camera, object)
        };
        cache.objects.set(object, objectData);
      }
      for (let i = 0, l2 = object.children.length; i < l2; i++) {
        renderObject(object.children[i], scene, camera);
      }
    }
    function getDistanceToSquared(object1, object2) {
      _a.setFromMatrixPosition(object1.matrixWorld);
      _b.setFromMatrixPosition(object2.matrixWorld);
      return _a.distanceToSquared(_b);
    }
    function filterAndFlatten(scene) {
      const result = [];
      scene.traverse(function(object) {
        if (object.isCSS2DObject)
          result.push(object);
      });
      return result;
    }
    function zOrder(scene) {
      const sorted = filterAndFlatten(scene).sort(function(a, b2) {
        if (a.renderOrder !== b2.renderOrder) {
          return b2.renderOrder - a.renderOrder;
        }
        const distanceA = cache.objects.get(a).distanceToCameraSquared;
        const distanceB = cache.objects.get(b2).distanceToCameraSquared;
        return distanceA - distanceB;
      });
      const zMax = sorted.length;
      for (let i = 0, l2 = sorted.length; i < l2; i++) {
        sorted[i].element.style.zIndex = zMax - i;
      }
    }
  }
};

// node_modules/openbim-components/core/SimpleRenderer/index.js
var SimpleRenderer = class extends BaseRenderer {
  constructor(components, container, parameters) {
    super(components);
    this.name = "SimpleRenderer";
    this.enabled = true;
    this.onBeforeUpdate = new Event();
    this.onAfterUpdate = new Event();
    this._renderer2D = new CSS2DRenderer();
    this.resize = () => {
      const width = this.container.clientWidth;
      const height = this.container.clientHeight;
      this._renderer.setSize(width, height);
      this._renderer2D.setSize(width, height);
      this.onResize.trigger();
    };
    this.onContextLost = (event) => {
      event.preventDefault();
      this.components.enabled = false;
    };
    this.onContextBack = () => {
      this._renderer.setRenderTarget(null);
      this._renderer.dispose();
      this._renderer = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      });
      this.components.enabled = true;
    };
    this.container = container;
    this._parameters = parameters;
    this._renderer = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...parameters
    });
    this._renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.setupRenderers();
    this.setupEvents(true);
    this.resize();
    this._canvas = this._renderer.domElement;
    const context = this._renderer.getContext();
    const { canvas } = context;
    canvas.addEventListener("webglcontextlost", this.onContextLost, false);
    canvas.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Component.get} */
  get() {
    return this._renderer;
  }
  /** {@link Updateable.update} */
  update(_delta) {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger(this);
    if (this.overrideScene && this.overrideCamera) {
      this._renderer.render(this.overrideScene, this.overrideCamera);
      this._renderer2D.render(this.overrideScene, this.overrideCamera);
    } else {
      const scene = this.components.scene.get();
      const camera = this.components.camera.get();
      if (!scene || !camera)
        return;
      this._renderer.render(scene, camera);
      this._renderer2D.render(scene, camera);
    }
    this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.enabled = false;
    this.setupEvents(false);
    this._renderer.domElement.remove();
    this._renderer.dispose();
    this._renderer2D.domElement.remove();
    this.onResize.reset();
    this.onAfterUpdate.reset();
    this.onBeforeUpdate.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(this._renderer.domElement.clientWidth, this._renderer.domElement.clientHeight);
  }
  setupEvents(active) {
    if (active) {
      window.addEventListener("resize", this.resize);
    } else {
      window.removeEventListener("resize", this.resize);
    }
  }
  setupRenderers() {
    this._renderer.localClippingEnabled = true;
    this.container.appendChild(this._renderer.domElement);
    this._renderer2D.domElement.style.position = "absolute";
    this._renderer2D.domElement.style.top = "0px";
    this._renderer2D.domElement.style.pointerEvents = "none";
    this.container.appendChild(this._renderer2D.domElement);
  }
};

// node_modules/camera-controls/dist/camera-controls.module.js
var MOUSE_BUTTON = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var ACTION = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
  return camera.isOrthographicCamera;
}
var PI_2 = Math.PI * 2;
var PI_HALF = Math.PI / 2;
var EPSILON = 1e-5;
function approxZero(number, error = EPSILON) {
  return Math.abs(number) < error;
}
function approxEquals(a, b2, error = EPSILON) {
  return approxZero(a - b2, error);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
function quatInvertCompat(target) {
  if (target.invert) {
    target.invert();
  } else {
    target.inverse();
  }
  return target;
}
var EventDispatcher2 = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type2, listener) {
    const listeners = this._listeners;
    if (listeners[type2] === void 0)
      listeners[type2] = [];
    if (listeners[type2].indexOf(listener) === -1)
      listeners[type2].push(listener);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(type2, listener) {
    const listeners = this._listeners;
    return listeners[type2] !== void 0 && listeners[type2].indexOf(listener) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type2, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type2];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1)
        listenerArray.splice(index, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(type2) {
    if (!type2) {
      this._listeners = {};
      return;
    }
    if (Array.isArray(this._listeners[type2]))
      this._listeners[type2].length = 0;
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l2 = array.length; i < l2; i++) {
        array[i].call(this, event);
      }
    }
  }
};
var VERSION = "1.38.1";
var TOUCH_DOLLY_FACTOR = 1 / 8;
var isBrowser = typeof window !== "undefined";
var isMac = isBrowser && /Mac/.test(navigator.platform);
var isPointerEventsNotSupported = !(isBrowser && "PointerEvent" in window);
var THREE;
var _ORIGIN;
var _AXIS_Y;
var _AXIS_Z;
var _v2;
var _v3A;
var _v3B;
var _v3C;
var _xColumn;
var _yColumn;
var _zColumn;
var _deltaTarget;
var _deltaOffset;
var _sphericalA;
var _sphericalB;
var _box3A;
var _box3B;
var _sphere;
var _quaternionA;
var _quaternionB;
var _rotationMatrix;
var _raycaster;
var CameraControls = class extends EventDispatcher2 {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * 	MathUtils : {
       * 		DEG2RAD: MathUtils.DEG2RAD,
       * 		clamp: MathUtils.clamp,
       * 	},
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(libs) {
    THREE = libs.THREE;
    _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
    _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
    _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
    _v2 = new THREE.Vector2();
    _v3A = new THREE.Vector3();
    _v3B = new THREE.Vector3();
    _v3C = new THREE.Vector3();
    _xColumn = new THREE.Vector3();
    _yColumn = new THREE.Vector3();
    _zColumn = new THREE.Vector3();
    _deltaTarget = new THREE.Vector3();
    _deltaOffset = new THREE.Vector3();
    _sphericalA = new THREE.Spherical();
    _sphericalB = new THREE.Spherical();
    _box3A = new THREE.Box3();
    _box3B = new THREE.Box3();
    _sphere = new THREE.Sphere();
    _quaternionA = new THREE.Quaternion();
    _quaternionB = new THREE.Quaternion();
    _rotationMatrix = new THREE.Matrix4();
    _raycaster = new THREE.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ACTION;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(camera, domElement) {
    super();
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.infinityDolly = false;
    this.minZoom = 0.01;
    this.maxZoom = Infinity;
    this.dampingFactor = 0.05;
    this.draggingDampingFactor = 0.25;
    this.azimuthRotateSpeed = 1;
    this.polarRotateSpeed = 1;
    this.dollySpeed = 1;
    this.truckSpeed = 2;
    this.dollyToCursor = false;
    this.dragToOffset = false;
    this.verticalDragToForward = false;
    this.boundaryFriction = 0;
    this.restThreshold = 0.01;
    this.colliderMeshes = [];
    this.cancel = () => {
    };
    this._enabled = true;
    this._state = ACTION.NONE;
    this._viewport = null;
    this._affectOffset = false;
    this._dollyControlAmount = 0;
    this._hasRested = true;
    this._boundaryEnclosesCamera = false;
    this._needsUpdate = true;
    this._updatedLastTime = false;
    this._elementRect = new DOMRect();
    this._activePointers = [];
    this._truckInternal = (deltaX, deltaY, dragToOffset) => {
      if (isPerspectiveCamera(this._camera)) {
        const offset2 = _v3A.copy(this._camera.position).sub(this._target);
        const fov = this._camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;
        const targetDistance = offset2.length() * Math.tan(fov * 0.5);
        const truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
        const pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
        if (this.verticalDragToForward) {
          dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
          this.forward(-pedestalY, true);
        } else {
          dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
        }
      } else if (isOrthographicCamera(this._camera)) {
        const camera2 = this._camera;
        const truckX = deltaX * (camera2.right - camera2.left) / camera2.zoom / this._elementRect.width;
        const pedestalY = deltaY * (camera2.top - camera2.bottom) / camera2.zoom / this._elementRect.height;
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
      }
    };
    this._rotateInternal = (deltaX, deltaY) => {
      const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
      const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
      this.rotate(theta, phi, true);
    };
    this._dollyInternal = (delta, x, y) => {
      const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
      const distance = this._sphericalEnd.radius * dollyScale;
      const prevRadius = this._sphericalEnd.radius;
      const signedPrevRadius = prevRadius * (delta >= 0 ? -1 : 1);
      this.dollyTo(distance);
      if (this.infinityDolly && (distance < this.minDistance || this.maxDistance === this.minDistance)) {
        this._camera.getWorldDirection(_v3A);
        this._targetEnd.add(_v3A.normalize().multiplyScalar(signedPrevRadius));
        this._target.add(_v3A.normalize().multiplyScalar(signedPrevRadius));
      }
      if (this.dollyToCursor) {
        this._dollyControlAmount += this._sphericalEnd.radius - prevRadius;
        if (this.infinityDolly && (distance < this.minDistance || this.maxDistance === this.minDistance)) {
          this._dollyControlAmount -= signedPrevRadius;
        }
        this._dollyControlCoord.set(x, y);
      }
      return;
    };
    this._zoomInternal = (delta, x, y) => {
      const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
      const prevZoom = this._zoomEnd;
      this.zoomTo(this._zoom * zoomScale);
      if (this.dollyToCursor) {
        this._dollyControlAmount += this._zoomEnd - prevZoom;
        this._dollyControlCoord.set(x, y);
      }
      return;
    };
    if (typeof THREE === "undefined") {
      console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
    }
    this._camera = camera;
    this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse = quatInvertCompat(this._yAxisUpSpace.clone());
    this._state = ACTION.NONE;
    this._target = new THREE.Vector3();
    this._targetEnd = this._target.clone();
    this._focalOffset = new THREE.Vector3();
    this._focalOffsetEnd = this._focalOffset.clone();
    this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
    this._sphericalEnd = this._spherical.clone();
    this._zoom = this._camera.zoom;
    this._zoomEnd = this._zoom;
    this._nearPlaneCorners = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    this._updateNearPlaneCorners();
    this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
    this._target0 = this._target.clone();
    this._position0 = this._camera.position.clone();
    this._zoom0 = this._zoom;
    this._focalOffset0 = this._focalOffset.clone();
    this._dollyControlAmount = 0;
    this._dollyControlCoord = new THREE.Vector2();
    this.mouseButtons = {
      left: ACTION.ROTATE,
      middle: ACTION.DOLLY,
      right: ACTION.TRUCK,
      wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE
    };
    this.touches = {
      one: ACTION.TOUCH_ROTATE,
      two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
      three: ACTION.TOUCH_TRUCK
    };
    const dragStartPosition = new THREE.Vector2();
    const lastDragPosition = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const onPointerDown2 = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      const pointer = {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp2);
      startDragging(event);
    };
    const onMouseDown = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      const pointer = {
        pointerId: 0,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
      this._domElement.ownerDocument.addEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.addEventListener("mouseup", onMouseUp);
      startDragging(event);
    };
    const onTouchStart = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      event.preventDefault();
      Array.prototype.forEach.call(event.changedTouches, (touch) => {
        const pointer = {
          pointerId: touch.identifier,
          clientX: touch.clientX,
          clientY: touch.clientY,
          deltaX: 0,
          deltaY: 0
        };
        this._activePointers.push(pointer);
      });
      this._domElement.ownerDocument.removeEventListener("touchmove", onTouchMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("touchend", onTouchEnd);
      this._domElement.ownerDocument.addEventListener("touchmove", onTouchMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("touchend", onTouchEnd);
      startDragging(event);
    };
    const onPointerMove2 = (event) => {
      if (event.cancelable)
        event.preventDefault();
      const pointerId = event.pointerId;
      const pointer = this._findPointerById(pointerId);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = 0;
        if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      dragging();
    };
    const onMouseMove = (event) => {
      const pointer = this._findPointerById(0);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
        this._state = this._state | this.mouseButtons.left;
      }
      if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
        this._state = this._state | this.mouseButtons.middle;
      }
      if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
        this._state = this._state | this.mouseButtons.right;
      }
      dragging();
    };
    const onTouchMove = (event) => {
      if (event.cancelable)
        event.preventDefault();
      Array.prototype.forEach.call(event.changedTouches, (touch) => {
        const pointerId = touch.identifier;
        const pointer = this._findPointerById(pointerId);
        if (!pointer)
          return;
        pointer.clientX = touch.clientX;
        pointer.clientY = touch.clientY;
      });
      dragging();
    };
    const onPointerUp2 = (event) => {
      const pointerId = event.pointerId;
      const pointer = this._findPointerById(pointerId);
      pointer && this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 0:
            this._state = ACTION.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = ACTION.NONE;
      }
      endDragging();
    };
    const onMouseUp = () => {
      const pointer = this._findPointerById(0);
      pointer && this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
      this._state = ACTION.NONE;
      endDragging();
    };
    const onTouchEnd = (event) => {
      Array.prototype.forEach.call(event.changedTouches, (touch) => {
        const pointerId = touch.identifier;
        const pointer = this._findPointerById(pointerId);
        pointer && this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
      });
      switch (this._activePointers.length) {
        case 0:
          this._state = ACTION.NONE;
          break;
        case 1:
          this._state = this.touches.one;
          break;
        case 2:
          this._state = this.touches.two;
          break;
        case 3:
          this._state = this.touches.three;
          break;
      }
      endDragging();
    };
    let lastScrollTimeStamp = -1;
    const onMouseWheel = (event) => {
      if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
        return;
      event.preventDefault();
      if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
        const now = performance.now();
        if (lastScrollTimeStamp - now < 1e3)
          this._getClientRect(this._elementRect);
        lastScrollTimeStamp = now;
      }
      const deltaYFactor = isMac ? -1 : -3;
      const delta = event.deltaMode === 1 ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
      const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
      const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case ACTION.ROTATE: {
          this._rotateInternal(event.deltaX, event.deltaY);
          break;
        }
        case ACTION.TRUCK: {
          this._truckInternal(event.deltaX, event.deltaY, false);
          break;
        }
        case ACTION.OFFSET: {
          this._truckInternal(event.deltaX, event.deltaY, true);
          break;
        }
        case ACTION.DOLLY: {
          this._dollyInternal(-delta, x, y);
          break;
        }
        case ACTION.ZOOM: {
          this._zoomInternal(-delta, x, y);
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    };
    const onContextMenu = (event) => {
      if (!this._enabled)
        return;
      event.preventDefault();
    };
    const startDragging = (event) => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v2);
      this._getClientRect(this._elementRect);
      dragStartPosition.copy(_v2);
      lastDragPosition.copy(_v2);
      const isMultiTouch = this._activePointers.length >= 2;
      if (isMultiTouch) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
        const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
        const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        lastDragPosition.set(x, y);
      }
      if ("touches" in event || "pointerType" in event && event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = 0;
        if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      this.dispatchEvent({ type: "controlstart" });
    };
    const dragging = () => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v2);
      const isPointerLockActive = this._domElement && document.pointerLockElement === this._domElement;
      const deltaX = isPointerLockActive ? -this._activePointers[0].deltaX : lastDragPosition.x - _v2.x;
      const deltaY = isPointerLockActive ? -this._activePointers[0].deltaY : lastDragPosition.y - _v2.y;
      lastDragPosition.copy(_v2);
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._rotateInternal(deltaX, deltaY);
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & ACTION.DOLLY) === ACTION.DOLLY ? this._dollyInternal(deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY) : this._zoomInternal(deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
      }
      if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dollyDelta = dollyStart.y - distance;
        dollyStart.set(0, distance);
        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ? this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY) : this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._truckInternal(deltaX, deltaY, false);
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._truckInternal(deltaX, deltaY, true);
      }
      this.dispatchEvent({ type: "control" });
    };
    const endDragging = () => {
      extractClientCoordFromEvent(this._activePointers, _v2);
      lastDragPosition.copy(_v2);
      if (this._activePointers.length === 0 && this._domElement) {
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
        this._domElement.ownerDocument.removeEventListener("touchmove", onTouchMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("touchend", onTouchEnd);
        this.dispatchEvent({ type: "controlend" });
      }
    };
    this._addAllEventListeners = (domElement2) => {
      this._domElement = domElement2;
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
      this._domElement.addEventListener("pointerdown", onPointerDown2);
      isPointerEventsNotSupported && this._domElement.addEventListener("mousedown", onMouseDown);
      isPointerEventsNotSupported && this._domElement.addEventListener("touchstart", onTouchStart);
      this._domElement.addEventListener("pointercancel", onPointerUp2);
      this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.addEventListener("contextmenu", onContextMenu);
    };
    this._removeAllEventListeners = () => {
      if (!this._domElement)
        return;
      this._domElement.removeEventListener("pointerdown", onPointerDown2);
      this._domElement.removeEventListener("mousedown", onMouseDown);
      this._domElement.removeEventListener("touchstart", onTouchStart);
      this._domElement.removeEventListener("pointercancel", onPointerUp2);
      this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.removeEventListener("contextmenu", onContextMenu);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.removeEventListener("touchmove", onTouchMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
      this._domElement.ownerDocument.removeEventListener("touchend", onTouchEnd);
    };
    this.cancel = () => {
      if (this._state === ACTION.NONE)
        return;
      this._state = ACTION.NONE;
      this._activePointers.length = 0;
      endDragging();
    };
    if (domElement)
      this.connect(domElement);
    this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this.updateCameraUp();
    this._camera.updateProjectionMatrix();
    this._updateNearPlaneCorners();
    this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    if (!this._domElement)
      return;
    this._enabled = enabled;
    if (enabled) {
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
    } else {
      this.cancel();
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
    }
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(distance) {
    if (this._spherical.radius === distance && this._sphericalEnd.radius === distance)
      return;
    this._spherical.radius = distance;
    this._sphericalEnd.radius = distance;
    this._needsUpdate = true;
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(azimuthAngle) {
    if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
      return;
    this._spherical.theta = azimuthAngle;
    this._sphericalEnd.theta = azimuthAngle;
    this._needsUpdate = true;
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(polarAngle) {
    if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
      return;
    this._spherical.phi = polarAngle;
    this._sphericalEnd.phi = polarAngle;
    this._needsUpdate = true;
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(boundaryEnclosesCamera) {
    this._boundaryEnclosesCamera = boundaryEnclosesCamera;
    this._needsUpdate = true;
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type2, listener) {
    super.addEventListener(type2, listener);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type2, listener) {
    super.removeEventListener(type2, listener);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(azimuthAngle, polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(azimuthAngle, enableTransition = false) {
    return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
    const theta = THREE.MathUtils.clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
    const phi = THREE.MathUtils.clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = theta;
    this._sphericalEnd.phi = phi;
    this._sphericalEnd.makeSafe();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.theta = this._sphericalEnd.theta;
      this._spherical.phi = this._sphericalEnd.phi;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(distance, enableTransition = false) {
    return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(distance, enableTransition = false) {
    const lastRadius = this._sphericalEnd.radius;
    const newRadius = THREE.MathUtils.clamp(distance, this.minDistance, this.maxDistance);
    const hasCollider = this.colliderMeshes.length >= 1;
    if (hasCollider) {
      const maxDistanceByCollisionTest = this._collisionTest();
      const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
      const isDollyIn = lastRadius > newRadius;
      if (!isDollyIn && isCollided)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(newRadius, maxDistanceByCollisionTest);
    } else {
      this._sphericalEnd.radius = newRadius;
    }
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.radius = this._sphericalEnd.radius;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(zoomStep, enableTransition = false) {
    return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(zoom, enableTransition = false) {
    this._zoomEnd = THREE.MathUtils.clamp(zoom, this.minZoom, this.maxZoom);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._zoom = this._zoomEnd;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(x, y, enableTransition = false) {
    console.warn("`pan` has been renamed to `truck`");
    return this.truck(x, y, enableTransition);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(x, y, enableTransition = false) {
    this._camera.updateMatrix();
    _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
    _xColumn.multiplyScalar(x);
    _yColumn.multiplyScalar(-y);
    const offset2 = _v3A.copy(_xColumn).add(_yColumn);
    const to = _v3B.copy(this._targetEnd).add(offset2);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(distance, enableTransition = false) {
    _v3A.setFromMatrixColumn(this._camera.matrix, 0);
    _v3A.crossVectors(this._camera.up, _v3A);
    _v3A.multiplyScalar(distance);
    const to = _v3B.copy(this._targetEnd).add(_v3A);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(x, y, z, enableTransition = false) {
    const offset2 = _v3A.set(x, y, z).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, offset2, this.boundaryFriction);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
    const promises = [];
    const aabb = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
    if (aabb.isEmpty()) {
      console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
      Promise.resolve();
    }
    const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
    const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
    promises.push(this.rotateTo(theta, phi, enableTransition));
    const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
    const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
    const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
    if (viewFromPolar) {
      rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
    }
    rotation.multiply(this._yAxisUpSpaceInverse);
    const bb = _box3B.makeEmpty();
    _v3B.copy(aabb.min).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    bb.min.x -= paddingLeft;
    bb.min.y -= paddingBottom;
    bb.max.x += paddingRight;
    bb.max.y += paddingTop;
    rotation.setFromUnitVectors(_AXIS_Z, normal);
    if (viewFromPolar) {
      rotation.premultiply(_quaternionB.invert());
    }
    rotation.premultiply(this._yAxisUpSpace);
    const bbSize = bb.getSize(_v3A);
    const center = bb.getCenter(_v3B).applyQuaternion(rotation);
    if (isPerspectiveCamera(this._camera)) {
      const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.dollyTo(distance, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const width = camera.right - camera.left;
      const height = camera.top - camera.bottom;
      const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.zoomTo(zoom, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    }
    return Promise.all(promises);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(sphereOrMesh, enableTransition) {
    const promises = [];
    const isSphere = sphereOrMesh instanceof THREE.Sphere;
    const boundingSphere = isSphere ? _sphere.copy(sphereOrMesh) : createBoundingSphere(sphereOrMesh, _sphere);
    promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
    if (isPerspectiveCamera(this._camera)) {
      const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
      promises.push(this.dollyTo(distanceToFit, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const width = this._camera.right - this._camera.left;
      const height = this._camera.top - this._camera.bottom;
      const diameter = 2 * boundingSphere.radius;
      const zoom = Math.min(width / diameter, height / diameter);
      promises.push(this.zoomTo(zoom, enableTransition));
    }
    promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    return Promise.all(promises);
  }
  /**
   * Make an orbit with given points.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
    const target = _v3B.set(targetX, targetY, targetZ);
    const position = _v3A.set(positionX, positionY, positionZ);
    this._targetEnd.copy(target);
    this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {
    const targetA = _v3A.set(targetAX, targetAY, targetAZ);
    const positionA = _v3B.set(positionAX, positionAY, positionAZ);
    _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
    const targetB = _v3C.set(targetBX, targetBY, targetBZ);
    const positionB = _v3B.set(positionBX, positionBY, positionBZ);
    _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
    this._targetEnd.copy(targetA.lerp(targetB, t));
    const deltaTheta = _sphericalB.theta - _sphericalA.theta;
    const deltaPhi = _sphericalB.phi - _sphericalA.phi;
    const deltaRadius = _sphericalB.radius - _sphericalA.radius;
    this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * setLookAt without target, keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(positionX, positionY, positionZ, enableTransition = false) {
    return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
  }
  /**
   * setLookAt without position, Stay still at the position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(targetX, targetY, targetZ, enableTransition = false) {
    const pos = this.getPosition(_v3A);
    const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
    this._sphericalEnd.phi = THREE.MathUtils.clamp(this.polarAngle, this.minPolarAngle, this.maxPolarAngle);
    return promise;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(x, y, z, enableTransition = false) {
    this._focalOffsetEnd.set(x, y, z);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._focalOffset.copy(this._focalOffsetEnd);
    }
    this._affectOffset = !approxZero(x) || !approxZero(y) || !approxZero(z);
    const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(targetX, targetY, targetZ) {
    this._camera.updateMatrixWorld();
    _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
    _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const position = _v3A.set(targetX, targetY, targetZ);
    const distance = position.distanceTo(this._camera.position);
    const cameraToPoint = position.sub(this._camera.position);
    _xColumn.multiplyScalar(cameraToPoint.x);
    _yColumn.multiplyScalar(cameraToPoint.y);
    _zColumn.multiplyScalar(cameraToPoint.z);
    _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
    _v3A.z = _v3A.z + distance;
    this.dollyTo(distance, false);
    this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
    this.moveTo(targetX, targetY, targetZ, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(box3) {
    if (!box3) {
      this._boundary.min.set(-Infinity, -Infinity, -Infinity);
      this._boundary.max.set(Infinity, Infinity, Infinity);
      this._needsUpdate = true;
      return;
    }
    this._boundary.copy(box3);
    this._boundary.clampPoint(this._targetEnd, this._targetEnd);
    this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(viewportOrX, y, width, height) {
    if (viewportOrX === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new THREE.Vector4();
    if (typeof viewportOrX === "number") {
      this._viewport.set(viewportOrX, y, width, height);
    } else {
      this._viewport.copy(viewportOrX);
    }
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(width, height, depth, cover = false) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const boundingRectAspect = width / height;
    const fov = this._camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;
    const aspect = this._camera.aspect;
    const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;
    return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(radius) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const vFOV = this._camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;
    const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
    const fov = 1 < this._camera.aspect ? vFOV : hFOV;
    return radius / Math.sin(fov * 0.5);
  }
  /**
   * Returns its current gazing target, which is the center position of the orbit.
   * @param out current gazing target
   * @category Methods
   */
  getTarget(out) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(this._targetEnd);
  }
  /**
   * Returns its current position.
   * @param out current position
   * @category Methods
   */
  getPosition(out) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd);
  }
  /**
   * Returns its current focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out current focal offset
   * @category Methods
   */
  getFocalOffset(out) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(this._focalOffsetEnd);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
    if (this._sphericalEnd.theta < 0)
      this._sphericalEnd.theta += PI_2;
    this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(enableTransition = false) {
    const promises = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
      this.zoomTo(this._zoom0, enableTransition)
    ];
    return Promise.all(promises);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this.getTarget(this._target0);
    this.getPosition(this._position0);
    this._zoom0 = this._zoom;
    this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
    quatInvertCompat(this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace));
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(delta) {
    const dampingFactor = this._state === ACTION.NONE ? this.dampingFactor : this.draggingDampingFactor;
    const lerpRatio = Math.min(dampingFactor * delta * 60, 1);
    const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
    const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
    const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
    const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
    const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
    if (!approxZero(deltaTheta) || !approxZero(deltaPhi) || !approxZero(deltaRadius) || !approxZero(deltaTarget.x) || !approxZero(deltaTarget.y) || !approxZero(deltaTarget.z) || !approxZero(deltaOffset.x) || !approxZero(deltaOffset.y) || !approxZero(deltaOffset.z)) {
      this._spherical.set(this._spherical.radius + deltaRadius * lerpRatio, this._spherical.phi + deltaPhi * lerpRatio, this._spherical.theta + deltaTheta * lerpRatio);
      this._target.add(deltaTarget.multiplyScalar(lerpRatio));
      this._focalOffset.add(deltaOffset.multiplyScalar(lerpRatio));
      this._needsUpdate = true;
    } else {
      this._spherical.copy(this._sphericalEnd);
      this._target.copy(this._targetEnd);
      this._focalOffset.copy(this._focalOffsetEnd);
    }
    if (this._dollyControlAmount !== 0) {
      if (isPerspectiveCamera(this._camera)) {
        const camera = this._camera;
        const cameraDirection = _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate();
        const planeX = _v3B.copy(cameraDirection).cross(camera.up).normalize();
        if (planeX.lengthSq() === 0)
          planeX.x = 1;
        const planeY = _v3C.crossVectors(planeX, cameraDirection);
        const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD * 0.5);
        const prevRadius = this._sphericalEnd.radius - this._dollyControlAmount;
        const lerpRatio2 = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
        const cursor = _v3A.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
        this._targetEnd.lerp(cursor, lerpRatio2);
      } else if (isOrthographicCamera(this._camera)) {
        const camera = this._camera;
        const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
        const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
        const prevZoom = this._zoom - this._dollyControlAmount;
        const lerpRatio2 = -(prevZoom - this._zoomEnd) / this._zoom;
        const cameraDirection = _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate();
        const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
        this._targetEnd.lerp(cursor, lerpRatio2);
        const newPlaneConstant = this._targetEnd.dot(cameraDirection);
        const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
        this._targetEnd.sub(pullBack);
      }
      this._target.copy(this._targetEnd);
      this._boundary.clampPoint(this._targetEnd, this._targetEnd);
      this._dollyControlAmount = 0;
    }
    const deltaZoom = this._zoomEnd - this._zoom;
    this._zoom += deltaZoom * lerpRatio;
    if (this._camera.zoom !== this._zoom) {
      if (approxZero(deltaZoom))
        this._zoom = this._zoomEnd;
      this._camera.zoom = this._zoom;
      this._camera.updateProjectionMatrix();
      this._updateNearPlaneCorners();
      this._needsUpdate = true;
    }
    const maxDistance = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
    this._spherical.makeSafe();
    this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
    this._camera.lookAt(this._target);
    if (this._affectOffset) {
      this._camera.updateMatrixWorld();
      _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
      _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
      _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
      _xColumn.multiplyScalar(this._focalOffset.x);
      _yColumn.multiplyScalar(-this._focalOffset.y);
      _zColumn.multiplyScalar(this._focalOffset.z);
      _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
      this._camera.position.add(_v3A);
    }
    if (this._boundaryEnclosesCamera) {
      this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    }
    const updated = this._needsUpdate;
    if (updated && !this._updatedLastTime) {
      this._hasRested = false;
      this.dispatchEvent({ type: "wake" });
      this.dispatchEvent({ type: "update" });
    } else if (updated) {
      this.dispatchEvent({ type: "update" });
      if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
        this._hasRested = true;
        this.dispatchEvent({ type: "rest" });
      }
    } else if (!updated && this._updatedLastTime) {
      this.dispatchEvent({ type: "sleep" });
    }
    this._updatedLastTime = updated;
    this._needsUpdate = false;
    return updated;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: infinityToMaxNumber(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: infinityToMaxNumber(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
      minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
      maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
      dampingFactor: this.dampingFactor,
      draggingDampingFactor: this.draggingDampingFactor,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(json, enableTransition = false) {
    const obj = JSON.parse(json);
    const position = _v3A.fromArray(obj.position);
    this.enabled = obj.enabled;
    this.minDistance = obj.minDistance;
    this.maxDistance = maxNumberToInfinity(obj.maxDistance);
    this.minZoom = obj.minZoom;
    this.maxZoom = maxNumberToInfinity(obj.maxZoom);
    this.minPolarAngle = obj.minPolarAngle;
    this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
    this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
    this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
    this.dampingFactor = obj.dampingFactor;
    this.draggingDampingFactor = obj.draggingDampingFactor;
    this.dollySpeed = obj.dollySpeed;
    this.truckSpeed = obj.truckSpeed;
    this.dollyToCursor = obj.dollyToCursor;
    this.verticalDragToForward = obj.verticalDragToForward;
    this._target0.fromArray(obj.target0);
    this._position0.fromArray(obj.position0);
    this._zoom0 = obj.zoom0;
    this._focalOffset0.fromArray(obj.focalOffset0);
    this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
    _sphericalA.setFromVector3(position.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
    this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
    this.zoomTo(obj.zoom, enableTransition);
    this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
    this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(domElement) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    domElement.setAttribute("data-camera-controls-version", VERSION);
    this._addAllEventListeners(domElement);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this._removeAllEventListeners();
    this._domElement = void 0;
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.disconnect();
    if (this._domElement && "setAttribute" in this._domElement)
      this._domElement.removeAttribute("data-camera-controls-version");
  }
  _findPointerById(pointerId) {
    let pointer = null;
    this._activePointers.some((activePointer) => {
      if (activePointer.pointerId === pointerId) {
        pointer = activePointer;
        return true;
      }
      return false;
    });
    return pointer;
  }
  _encloseToBoundary(position, offset2, friction) {
    const offsetLength2 = offset2.lengthSq();
    if (offsetLength2 === 0) {
      return position;
    }
    const newTarget = _v3B.copy(offset2).add(position);
    const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
    const deltaClampedTarget = clampedTarget.sub(newTarget);
    const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
    if (deltaClampedTargetLength2 === 0) {
      return position.add(offset2);
    } else if (deltaClampedTargetLength2 === offsetLength2) {
      return position;
    } else if (friction === 0) {
      return position.add(offset2).add(deltaClampedTarget);
    } else {
      const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset2.dot(deltaClampedTarget);
      return position.add(_v3B.copy(offset2).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
    }
  }
  _updateNearPlaneCorners() {
    if (isPerspectiveCamera(this._camera)) {
      const camera = this._camera;
      const near = camera.near;
      const fov = camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;
      const heightHalf = Math.tan(fov * 0.5) * near;
      const widthHalf = heightHalf * camera.aspect;
      this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
      this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const zoomInv = 1 / camera.zoom;
      const left2 = camera.left * zoomInv;
      const right2 = camera.right * zoomInv;
      const top2 = camera.top * zoomInv;
      const bottom2 = camera.bottom * zoomInv;
      this._nearPlaneCorners[0].set(left2, top2, 0);
      this._nearPlaneCorners[1].set(right2, top2, 0);
      this._nearPlaneCorners[2].set(right2, bottom2, 0);
      this._nearPlaneCorners[3].set(left2, bottom2, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let distance = Infinity;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (!hasCollider)
      return distance;
    if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
      return distance;
    const direction = _v3A.setFromSpherical(this._spherical).divideScalar(this._spherical.radius);
    _rotationMatrix.lookAt(_ORIGIN, direction, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);
      nearPlaneCorner.applyMatrix4(_rotationMatrix);
      const origin = _v3C.addVectors(this._target, nearPlaneCorner);
      _raycaster.set(origin, direction);
      _raycaster.far = this._spherical.radius + 1;
      const intersects = _raycaster.intersectObjects(this.colliderMeshes);
      if (intersects.length !== 0 && intersects[0].distance < distance) {
        distance = intersects[0].distance;
      }
    }
    return distance;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(target) {
    if (!this._domElement)
      return;
    const rect = this._domElement.getBoundingClientRect();
    target.x = rect.left;
    target.y = rect.top;
    if (this._viewport) {
      target.x += this._viewport.x;
      target.y += rect.height - this._viewport.w - this._viewport.y;
      target.width = this._viewport.z;
      target.height = this._viewport.w;
    } else {
      target.width = rect.width;
      target.height = rect.height;
    }
    return target;
  }
  _createOnRestPromise(resolveImmediately) {
    if (resolveImmediately)
      return Promise.resolve();
    this._hasRested = false;
    this.dispatchEvent({ type: "transitionstart" });
    return new Promise((resolve) => {
      const onResolve = () => {
        this.removeEventListener("rest", onResolve);
        resolve();
      };
      this.addEventListener("rest", onResolve);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(_domElement) {
  }
  _removeAllEventListeners() {
  }
};
function createBoundingSphere(object3d, out) {
  const boundingSphere = out;
  const center = boundingSphere.center;
  _box3A.makeEmpty();
  object3d.traverseVisible((object) => {
    if (!object.isMesh)
      return;
    _box3A.expandByObject(object);
  });
  _box3A.getCenter(center);
  let maxRadiusSq = 0;
  object3d.traverseVisible((object) => {
    if (!object.isMesh)
      return;
    const mesh = object;
    const geometry = mesh.geometry.clone();
    geometry.applyMatrix4(mesh.matrixWorld);
    if (geometry.isBufferGeometry) {
      const bufferGeometry = geometry;
      const position = bufferGeometry.attributes.position;
      for (let i = 0, l2 = position.count; i < l2; i++) {
        _v3A.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
      }
    } else {
      const position = geometry.attributes.position;
      const vector = new THREE.Vector3();
      for (let i = 0, l2 = position.count; i < l2; i++) {
        vector.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
      }
    }
  });
  boundingSphere.radius = Math.sqrt(maxRadiusSq);
  return boundingSphere;
}

// node_modules/openbim-components/core/SimpleCamera/index.js
var SimpleCamera = class _SimpleCamera extends Component {
  /** {@link Component.enabled} */
  get enabled() {
    return this.controls.enabled;
  }
  /** {@link Component.enabled} */
  set enabled(enabled) {
    this.controls.enabled = enabled;
  }
  constructor(components) {
    super(components);
    this.onBeforeUpdate = new Event();
    this.onAfterUpdate = new Event();
    this.onAspectUpdated = new Event();
    this.updateAspect = () => {
      if (this.components.renderer.isResizeable()) {
        const size = this.components.renderer.getSize();
        this._perspectiveCamera.aspect = size.width / size.height;
        this._perspectiveCamera.updateProjectionMatrix();
        this.onAspectUpdated.trigger();
      }
    };
    this._perspectiveCamera = this.setupCamera();
    this.activeCamera = this._perspectiveCamera;
    this.controls = this.setupCameraControls();
    const scene = components.scene.get();
    scene.add(this._perspectiveCamera);
    this.setupEvents(true);
  }
  /** {@link Component.get} */
  get() {
    return this.activeCamera;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.setupEvents(false);
    this.enabled = false;
    this.onAspectUpdated.reset();
    this.onBeforeUpdate.reset();
    this.onAfterUpdate.reset();
    this._perspectiveCamera.removeFromParent();
    this.controls.dispose();
  }
  /** {@link Updateable.update} */
  update(_delta) {
    if (this.enabled) {
      this.onBeforeUpdate.trigger(this);
      this.controls.update(_delta);
      this.onAfterUpdate.trigger(this);
    }
  }
  setupCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new PerspectiveCamera(60, aspect, 1, 1e3);
    camera.position.set(50, 50, 50);
    camera.lookAt(new Vector3(0, 0, 0));
    return camera;
  }
  setupCameraControls() {
    CameraControls.install({ THREE: _SimpleCamera.getSubsetOfThree() });
    const dom = this.components.renderer.get().domElement;
    const controls = new CameraControls(this._perspectiveCamera, dom);
    controls.dampingFactor = 0.2;
    controls.dollyToCursor = true;
    controls.infinityDolly = true;
    controls.setTarget(0, 0, 0);
    return controls;
  }
  setupEvents(active) {
    if (active) {
      window.addEventListener("resize", this.updateAspect);
    } else {
      window.removeEventListener("resize", this.updateAspect);
    }
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};

// node_modules/openbim-components/base-types/base-raycaster.js
var BaseRaycaster = class extends Component {
};

// node_modules/openbim-components/core/SimpleRaycaster/index.js
var SimpleRaycaster = class extends BaseRaycaster {
  constructor(components) {
    super(components);
    this.enabled = true;
    this._raycaster = new Raycaster();
    const renderer = components.renderer.get();
    const dom = renderer.domElement;
    this.mouse = new Mouse(dom);
  }
  /** {@link Component.get} */
  get() {
    return this._raycaster;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.mouse.dispose();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   */
  castRay(items = this.components.meshes) {
    const camera = this.components.camera.get();
    this._raycaster.setFromCamera(this.mouse.position, camera);
    const result = this._raycaster.intersectObjects(items);
    const filtered = this.filterClippingPlanes(result);
    return filtered.length > 0 ? filtered[0] : null;
  }
  castRayFromVector(origin, direction, items = this.components.meshes) {
    this._raycaster.set(origin, direction);
    const result = this._raycaster.intersectObjects(items);
    const filtered = this.filterClippingPlanes(result);
    return filtered.length > 0 ? filtered[0] : null;
  }
  filterClippingPlanes(objs) {
    const renderer = this.components.renderer;
    if (!renderer.clippingPlanes) {
      return objs;
    }
    const planes = renderer.clippingPlanes;
    if (objs.length <= 0 || !planes || (planes === null || planes === void 0 ? void 0 : planes.length) <= 0)
      return objs;
    return objs.filter((elem) => planes.every((elem2) => elem2.distanceToPoint(elem.point) > 0));
  }
};

// node_modules/openbim-components/core/SimpleGrid/index.js
var SimpleGrid = class _SimpleGrid extends Component {
  /** {@link Hideable.visible} */
  get visible() {
    return this._grid.visible;
  }
  /** {@link Hideable.visible} */
  set visible(visible) {
    if (visible) {
      const scene = this.components.scene.get();
      scene.add(this._grid);
    } else {
      this._grid.removeFromParent();
    }
  }
  /** The material of the grid. */
  get material() {
    return this._grid.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(active) {
    this._fade = active ? 3 : 0;
    this.material.uniforms.uFade.value = this._fade;
  }
  constructor(components, color2 = new Color(12303291), size1 = 1, size2 = 10, distance = 500) {
    super(components);
    this.enabled = true;
    this._fade = 3;
    this.updateZoom = () => {
      const camera = this.components.camera;
      this.material.uniforms.uZoom.value = camera.get().zoom;
    };
    this.components.tools.add(_SimpleGrid.uuid, this);
    const geometry = new PlaneGeometry(2, 2, 1, 1);
    const material = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: size1
        },
        uSize2: {
          value: size2
        },
        uColor: {
          value: color2
        },
        uDistance: {
          value: distance
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this._grid = new Mesh(geometry, material);
    this._grid.frustumCulled = false;
    const scene = components.scene.get();
    scene.add(this._grid);
    this.setupEvents(true);
  }
  /** {@link Component.get} */
  get() {
    return this._grid;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.setupEvents(false);
    const disposer = await this.components.tools.get(Disposer);
    disposer.destroy(this._grid);
  }
  setupEvents(active) {
    const camera = this.components.camera;
    const controls = camera.controls;
    if (active) {
      controls.addEventListener("update", this.updateZoom);
    } else {
      controls.removeEventListener("update", this.updateZoom);
    }
  }
};
SimpleGrid.uuid = "d1e814d5-b81c-4452-87a2-f039375e0489";
ToolComponent.libraryUUIDs.add(SimpleGrid.uuid);

// node_modules/@popperjs/core/dist/esm/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/dist/esm/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/dist/esm/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/dist/esm/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/dist/esm/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/dist/esm/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/dist/esm/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/dist/esm/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/dist/esm/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v3 = within(min2, value, max2);
  return v3 > max2 ? max2 : v3;
}

// node_modules/@popperjs/core/dist/esm/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/dist/esm/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/dist/esm/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/dist/esm/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/dist/esm/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/dist/esm/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/dist/esm/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/dist/esm/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/dist/esm/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/dist/esm/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/dist/esm/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/dist/esm/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/dist/esm/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/dist/esm/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b2) {
    return overflows[a] - overflows[b2];
  });
}

// node_modules/@popperjs/core/dist/esm/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/dist/esm/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/dist/esm/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/dist/esm/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/dist/esm/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/dist/esm/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/dist/esm/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/dist/esm/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/dist/esm/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/dist/esm/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/dist/esm/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/dist/esm/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/dist/esm/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/openbim-components/utils/LineIntersectionPicker/index.js
var LineIntersectionPicker = class extends Component {
  set enabled(value) {
    this._enabled = value;
    if (!value) {
      this._pickedPoint = null;
    }
  }
  get enabled() {
    return this._enabled;
  }
  get config() {
    return this._config;
  }
  set config(value) {
    this._config = { ...this._config, ...value };
  }
  constructor(components, config) {
    super(components);
    this.name = "LineIntersectionPicker";
    this.onAfterUpdate = new Event();
    this.onBeforeUpdate = new Event();
    this._pickedPoint = null;
    this._raycaster = new Raycaster();
    this._originVector = new Vector3();
    this.config = {
      snapDistance: 0.25,
      ...config
    };
    if (this._raycaster.params.Line) {
      this._raycaster.params.Line.threshold = 0.2;
    }
    this._mouse = new Mouse(components.renderer.get().domElement);
    const marker = document.createElement("div");
    marker.className = "w-[15px] h-[15px] border-3 border-solid border-red-500";
    this._marker = new CSS2DObject(marker);
    this._marker.visible = false;
    this.components.scene.get().add(this._marker);
    this.enabled = false;
  }
  async dispose() {
    this.onAfterUpdate.reset();
    this.onBeforeUpdate.reset();
    this._marker.removeFromParent();
    this._marker.element.remove();
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled) {
      return;
    }
    this.onBeforeUpdate.trigger(this);
    this._raycaster.setFromCamera(this._mouse.position, this.components.camera.get());
    const lines = this.components.meshes.filter((mesh) => mesh.isLine);
    const intersects = this._raycaster.intersectObjects(lines);
    if (intersects.length !== 2) {
      this._pickedPoint = null;
      this.updateMarker();
      return;
    }
    const lineA = intersects[0].object;
    const lineB = intersects[1].object;
    const indices = [intersects[0].index, intersects[1].index];
    const hitPoint = new Vector3().copy(intersects[0].point).add(intersects[1].point).multiplyScalar(0.5);
    const isSameElement = lineA.uuid === lineB.uuid;
    if (isSameElement) {
      const line = lineA;
      const pos = line.geometry.getAttribute("position");
      const vectorA = new Vector3().fromBufferAttribute(pos, indices[0]);
      const vectorB = new Vector3().fromBufferAttribute(pos, indices[0] + 1);
      const vectorC = new Vector3().fromBufferAttribute(pos, indices[1]);
      const vectorD = new Vector3().fromBufferAttribute(pos, indices[1] + 1);
      const point = this.findIntersection(vectorA, vectorB, vectorC, vectorD);
      if (!point) {
        return;
      }
      this._pickedPoint = point;
      if (this._pickedPoint.distanceTo(hitPoint) > 0.25) {
        return;
      }
      this.updateMarker();
    } else {
      const pos1 = lineA.geometry.getAttribute("position");
      const pos2 = lineB.geometry.getAttribute("position");
      const vectorA = new Vector3().fromBufferAttribute(pos1, indices[0]);
      const vectorB = new Vector3().fromBufferAttribute(pos1, indices[0] + 1);
      const vectorC = new Vector3().fromBufferAttribute(pos2, indices[1]);
      const vectorD = new Vector3().fromBufferAttribute(pos2, indices[1] + 1);
      const point = this.findIntersection(vectorA, vectorB, vectorC, vectorD);
      if (!point) {
        return;
      }
      this._pickedPoint = point;
      if (this._pickedPoint.distanceTo(hitPoint) > 0.25) {
        return;
      }
      this.updateMarker();
    }
    this.onAfterUpdate.trigger(this);
  }
  findIntersection(p1, p2, p3, p4) {
    const line1Dir = p2.sub(p1);
    const line2Dir = p4.sub(p3);
    const lineDirCross = new Vector3().crossVectors(line1Dir, line2Dir);
    const denominator = lineDirCross.lengthSq();
    if (denominator === 0) {
      return null;
    }
    const lineToPoint = p3.sub(p1);
    const lineToPointCross = new Vector3().crossVectors(lineDirCross, lineToPoint);
    const t1 = lineToPointCross.dot(line2Dir) / denominator;
    return new Vector3().addVectors(p1, line1Dir.multiplyScalar(t1));
  }
  updateMarker() {
    var _a2;
    this._marker.visible = !!this._pickedPoint;
    this._marker.position.copy((_a2 = this._pickedPoint) !== null && _a2 !== void 0 ? _a2 : this._originVector);
  }
  get() {
    return this._pickedPoint;
  }
};

// node_modules/openbim-components/core/Simple2DMarker/index.js
var Simple2DMarker = class extends Component {
  set visible(value) {
    this._visible = value;
    this._marker.visible = value;
  }
  get visible() {
    return this._visible;
  }
  constructor(components, marker) {
    super(components);
    this.enabled = true;
    this._visible = true;
    let _marker;
    if (marker) {
      _marker = marker;
    } else {
      _marker = document.createElement("div");
      _marker.className = "w-[15px] h-[15px] border-3 border-solid border-red-600";
    }
    this._marker = new CSS2DObject(_marker);
    this.components.scene.get().add(this._marker);
    this.visible = true;
  }
  /** {@link Component.get} */
  get() {
    return this._marker;
  }
  toggleVisibility() {
    this.visible = !this.visible;
  }
  async dispose() {
    this._marker.removeFromParent();
    this._marker.element.remove();
  }
};

// node_modules/openbim-components/utils/VertexPicker/index.js
var VertexPicker = class extends Component {
  set enabled(value) {
    this._enabled = value;
    if (!value) {
      this._marker.visible = false;
      this._pickedPoint = null;
    }
  }
  get enabled() {
    return this._enabled;
  }
  get _raycaster() {
    return this._components.raycaster;
  }
  constructor(components, config) {
    super(components);
    this.name = "VertexPicker";
    this.afterUpdate = new Event();
    this.beforeUpdate = new Event();
    this._pickedPoint = null;
    this._enabled = false;
    this._workingPlane = null;
    this.update = () => {
      if (!this.enabled)
        return;
      this.beforeUpdate.trigger(this);
      const intersects = this._raycaster.castRay();
      if (!intersects) {
        this._marker.visible = false;
        this._pickedPoint = null;
        return;
      }
      const point = this.getClosestVertex(intersects);
      if (!point) {
        this._marker.visible = false;
        this._pickedPoint = null;
        return;
      }
      const isOnPlane = !this.workingPlane ? true : Math.abs(this.workingPlane.distanceToPoint(point)) < 1e-3;
      if (!isOnPlane) {
        this._marker.visible = false;
        this._pickedPoint = null;
        return;
      }
      this._pickedPoint = point;
      this._marker.visible = true;
      this._marker.get().position.set(this._pickedPoint.x, this._pickedPoint.y, this._pickedPoint.z);
      this.afterUpdate.trigger(this);
    };
    this._components = components;
    this.config = {
      snapDistance: 0.25,
      showOnlyVertex: false,
      ...config
    };
    this._marker = new Simple2DMarker(components, this.config.previewElement);
    this._marker.visible = false;
    this.setupEvents(true);
    this.enabled = false;
  }
  set workingPlane(plane) {
    this._workingPlane = plane;
  }
  get workingPlane() {
    return this._workingPlane;
  }
  set config(value) {
    this._config = { ...this._config, ...value };
  }
  get config() {
    return this._config;
  }
  async dispose() {
    this.setupEvents(false);
    await this._marker.dispose();
    this.afterUpdate.reset();
    this.beforeUpdate.reset();
    this._components = null;
  }
  get() {
    return this._pickedPoint;
  }
  getClosestVertex(intersects) {
    let closestVertex = new Vector3();
    let vertexFound = false;
    let closestDistance = Number.MAX_SAFE_INTEGER;
    const vertices = this.getVertices(intersects);
    vertices === null || vertices === void 0 ? void 0 : vertices.forEach((vertex) => {
      if (!vertex)
        return;
      const distance = intersects.point.distanceTo(vertex);
      if (distance > closestDistance || distance > this._config.snapDistance)
        return;
      vertexFound = true;
      closestVertex = vertex;
      closestDistance = intersects.point.distanceTo(vertex);
    });
    if (vertexFound)
      return closestVertex;
    return this.config.showOnlyVertex ? null : intersects.point;
  }
  getVertices(intersects) {
    const mesh = intersects.object;
    if (!intersects.face || !mesh)
      return null;
    const geom = mesh.geometry;
    return [
      this.getVertex(intersects.face.a, geom),
      this.getVertex(intersects.face.b, geom),
      this.getVertex(intersects.face.c, geom)
    ].map((vertex) => vertex === null || vertex === void 0 ? void 0 : vertex.applyMatrix4(mesh.matrixWorld));
  }
  getVertex(index, geom) {
    if (index === void 0)
      return null;
    const vertices = geom.attributes.position;
    return new Vector3(vertices.getX(index), vertices.getY(index), vertices.getZ(index));
  }
  setupEvents(active) {
    const container = this._components.ui.viewerContainer;
    if (active) {
      container.addEventListener("mousemove", this.update);
    } else {
      container.addEventListener("mousemove", this.update);
    }
  }
};

// node_modules/openbim-components/utils/GeometryVerticesMarker/index.js
var GeometryVerticesMarker = class extends Component {
  set visible(value) {
    this._visible = value;
    for (const marker of this._markers)
      marker.visible = value;
  }
  get visible() {
    return this._visible;
  }
  constructor(components, geometry) {
    super(components);
    this.name = "GeometryVerticesMarker";
    this.enabled = true;
    this._markers = [];
    this._visible = true;
    const position = geometry.getAttribute("position");
    for (let index = 0; index < position.count; index++) {
      const marker = new Simple2DMarker(components);
      marker.get().position.set(position.getX(index), position.getY(index), position.getZ(index));
      this._markers.push(marker);
    }
  }
  async dispose() {
    for (const marker of this._markers) {
      await marker.dispose();
    }
    this._markers = [];
  }
  get() {
    return this._markers;
  }
};

// node_modules/openbim-components/ui/SimpleUIComponent/index.js
var SimpleUIComponent = class extends Component {
  get domElement() {
    if (!this._domElement) {
      throw new Error("Dom element not initialized!");
    }
    return this._domElement;
  }
  set domElement(ele) {
    if (this._domElement) {
      this._domElement.remove();
    }
    this._domElement = ele;
  }
  set parent(value) {
    this._parent = value;
  }
  get parent() {
    return this._parent;
  }
  get active() {
    return this._active;
  }
  set active(active) {
    this.domElement.setAttribute("data-active", String(active));
    this._active = active;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (value) {
      this.domElement.classList.remove("hidden");
      this.onVisible.trigger(this.get());
    } else {
      this.domElement.classList.add("hidden");
      this.onHidden.trigger(this.get());
    }
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (value) {
      this.onEnabled.trigger(this.get());
    } else {
      this.onDisabled.trigger(this.get());
    }
  }
  get hasElements() {
    return this.children.length > 0;
  }
  set template(value) {
    const regex = /id="([^"]+)"/g;
    const temp = document.createElement("div");
    temp.innerHTML = value.replace(regex, `id="$1-${this.id}"`);
    const newElement = temp.firstElementChild;
    newElement.id = this.id;
    this.domElement = newElement;
    temp.remove();
  }
  constructor(components, template, id) {
    super(components);
    this.name = "SimpleUIComponent";
    this.children = [];
    this.data = {};
    this.slots = {};
    this.innerElements = {};
    this.onVisible = new Event();
    this.onHidden = new Event();
    this.onEnabled = new Event();
    this.onDisabled = new Event();
    this._parent = null;
    this._enabled = true;
    this._visible = true;
    this._active = false;
    this._components = components;
    this.id = id !== null && id !== void 0 ? id : tooeenRandomId();
    this.template = template !== null && template !== void 0 ? template : "<div></div>";
  }
  cleanData() {
    this.data = {};
  }
  get() {
    return this.domElement;
  }
  async dispose(onlyChildren = false) {
    for (const name in this.slots) {
      const slot = this.slots[name];
      await slot.dispose();
    }
    for (const child of this.children) {
      await child.dispose();
      this.removeChild(child);
    }
    for (const name in this.innerElements) {
      const element = this.innerElements[name];
      if (element) {
        element.remove();
      }
    }
    if (!onlyChildren) {
      if (this._domElement) {
        this._domElement.remove();
      }
      this.onVisible.reset();
      this.onHidden.reset();
      this.onEnabled.reset();
      this.onDisabled.reset();
      this.innerElements = {};
      this.children = [];
      this.slots = {};
      this.parent = null;
    }
  }
  addChild(...items) {
    for (const item of items) {
      this.children.push(item);
      this.domElement.append(item.domElement);
      item.parent = this;
    }
  }
  removeChild(...items) {
    for (const item of items) {
      item.domElement.remove();
      item.parent = null;
    }
    const filtered = this.children.filter((child) => !items.includes(child));
    this.children = filtered;
  }
  removeFromParent() {
    if (!this.parent)
      return;
    this.get().removeAttribute("data-tooeen-slot");
    this.parent.removeChild(this);
  }
  getInnerElement(id) {
    return this.get().querySelector(`#${id}-${this.id}`);
  }
  setSlot(name, uiComponent) {
    const slot = this.get().querySelector(`[data-tooeen-slot="${name}"]`);
    if (!slot)
      throw new Error(`Slot ${name} not found. You need to declare it in the UIComponent template using data-tooeen="${name}"`);
    const existingSlot = this.slots[name];
    if (existingSlot)
      existingSlot.removeFromParent();
    this.slots[name] = uiComponent;
    uiComponent.get().setAttribute("data-tooeen-slot", name);
    slot.replaceWith(uiComponent.get());
    this.children.push(uiComponent);
  }
  setSlots() {
    for (const name in this.slots) {
      const component = this.slots[name];
      this.setSlot(name, component);
    }
  }
};

// node_modules/openbim-components/ui/ToolbarComponent/index.js
var Toolbar = class _Toolbar extends SimpleUIComponent {
  set visible(visible) {
    this._visible = visible && this.hasElements;
    if (visible && this.hasElements) {
      this.domElement.classList.remove("hidden");
      this.onVisible.trigger(this.get());
    } else {
      this.domElement.classList.add("hidden");
      this.onHidden.trigger(this.get());
    }
  }
  get visible() {
    return this._visible;
  }
  set enabled(enabled) {
    this.closeMenus();
    this.children.forEach((button) => {
      button.enabled = enabled;
      button.menu.enabled = enabled;
    });
    this._enabled = enabled;
  }
  set position(position) {
    this._position = position;
    this.updateElements();
  }
  get position() {
    return this._position;
  }
  constructor(components, options) {
    var _a2, _b2;
    const _options = {
      position: "bottom",
      ...options
    };
    const template = `
    <div class="${_Toolbar.Class.Base}"></div> 
    `;
    super(components, template);
    this.children = [];
    this._parent = null;
    this.name = (_a2 = _options.name) !== null && _a2 !== void 0 ? _a2 : "Toolbar";
    this.position = (_b2 = _options.position) !== null && _b2 !== void 0 ? _b2 : "bottom";
    this.visible = true;
  }
  get hasElements() {
    return this.children.length > 0;
  }
  get() {
    return this.domElement;
  }
  addChild(...button) {
    button.forEach((btn) => {
      btn.parent = this;
      this.children.push(btn);
      this.domElement.append(btn.domElement);
    });
    this._components.ui.updateToolbars();
  }
  updateElements() {
    this.children.forEach((button) => button.parent = this);
  }
  closeMenus() {
    this.children.forEach((button) => button.closeMenus());
  }
  setDirection(direction = "horizontal") {
    this.domElement.classList.remove("flex-col");
    const directionClass = direction === "horizontal" ? ["flex"] : ["flex-col"];
    this.domElement.classList.add(...directionClass);
  }
};
Toolbar.Class = {
  Base: `flex shadow-md w-fit h-fit gap-x-2 gap-y-2 p-2 text-white rounded pointer-events-auto backdrop-blur-xl 
           bg-ifcjs-100 z-50 backdrop-blur-xl`
};

// node_modules/openbim-components/ui/ButtonComponent/index.js
var Button = class _Button extends SimpleUIComponent {
  set tooltip(value) {
    const element = this.innerElements.tooltip;
    element.textContent = value;
    if (value) {
      element.classList.remove("hidden");
    } else {
      element.classList.add("hidden");
    }
  }
  get tooltip() {
    return this.innerElements.tooltip.textContent;
  }
  set label(value) {
    const element = this.innerElements.label;
    element.textContent = value;
    if (value) {
      element.classList.remove("hidden");
    } else {
      element.classList.add("hidden");
    }
  }
  get label() {
    return this.innerElements.label.textContent;
  }
  set parent(toolbar) {
    this._parent = toolbar;
    if (toolbar) {
      this.menu.position = toolbar.position;
      this.updateMenuPlacement();
    }
  }
  get parent() {
    return this._parent;
  }
  set alignment(value) {
    this.domElement.classList.remove("justify-start", "justify-center", "justify-end");
    this.domElement.classList.add(`justify-${value}`);
  }
  set materialIcon(name) {
    const icon = this.innerElements.icon;
    icon.textContent = name;
    if (name) {
      icon.style.display = "unset";
    } else {
      icon.style.display = "none";
    }
  }
  get materialIcon() {
    return this.innerElements.icon.textContent;
  }
  get customIcon() {
    return this.innerElements.customIcon.innerHTML;
  }
  constructor(components, options) {
    var _a2, _b2, _c;
    const template = `
    <button class="${_Button.Class.Base}">
      <span style="display: none" id="custom-icon" class="md-18"></span> 
      <span style="display: none" id="icon" class="material-icons md-18"></span> 
      <span id="tooltip" class="${_Button.Class.Tooltip}"></span> 
      <p id="label" class="${_Button.Class.Label}"></p>
    </button>
    `;
    super(components, template);
    this.name = "TooeenButton";
    this.onClick = new Event();
    this._parent = null;
    this._closeOnClick = true;
    this.innerElements = {
      customIcon: this.getInnerElement("custom-icon"),
      icon: this.getInnerElement("icon"),
      label: this.getInnerElement("label"),
      tooltip: this.getInnerElement("tooltip")
    };
    this.materialIcon = (_a2 = options === null || options === void 0 ? void 0 : options.materialIconName) !== null && _a2 !== void 0 ? _a2 : null;
    this.label = (_b2 = options === null || options === void 0 ? void 0 : options.name) !== null && _b2 !== void 0 ? _b2 : null;
    this.tooltip = (_c = options === null || options === void 0 ? void 0 : options.tooltip) !== null && _c !== void 0 ? _c : null;
    this.alignment = "start";
    if ((options === null || options === void 0 ? void 0 : options.closeOnClick) !== void 0) {
      this._closeOnClick = options.closeOnClick;
    }
    this.domElement.onclick = async (e) => {
      e.stopImmediatePropagation();
      await this.onClick.trigger(e);
      if (this.menu.children.length) {
        this.menu.visible = true;
        this._popper.update();
      } else if (this._closeOnClick) {
        this._components.ui.closeMenus();
        this._components.ui.contextMenu.visible = false;
        if (this.parent) {
          if (!this.parent.parent) {
            this._components.ui.closeMenus();
          }
          if (this.parent.closeMenus) {
            this.parent.closeMenus();
          }
        }
      }
    };
    this.domElement.addEventListener("mouseover", ({ target }) => {
      if (this.isButton(target)) {
        if (this._components.ui.tooltipsEnabled) {
          this.innerElements.tooltip.classList.remove("opacity-0");
        }
      }
    });
    this.domElement.addEventListener("mouseleave", ({ target }) => {
      if (this.isButton(target)) {
        this.innerElements.tooltip.classList.add("opacity-0");
      }
    });
    this.menu = new Toolbar(components);
    this.menu.visible = false;
    this.menu.parent = this;
    this.menu.setDirection("vertical");
    this.domElement.append(this.menu.domElement);
    this._popper = createPopper3(this.domElement, this.menu.domElement, {
      modifiers: [
        {
          name: "offset",
          options: { offset: [0, 15] }
        },
        {
          name: "preventOverflow",
          options: { boundary: this._components.ui.viewerContainer }
        }
      ]
    });
    this.onEnabled.add(() => this.domElement.disabled = false);
    this.onDisabled.add(() => this.domElement.disabled = true);
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    await this.menu.dispose();
    if (!onlyChildren) {
      this.domElement.remove();
    }
    this.onClick.reset();
    this._popper.destroy();
  }
  addChild(...button) {
    this.menu.addChild(...button);
  }
  closeMenus() {
    this.menu.closeMenus();
    this.menu.visible = false;
  }
  async setCustomIcon(url) {
    const { customIcon } = this.innerElements;
    if (url) {
      const response = await fetch(url);
      customIcon.innerHTML = await response.text();
      customIcon.style.display = "unset";
    } else {
      customIcon.style.display = "none";
    }
  }
  updateMenuPlacement() {
    var _a2, _b2, _c, _d, _e, _f;
    let placement = "bottom";
    if (((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.position) === "bottom") {
      placement = ((_b2 = this.parent) === null || _b2 === void 0 ? void 0 : _b2.parent) ? "right" : "top";
    }
    if (((_c = this.parent) === null || _c === void 0 ? void 0 : _c.position) === "top") {
      placement = ((_d = this.parent) === null || _d === void 0 ? void 0 : _d.parent) ? "right" : "bottom";
    }
    if (((_e = this.parent) === null || _e === void 0 ? void 0 : _e.position) === "left") {
      placement = "right";
    }
    if (((_f = this.parent) === null || _f === void 0 ? void 0 : _f.position) === "right") {
      placement = "left";
    }
    this._popper.setOptions({ placement });
  }
  isButton(element) {
    return element === this.get() || element === this.innerElements.icon || element === this.innerElements.label;
  }
};
Button.Class = {
  Base: `
    relative flex gap-x-2 items-center bg-transparent text-white rounded-[10px] 
    max-h-8 p-2 hover:cursor-pointer hover:bg-ifcjs-200 hover:text-black
    data-[active=true]:cursor-pointer data-[active=true]:bg-ifcjs-200 data-[active=true]:text-black
    disabled:cursor-default disabled:bg-gray-600 disabled:text-gray-400 pointer-events-auto
    transition-all fill-white hover:fill-black
    `,
  Label: "text-sm tracking-[1.25px] whitespace-nowrap",
  Tooltip: `
    transition-opacity bg-ifcjs-100 text-sm text-gray-100 rounded-md 
    absolute left-1/2 -translate-x-1/2 -translate-y-12 opacity-0 mx-auto p-4 w-max h-4 flex items-center
    pointer-events-none
    `
};

// node_modules/openbim-components/ui/TreeView/index.js
var TreeView = class _TreeView extends SimpleUIComponent {
  set description(value) {
    const element = this.innerElements.description;
    element.textContent = value;
    if (value) {
      element.classList.remove("hidden");
    } else {
      element.classList.add("hidden");
    }
  }
  get description() {
    return this.innerElements.description.textContent;
  }
  set title(value) {
    this.innerElements.title.textContent = value;
  }
  get title() {
    return this.innerElements.title.textContent;
  }
  set materialIcon(name) {
    this.innerElements.expandBtn.textContent = name;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(expanded) {
    this._expanded = expanded;
    this.slots.content.visible = expanded;
    if (expanded) {
      this.onExpand.trigger();
      this.innerElements.titleContainer.classList.add("bg-ifcjs-120");
      this.materialIcon = "arrow_drop_down";
    } else {
      this.onCollapse.trigger();
      this.innerElements.titleContainer.classList.remove("bg-ifcjs-120");
      this.materialIcon = "arrow_right";
    }
  }
  set onmouseover(listener) {
    this.domElement.onmouseover = (e) => {
      e.stopImmediatePropagation();
      listener(e);
    };
  }
  constructor(components, title) {
    const template = `
    <div class="flex flex-col items-start w-full box-border cursor-pointer text-base">
      <div id="title-container" class="flex flex-wrap items-center text-base justify-between hover:bg-ifcjs-120 rounded-md w-full min-h-[30px] pr-3 bg-ifcjs-120">
        <div class="flex flex-row items-center gap-x-2 mr-4">
          <span id="expandBtn" class="material-icons md-18 text-white rounded-[10px] h-fit hover:cursor-pointer hover:bg-ifcjs-200 hover:text-black transition-all p-1"></span>
          <div class="flex flex-col items-start py-[5px]">
            <p id="title" class="text-base"></p>
            <p id="description" class="text-sm text-gray-400"></p>
          </div>
        </div> 
        <div data-tooeen-slot="titleRight"></div>
      </div>
      <div data-tooeen-slot="content"></div>
    </div>
    `;
    super(components, template);
    this._expanded = true;
    this.onExpand = new Event();
    this.onCollapse = new Event();
    this.onClick = new Event();
    this.domElement.onclick = async (e) => {
      e.stopImmediatePropagation();
      await this.onClick.trigger(e);
    };
    this.innerElements = {
      titleContainer: this.getInnerElement("title-container"),
      title: this.getInnerElement("title"),
      description: this.getInnerElement("description"),
      expandBtn: this.getInnerElement("expandBtn")
    };
    this.innerElements.expandBtn.onclick = () => this.toggle();
    this.slots = {
      content: new SimpleUIComponent(components, `<div class="flex flex-col w-full pl-[22px]"></div>`),
      titleRight: new SimpleUIComponent(components)
    };
    this.setSlots();
    this.title = title !== null && title !== void 0 ? title : null;
    this.collapse();
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    if (!onlyChildren) {
      this.onExpand.reset();
      this.onCollapse.reset();
    }
  }
  toggle(deep = false) {
    if (deep) {
      if (this.expanded) {
        this.collapse();
      } else {
        this.expand();
      }
    } else {
      this.expanded = !this.expanded;
    }
  }
  addChild(...items) {
    this.slots.content.addChild(...items);
  }
  collapse(deep = true) {
    if (!this.expanded)
      return;
    this.expanded = false;
    if (!deep)
      return;
    for (const child of this.children)
      if (child instanceof _TreeView)
        child.collapse(deep);
  }
  expand(deep = true) {
    if (this.expanded)
      return;
    this.expanded = true;
    if (!deep)
      return;
    for (const child of this.children)
      if (child instanceof _TreeView)
        child.expand(deep);
  }
};

// node_modules/openbim-components/ui/UIManager/index.js
var UIManager = class extends Component {
  get viewerContainer() {
    return this._components.renderer.get().domElement.parentElement;
  }
  constructor(components) {
    super(components);
    this.name = "UIManager";
    this.enabled = true;
    this.toolbars = [];
    this.tooltipsEnabled = true;
    this.children = [];
    this._mouseMoved = false;
    this._mouseDown = false;
    this._containers = {
      top: document.createElement("div"),
      right: document.createElement("div"),
      bottom: document.createElement("div"),
      left: document.createElement("div")
    };
    this.onMouseUp = () => {
      this._mouseDown = false;
    };
    this.onMouseMoved = () => {
      if (this._mouseDown) {
        this._mouseMoved = true;
      }
    };
    this.onMouseDown = (event) => {
      this._mouseDown = true;
      const canvas = this._components.renderer.get().domElement;
      if (event.target === canvas) {
        this.closeMenus();
        this.contextMenu.visible = false;
      }
    };
    this.onContextMenu = (event) => {
      if (this._mouseMoved) {
        this._mouseMoved = false;
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
      this.closeMenus();
      this._contextMenuContainer.style.left = `${event.offsetX}px`;
      this._contextMenuContainer.style.top = `${event.offsetY}px`;
      this.contextMenu.visible = true;
      this._popperInstance.update();
    };
    this._components = components;
    this.contextMenu = new Toolbar(components);
    this.contextMenu.setDirection("vertical");
    this.contextMenu.position = "left";
    this._contextMenuContainer = document.createElement("div");
    this._contextMenuContainer.style.position = "absolute";
    this._contextMenuContainer.append(this.contextMenu.domElement);
    this._popperInstance = createPopper3(this._contextMenuContainer, this.contextMenu.domElement, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "preventOverflow",
          options: {
            boundary: Object.values(this._containers)
          }
        }
      ]
    });
    const containerClasses = {
      top: ["top-0", "pt-4"],
      right: ["top-0", "right-0", "pr-4"],
      bottom: ["bottom-0", "pb-4"],
      left: ["top-0", "left-0", "pl-4"]
    };
    for (const id in this._containers) {
      const container = this._containers[id];
      container.className = "absolute flex gap-y-3 gap-x-3 pointer-events-none p-4";
      container.classList.add(...containerClasses[id]);
      container.id = `${id}-toolbar-container`;
      this.setContainerAlignment(id, "center");
    }
    const hContainerClass = ["flex-row", "w-full"];
    const vContainerClass = ["flex-column", "h-full"];
    this._containers.top.classList.add(...hContainerClass);
    this._containers.right.classList.add(...vContainerClass);
    this._containers.bottom.classList.add(...hContainerClass);
    this._containers.left.classList.add(...vContainerClass);
  }
  get() {
    return this.toolbars;
  }
  async dispose() {
    this.setupEvents(false);
    for (const name in this._containers) {
      const element = this._containers[name];
      element.remove();
    }
    for (const toolbar of this.toolbars) {
      await toolbar.dispose();
    }
    for (const child of this.children) {
      await child.dispose();
    }
    this._popperInstance.destroy();
    this.children = [];
    await this.contextMenu.dispose();
    this._containers = {};
    this._contextMenuContainer.remove();
    this._popperInstance = null;
    this._components = null;
    this.contextMenu = null;
    this._contextMenuContainer = null;
  }
  init() {
    this.setupEvents(true);
    this.viewerContainer.append(this._containers.top, this._containers.right, this._containers.bottom, this._containers.left, this._contextMenuContainer);
  }
  add(...uiComponents) {
    for (const component of uiComponents) {
      this.children.push(component);
      this.viewerContainer.append(component.domElement);
    }
  }
  closeMenus() {
    this.toolbars.forEach((toolbar) => toolbar.closeMenus());
    this.contextMenu.closeMenus();
  }
  setContainerAlignment(container, alingment) {
    this._containers[container].style.justifyContent = alingment;
    this._containers[container].style.alignItems = alingment;
  }
  addToolbar(...toolbar) {
    toolbar.forEach((tlbr) => {
      const container = this._containers[tlbr.position];
      if (!container) {
        return;
      }
      container.append(tlbr.domElement);
      this.toolbars.push(tlbr);
    });
    this.updateToolbars();
  }
  updateToolbars() {
    this.toolbars.forEach((toolbar) => {
      toolbar.visible = true;
      toolbar.updateElements();
      if (toolbar.position === "bottom" || toolbar.position === "top") {
        toolbar.setDirection("horizontal");
      } else {
        toolbar.setDirection("vertical");
      }
    });
  }
  setupEvents(active) {
    if (active) {
      this.viewerContainer.addEventListener("mouseup", this.onMouseUp);
      this.viewerContainer.addEventListener("mousedown", this.onMouseDown);
      this.viewerContainer.addEventListener("mousemove", this.onMouseMoved);
      this.viewerContainer.addEventListener("contextmenu", this.onContextMenu);
    } else {
      this.viewerContainer.removeEventListener("mouseup", this.onMouseUp);
      this.viewerContainer.removeEventListener("mousedown", this.onMouseDown);
      this.viewerContainer.removeEventListener("mousemove", this.onMouseMoved);
      this.viewerContainer.removeEventListener("contextmenu", this.onContextMenu);
    }
  }
};
UIManager.Class = {
  Label: "block leading-6 text-gray-400 text-sm"
};

// node_modules/openbim-components/ui/SimpleUICard/index.js
var SimpleUICard = class extends SimpleUIComponent {
  set title(value) {
    this.innerElements.title.textContent = value;
  }
  get title() {
    return this.innerElements.title.textContent;
  }
  set description(value) {
    this.innerElements.description.textContent = value;
  }
  get description() {
    return this.innerElements.description.textContent;
  }
  constructor(components, id) {
    const template = `
    <div class="p-2 text-white flex items-center rounded-lg border-transparent border border-solid">
      <div class="mr-auto">
        <p id="title" class="text-base"></p>
        <p id="description" class="text-sm text-gray-400"></p>
      </div>
      <div data-tooeen-slot="rightContainer"></div> 
    </div> 
    `;
    super(components, template, id);
    this.name = "SimpleUICard";
    this.innerElements = {
      title: this.getInnerElement("title"),
      description: this.getInnerElement("description")
    };
    this.slots = {
      rightContainer: new SimpleUIComponent(components, `<div class="flex"></div>`)
    };
    this.setSlots();
  }
  addChild(...items) {
    items.forEach((item) => {
      this.slots.rightContainer.addChild(item);
    });
  }
};

// node_modules/openbim-components/ui/FloatingWindow/index.js
var FloatingWindow = class _FloatingWindow extends SimpleUIComponent {
  get viewerContainer() {
    return this._components.renderer.get().domElement.parentElement;
  }
  set description(value) {
    const element = this.innerElements.description;
    element.textContent = value;
    if (value) {
      element.classList.remove("hidden");
    } else {
      element === null || element === void 0 ? void 0 : element.classList.add("hidden");
    }
  }
  get description() {
    return this.innerElements.description.textContent;
  }
  set title(value) {
    const element = this.innerElements.title;
    element.textContent = value;
    if (value) {
      element.classList.remove("hidden");
    } else {
      element.classList.add("hidden");
    }
  }
  get title() {
    return this.innerElements.title.textContent;
  }
  set resizeable(value) {
    this._resizeable = value;
    if (value) {
      this.get().classList.add("resize");
    } else {
      this.get().classList.remove("resize");
    }
  }
  get resizeable() {
    return this._resizeable;
  }
  set movable(value) {
    this._movable = value;
    if (value) {
      this.innerElements.titleContainer.classList.add("cursor-move");
    } else {
      this.innerElements.titleContainer.classList.remove("cursor-move");
    }
  }
  get movable() {
    return this._movable;
  }
  constructor(components, id) {
    const template = `
    <div class="${_FloatingWindow.Class.Base}">
      <div id="title-container" class="z-10 flex justify-between items-center top-0 select-none cursor-move px-6 py-3 border-b-2 border-solid border-[#3A444E]">
        <div class="flex flex-col">
          <h3 id="title">Tooeen Floating Window</h3>
          <p id="description" class="${_FloatingWindow.Class.Description}"></p>
        </div>
        <span id="close" class="material-icons text-2xl ml-4 text-gray-400 z-20 hover:cursor-pointer hover:text-ifcjs-200">close</span>
      </div>
      <div data-tooeen-slot="content"></div>
    </div>
    `;
    super(components, template, id);
    this._resizeable = true;
    this._movable = true;
    this.onMoved = new Event();
    this.onResized = new Event();
    this._isMouseDown = false;
    this._offsetX = 0;
    this._offsetY = 0;
    this.onMOuseDown = (event) => {
      if (!this.movable)
        return;
      this._isMouseDown = true;
      const rect = this.domElement.getBoundingClientRect();
      this._offsetX = event.clientX - rect.left;
      this._offsetY = event.clientY - rect.top;
    };
    this.onMouseUp = () => {
      this._isMouseDown = false;
    };
    this.onMouseMove = (event) => {
      if (!(this._isMouseDown && this.movable))
        return;
      const { width, height } = this.domElement.getBoundingClientRect();
      const { x, y, width: containerWidth, height: containerHeight } = this.viewerContainer.getBoundingClientRect();
      const maxLeft = containerWidth - width;
      const maxTop = containerHeight - height;
      const left2 = Math.max(0, Math.min(event.clientX - this._offsetX - x, maxLeft));
      const top2 = Math.max(0, Math.min(event.clientY - this._offsetY - y, maxTop));
      this.domElement.style.left = `${left2}px`;
      this.domElement.style.top = `${top2}px`;
      this.onMoved.trigger(this);
    };
    this.innerElements = {
      title: this.getInnerElement("title"),
      description: this.getInnerElement("description"),
      titleContainer: this.getInnerElement("title-container"),
      closeBtn: this.getInnerElement("close")
    };
    this.slots = {
      content: new SimpleUIComponent(components, `<div class="flex flex-col gap-y-4 p-4 overflow-auto"></div>`)
    };
    this.setSlots();
    this.innerElements.closeBtn.onclick = () => this.visible = false;
    this.setMovableListeners();
    const observer = new ResizeObserver(() => this.onResized.trigger());
    observer.observe(this.get());
    this.description = null;
    this.movable = true;
    this.resizeable = true;
    this.referencePoints = {
      topLeft: new Vector2(),
      top: new Vector2(),
      topRight: new Vector2(),
      left: new Vector2(),
      center: new Vector2(),
      right: new Vector2(),
      bottomLeft: new Vector2(),
      bottom: new Vector2(),
      bottomRight: new Vector2()
    };
    this.domElement.style.width = "400px";
    this.domElement.style.height = "250px";
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.setupEvents(false);
    this.onMoved.reset();
    this.onResized.reset();
  }
  setMovableListeners() {
    try {
      this._components.renderer;
    } catch (_e) {
      return;
    }
    this.setupEvents(true);
  }
  addChild(...items) {
    const content = this.slots.content;
    content.addChild(...items);
    if (!content.visible)
      content.visible = true;
  }
  updateReferencePoints() {
    const uiElementRect = this.domElement.getBoundingClientRect();
    this.referencePoints.topLeft.set(uiElementRect.x, uiElementRect.y);
    this.referencePoints.top.set(uiElementRect.x + uiElementRect.width / 2, uiElementRect.y);
    this.referencePoints.topRight.set(uiElementRect.x + uiElementRect.width, uiElementRect.y);
    this.referencePoints.left.set(uiElementRect.x, uiElementRect.y + uiElementRect.height / 2);
    this.referencePoints.center.set(uiElementRect.x + uiElementRect.width / 2, uiElementRect.y + uiElementRect.height / 2);
    this.referencePoints.right.set(uiElementRect.x + uiElementRect.width, uiElementRect.y + uiElementRect.height / 2);
    this.referencePoints.bottomLeft.set(uiElementRect.x, uiElementRect.y + uiElementRect.height);
    this.referencePoints.bottom.set(uiElementRect.x + uiElementRect.width / 2, uiElementRect.y + uiElementRect.height);
    this.referencePoints.bottomRight.set(uiElementRect.x + uiElementRect.width, uiElementRect.y + uiElementRect.height);
  }
  setupEvents(active) {
    const title = this.innerElements.titleContainer;
    const container = this.viewerContainer;
    if (active) {
      if (title) {
        title.addEventListener("mousedown", this.onMOuseDown);
      }
      container.addEventListener("mousemove", this.onMouseMove);
      container.addEventListener("mouseup", this.onMouseUp);
    } else {
      if (title) {
        title.removeEventListener("mousedown", this.onMOuseDown);
      }
      container.removeEventListener("mousemove", this.onMouseMove);
      container.removeEventListener("mouseup", this.onMouseUp);
    }
  }
};
FloatingWindow.Class = {
  Base: "absolute flex flex-col backdrop-blur-xl shadow-md overflow-auto top-5 resize z-50 left-5 min-h-[80px] min-w-[150px] w-fit h-fit text-white bg-ifcjs-100 rounded-md",
  Description: "text-base text-gray-400"
};

// node_modules/openbim-components/ui/Dropdown/index.js
var Dropdown = class extends SimpleUIComponent {
  set value(value) {
    var _a2;
    const option = (_a2 = this.options.find((v3) => v3 === value)) !== null && _a2 !== void 0 ? _a2 : this.options[0];
    this.innerElements.button.textContent = option !== null && option !== void 0 ? option : null;
    this.onChange.trigger(this.value);
  }
  get value() {
    return this.innerElements.button.textContent;
  }
  set allowSearch(value) {
    this._allowSearch = value;
    if (value) {
      this.innerElements.search.classList.remove("hidden");
    } else {
      this.innerElements.search.classList.add("hidden");
    }
  }
  get allowSearch() {
    return this._allowSearch;
  }
  set label(value) {
    this.innerElements.label.textContent = value;
    if (value) {
      this.innerElements.label.classList.remove("hidden");
    } else {
      this.innerElements.label.classList.add("hidden");
    }
  }
  get label() {
    return this.innerElements.label.textContent;
  }
  constructor(components, name = "Tooeen Dropdown") {
    const template = `
    <div class="w-full">
      <label id="label" class="${UIManager.Class.Label}"></label>
      <button
      id="button"
      data-dropdown-toggle="dropdown"
      class="text-white w-full ring-1 ring-gray-500 focus:outline-none focus:ring-ifcjs-200 rounded-md text-base p-3 text-center inline-flex items-center"
      type="button">
        <svg class="w-2.5 h-2.5 ml-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6">
          <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m1 1 4 4 4-4"/>
        </svg>
        </button>
      <div id="dropdown" class="z-10 absolute hidden px-4 py-3 mt-1 max-h-[300px] w-fit overflow-auto bg-[#212121] rounded-md shadow">
        <div id="search" class="hidden">
          <label class="block leading-6 text-gray-400 text-xs">Search</label>
          <input id="searchInput" class="block bg-transparent w-full rounded-md p-3 text-white ring-1 text-base ring-gray-500 placeholder:text-gray-400 focus:ring-ifcjs-200 focus:outline-none"></input>
        </div>
        <ul id="dropdownList" class="text-sm text-white"></ul>
      </div>
    </div>
    `;
    super(components, template);
    this.name = "TooeenDropdown";
    this.options = [];
    this.onChange = new Event();
    this._allowSearch = false;
    this.hide = (event) => {
      if (!this.get().contains(event.target)) {
        this.innerElements.dropdown.classList.add("hidden");
      }
    };
    this.innerElements = {
      label: this.getInnerElement("label"),
      button: this.getInnerElement("button"),
      dropdown: this.getInnerElement("dropdown"),
      search: this.getInnerElement("search"),
      searchInput: this.getInnerElement("searchInput"),
      dropdownList: this.getInnerElement("dropdownList")
    };
    this.setSearch();
    this.innerElements.button.onclick = () => this.toggle();
    this.setupEvents(true);
    this.label = name;
  }
  async dispose(onlyChildren = false) {
    super.dispose(onlyChildren);
    this.onChange.reset();
    this.setupEvents(false);
  }
  toggle() {
    if (this.innerElements.dropdown.classList.contains("hidden")) {
      this.innerElements.dropdown.classList.remove("hidden");
    } else {
      this.innerElements.dropdown.classList.add("hidden");
    }
  }
  addOption(...value) {
    const options = value.filter((option) => !this.options.includes(option));
    for (const option of options) {
      this.options.push(option);
      const li = document.createElement("li");
      li.id = `${option.replace(/\s+/g, "_")}-${this.id}`;
      li.className = "py-2 text-base cursor-pointer hover:text-ifcjs-200";
      li.textContent = option;
      li.onclick = () => {
        this.value = option;
        this.innerElements.dropdown.classList.add("hidden");
      };
      this.innerElements.dropdownList.appendChild(li);
    }
    return this;
  }
  removeOption(...value) {
    const optionsToDelete = value.filter((option) => this.options.includes(option));
    for (const name of optionsToDelete) {
      const option = this.get().querySelector(`#${name.replace(/\s+/g, "_")}-${this.id}`);
      if (!option)
        continue;
      option.remove();
    }
    this.options = this.options.filter((option) => !value.includes(option));
    return this;
  }
  setSearch() {
    this.innerElements.searchInput.oninput = () => {
      var _a2;
      const searchValue = this.innerElements.searchInput.value.toLowerCase();
      const list = this.innerElements.dropdownList.children;
      for (const child of list) {
        const childText = (_a2 = child.textContent) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
        if (!childText)
          continue;
        if (childText.includes(searchValue)) {
          child.classList.remove("hidden");
        } else {
          child.classList.add("hidden");
        }
      }
    };
  }
  setupEvents(active) {
    if (active) {
      document.addEventListener("click", this.hide, true);
    } else {
      document.removeEventListener("click", this.hide, true);
    }
  }
};

// node_modules/openbim-components/ui/TextInput/index.js
var TextInput = class extends SimpleUIComponent {
  set value(value) {
    this.innerElements.input.value = value;
    this.onChange.trigger(this.value);
  }
  get value() {
    return this.innerElements.input.value;
  }
  set label(value) {
    this.innerElements.label.textContent = value;
    if (value) {
      this.innerElements.label.classList.remove("hidden");
    } else {
      this.innerElements.label.classList.add("hidden");
    }
  }
  get label() {
    return this.innerElements.label.textContent;
  }
  constructor(components) {
    const template = `
    <div class="w-full">
      <label id="label" class="${UIManager.Class.Label}"></label>
      <input id="input" type="text" class="block bg-transparent w-full rounded-md p-3 text-white ring-1 text-base ring-gray-500 focus:ring-ifcjs-200 focus:outline-none placeholder:text-gray-400">
    </div>
    `;
    super(components, template);
    this.name = "TooeenTextInput";
    this.onChange = new Event();
    this.innerElements = {
      label: this.getInnerElement("label"),
      input: this.getInnerElement("input")
    };
    this.label = "Tooeen Text";
    this.innerElements.label.setAttribute("for", `input-${this.id}`);
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.onChange.reset();
  }
};

// node_modules/openbim-components/ui/CheckboxInput/index.js
var CheckboxInput = class extends SimpleUIComponent {
  set value(value) {
    this.innerElements.input.checked = value;
    this.onChange.trigger(this.value);
  }
  get value() {
    return this.innerElements.input.checked;
  }
  set label(value) {
    this.innerElements.label.textContent = value;
    if (value) {
      this.innerElements.label.classList.remove("hidden");
    } else {
      this.innerElements.label.classList.add("hidden");
    }
  }
  get label() {
    return this.innerElements.label.textContent;
  }
  constructor(components) {
    const template = `
    <div class="w-full flex gap-x-2 items-center">
        <input id="input" type="checkbox" 
            class="h-4 w-4 rounded border-gray-300 accent-ifcjs-300 text-ifcjs-300 focus:ring-ifcjs-300">
        <label id="label" class="${UIManager.Class.Label}"></label>
    </div>
    `;
    super(components, template);
    this.name = "TooeenCheckboxInput";
    this.onChange = new Event();
    this.innerElements = {
      label: this.getInnerElement("label"),
      input: this.getInnerElement("input")
    };
    this.innerElements.input.addEventListener("change", () => {
      this.onChange.trigger(this.value);
    });
    this.label = "Tooeen Checkbox";
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.onChange.reset();
  }
};

// node_modules/openbim-components/ui/ColorInput/index.js
var ColorInput = class extends SimpleUIComponent {
  set value(value) {
    this.innerElements.input.value = value;
    this.onChange.trigger(this.value);
  }
  get value() {
    return this.innerElements.input.value;
  }
  set label(value) {
    this.innerElements.label.textContent = value;
    if (value) {
      this.innerElements.label.classList.remove("hidden");
    } else {
      this.innerElements.label.classList.add("hidden");
    }
  }
  get label() {
    return this.innerElements.label.textContent;
  }
  // @ts-ignore
  constructor(components) {
    const template = `
    <div class="w-full">
      <label id="label" class="${UIManager.Class.Label}"></label>
      <input id="input" type="color" class="block w-full h-[48px] rounded-md text-white text-base ring-gray-500 focus:ring-ifcjs-200 focus:outline-none">
    </div>
    `;
    super(components, template);
    this.name = "TooeenColorInput";
    this.onChange = new Event();
    this.innerElements = {
      label: this.getInnerElement("label"),
      input: this.getInnerElement("input")
    };
    this.label = "Tooeen Color";
    this.value = "#BCF124";
    this.innerElements.input.oninput = () => {
      this.onChange.trigger(this.value);
    };
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.onChange.reset();
  }
};

// node_modules/openbim-components/ui/RangeInput/index.js
var RangeInput = class extends SimpleUIComponent {
  set value(value) {
    this.innerElements.input.value = String(value);
    this.onChange.trigger(this.value);
  }
  get value() {
    return Number(this.innerElements.input.value);
  }
  set label(value) {
    this.innerElements.label.textContent = value;
    if (value) {
      this.innerElements.label.classList.remove("hidden");
    } else {
      this.innerElements.label.classList.add("hidden");
    }
  }
  get label() {
    return this.innerElements.label.textContent;
  }
  set min(value) {
    this.innerElements.input.min = String(value);
  }
  get min() {
    return Number(this.innerElements.input.min);
  }
  set max(value) {
    this.innerElements.input.max = String(value);
  }
  get max() {
    return Number(this.innerElements.input.max);
  }
  set step(value) {
    this.innerElements.input.step = String(value);
  }
  get step() {
    return Number(this.innerElements.input.step);
  }
  // @ts-ignore
  constructor(components) {
    const template = `
    <div>
      <label id="label" class="${UIManager.Class.Label}"></label>
      <input id="input" type="range" class="block w-full rounded-md border-0 py-1.5 shadow-sm accent-ifcjs-300">
    </div>
    `;
    super(components, template);
    this.name = "TooeenRangeInput";
    this.onChange = new Event();
    this.innerElements = {
      label: this.getInnerElement("label"),
      input: this.getInnerElement("input")
    };
    this.label = "Tooeen Range";
    this.innerElements.input.oninput = () => {
      this.onChange.trigger(this.value);
    };
  }
};

// node_modules/openbim-components/ui/Canvas/index.js
var Canvas = class extends SimpleUIComponent {
  constructor(components) {
    const template = `
        <canvas class="absolute w-80 h-40 right-8 bottom-4 bg-ifcjs-120 
        border-transparent border border-solid rounded-lg"></canvas> 
    `;
    super(components, template);
    this.name = "Canvas";
    this.onResize = new Event();
    this._size = new Vector2(320, 160);
  }
  getSize() {
    return this._size;
  }
  resize(size) {
    if (size) {
      this._size = size;
      this.domElement.style.width = `${size.x}px`;
      this.domElement.style.height = `${size.y}px`;
      this.onResize.trigger(size);
    }
  }
};

// node_modules/openbim-components/ui/DragAndDropInput/index.js
var DragAndDropInput = class extends SimpleUIComponent {
  constructor(components, config) {
    const subtitle = config ? config.subTitle : "";
    const template = `
      <div class="absolute top-8 bottom-8 left-8 right-8">
        <div class="flex items-center justify-center w-full h-full">
            <label for="dropzone-file" class="h-full flex flex-col items-center justify-center w-full border-2 border-gray-300 border-dashed rounded-lg cursor-pointer backdrop-blur-xl bg-ifcjs-100 dark:hover:bg-bray-800 dark:bg-gray-700 dark:border-gray-600 dark:hover:border-gray-500 dark:hover:bg-gray-600 transition ease-in-out hover:backdrop-blur-xl duration-300">
                <div class="flex flex-col items-center justify-center pt-5 pb-6">
                    <svg class="w-8 h-8 mb-4 text-gray-500 dark:text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 16">
                        <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"/>
                    </svg>
                    <p class="mb-2 text-sm text-gray-500 dark:text-gray-400"><span class="font-semibold">Click to upload</span> or drag and drop</p>
                    <p class="text-xs text-gray-500 dark:text-gray-400">${subtitle}</p>
                </div>
                <input id="dropzone-file" type="file" class="hidden" />
            </label>
        </div> 
      </div>
    `;
    super(components, template);
    this.name = "DragAndDropInput";
    this.onFilesLoaded = new Event();
    const input = this.get().querySelector("input");
    if (!input)
      throw new Error("Input not found!");
    const onFilesLoaded = async () => {
      if (input.files === null)
        return;
      await this.onFilesLoaded.trigger(input.files);
    };
    input.onchange = () => onFilesLoaded();
    const allowDragDrop = (event) => event.preventDefault();
    this.get().ondragover = allowDragDrop;
    this.get().ondragenter = allowDragDrop;
    this.get().ondrop = async (event) => {
      event.preventDefault();
      input.files = event.dataTransfer.files;
      await onFilesLoaded();
    };
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.onFilesLoaded.reset();
  }
};

// node_modules/openbim-components/ui/Spinner/index.js
var Spinner = class extends SimpleUIComponent {
  constructor(components) {
    const template = `
    <div class="absolute w-screen h-screen top-0 bottom-0 right-0 left-0 flex justify-center items-center pointer-events-none">
      <div role="status">
        <svg aria-hidden="true" class="w-8 h-8 mr-2 text-ifcjs-200 animate-spin fill-black" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"/>
          <path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"/>
        </svg>
        <span class="sr-only">Loading...</span>
      </div>
    </div>
    `;
    super(components, template);
    this.name = "Spinner";
  }
};

// node_modules/openbim-components/ui/ToastNotification/index.js
var ToastNotification = class extends SimpleUIComponent {
  set materialIcon(name) {
    this.innerElements.icon.textContent = name;
    if (name) {
      this.innerElements.icon.classList.remove("hidden");
    } else {
      this.innerElements.icon.classList.add("hidden");
    }
  }
  constructor(components, config) {
    var _a2;
    const template = `
    <div class="absolute bottom-8 left-8 transition-transform">
      <div id="toast-default" class="flex items-center w-full max-w-xs p-4 text-gray-500 bg-ifcjs-200 rounded-lg shadow dark:text-gray-400 dark:bg-gray-800" role="alert">
        <div class="inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-ifcjs-200 bg-ifcjs-300 rounded-full dark:bg-blue-800 dark:text-blue-200">
          <span id="icon" class="material-icons md-18"></span>
        </div>
        <p id="message" class="ml-3 text-sm font-normal"></p>
      </div>
    </div>
    `;
    super(components, template);
    this.name = "ToastNotification";
    this.duration = 3e3;
    this.innerElements = {
      icon: this.getInnerElement("icon"),
      message: this.getInnerElement("message")
    };
    this.domElement.style.zIndex = "9999";
    this.materialIcon = (_a2 = config.materialIconName) !== null && _a2 !== void 0 ? _a2 : "done";
    this.message = config.message;
  }
  get message() {
    return this.innerElements.message.textContent;
  }
  set message(value) {
    this.innerElements.message.textContent = value;
  }
  set visible(active) {
    const delay = 200;
    if (active) {
      super.visible = active;
      setTimeout(() => {
        this.domElement.style.transform = "translateY(0)";
        this.hideAutomatically();
      }, delay);
    } else {
      this.domElement.style.transform = "translateY(10rem)";
      setTimeout(() => super.visible = active, delay);
    }
  }
  hideAutomatically() {
    setTimeout(() => {
      this.visible = false;
    }, this.duration);
  }
};

// node_modules/openbim-components/ui/TextArea/index.js
var TextArea = class extends SimpleUIComponent {
  set value(value) {
    this.innerElements.input.value = value;
    this.onChange.trigger(this.value);
  }
  get value() {
    return this.innerElements.input.value;
  }
  set label(value) {
    this.innerElements.label.textContent = value;
    if (value) {
      this.innerElements.label.classList.remove("hidden");
    } else {
      this.innerElements.label.classList.add("hidden");
    }
  }
  get label() {
    return this.innerElements.label.textContent;
  }
  set placeholder(value) {
    this.innerElements.input.placeholder = value;
  }
  get placeholder() {
    return this.innerElements.input.placeholder;
  }
  constructor(components) {
    const template = `
    <div class="w-full">
      <label id="label" for="message" class="${UIManager.Class.Label}"></label>
      <textarea id="input" rows="4" class="block bg-transparent w-full rounded-md p-3 text-white ring-1 text-base ring-gray-500 focus:ring-ifcjs-200 focus:outline-none placeholder:text-gray-400"></textarea>
    </div>
    `;
    super(components, template);
    this.name = "TooeenTextArea";
    this.onChange = new Event();
    this.innerElements = {
      label: this.getInnerElement("label"),
      input: this.getInnerElement("input")
    };
    this.label = "Tooeen Text Area";
    this.placeholder = "Write something...";
    this.innerElements.label.setAttribute("for", `input-${this.id}`);
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.onChange.reset();
  }
};

// node_modules/openbim-components/ui/CommandsMenu/index.js
var CommandsMenu = class extends SimpleUIComponent {
  get hasCommands() {
    return Object.keys(this.commands).length !== 0;
  }
  constructor(components) {
    const template = `<div id="window" class="absolute bg-ifcjs-100 backdrop-blur-xl rounded-md p-3 z-50"></div>`;
    super(components, template);
    this.name = "CommandsMenu";
    this.offset = new Vector2(20, -10);
    this.commands = {};
    this.hideCommandsMenu = () => {
      this.visible = false;
    };
    this.innerElements = {
      window: this.getInnerElement("window")
    };
    this.setupEvents(true);
  }
  update() {
    this.dispose(true);
    for (const name in this.commands) {
      const command = this.commands[name];
      const button = new Button(this._components, { name });
      button.name = name;
      this.addChild(button);
      button.onClick.add(() => command(this.commandData));
    }
  }
  popup(x, y) {
    this.domElement.style.left = `${x + this.offset.x}px`;
    this.domElement.style.top = `${y + this.offset.y}px`;
    this.visible = true;
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    if (!onlyChildren) {
      this.setupEvents(false);
      this.commands = {};
      this.commandData = null;
    }
  }
  setupEvents(active) {
    if (active) {
      window.addEventListener("click", this.hideCommandsMenu);
    } else {
      window.removeEventListener("click", this.hideCommandsMenu);
    }
  }
};

// node_modules/openbim-components/ui/Drawer/index.js
var Drawer = class extends SimpleUIComponent {
  get visible() {
    return this._visible;
  }
  set visible(value) {
    const classes = this.domElement.classList;
    const isHorizontal = this._type === "top" || this._type === "bottom";
    if (isHorizontal) {
      const sign = this._type === "top" ? "-" : "";
      if (value) {
        classes.remove(`${sign}translate-y-full`);
      } else {
        classes.add(`${sign}translate-y-full`);
      }
    } else {
      const sign = this._type === "left" ? "-" : "";
      if (value) {
        classes.remove(`${sign}translate-x-full`);
      } else {
        classes.add(`${sign}translate-x-full`);
      }
    }
    this._visible = value;
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
    const horizontal = this._type === "top" || this._type === "bottom";
    const height = horizontal ? this._size : "inherit";
    const width = horizontal ? "inherit" : this._size;
    this.domElement.style.height = height;
    this.domElement.style.width = width;
  }
  set alignment(value) {
    const classes = this.domElement.classList;
    this._type = value;
    classes.remove("h-full");
    classes.remove("w-full");
    classes.remove("top-0");
    classes.remove("bottom-0");
    classes.remove("left-0");
    classes.remove("right-0");
    classes.remove("-translate-x-full");
    classes.remove("-translate-y-full");
    classes.remove("translate-x-full");
    classes.remove("translate-y-full");
    if (value === "top" || value === "bottom") {
      classes.add("w-full");
      classes.add("left-0");
      classes.add(`${value}-0`);
    } else {
      classes.add("h-full");
      classes.add("top-0");
      classes.add(`${value}-0`);
    }
    this.size = this._size;
    this.visible = this._visible;
  }
  constructor(components) {
    const template = `
        <div class="fixed bg-ifcjs-100 backdrop-blur-xl shadow-md overflow-auto shadow-lg z-20 top-0 left-0 h-full transition-all duration-500 transform">
            <div class="px-6 py-4">
                <div data-tooeen-slot="content"></div>
            </div>
        </div>
    `;
    super(components, template);
    this.name = "Drawer";
    this._size = "10rem";
    this._visible = true;
    this._type = "left";
    this.domElement.style.width = this._size;
    this.slots = {
      content: new SimpleUIComponent(components, `<div class="flex flex-col gap-y-4 p-4 overflow-auto"></div>`)
    };
    this.setSlots();
  }
  addChild(...items) {
    const content = this.slots.content;
    content.addChild(...items);
    if (!content.visible)
      content.visible = true;
  }
};

// node_modules/openbim-components/ui/Modal/index.js
var Modal = class extends SimpleUIComponent {
  set description(value) {
    const element = this.innerElements.description;
    element.textContent = value;
    if (value) {
      element.classList.remove("hidden");
    } else {
      element === null || element === void 0 ? void 0 : element.classList.add("hidden");
    }
  }
  get description() {
    return this.innerElements.description.textContent;
  }
  set title(value) {
    const element = this.innerElements.title;
    element.textContent = value;
    if (value) {
      element.classList.remove("hidden");
    } else {
      element.classList.add("hidden");
    }
  }
  get title() {
    return this.innerElements.title.textContent;
  }
  set visible(value) {
    this._visible = value;
    if (value) {
      this.get().showModal();
      this.onVisible.trigger();
    } else {
      this.get().close();
      this.onHidden.trigger();
    }
  }
  get visible() {
    return this._visible;
  }
  constructor(components, title = "Tooeen Modal") {
    const template = `
    <dialog>
      <div class="flex flex-col backdrop-blur-xl w-[350px] h-fit text-white bg-ifcjs-100 rounded-md">
        <div class="flex justify-between items-center top-0 select-none px-6 py-3 border-b-2 border-solid border-[#3A444E]">
          <h3 id="title">${title}</h3>
          <p id="description" class="text-base text-gray-400"></p>
        </div>
        <div data-tooeen-slot="content"></div>
        <div data-tooeen-slot="actionButtons"></div>
      </div>
    </dialog> 
    `;
    super(components, template);
    this.onAccept = new Event();
    this.onCancel = new Event();
    this.innerElements = {
      title: this.getInnerElement("title"),
      description: this.getInnerElement("description")
    };
    this.slots = {
      content: new SimpleUIComponent(components),
      actionButtons: new SimpleUIComponent(components, `<div class="flex gap-x-2 justify-end p-4"></div>`)
    };
    this.setSlots();
    const acceptBtn = new Button(this._components);
    acceptBtn.materialIcon = "check";
    acceptBtn.label = "Accept";
    acceptBtn.get().classList.remove("hover:bg-ifcjs-200");
    acceptBtn.get().classList.add("hover:bg-success");
    acceptBtn.onClick.add(() => this.onAccept.trigger());
    const cancelBtn = new Button(this._components);
    cancelBtn.materialIcon = "close";
    cancelBtn.label = "Cancel";
    cancelBtn.get().classList.remove("hover:bg-ifcjs-200");
    cancelBtn.get().classList.add("hover:bg-error");
    cancelBtn.onClick.add(() => this.onCancel.trigger());
    this.slots.actionButtons.addChild(cancelBtn, acceptBtn);
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.onCancel.reset();
    this.onAccept.reset();
  }
};

// node_modules/openbim-components/core/Components/index.js
var Components = class _Components {
  /**
   * The [Three.js renderer](https://threejs.org/docs/#api/en/renderers/WebGLRenderer)
   * used to render the scene. This library provides multiple renderer
   * components with pre-made functionality (e.g. rendering of 2D CSS elements.
   */
  get renderer() {
    if (!this._renderer) {
      throw new Error("Renderer hasn't been initialised.");
    }
    return this._renderer;
  }
  /**
   * This needs to be initialized before calling init().
   */
  set renderer(renderer) {
    this._renderer = renderer;
  }
  /**
   * The [Three.js scene](https://threejs.org/docs/#api/en/scenes/Scene)
   * where all the rendered items are placed.
   */
  get scene() {
    if (!this._scene) {
      throw new Error("Scene hasn't been initialised.");
    }
    return this._scene;
  }
  /**
   * This needs to be initialized before calling init().
   */
  set scene(scene) {
    this._scene = scene;
  }
  /**
   * The [Three.js camera](https://threejs.org/docs/#api/en/cameras/Camera)
   * that determines the point of view of the renderer.
   */
  get camera() {
    if (!this._camera) {
      throw new Error("Camera hasn't been initialised.");
    }
    return this._camera;
  }
  /**
   * This needs to be initialized before calling init().
   */
  set camera(camera) {
    this._camera = camera;
  }
  /**
   * A component using the [Three.js raycaster](https://threejs.org/docs/#api/en/core/Raycaster)
   * used primarily to pick 3D items with the mouse or a touch screen.
   */
  get raycaster() {
    if (!this._raycaster) {
      throw new Error("Raycaster hasn't been initialised.");
    }
    return this._raycaster;
  }
  /**
   * Although this is not necessary to make the library work, it's necessary
   * to initialize this if any component that needs a raycaster is used.
   */
  set raycaster(raycaster) {
    this._raycaster = raycaster;
  }
  constructor() {
    this.meshes = [];
    this.onInitialized = new Event();
    this.enabled = false;
    this.update = async () => {
      if (!this.enabled)
        return;
      const delta = this._clock.getDelta();
      await _Components.update(this.scene, delta);
      await _Components.update(this.renderer, delta);
      await _Components.update(this.camera, delta);
      await this.tools.update(delta);
      const renderer = this.renderer.get();
      renderer.setAnimationLoop(this.update);
    };
    this._clock = new Clock();
    this.tools = new ToolComponent(this);
    this.ui = new UIManager(this);
    _Components.setupBVH();
  }
  /**
   * Initializes the library. It should be called at the start of the app after
   * initializing the scene, the renderer and the
   * camera. Additionally, if any component that need a raycaster is
   * used, the {@link raycaster} will need to be initialized.
   */
  init() {
    this.enabled = true;
    this._clock.start();
    this.ui.init();
    this.update();
    this.onInitialized.trigger(this);
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  async dispose() {
    const disposer = await this.tools.get(Disposer);
    this.enabled = false;
    await this.tools.dispose();
    await this.ui.dispose();
    this.onInitialized.reset();
    this._clock.stop();
    for (const mesh of this.meshes) {
      disposer.destroy(mesh);
    }
    this.meshes.length = 0;
    if (this.renderer.isDisposeable()) {
      await this.renderer.dispose();
    }
    if (this.scene.isDisposeable()) {
      await this.scene.dispose();
    }
    if (this.camera.isDisposeable()) {
      await this.camera.dispose();
    }
    if (this.raycaster.isDisposeable()) {
      await this.raycaster.dispose();
    }
  }
  static async update(component, delta) {
    if (component.isUpdateable() && component.enabled) {
      await component.update(delta);
    }
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
    BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
    Mesh.prototype.raycast = acceleratedRaycast;
  }
};

// node_modules/three/examples/jsm/controls/TransformControls.js
var _raycaster2 = new Raycaster();
var _tempVector = new Vector3();
var _tempVector2 = new Vector3();
var _tempQuaternion = new Quaternion();
var _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var _changeEvent = { type: "change" };
var _mouseDownEvent = { type: "mouseDown" };
var _mouseUpEvent = { type: "mouseUp", mode: null };
var _objectChangeEvent = { type: "objectChange" };
var TransformControls = class extends Object3D {
  constructor(camera, domElement) {
    super();
    if (domElement === void 0) {
      console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
      domElement = document;
    }
    this.isTransformControls = true;
    this.visible = false;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    const _gizmo = new TransformControlsGizmo();
    this._gizmo = _gizmo;
    this.add(_gizmo);
    const _plane = new TransformControlsPlane();
    this._plane = _plane;
    this.add(_plane);
    const scope = this;
    function defineProperty2(propName, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            _plane[propName] = value;
            _gizmo[propName] = value;
            scope.dispatchEvent({ type: propName + "-changed", value });
            scope.dispatchEvent(_changeEvent);
          }
        }
      });
      scope[propName] = defaultValue;
      _plane[propName] = defaultValue;
      _gizmo[propName] = defaultValue;
    }
    defineProperty2("camera", camera);
    defineProperty2("object", void 0);
    defineProperty2("enabled", true);
    defineProperty2("axis", null);
    defineProperty2("mode", "translate");
    defineProperty2("translationSnap", null);
    defineProperty2("rotationSnap", null);
    defineProperty2("scaleSnap", null);
    defineProperty2("space", "world");
    defineProperty2("size", 1);
    defineProperty2("dragging", false);
    defineProperty2("showX", true);
    defineProperty2("showY", true);
    defineProperty2("showZ", true);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty2("worldPosition", worldPosition);
    defineProperty2("worldPositionStart", worldPositionStart);
    defineProperty2("worldQuaternion", worldQuaternion);
    defineProperty2("worldQuaternionStart", worldQuaternionStart);
    defineProperty2("cameraPosition", cameraPosition);
    defineProperty2("cameraQuaternion", cameraQuaternion);
    defineProperty2("pointStart", pointStart);
    defineProperty2("pointEnd", pointEnd);
    defineProperty2("rotationAxis", rotationAxis);
    defineProperty2("rotationAngle", rotationAngle);
    defineProperty2("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    if (this.object !== void 0) {
      this.object.updateMatrixWorld();
      if (this.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);
      }
      this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);
      this._parentQuaternionInv.copy(this._parentQuaternion).invert();
      this._worldQuaternionInv.copy(this.worldQuaternion).invert();
    }
    this.camera.updateMatrixWorld();
    this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);
    if (this.camera.isOrthographicCamera) {
      this.camera.getWorldDirection(this.eye).negate();
    } else {
      this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
    }
    super.updateMatrixWorld(this);
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true)
      return;
    _raycaster2.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster2);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer.button !== 0)
      return;
    if (this.axis !== null) {
      _raycaster2.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster2, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space = this.space;
    if (mode === "scale") {
      space = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer.button !== -1)
      return;
    _raycaster2.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster2, true);
    if (!planeIntersect)
      return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1)
        this._offset.x = 0;
      if (axis.indexOf("Y") === -1)
        this._offset.y = 0;
      if (axis.indexOf("Z") === -1)
        this._offset.z = 0;
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d2 = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0)
          d2 *= -1;
        _tempVector2.set(d2, d2, d2);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      if (axis === "E") {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      } else if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        this.rotationAngle = this._offset.dot(_tempVector.cross(this.eye).normalize()) * ROTATION_SPEED;
      }
      if (this.rotationSnap)
        this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer.button !== 0)
      return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.traverse(function(child) {
      if (child.geometry)
        child.geometry.dispose();
      if (child.material)
        child.material.dispose();
    });
  }
  // Set current object
  attach(object) {
    this.object = object;
    this.visible = true;
    return this;
  }
  // Detach from object
  detach() {
    this.object = void 0;
    this.visible = false;
    this.axis = null;
    return this;
  }
  reset() {
    if (!this.enabled)
      return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  getRaycaster() {
    return _raycaster2;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  setSize(size) {
    this.size = size;
  }
  setSpace(space) {
    this.space = space;
  }
};
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled)
    return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled)
    return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled)
    return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled)
    return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
var _tempEuler = new Euler();
var _alignVector = new Vector3(0, 1, 0);
var _zeroVector = new Vector3(0, 0, 0);
var _lookAtMatrix = new Matrix4();
var _tempQuaternion2 = new Quaternion();
var _identityQuaternion = new Quaternion();
var _dirVector = new Vector3();
var _tempMatrix = new Matrix4();
var _unitX = new Vector3(1, 0, 0);
var _unitY = new Vector3(0, 1, 0);
var _unitZ = new Vector3(0, 0, 1);
var _v1 = new Vector3();
var _v22 = new Vector3();
var _v3 = new Vector3();
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space = this.mode === "scale" ? "local" : this.space;
    const quaternion = space === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale")
      space = "local";
    _v1.copy(_unitX).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v22.copy(_unitY).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v22);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v22);
            _dirVector.copy(_v22).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v22);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
};

// node_modules/openbim-components/core/SimpleClipper/simple-plane.js
var SimplePlane = class _SimplePlane extends Component {
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(state) {
    this._enabled = state;
    this.components.renderer.togglePlane(state, this._plane);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(state) {
    this._visible = state;
    this._controls.visible = state;
    this._helper.visible = state;
    this.toggleControls(state);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(material) {
    this._planeMesh.material = material;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(size) {
    this._planeMesh.scale.set(size, size, size);
  }
  constructor(components, origin, normal, material, size = 5, activateControls = true) {
    super(components);
    this.name = "SimplePlane";
    this.onDraggingStarted = new Event();
    this.onDraggingEnded = new Event();
    this._plane = new Plane();
    this._visible = true;
    this._enabled = true;
    this._controlsActive = false;
    this._arrowBoundBox = new Mesh();
    this._hiddenMaterial = new MeshBasicMaterial({
      visible: false
    });
    this.update = () => {
      if (!this._enabled)
        return;
      this._plane.setFromNormalAndCoplanarPoint(this._normal, this._helper.position);
    };
    this.changeDrag = (event) => {
      this._visible = !event.value;
      this.preventCameraMovement();
      this.notifyDraggingChanged(event);
    };
    this._normal = normal;
    this._origin = origin;
    this.components.renderer.togglePlane(true, this._plane);
    this._planeMesh = _SimplePlane.newPlaneMesh(size, material);
    this._helper = this.newHelper();
    this._controls = this.newTransformControls();
    this._plane.setFromNormalAndCoplanarPoint(normal, origin);
    if (activateControls) {
      this.toggleControls(true);
    }
  }
  /** {@link Component.get} */
  get() {
    return this._plane;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this._enabled = false;
    this.onDraggingStarted.reset();
    this.onDraggingEnded.reset();
    this._helper.removeFromParent();
    this.components.renderer.togglePlane(false, this._plane);
    this._arrowBoundBox.removeFromParent();
    this._arrowBoundBox.geometry.dispose();
    this._planeMesh.geometry.dispose();
    this._controls.removeFromParent();
    this._controls.dispose();
  }
  toggleControls(state) {
    if (state) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update);
      this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else {
      this._controls.removeEventListener("change", this.update);
      this._controls.removeEventListener("dragging-changed", this.changeDrag);
    }
    this._controlsActive = state;
  }
  newTransformControls() {
    const camera = this.components.camera.get();
    const container = this.components.renderer.get().domElement;
    const controls = new TransformControls(camera, container);
    this.initializeControls(controls);
    this.components.scene.get().add(controls);
    return controls;
  }
  initializeControls(controls) {
    controls.attach(this._helper);
    controls.showX = false;
    controls.showY = false;
    controls.setSpace("local");
    this.createArrowBoundingBox();
    controls.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2);
    this._arrowBoundBox.material = this._hiddenMaterial;
    this._arrowBoundBox.rotateX(Math.PI / 2);
    this._arrowBoundBox.updateMatrix();
    this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(event) {
    if (event.value) {
      this.onDraggingStarted.trigger();
    } else {
      this.onDraggingEnded.trigger();
    }
  }
  preventCameraMovement() {
    this.components.camera.enabled = this._visible;
  }
  newHelper() {
    const helper = new Object3D();
    helper.lookAt(this._normal);
    helper.position.copy(this._origin);
    this._planeMesh.position.z += 0.01;
    helper.add(this._planeMesh);
    this.components.scene.get().add(helper);
    return helper;
  }
  static newPlaneMesh(size, material) {
    const planeGeom = new PlaneGeometry(1);
    const mesh = new Mesh(planeGeom, material);
    mesh.scale.set(size, size, size);
    return mesh;
  }
};

// node_modules/openbim-components/core/SimpleClipper/index.js
var SimpleClipper = class _SimpleClipper extends Component {
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(state) {
    this._enabled = state;
    for (const plane of this._planes) {
      plane.enabled = state;
    }
    this.updateMaterialsAndPlanes();
    if (this.components.ui.enabled) {
      this.uiElement.get("main").active = state;
    }
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(state) {
    this._visible = state;
    for (const plane of this._planes) {
      plane.visible = state;
    }
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(material) {
    this._material = material;
    for (const plane of this._planes) {
      plane.planeMaterial = material;
    }
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(size) {
    this._size = size;
    for (const plane of this._planes) {
      plane.size = size;
    }
  }
  constructor(components) {
    super(components);
    this.onAfterCreate = new Event();
    this.onAfterDelete = new Event();
    this.onBeforeDrag = new Event();
    this.onAfterDrag = new Event();
    this.onBeforeCreate = new Event();
    this.onBeforeCancel = new Event();
    this.onAfterCancel = new Event();
    this.onBeforeDelete = new Event();
    this.uiElement = new UIElement();
    this.orthogonalY = false;
    this.toleranceOrthogonalY = 0.7;
    this._planes = [];
    this._material = new MeshBasicMaterial({
      color: 16776960,
      side: DoubleSide,
      transparent: true,
      opacity: 0.2
    });
    this._size = 5;
    this._enabled = false;
    this._visible = true;
    this._onStartDragging = () => {
      this.onBeforeDrag.trigger();
    };
    this._onEndDragging = () => {
      this.onAfterDrag.trigger();
    };
    this.components.tools.add(_SimpleClipper.uuid, this);
    this.PlaneType = SimplePlane;
    if (components.ui.enabled) {
      this.setUI(components);
    }
  }
  endCreation() {
  }
  cancelCreation() {
  }
  /** {@link Component.get} */
  get() {
    return this._planes;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this._enabled = false;
    for (const plane of this._planes) {
      await plane.dispose();
    }
    this._planes.length = 0;
    this.uiElement.dispose();
    this._material.dispose();
    this.onBeforeCreate.reset();
    this.onBeforeCancel.reset();
    this.onBeforeDelete.reset();
    this.onBeforeDrag.reset();
    this.onAfterCreate.reset();
    this.onAfterCancel.reset();
    this.onAfterDelete.reset();
    this.onAfterDrag.reset();
  }
  /** {@link Createable.create} */
  create() {
    if (!this.enabled)
      return;
    const intersects = this.components.raycaster.castRay();
    if (!intersects)
      return;
    this.createPlaneFromIntersection(intersects);
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * @param isPlan - whether this is a clipping plane used for floor plan
   * navigation.
   */
  createFromNormalAndCoplanarPoint(normal, point) {
    const plane = this.newPlane(point, normal);
    this.updateMaterialsAndPlanes();
    return plane;
  }
  /**
   * {@link Createable.delete}
   *
   * @param plane - the plane to delete. If undefined, the the first plane
   * found under the cursor will be deleted.
   */
  delete(plane) {
    if (!this.enabled)
      return;
    if (!plane) {
      plane = this.pickPlane();
    }
    if (!plane) {
      return;
    }
    this.deletePlane(plane);
  }
  /** Deletes all the existing clipping planes. */
  deleteAll() {
    while (this._planes.length > 0) {
      this.delete(this._planes[0]);
    }
  }
  deletePlane(plane) {
    const index = this._planes.indexOf(plane);
    if (index !== -1) {
      this._planes.splice(index, 1);
      this.components.renderer.togglePlane(false, plane.get());
      plane.dispose();
      this.updateMaterialsAndPlanes();
      this.onAfterDelete.trigger(plane);
    }
  }
  setUI(components) {
    const main2 = new Button(components);
    main2.materialIcon = "content_cut";
    main2.onClick.add(() => {
      this.enabled = !this.enabled;
      this.visible = !this.visible;
    });
    main2.active = this.enabled;
    this.uiElement.set({ main: main2 });
  }
  pickPlane() {
    const meshes = this.getAllPlaneMeshes();
    const intersects = this.components.raycaster.castRay(meshes);
    if (intersects) {
      const found = intersects.object;
      return this._planes.find((p2) => p2.meshes.includes(found));
    }
    return void 0;
  }
  getAllPlaneMeshes() {
    const meshes = [];
    for (const plane of this._planes) {
      meshes.push(...plane.meshes);
    }
    return meshes;
  }
  createPlaneFromIntersection(intersect) {
    var _a2;
    const constant = intersect.point.distanceTo(new Vector3(0, 0, 0));
    const normal = (_a2 = intersect.face) === null || _a2 === void 0 ? void 0 : _a2.normal;
    if (!constant || !normal)
      return;
    const worldNormal = this.getWorldNormal(intersect, normal);
    const plane = this.newPlane(intersect.point, worldNormal.negate());
    this.components.renderer.togglePlane(true, plane.get());
    this.updateMaterialsAndPlanes();
  }
  getWorldNormal(intersect, normal) {
    const object = intersect.object;
    let transform = intersect.object.matrixWorld.clone();
    const isInstance = object instanceof InstancedMesh;
    if (isInstance && intersect.instanceId !== void 0) {
      const temp = new Matrix4();
      object.getMatrixAt(intersect.instanceId, temp);
      transform = temp.multiply(transform);
    }
    const normalMatrix = new Matrix3().getNormalMatrix(transform);
    const worldNormal = normal.clone().applyMatrix3(normalMatrix).normalize();
    this.normalizePlaneDirectionY(worldNormal);
    return worldNormal;
  }
  normalizePlaneDirectionY(normal) {
    if (this.orthogonalY) {
      if (normal.y > this.toleranceOrthogonalY) {
        normal.x = 0;
        normal.y = 1;
        normal.z = 0;
      }
      if (normal.y < -this.toleranceOrthogonalY) {
        normal.x = 0;
        normal.y = -1;
        normal.z = 0;
      }
    }
  }
  newPlane(point, normal) {
    const plane = this.newPlaneInstance(point, normal);
    plane.onDraggingStarted.add(this._onStartDragging);
    plane.onDraggingEnded.add(this._onEndDragging);
    this._planes.push(plane);
    this.onAfterCreate.trigger(plane);
    return plane;
  }
  newPlaneInstance(point, normal) {
    return new this.PlaneType(this.components, point, normal, this._material);
  }
  updateMaterialsAndPlanes() {
    this.components.renderer.updateClippingPlanes();
    const planes = this.components.renderer.clippingPlanes;
    for (const model of this.components.meshes) {
      if (Array.isArray(model.material)) {
        for (const mat of model.material) {
          mat.clippingPlanes = planes;
        }
      } else {
        model.material.clippingPlanes = planes;
      }
    }
  }
};
SimpleClipper.uuid = "66290bc5-18c4-4cd1-9379-2e17a0617611";
ToolComponent.libraryUUIDs.add(SimpleClipper.uuid);

// node_modules/openbim-components/core/ScreenCuller/src/screen-culler-helper.js
function clientWaitAsync(gl, sync, flags, intervalMilliseconds) {
  return new Promise((resolve, reject) => {
    function test() {
      const res = gl.clientWaitSync(sync, flags, 0);
      if (res === gl.WAIT_FAILED) {
        reject();
        return;
      }
      if (res === gl.TIMEOUT_EXPIRED) {
        setTimeout(test, intervalMilliseconds);
        return;
      }
      resolve();
    }
    test();
  });
}
async function getBufferSubDataAsync(gl, target, buffer, srcByteOffset, dstBuffer, dstOffset, length) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  gl.flush();
  await clientWaitAsync(gl, sync, 0, 10);
  gl.deleteSync(sync);
  gl.bindBuffer(target, buffer);
  gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
  gl.bindBuffer(target, null);
}
async function readPixelsAsync(gl, x, y, w, h2, format, type2, dest) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
  gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
  gl.readPixels(x, y, w, h2, format, type2, 0);
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
  await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);
  gl.deleteBuffer(buf);
  return dest;
}

// node_modules/openbim-components/core/ScreenCuller/index.js
var ScreenCuller = class _ScreenCuller extends Component {
  constructor(components, updateInterval = 1e3, rtWidth = 512, rtHeight = 512, autoUpdate = true) {
    super(components);
    this.updateInterval = updateInterval;
    this.rtWidth = rtWidth;
    this.rtHeight = rtHeight;
    this.autoUpdate = autoUpdate;
    this.onViewUpdated = new Event();
    this.enabled = true;
    this.needsUpdate = false;
    this.renderDebugFrame = false;
    this._meshColorMap = /* @__PURE__ */ new Map();
    this._visibleMeshes = [];
    this._colorMeshes = /* @__PURE__ */ new Map();
    this._meshes = /* @__PURE__ */ new Map();
    this._currentVisibleMeshes = /* @__PURE__ */ new Set();
    this._recentlyHiddenMeshes = /* @__PURE__ */ new Set();
    this._transparentMat = new MeshBasicMaterial({
      transparent: true,
      opacity: 0
    });
    this._colors = { r: 0, g: 0, b: 0, i: 0 };
    this._scene = new Scene();
    this.updateVisibility = async (force) => {
      if (!this.enabled)
        return;
      if (!this.needsUpdate && !force)
        return;
      const camera = this.components.camera.get();
      camera.updateMatrix();
      this.renderer.setSize(this.rtWidth, this.rtHeight);
      this.renderer.setRenderTarget(this.renderTarget);
      this.renderer.render(this._scene, camera);
      const context = this.renderer.getContext();
      await readPixelsAsync(context, 0, 0, this.rtWidth, this.rtHeight, context.RGBA, context.UNSIGNED_BYTE, this._buffer);
      this.renderer.setRenderTarget(null);
      if (this.renderDebugFrame) {
        this.renderer.render(this._scene, camera);
      }
      this.worker.postMessage({
        buffer: this._buffer
      });
      this.needsUpdate = false;
    };
    this.handleWorkerMessage = async (event) => {
      const colors = event.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes);
      this._currentVisibleMeshes.clear();
      this._visibleMeshes = [];
      for (const code2 of colors.values()) {
        const mesh = this._meshColorMap.get(code2);
        if (mesh) {
          this._visibleMeshes.push(mesh);
          mesh.visible = true;
          this._currentVisibleMeshes.add(mesh.uuid);
          this._recentlyHiddenMeshes.delete(mesh.uuid);
        }
      }
      for (const uuid of this._recentlyHiddenMeshes) {
        const mesh = this._meshes.get(uuid);
        if (mesh === void 0)
          continue;
        mesh.visible = false;
      }
      await this.onViewUpdated.trigger();
    };
    components.tools.add(_ScreenCuller.uuid, this);
    this.renderer = new WebGLRenderer();
    const planes = this.components.renderer.clippingPlanes;
    this.renderer.clippingPlanes = planes;
    this.renderTarget = new WebGLRenderTarget(rtWidth, rtHeight);
    this.bufferSize = rtWidth * rtHeight * 4;
    this._buffer = new Uint8Array(this.bufferSize);
    this.materialCache = /* @__PURE__ */ new Map();
    const code = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Set();
        for (let i = 0; i < buffer.length; i += 4) {
            const r = buffer[i];
            const g = buffer[i + 1];
            const b = buffer[i + 2];
            const code = "" + r + "-" + g + "-" + b;
            colors.add(code);
        }
        postMessage({ colors });
      });
    `;
    const blob = new Blob([code], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.worker.addEventListener("message", this.handleWorkerMessage);
    if (autoUpdate)
      window.setInterval(this.updateVisibility, updateInterval);
  }
  /**
   * {@link Component.get}.
   * @returns the map of internal meshes used to determine visibility.
   */
  get() {
    return this._colorMeshes;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.enabled = false;
    this._currentVisibleMeshes.clear();
    this._recentlyHiddenMeshes.clear();
    this._scene.children.length = 0;
    this.onViewUpdated.reset();
    this.worker.terminate();
    this.renderer.dispose();
    this.renderTarget.dispose();
    this._buffer = null;
    this._transparentMat.dispose();
    this._meshColorMap.clear();
    this._visibleMeshes = [];
    for (const id in this.materialCache) {
      const material = this.materialCache.get(id);
      if (material) {
        material.dispose();
      }
    }
    const disposer = await this.components.tools.get(Disposer);
    for (const id in this._colorMeshes) {
      const mesh = this._colorMeshes.get(id);
      if (mesh) {
        disposer.destroy(mesh);
      }
    }
    this._colorMeshes.clear();
    this._meshes.clear();
  }
  /**
   * Adds a new mesh to be processed and managed by the culler.
   * @mesh the mesh or instanced mesh to add.
   */
  add(mesh) {
    if (!this.enabled)
      return;
    const isInstanced = mesh instanceof InstancedMesh;
    const { geometry, material } = mesh;
    const { r, g, b: b2, code } = this.getNextColor();
    const colorMaterial = this.getMaterial(r, g, b2);
    let newMaterial;
    if (Array.isArray(material)) {
      let transparentOnly = true;
      const matArray = [];
      for (const mat of material) {
        if (this.isTransparent(mat)) {
          matArray.push(this._transparentMat);
        } else {
          transparentOnly = false;
          matArray.push(colorMaterial);
        }
      }
      if (transparentOnly) {
        colorMaterial.dispose();
        return;
      }
      newMaterial = matArray;
    } else if (this.isTransparent(material)) {
      colorMaterial.dispose();
      return;
    } else {
      newMaterial = colorMaterial;
    }
    this._meshColorMap.set(code, mesh);
    const count = isInstanced ? mesh.count : 1;
    const colorMesh = new InstancedMesh(geometry, newMaterial, count);
    if (isInstanced) {
      colorMesh.instanceMatrix = mesh.instanceMatrix;
    } else {
      colorMesh.setMatrixAt(0, new Matrix4());
    }
    mesh.visible = false;
    colorMesh.applyMatrix4(mesh.matrix);
    colorMesh.updateMatrix();
    this._scene.add(colorMesh);
    this._colorMeshes.set(mesh.uuid, colorMesh);
    this._meshes.set(mesh.uuid, mesh);
  }
  getMaterial(r, g, b2) {
    const colorEnabled = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const code = `rgb(${r}, ${g}, ${b2})`;
    const color2 = new Color(code);
    let material = this.materialCache.get(code);
    const clippingPlanes = this.components.renderer.clippingPlanes;
    if (!material) {
      material = new MeshBasicMaterial({
        color: color2,
        clippingPlanes,
        side: DoubleSide
      });
      this.materialCache.set(code, material);
    }
    ColorManagement.enabled = colorEnabled;
    return material;
  }
  isTransparent(material) {
    return material.transparent && material.opacity < 1;
  }
  getNextColor() {
    if (this._colors.i === 0) {
      this._colors.b++;
      if (this._colors.b === 256) {
        this._colors.b = 0;
        this._colors.i = 1;
      }
    }
    if (this._colors.i === 1) {
      this._colors.g++;
      this._colors.i = 0;
      if (this._colors.g === 256) {
        this._colors.g = 0;
        this._colors.i = 2;
      }
    }
    if (this._colors.i === 2) {
      this._colors.r++;
      this._colors.i = 1;
      if (this._colors.r === 256) {
        this._colors.r = 0;
        this._colors.i = 0;
      }
    }
    return {
      r: this._colors.r,
      g: this._colors.g,
      b: this._colors.b,
      code: `${this._colors.r}-${this._colors.g}-${this._colors.b}`
    };
  }
};
ScreenCuller.uuid = "69f2a50d-c266-44fc-b1bd-fa4d34be89e6";
ToolComponent.libraryUUIDs.add(ScreenCuller.uuid);

// node_modules/dexie/dist/modern/dexie.mjs
var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
var keys = Object.keys;
var isArray = Array.isArray;
if (typeof Promise !== "undefined" && !_global.Promise) {
  _global.Promise = Promise;
}
function extend(obj, extension) {
  if (typeof extension !== "object")
    return obj;
  keys(extension).forEach(function(key) {
    obj[key] = extension[key];
  });
  return obj;
}
var getProto = Object.getPrototypeOf;
var _hasOwn = {}.hasOwnProperty;
function hasOwn(obj, prop) {
  return _hasOwn.call(obj, prop);
}
function props(proto, extension) {
  if (typeof extension === "function")
    extension = extension(getProto(proto));
  (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach((key) => {
    setProp(proto, key, extension[key]);
  });
}
var defineProperty = Object.defineProperty;
function setProp(obj, prop, functionOrGetSet, options) {
  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
}
function derive(Child) {
  return {
    from: function(Parent) {
      Child.prototype = Object.create(Parent.prototype);
      setProp(Child.prototype, "constructor", Child);
      return {
        extend: props.bind(null, Child.prototype)
      };
    }
  };
}
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function getPropertyDescriptor(obj, prop) {
  const pd = getOwnPropertyDescriptor(obj, prop);
  let proto;
  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}
var _slice = [].slice;
function slice(args, start2, end2) {
  return _slice.call(args, start2, end2);
}
function override(origFunc, overridedFactory) {
  return overridedFactory(origFunc);
}
function assert(b2) {
  if (!b2)
    throw new Error("Assertion Failed");
}
function asap$1(fn2) {
  if (_global.setImmediate)
    setImmediate(fn2);
  else
    setTimeout(fn2, 0);
}
function arrayToObject(array, extractor) {
  return array.reduce((result, item, i) => {
    var nameAndValue = extractor(item, i);
    if (nameAndValue)
      result[nameAndValue[0]] = nameAndValue[1];
    return result;
  }, {});
}
function tryCatch(fn2, onerror, args) {
  try {
    fn2.apply(null, args);
  } catch (ex) {
    onerror && onerror(ex);
  }
}
function getByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string" && hasOwn(obj, keyPath))
    return obj[keyPath];
  if (!keyPath)
    return obj;
  if (typeof keyPath !== "string") {
    var rv = [];
    for (var i = 0, l2 = keyPath.length; i < l2; ++i) {
      var val = getByKeyPath(obj, keyPath[i]);
      rv.push(val);
    }
    return rv;
  }
  var period = keyPath.indexOf(".");
  if (period !== -1) {
    var innerObj = obj[keyPath.substr(0, period)];
    return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
  }
  return void 0;
}
function setByKeyPath(obj, keyPath, value) {
  if (!obj || keyPath === void 0)
    return;
  if ("isFrozen" in Object && Object.isFrozen(obj))
    return;
  if (typeof keyPath !== "string" && "length" in keyPath) {
    assert(typeof value !== "string" && "length" in value);
    for (var i = 0, l2 = keyPath.length; i < l2; ++i) {
      setByKeyPath(obj, keyPath[i], value[i]);
    }
  } else {
    var period = keyPath.indexOf(".");
    if (period !== -1) {
      var currentKeyPath = keyPath.substr(0, period);
      var remainingKeyPath = keyPath.substr(period + 1);
      if (remainingKeyPath === "")
        if (value === void 0) {
          if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
            obj.splice(currentKeyPath, 1);
          else
            delete obj[currentKeyPath];
        } else
          obj[currentKeyPath] = value;
      else {
        var innerObj = obj[currentKeyPath];
        if (!innerObj || !hasOwn(obj, currentKeyPath))
          innerObj = obj[currentKeyPath] = {};
        setByKeyPath(innerObj, remainingKeyPath, value);
      }
    } else {
      if (value === void 0) {
        if (isArray(obj) && !isNaN(parseInt(keyPath)))
          obj.splice(keyPath, 1);
        else
          delete obj[keyPath];
      } else
        obj[keyPath] = value;
    }
  }
}
function delByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string")
    setByKeyPath(obj, keyPath, void 0);
  else if ("length" in keyPath)
    [].map.call(keyPath, function(kp) {
      setByKeyPath(obj, kp, void 0);
    });
}
function shallowClone(obj) {
  var rv = {};
  for (var m2 in obj) {
    if (hasOwn(obj, m2))
      rv[m2] = obj[m2];
  }
  return rv;
}
var concat = [].concat;
function flatten(a) {
  return concat.apply([], a);
}
var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map((num) => ["Int", "Uint", "Float"].map((t) => t + num + "Array")))).filter((t) => _global[t]);
var intrinsicTypes = intrinsicTypeNames.map((t) => _global[t]);
arrayToObject(intrinsicTypeNames, (x) => [x, true]);
var circularRefs = null;
function deepClone(any) {
  circularRefs = typeof WeakMap !== "undefined" && /* @__PURE__ */ new WeakMap();
  const rv = innerDeepClone(any);
  circularRefs = null;
  return rv;
}
function innerDeepClone(any) {
  if (!any || typeof any !== "object")
    return any;
  let rv = circularRefs && circularRefs.get(any);
  if (rv)
    return rv;
  if (isArray(any)) {
    rv = [];
    circularRefs && circularRefs.set(any, rv);
    for (var i = 0, l2 = any.length; i < l2; ++i) {
      rv.push(innerDeepClone(any[i]));
    }
  } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
    rv = any;
  } else {
    const proto = getProto(any);
    rv = proto === Object.prototype ? {} : Object.create(proto);
    circularRefs && circularRefs.set(any, rv);
    for (var prop in any) {
      if (hasOwn(any, prop)) {
        rv[prop] = innerDeepClone(any[prop]);
      }
    }
  }
  return rv;
}
var { toString } = {};
function toStringTag(o) {
  return toString.call(o).slice(8, -1);
}
var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
  var i;
  return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function() {
  return null;
};
var NO_CHAR_ARRAY = {};
function getArrayOf(arrayLike) {
  var i, a, x, it;
  if (arguments.length === 1) {
    if (isArray(arrayLike))
      return arrayLike.slice();
    if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
      return [arrayLike];
    if (it = getIteratorOf(arrayLike)) {
      a = [];
      while (x = it.next(), !x.done)
        a.push(x.value);
      return a;
    }
    if (arrayLike == null)
      return [arrayLike];
    i = arrayLike.length;
    if (typeof i === "number") {
      a = new Array(i);
      while (i--)
        a[i] = arrayLike[i];
      return a;
    }
    return [arrayLike];
  }
  i = arguments.length;
  a = new Array(i);
  while (i--)
    a[i] = arguments[i];
  return a;
}
var isAsyncFunction = typeof Symbol !== "undefined" ? (fn2) => fn2[Symbol.toStringTag] === "AsyncFunction" : () => false;
var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function setDebug(value, filter) {
  debug = value;
  libraryFilter = filter;
}
var libraryFilter = () => true;
var NEEDS_THROW_FOR_STACK = !new Error("").stack;
function getErrorWithStack() {
  if (NEEDS_THROW_FOR_STACK)
    try {
      getErrorWithStack.arguments;
      throw new Error();
    } catch (e) {
      return e;
    }
  return new Error();
}
function prettyStack(exception, numIgnoredFrames) {
  var stack = exception.stack;
  if (!stack)
    return "";
  numIgnoredFrames = numIgnoredFrames || 0;
  if (stack.indexOf(exception.name) === 0)
    numIgnoredFrames += (exception.name + exception.message).split("\n").length;
  return stack.split("\n").slice(numIgnoredFrames).filter(libraryFilter).map((frame) => "\n" + frame).join("");
}
var dexieErrorNames = [
  "Modify",
  "Bulk",
  "OpenFailed",
  "VersionChange",
  "Schema",
  "Upgrade",
  "InvalidTable",
  "MissingAPI",
  "NoSuchDatabase",
  "InvalidArgument",
  "SubTransaction",
  "Unsupported",
  "Internal",
  "DatabaseClosed",
  "PrematureCommit",
  "ForeignAwait"
];
var idbDomErrorNames = [
  "Unknown",
  "Constraint",
  "Data",
  "TransactionInactive",
  "ReadOnly",
  "Version",
  "NotFound",
  "InvalidState",
  "InvalidAccess",
  "Abort",
  "Timeout",
  "QuotaExceeded",
  "Syntax",
  "DataClone"
];
var errorList = dexieErrorNames.concat(idbDomErrorNames);
var defaultTexts = {
  VersionChanged: "Database version changed by other database connection",
  DatabaseClosed: "Database has been closed",
  Abort: "Transaction aborted",
  TransactionInactive: "Transaction has already completed or failed",
  MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
};
function DexieError(name, msg) {
  this._e = getErrorWithStack();
  this.name = name;
  this.message = msg;
}
derive(DexieError).from(Error).extend({
  stack: {
    get: function() {
      return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
    }
  },
  toString: function() {
    return this.name + ": " + this.message;
  }
});
function getMultiErrorMessage(msg, failures) {
  return msg + ". Errors: " + Object.keys(failures).map((key) => failures[key].toString()).filter((v3, i, s3) => s3.indexOf(v3) === i).join("\n");
}
function ModifyError(msg, failures, successCount, failedKeys) {
  this._e = getErrorWithStack();
  this.failures = failures;
  this.failedKeys = failedKeys;
  this.successCount = successCount;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(ModifyError).from(DexieError);
function BulkError(msg, failures) {
  this._e = getErrorWithStack();
  this.name = "BulkError";
  this.failures = Object.keys(failures).map((pos) => failures[pos]);
  this.failuresByPos = failures;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(BulkError).from(DexieError);
var errnames = errorList.reduce((obj, name) => (obj[name] = name + "Error", obj), {});
var BaseException = DexieError;
var exceptions = errorList.reduce((obj, name) => {
  var fullName = name + "Error";
  function DexieError2(msgOrInner, inner) {
    this._e = getErrorWithStack();
    this.name = fullName;
    if (!msgOrInner) {
      this.message = defaultTexts[name] || fullName;
      this.inner = null;
    } else if (typeof msgOrInner === "string") {
      this.message = `${msgOrInner}${!inner ? "" : "\n " + inner}`;
      this.inner = inner || null;
    } else if (typeof msgOrInner === "object") {
      this.message = `${msgOrInner.name} ${msgOrInner.message}`;
      this.inner = msgOrInner;
    }
  }
  derive(DexieError2).from(BaseException);
  obj[name] = DexieError2;
  return obj;
}, {});
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;
var exceptionMap = idbDomErrorNames.reduce((obj, name) => {
  obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
function mapError(domError, message) {
  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
    return domError;
  var rv = new exceptionMap[domError.name](message || domError.message, domError);
  if ("stack" in domError) {
    setProp(rv, "stack", { get: function() {
      return this.inner.stack;
    } });
  }
  return rv;
}
var fullNameExceptions = errorList.reduce((obj, name) => {
  if (["Syntax", "Type", "Range"].indexOf(name) === -1)
    obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;
function nop() {
}
function mirror(val) {
  return val;
}
function pureFunctionChain(f1, f2) {
  if (f1 == null || f1 === mirror)
    return f2;
  return function(val) {
    return f2(f1(val));
  };
}
function callBoth(on1, on2) {
  return function() {
    on1.apply(this, arguments);
    on2.apply(this, arguments);
  };
}
function hookCreatingChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res !== void 0)
      arguments[0] = res;
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res2 !== void 0 ? res2 : res;
  };
}
function hookDeletingChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    f1.apply(this, arguments);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = this.onerror = null;
    f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
  };
}
function hookUpdatingChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function(modifications) {
    var res = f1.apply(this, arguments);
    extend(modifications, res);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
  };
}
function reverseStoppableEventChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    if (f2.apply(this, arguments) === false)
      return false;
    return f1.apply(this, arguments);
  };
}
function promisableChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res && typeof res.then === "function") {
      var thiz = this, i = arguments.length, args = new Array(i);
      while (i--)
        args[i] = arguments[i];
      return res.then(function() {
        return f2.apply(thiz, args);
      });
    }
    return f2.apply(this, arguments);
  };
}
var INTERNAL = {};
var LONG_STACKS_CLIP_LIMIT = 100;
var MAX_LONG_STACKS = 20;
var ZONE_ECHO_LIMIT = 100;
var [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === "undefined" ? [] : (() => {
  let globalP = Promise.resolve();
  if (typeof crypto === "undefined" || !crypto.subtle)
    return [globalP, getProto(globalP), globalP];
  const nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [
    nativeP,
    getProto(nativeP),
    globalP
  ];
})();
var nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
var patchGlobalPromise = !!resolvedGlobalPromise;
var stack_being_generated = false;
var schedulePhysicalTick = resolvedGlobalPromise ? () => {
  resolvedGlobalPromise.then(physicalTick);
} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {
  var hiddenDiv = document.createElement("div");
  new MutationObserver(() => {
    physicalTick();
    hiddenDiv = null;
  }).observe(hiddenDiv, { attributes: true });
  hiddenDiv.setAttribute("i", "1");
} : () => {
  setTimeout(physicalTick, 0);
};
var asap = function(callback, args) {
  microtickQueue.push([callback, args]);
  if (needsNewPhysicalTick) {
    schedulePhysicalTick();
    needsNewPhysicalTick = false;
  }
};
var isOutsideMicroTick = true;
var needsNewPhysicalTick = true;
var unhandledErrors = [];
var rejectingErrors = [];
var currentFulfiller = null;
var rejectionMapper = mirror;
var globalPSD = {
  id: "global",
  global: true,
  ref: 0,
  unhandleds: [],
  onunhandled: globalError,
  pgp: false,
  env: {},
  finalize: function() {
    this.unhandleds.forEach((uh) => {
      try {
        globalError(uh[0], uh[1]);
      } catch (e) {
      }
    });
  }
};
var PSD = globalPSD;
var microtickQueue = [];
var numScheduledCalls = 0;
var tickFinalizers = [];
function DexiePromise(fn2) {
  if (typeof this !== "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [];
  this.onuncatched = nop;
  this._lib = false;
  var psd = this._PSD = PSD;
  if (debug) {
    this._stackHolder = getErrorWithStack();
    this._prev = null;
    this._numPrev = 0;
  }
  if (typeof fn2 !== "function") {
    if (fn2 !== INTERNAL)
      throw new TypeError("Not a function");
    this._state = arguments[1];
    this._value = arguments[2];
    if (this._state === false)
      handleRejection(this, this._value);
    return;
  }
  this._state = null;
  this._value = null;
  ++psd.ref;
  executePromiseTask(this, fn2);
}
var thenProp = {
  get: function() {
    var psd = PSD, microTaskId = totalEchoes;
    function then(onFulfilled, onRejected) {
      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
      const cleanup = possibleAwait && !decrementExpectedAwaits();
      var rv = new DexiePromise((resolve, reject) => {
        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
      });
      debug && linkToPreviousPromise(rv, this);
      return rv;
    }
    then.prototype = INTERNAL;
    return then;
  },
  set: function(value) {
    setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
      get: function() {
        return value;
      },
      set: thenProp.set
    });
  }
};
props(DexiePromise.prototype, {
  then: thenProp,
  _then: function(onFulfilled, onRejected) {
    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
  },
  catch: function(onRejected) {
    if (arguments.length === 1)
      return this.then(null, onRejected);
    var type2 = arguments[0], handler = arguments[1];
    return typeof type2 === "function" ? this.then(null, (err) => err instanceof type2 ? handler(err) : PromiseReject(err)) : this.then(null, (err) => err && err.name === type2 ? handler(err) : PromiseReject(err));
  },
  finally: function(onFinally) {
    return this.then((value) => {
      onFinally();
      return value;
    }, (err) => {
      onFinally();
      return PromiseReject(err);
    });
  },
  stack: {
    get: function() {
      if (this._stack)
        return this._stack;
      try {
        stack_being_generated = true;
        var stacks = getStack(this, [], MAX_LONG_STACKS);
        var stack = stacks.join("\nFrom previous: ");
        if (this._state !== null)
          this._stack = stack;
        return stack;
      } finally {
        stack_being_generated = false;
      }
    }
  },
  timeout: function(ms, msg) {
    return ms < Infinity ? new DexiePromise((resolve, reject) => {
      var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);
      this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
    }) : this;
  }
});
if (typeof Symbol !== "undefined" && Symbol.toStringTag)
  setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
globalPSD.env = snapShot();
function Listener(onFulfilled, onRejected, resolve, reject, zone) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.resolve = resolve;
  this.reject = reject;
  this.psd = zone;
}
props(DexiePromise, {
  all: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise(function(resolve, reject) {
      if (values.length === 0)
        resolve([]);
      var remaining = values.length;
      values.forEach((a, i) => DexiePromise.resolve(a).then((x) => {
        values[i] = x;
        if (!--remaining)
          resolve(values);
      }, reject));
    });
  },
  resolve: (value) => {
    if (value instanceof DexiePromise)
      return value;
    if (value && typeof value.then === "function")
      return new DexiePromise((resolve, reject) => {
        value.then(resolve, reject);
      });
    var rv = new DexiePromise(INTERNAL, true, value);
    linkToPreviousPromise(rv, currentFulfiller);
    return rv;
  },
  reject: PromiseReject,
  race: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise((resolve, reject) => {
      values.map((value) => DexiePromise.resolve(value).then(resolve, reject));
    });
  },
  PSD: {
    get: () => PSD,
    set: (value) => PSD = value
  },
  totalEchoes: { get: () => totalEchoes },
  newPSD: newScope,
  usePSD,
  scheduler: {
    get: () => asap,
    set: (value) => {
      asap = value;
    }
  },
  rejectionMapper: {
    get: () => rejectionMapper,
    set: (value) => {
      rejectionMapper = value;
    }
  },
  follow: (fn2, zoneProps) => {
    return new DexiePromise((resolve, reject) => {
      return newScope((resolve2, reject2) => {
        var psd = PSD;
        psd.unhandleds = [];
        psd.onunhandled = reject2;
        psd.finalize = callBoth(function() {
          run_at_end_of_this_or_next_physical_tick(() => {
            this.unhandleds.length === 0 ? resolve2() : reject2(this.unhandleds[0]);
          });
        }, psd.finalize);
        fn2();
      }, zoneProps, resolve, reject);
    });
  }
});
if (NativePromise) {
  if (NativePromise.allSettled)
    setProp(DexiePromise, "allSettled", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve) => {
        if (possiblePromises.length === 0)
          resolve([]);
        let remaining = possiblePromises.length;
        const results = new Array(remaining);
        possiblePromises.forEach((p2, i) => DexiePromise.resolve(p2).then((value) => results[i] = { status: "fulfilled", value }, (reason) => results[i] = { status: "rejected", reason }).then(() => --remaining || resolve(results)));
      });
    });
  if (NativePromise.any && typeof AggregateError !== "undefined")
    setProp(DexiePromise, "any", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve, reject) => {
        if (possiblePromises.length === 0)
          reject(new AggregateError([]));
        let remaining = possiblePromises.length;
        const failures = new Array(remaining);
        possiblePromises.forEach((p2, i) => DexiePromise.resolve(p2).then((value) => resolve(value), (failure) => {
          failures[i] = failure;
          if (!--remaining)
            reject(new AggregateError(failures));
        }));
      });
    });
}
function executePromiseTask(promise, fn2) {
  try {
    fn2((value) => {
      if (promise._state !== null)
        return;
      if (value === promise)
        throw new TypeError("A promise cannot be resolved with itself.");
      var shouldExecuteTick = promise._lib && beginMicroTickScope();
      if (value && typeof value.then === "function") {
        executePromiseTask(promise, (resolve, reject) => {
          value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
        });
      } else {
        promise._state = true;
        promise._value = value;
        propagateAllListeners(promise);
      }
      if (shouldExecuteTick)
        endMicroTickScope();
    }, handleRejection.bind(null, promise));
  } catch (ex) {
    handleRejection(promise, ex);
  }
}
function handleRejection(promise, reason) {
  rejectingErrors.push(reason);
  if (promise._state !== null)
    return;
  var shouldExecuteTick = promise._lib && beginMicroTickScope();
  reason = rejectionMapper(reason);
  promise._state = false;
  promise._value = reason;
  debug && reason !== null && typeof reason === "object" && !reason._promise && tryCatch(() => {
    var origProp = getPropertyDescriptor(reason, "stack");
    reason._promise = promise;
    setProp(reason, "stack", {
      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack
    });
  });
  addPossiblyUnhandledError(promise);
  propagateAllListeners(promise);
  if (shouldExecuteTick)
    endMicroTickScope();
}
function propagateAllListeners(promise) {
  var listeners = promise._listeners;
  promise._listeners = [];
  for (var i = 0, len = listeners.length; i < len; ++i) {
    propagateToListener(promise, listeners[i]);
  }
  var psd = promise._PSD;
  --psd.ref || psd.finalize();
  if (numScheduledCalls === 0) {
    ++numScheduledCalls;
    asap(() => {
      if (--numScheduledCalls === 0)
        finalizePhysicalTick();
    }, []);
  }
}
function propagateToListener(promise, listener) {
  if (promise._state === null) {
    promise._listeners.push(listener);
    return;
  }
  var cb = promise._state ? listener.onFulfilled : listener.onRejected;
  if (cb === null) {
    return (promise._state ? listener.resolve : listener.reject)(promise._value);
  }
  ++listener.psd.ref;
  ++numScheduledCalls;
  asap(callListener, [cb, promise, listener]);
}
function callListener(cb, promise, listener) {
  try {
    currentFulfiller = promise;
    var ret, value = promise._value;
    if (promise._state) {
      ret = cb(value);
    } else {
      if (rejectingErrors.length)
        rejectingErrors = [];
      ret = cb(value);
      if (rejectingErrors.indexOf(value) === -1)
        markErrorAsHandled(promise);
    }
    listener.resolve(ret);
  } catch (e) {
    listener.reject(e);
  } finally {
    currentFulfiller = null;
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
    --listener.psd.ref || listener.psd.finalize();
  }
}
function getStack(promise, stacks, limit) {
  if (stacks.length === limit)
    return stacks;
  var stack = "";
  if (promise._state === false) {
    var failure = promise._value, errorName, message;
    if (failure != null) {
      errorName = failure.name || "Error";
      message = failure.message || failure;
      stack = prettyStack(failure, 0);
    } else {
      errorName = failure;
      message = "";
    }
    stacks.push(errorName + (message ? ": " + message : "") + stack);
  }
  if (debug) {
    stack = prettyStack(promise._stackHolder, 2);
    if (stack && stacks.indexOf(stack) === -1)
      stacks.push(stack);
    if (promise._prev)
      getStack(promise._prev, stacks, limit);
  }
  return stacks;
}
function linkToPreviousPromise(promise, prev) {
  var numPrev = prev ? prev._numPrev + 1 : 0;
  if (numPrev < LONG_STACKS_CLIP_LIMIT) {
    promise._prev = prev;
    promise._numPrev = numPrev;
  }
}
function physicalTick() {
  beginMicroTickScope() && endMicroTickScope();
}
function beginMicroTickScope() {
  var wasRootExec = isOutsideMicroTick;
  isOutsideMicroTick = false;
  needsNewPhysicalTick = false;
  return wasRootExec;
}
function endMicroTickScope() {
  var callbacks, i, l2;
  do {
    while (microtickQueue.length > 0) {
      callbacks = microtickQueue;
      microtickQueue = [];
      l2 = callbacks.length;
      for (i = 0; i < l2; ++i) {
        var item = callbacks[i];
        item[0].apply(null, item[1]);
      }
    }
  } while (microtickQueue.length > 0);
  isOutsideMicroTick = true;
  needsNewPhysicalTick = true;
}
function finalizePhysicalTick() {
  var unhandledErrs = unhandledErrors;
  unhandledErrors = [];
  unhandledErrs.forEach((p2) => {
    p2._PSD.onunhandled.call(null, p2._value, p2);
  });
  var finalizers = tickFinalizers.slice(0);
  var i = finalizers.length;
  while (i)
    finalizers[--i]();
}
function run_at_end_of_this_or_next_physical_tick(fn2) {
  function finalizer() {
    fn2();
    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
  }
  tickFinalizers.push(finalizer);
  ++numScheduledCalls;
  asap(() => {
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
  }, []);
}
function addPossiblyUnhandledError(promise) {
  if (!unhandledErrors.some((p2) => p2._value === promise._value))
    unhandledErrors.push(promise);
}
function markErrorAsHandled(promise) {
  var i = unhandledErrors.length;
  while (i)
    if (unhandledErrors[--i]._value === promise._value) {
      unhandledErrors.splice(i, 1);
      return;
    }
}
function PromiseReject(reason) {
  return new DexiePromise(INTERNAL, false, reason);
}
function wrap(fn2, errorCatcher) {
  var psd = PSD;
  return function() {
    var wasRootExec = beginMicroTickScope(), outerScope = PSD;
    try {
      switchToZone(psd, true);
      return fn2.apply(this, arguments);
    } catch (e) {
      errorCatcher && errorCatcher(e);
    } finally {
      switchToZone(outerScope, false);
      if (wasRootExec)
        endMicroTickScope();
    }
  };
}
var task = { awaits: 0, echoes: 0, id: 0 };
var taskCounter = 0;
var zoneStack = [];
var zoneEchoes = 0;
var totalEchoes = 0;
var zone_id_counter = 0;
function newScope(fn2, props2, a1, a2) {
  var parent = PSD, psd = Object.create(parent);
  psd.parent = parent;
  psd.ref = 0;
  psd.global = false;
  psd.id = ++zone_id_counter;
  var globalEnv = globalPSD.env;
  psd.env = patchGlobalPromise ? {
    Promise: DexiePromise,
    PromiseProp: { value: DexiePromise, configurable: true, writable: true },
    all: DexiePromise.all,
    race: DexiePromise.race,
    allSettled: DexiePromise.allSettled,
    any: DexiePromise.any,
    resolve: DexiePromise.resolve,
    reject: DexiePromise.reject,
    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
  } : {};
  if (props2)
    extend(psd, props2);
  ++parent.ref;
  psd.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var rv = usePSD(psd, fn2, a1, a2);
  if (psd.ref === 0)
    psd.finalize();
  return rv;
}
function incrementExpectedAwaits() {
  if (!task.id)
    task.id = ++taskCounter;
  ++task.awaits;
  task.echoes += ZONE_ECHO_LIMIT;
  return task.id;
}
function decrementExpectedAwaits() {
  if (!task.awaits)
    return false;
  if (--task.awaits === 0)
    task.id = 0;
  task.echoes = task.awaits * ZONE_ECHO_LIMIT;
  return true;
}
if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
  incrementExpectedAwaits = decrementExpectedAwaits = nop;
}
function onPossibleParallellAsync(possiblePromise) {
  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
    incrementExpectedAwaits();
    return possiblePromise.then((x) => {
      decrementExpectedAwaits();
      return x;
    }, (e) => {
      decrementExpectedAwaits();
      return rejection(e);
    });
  }
  return possiblePromise;
}
function zoneEnterEcho(targetZone) {
  ++totalEchoes;
  if (!task.echoes || --task.echoes === 0) {
    task.echoes = task.id = 0;
  }
  zoneStack.push(PSD);
  switchToZone(targetZone, true);
}
function zoneLeaveEcho() {
  var zone = zoneStack[zoneStack.length - 1];
  zoneStack.pop();
  switchToZone(zone, false);
}
function switchToZone(targetZone, bEnteringZone) {
  var currentZone = PSD;
  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
  }
  if (targetZone === PSD)
    return;
  PSD = targetZone;
  if (currentZone === globalPSD)
    globalPSD.env = snapShot();
  if (patchGlobalPromise) {
    var GlobalPromise = globalPSD.env.Promise;
    var targetEnv = targetZone.env;
    nativePromiseProto.then = targetEnv.nthen;
    GlobalPromise.prototype.then = targetEnv.gthen;
    if (currentZone.global || targetZone.global) {
      Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
      GlobalPromise.all = targetEnv.all;
      GlobalPromise.race = targetEnv.race;
      GlobalPromise.resolve = targetEnv.resolve;
      GlobalPromise.reject = targetEnv.reject;
      if (targetEnv.allSettled)
        GlobalPromise.allSettled = targetEnv.allSettled;
      if (targetEnv.any)
        GlobalPromise.any = targetEnv.any;
    }
  }
}
function snapShot() {
  var GlobalPromise = _global.Promise;
  return patchGlobalPromise ? {
    Promise: GlobalPromise,
    PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
    all: GlobalPromise.all,
    race: GlobalPromise.race,
    allSettled: GlobalPromise.allSettled,
    any: GlobalPromise.any,
    resolve: GlobalPromise.resolve,
    reject: GlobalPromise.reject,
    nthen: nativePromiseProto.then,
    gthen: GlobalPromise.prototype.then
  } : {};
}
function usePSD(psd, fn2, a1, a2, a3) {
  var outerScope = PSD;
  try {
    switchToZone(psd, true);
    return fn2(a1, a2, a3);
  } finally {
    switchToZone(outerScope, false);
  }
}
function enqueueNativeMicroTask(job) {
  nativePromiseThen.call(resolvedNativePromise, job);
}
function nativeAwaitCompatibleWrap(fn2, zone, possibleAwait, cleanup) {
  return typeof fn2 !== "function" ? fn2 : function() {
    var outerZone = PSD;
    if (possibleAwait)
      incrementExpectedAwaits();
    switchToZone(zone, true);
    try {
      return fn2.apply(this, arguments);
    } finally {
      switchToZone(outerZone, false);
      if (cleanup)
        enqueueNativeMicroTask(decrementExpectedAwaits);
    }
  };
}
function getPatchedPromiseThen(origThen, zone) {
  return function(onResolved, onRejected) {
    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
  };
}
var UNHANDLEDREJECTION = "unhandledrejection";
function globalError(err, promise) {
  var rv;
  try {
    rv = promise.onuncatched(err);
  } catch (e) {
  }
  if (rv !== false)
    try {
      var event, eventData = { promise, reason: err };
      if (_global.document && document.createEvent) {
        event = document.createEvent("Event");
        event.initEvent(UNHANDLEDREJECTION, true, true);
        extend(event, eventData);
      } else if (_global.CustomEvent) {
        event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
        extend(event, eventData);
      }
      if (event && _global.dispatchEvent) {
        dispatchEvent(event);
        if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
          try {
            _global.onunhandledrejection(event);
          } catch (_) {
          }
      }
      if (debug && event && !event.defaultPrevented) {
        console.warn(`Unhandled rejection: ${err.stack || err}`);
      }
    } catch (e) {
    }
}
var rejection = DexiePromise.reject;
function tempTransaction(db, mode, storeNames, fn2) {
  if (!db.idbdb || !db._state.openComplete && (!PSD.letThrough && !db._vip)) {
    if (db._state.openComplete) {
      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
    }
    if (!db._state.isBeingOpened) {
      if (!db._options.autoOpen)
        return rejection(new exceptions.DatabaseClosed());
      db.open().catch(nop);
    }
    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn2));
  } else {
    var trans = db._createTransaction(mode, storeNames, db._dbSchema);
    try {
      trans.create();
      db._state.PR1398_maxLoop = 3;
    } catch (ex) {
      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
        console.warn("Dexie: Need to reopen db");
        db._close();
        return db.open().then(() => tempTransaction(db, mode, storeNames, fn2));
      }
      return rejection(ex);
    }
    return trans._promise(mode, (resolve, reject) => {
      return newScope(() => {
        PSD.trans = trans;
        return fn2(resolve, reject, trans);
      });
    }).then((result) => {
      return trans._completion.then(() => result);
    });
  }
}
var DEXIE_VERSION = "3.2.7";
var maxString = String.fromCharCode(65535);
var minKey = -Infinity;
var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
var STRING_EXPECTED = "String expected.";
var connections = [];
var isIEOrEdge = typeof navigator !== "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
var hasIEDeleteObjectStoreBug = isIEOrEdge;
var hangsOnDeleteLargeKeyRange = isIEOrEdge;
var dexieStackFrameFilter = (frame) => !/(dexie\.js|dexie\.min\.js)/.test(frame);
var DBNAMES_DB = "__dbnames";
var READONLY = "readonly";
var READWRITE = "readwrite";
function combine(filter1, filter2) {
  return filter1 ? filter2 ? function() {
    return filter1.apply(this, arguments) && filter2.apply(this, arguments);
  } : filter1 : filter2;
}
var AnyRange = {
  type: 3,
  lower: -Infinity,
  lowerOpen: false,
  upper: [[]],
  upperOpen: false
};
function workaroundForUndefinedPrimKey(keyPath) {
  return typeof keyPath === "string" && !/\./.test(keyPath) ? (obj) => {
    if (obj[keyPath] === void 0 && keyPath in obj) {
      obj = deepClone(obj);
      delete obj[keyPath];
    }
    return obj;
  } : (obj) => obj;
}
var Table = class {
  _trans(mode, fn2, writeLocked) {
    const trans = this._tx || PSD.trans;
    const tableName = this.name;
    function checkTableInTransaction(resolve, reject, trans2) {
      if (!trans2.schema[tableName])
        throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
      return fn2(trans2.idbtrans, trans2);
    }
    const wasRootExec = beginMicroTickScope();
    try {
      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
    } finally {
      if (wasRootExec)
        endMicroTickScope();
    }
  }
  get(keyOrCrit, cb) {
    if (keyOrCrit && keyOrCrit.constructor === Object)
      return this.where(keyOrCrit).first(cb);
    return this._trans("readonly", (trans) => {
      return this.core.get({ trans, key: keyOrCrit }).then((res) => this.hook.reading.fire(res));
    }).then(cb);
  }
  where(indexOrCrit) {
    if (typeof indexOrCrit === "string")
      return new this.db.WhereClause(this, indexOrCrit);
    if (isArray(indexOrCrit))
      return new this.db.WhereClause(this, `[${indexOrCrit.join("+")}]`);
    const keyPaths = keys(indexOrCrit);
    if (keyPaths.length === 1)
      return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix) => {
      if (ix.compound && keyPaths.every((keyPath) => ix.keyPath.indexOf(keyPath) >= 0)) {
        for (let i = 0; i < keyPaths.length; ++i) {
          if (keyPaths.indexOf(ix.keyPath[i]) === -1)
            return false;
        }
        return true;
      }
      return false;
    }).sort((a, b2) => a.keyPath.length - b2.keyPath.length)[0];
    if (compoundIndex && this.db._maxKey !== maxString) {
      const keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
      return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map((kp) => indexOrCrit[kp]));
    }
    if (!compoundIndex && debug)
      console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a compound index [${keyPaths.join("+")}]`);
    const { idxByName } = this.schema;
    const idb = this.db._deps.indexedDB;
    function equals(a, b2) {
      try {
        return idb.cmp(a, b2) === 0;
      } catch (e) {
        return false;
      }
    }
    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {
      const index = idxByName[keyPath];
      const value = indexOrCrit[keyPath];
      return [
        prevIndex || index,
        prevIndex || !index ? combine(prevFilterFn, index && index.multi ? (x) => {
          const prop = getByKeyPath(x, keyPath);
          return isArray(prop) && prop.some((item) => equals(value, item));
        } : (x) => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn
      ];
    }, [null, null]);
    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
  }
  filter(filterFunction) {
    return this.toCollection().and(filterFunction);
  }
  count(thenShortcut) {
    return this.toCollection().count(thenShortcut);
  }
  offset(offset2) {
    return this.toCollection().offset(offset2);
  }
  limit(numRows) {
    return this.toCollection().limit(numRows);
  }
  each(callback) {
    return this.toCollection().each(callback);
  }
  toArray(thenShortcut) {
    return this.toCollection().toArray(thenShortcut);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(index) {
    return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? `[${index.join("+")}]` : index));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(constructor) {
    this.schema.mappedClass = constructor;
    const readHook = (obj) => {
      if (!obj)
        return obj;
      const res = Object.create(constructor.prototype);
      for (var m2 in obj)
        if (hasOwn(obj, m2))
          try {
            res[m2] = obj[m2];
          } catch (_) {
          }
      return res;
    };
    if (this.schema.readHook) {
      this.hook.reading.unsubscribe(this.schema.readHook);
    }
    this.schema.readHook = readHook;
    this.hook("reading", readHook);
    return constructor;
  }
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return this.mapToClass(Class);
  }
  add(obj, key) {
    const { auto: auto2, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto2) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
    }).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  update(keyOrObject, modifications) {
    if (typeof keyOrObject === "object" && !isArray(keyOrObject)) {
      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
      if (key === void 0)
        return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
      try {
        if (typeof modifications !== "function") {
          keys(modifications).forEach((keyPath) => {
            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
          });
        } else {
          modifications(keyOrObject, { value: keyOrObject, primKey: key });
        }
      } catch (_a2) {
      }
      return this.where(":id").equals(key).modify(modifications);
    } else {
      return this.where(":id").equals(keyOrObject).modify(modifications);
    }
  }
  put(obj, key) {
    const { auto: auto2, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto2) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  delete(key) {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "delete", keys: [key] })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "deleteRange", range: AnyRange })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  bulkGet(keys2) {
    return this._trans("readonly", (trans) => {
      return this.core.getMany({
        keys: keys2,
        trans
      }).then((result) => result.map((res) => this.hook.reading.fire(res)));
    });
  }
  bulkAdd(objects, keysOrOptions, options) {
    const keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys2 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto: auto2, keyPath } = this.schema.primKey;
      if (keyPath && keys2)
        throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (keys2 && keys2.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToAdd = keyPath && auto2 ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "add", keys: keys2, values: objectsToAdd, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkPut(objects, keysOrOptions, options) {
    const keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys2 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto: auto2, keyPath } = this.schema.primKey;
      if (keyPath && keys2)
        throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (keys2 && keys2.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToPut = keyPath && auto2 ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "put", keys: keys2, values: objectsToPut, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkDelete(keys2) {
    const numKeys = keys2.length;
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "delete", keys: keys2 });
    }).then(({ numFailures, lastResult, failures }) => {
      if (numFailures === 0)
        return lastResult;
      throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);
    });
  }
};
function Events(ctx) {
  var evs = {};
  var rv = function(eventName, subscriber) {
    if (subscriber) {
      var i2 = arguments.length, args = new Array(i2 - 1);
      while (--i2)
        args[i2 - 1] = arguments[i2];
      evs[eventName].subscribe.apply(null, args);
      return ctx;
    } else if (typeof eventName === "string") {
      return evs[eventName];
    }
  };
  rv.addEventType = add;
  for (var i = 1, l2 = arguments.length; i < l2; ++i) {
    add(arguments[i]);
  }
  return rv;
  function add(eventName, chainFunction, defaultFunction) {
    if (typeof eventName === "object")
      return addConfiguredEvents(eventName);
    if (!chainFunction)
      chainFunction = reverseStoppableEventChain;
    if (!defaultFunction)
      defaultFunction = nop;
    var context = {
      subscribers: [],
      fire: defaultFunction,
      subscribe: function(cb) {
        if (context.subscribers.indexOf(cb) === -1) {
          context.subscribers.push(cb);
          context.fire = chainFunction(context.fire, cb);
        }
      },
      unsubscribe: function(cb) {
        context.subscribers = context.subscribers.filter(function(fn2) {
          return fn2 !== cb;
        });
        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
      }
    };
    evs[eventName] = rv[eventName] = context;
    return context;
  }
  function addConfiguredEvents(cfg) {
    keys(cfg).forEach(function(eventName) {
      var args = cfg[eventName];
      if (isArray(args)) {
        add(eventName, cfg[eventName][0], cfg[eventName][1]);
      } else if (args === "asap") {
        var context = add(eventName, mirror, function fire() {
          var i2 = arguments.length, args2 = new Array(i2);
          while (i2--)
            args2[i2] = arguments[i2];
          context.subscribers.forEach(function(fn2) {
            asap$1(function fireEvent() {
              fn2.apply(null, args2);
            });
          });
        });
      } else
        throw new exceptions.InvalidArgument("Invalid event config");
    });
  }
}
function makeClassConstructor(prototype, constructor) {
  derive(constructor).from({ prototype });
  return constructor;
}
function createTableConstructor(db) {
  return makeClassConstructor(Table.prototype, function Table2(name, tableSchema, trans) {
    this.db = db;
    this._tx = trans;
    this.name = name;
    this.schema = tableSchema;
    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
      "creating": [hookCreatingChain, nop],
      "reading": [pureFunctionChain, mirror],
      "updating": [hookUpdatingChain, nop],
      "deleting": [hookDeletingChain, nop]
    });
  });
}
function isPlainKeyRange(ctx, ignoreLimitFilter) {
  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
}
function addFilter(ctx, fn2) {
  ctx.filter = combine(ctx.filter, fn2);
}
function addReplayFilter(ctx, factory, isLimitFilter) {
  var curr = ctx.replayFilter;
  ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;
  ctx.justLimit = isLimitFilter && !curr;
}
function addMatchFilter(ctx, fn2) {
  ctx.isMatch = combine(ctx.isMatch, fn2);
}
function getIndexOrStore(ctx, coreSchema) {
  if (ctx.isPrimKey)
    return coreSchema.primaryKey;
  const index = coreSchema.getIndexByKeyPath(ctx.index);
  if (!index)
    throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
  return index;
}
function openCursor(ctx, coreTable, trans) {
  const index = getIndexOrStore(ctx, coreTable.schema);
  return coreTable.openCursor({
    trans,
    values: !ctx.keysOnly,
    reverse: ctx.dir === "prev",
    unique: !!ctx.unique,
    query: {
      index,
      range: ctx.range
    }
  });
}
function iter(ctx, fn2, coreTrans, coreTable) {
  const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
  if (!ctx.or) {
    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn2, !ctx.keysOnly && ctx.valueMapper);
  } else {
    const set = {};
    const union = (item, cursor, advance) => {
      if (!filter || filter(cursor, advance, (result) => cursor.stop(result), (err) => cursor.fail(err))) {
        var primaryKey = cursor.primaryKey;
        var key = "" + primaryKey;
        if (key === "[object ArrayBuffer]")
          key = "" + new Uint8Array(primaryKey);
        if (!hasOwn(set, key)) {
          set[key] = true;
          fn2(item, cursor, advance);
        }
      }
    };
    return Promise.all([
      ctx.or._iterate(union, coreTrans),
      iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
    ]);
  }
}
function iterate(cursorPromise, filter, fn2, valueMapper) {
  var mappedFn = valueMapper ? (x, c3, a) => fn2(valueMapper(x), c3, a) : fn2;
  var wrappedFn = wrap(mappedFn);
  return cursorPromise.then((cursor) => {
    if (cursor) {
      return cursor.start(() => {
        var c3 = () => cursor.continue();
        if (!filter || filter(cursor, (advancer) => c3 = advancer, (val) => {
          cursor.stop(val);
          c3 = nop;
        }, (e) => {
          cursor.fail(e);
          c3 = nop;
        }))
          wrappedFn(cursor.value, cursor, (advancer) => c3 = advancer);
        c3();
      });
    }
  });
}
function cmp(a, b2) {
  try {
    const ta = type(a);
    const tb = type(b2);
    if (ta !== tb) {
      if (ta === "Array")
        return 1;
      if (tb === "Array")
        return -1;
      if (ta === "binary")
        return 1;
      if (tb === "binary")
        return -1;
      if (ta === "string")
        return 1;
      if (tb === "string")
        return -1;
      if (ta === "Date")
        return 1;
      if (tb !== "Date")
        return NaN;
      return -1;
    }
    switch (ta) {
      case "number":
      case "Date":
      case "string":
        return a > b2 ? 1 : a < b2 ? -1 : 0;
      case "binary": {
        return compareUint8Arrays(getUint8Array(a), getUint8Array(b2));
      }
      case "Array":
        return compareArrays(a, b2);
    }
  } catch (_a2) {
  }
  return NaN;
}
function compareArrays(a, b2) {
  const al = a.length;
  const bl = b2.length;
  const l2 = al < bl ? al : bl;
  for (let i = 0; i < l2; ++i) {
    const res = cmp(a[i], b2[i]);
    if (res !== 0)
      return res;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function compareUint8Arrays(a, b2) {
  const al = a.length;
  const bl = b2.length;
  const l2 = al < bl ? al : bl;
  for (let i = 0; i < l2; ++i) {
    if (a[i] !== b2[i])
      return a[i] < b2[i] ? -1 : 1;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function type(x) {
  const t = typeof x;
  if (t !== "object")
    return t;
  if (ArrayBuffer.isView(x))
    return "binary";
  const tsTag = toStringTag(x);
  return tsTag === "ArrayBuffer" ? "binary" : tsTag;
}
function getUint8Array(a) {
  if (a instanceof Uint8Array)
    return a;
  if (ArrayBuffer.isView(a))
    return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  return new Uint8Array(a);
}
var Collection = class {
  _read(fn2, cb) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn2).then(cb);
  }
  _write(fn2) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn2, "locked");
  }
  _addAlgorithm(fn2) {
    var ctx = this._ctx;
    ctx.algorithm = combine(ctx.algorithm, fn2);
  }
  _iterate(fn2, coreTrans) {
    return iter(this._ctx, fn2, coreTrans, this._ctx.table.core);
  }
  clone(props2) {
    var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
    if (props2)
      extend(ctx, props2);
    rv._ctx = ctx;
    return rv;
  }
  raw() {
    this._ctx.valueMapper = null;
    return this;
  }
  each(fn2) {
    var ctx = this._ctx;
    return this._read((trans) => iter(ctx, fn2, trans, ctx.table.core));
  }
  count(cb) {
    return this._read((trans) => {
      const ctx = this._ctx;
      const coreTable = ctx.table.core;
      if (isPlainKeyRange(ctx, true)) {
        return coreTable.count({
          trans,
          query: {
            index: getIndexOrStore(ctx, coreTable.schema),
            range: ctx.range
          }
        }).then((count2) => Math.min(count2, ctx.limit));
      } else {
        var count = 0;
        return iter(ctx, () => {
          ++count;
          return false;
        }, trans, coreTable).then(() => count);
      }
    }).then(cb);
  }
  sortBy(keyPath, cb) {
    const parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
    function getval(obj, i) {
      if (i)
        return getval(obj[parts[i]], i - 1);
      return obj[lastPart];
    }
    var order2 = this._ctx.dir === "next" ? 1 : -1;
    function sorter(a, b2) {
      var aVal = getval(a, lastIndex), bVal = getval(b2, lastIndex);
      return aVal < bVal ? -order2 : aVal > bVal ? order2 : 0;
    }
    return this.toArray(function(a) {
      return a.sort(sorter);
    }).then(cb);
  }
  toArray(cb) {
    return this._read((trans) => {
      var ctx = this._ctx;
      if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
        const { valueMapper } = ctx;
        const index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          limit: ctx.limit,
          values: true,
          query: {
            index,
            range: ctx.range
          }
        }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);
      } else {
        const a = [];
        return iter(ctx, (item) => a.push(item), trans, ctx.table.core).then(() => a);
      }
    }, cb);
  }
  offset(offset2) {
    var ctx = this._ctx;
    if (offset2 <= 0)
      return this;
    ctx.offset += offset2;
    if (isPlainKeyRange(ctx)) {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset2;
        return (cursor, advance) => {
          if (offsetLeft === 0)
            return true;
          if (offsetLeft === 1) {
            --offsetLeft;
            return false;
          }
          advance(() => {
            cursor.advance(offsetLeft);
            offsetLeft = 0;
          });
          return false;
        };
      });
    } else {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset2;
        return () => --offsetLeft < 0;
      });
    }
    return this;
  }
  limit(numRows) {
    this._ctx.limit = Math.min(this._ctx.limit, numRows);
    addReplayFilter(this._ctx, () => {
      var rowsLeft = numRows;
      return function(cursor, advance, resolve) {
        if (--rowsLeft <= 0)
          advance(resolve);
        return rowsLeft >= 0;
      };
    }, true);
    return this;
  }
  until(filterFunction, bIncludeStopEntry) {
    addFilter(this._ctx, function(cursor, advance, resolve) {
      if (filterFunction(cursor.value)) {
        advance(resolve);
        return bIncludeStopEntry;
      } else {
        return true;
      }
    });
    return this;
  }
  first(cb) {
    return this.limit(1).toArray(function(a) {
      return a[0];
    }).then(cb);
  }
  last(cb) {
    return this.reverse().first(cb);
  }
  filter(filterFunction) {
    addFilter(this._ctx, function(cursor) {
      return filterFunction(cursor.value);
    });
    addMatchFilter(this._ctx, filterFunction);
    return this;
  }
  and(filter) {
    return this.filter(filter);
  }
  or(indexName) {
    return new this.db.WhereClause(this._ctx.table, indexName, this);
  }
  reverse() {
    this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
    if (this._ondirectionchange)
      this._ondirectionchange(this._ctx.dir);
    return this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.key, cursor);
    });
  }
  eachUniqueKey(cb) {
    this._ctx.unique = "unique";
    return this.eachKey(cb);
  }
  eachPrimaryKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.primaryKey, cursor);
    });
  }
  keys(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor) {
      a.push(cursor.key);
    }).then(function() {
      return a;
    }).then(cb);
  }
  primaryKeys(cb) {
    var ctx = this._ctx;
    if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
      return this._read((trans) => {
        var index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          values: false,
          limit: ctx.limit,
          query: {
            index,
            range: ctx.range
          }
        });
      }).then(({ result }) => result).then(cb);
    }
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor) {
      a.push(cursor.primaryKey);
    }).then(function() {
      return a;
    }).then(cb);
  }
  uniqueKeys(cb) {
    this._ctx.unique = "unique";
    return this.keys(cb);
  }
  firstKey(cb) {
    return this.limit(1).keys(function(a) {
      return a[0];
    }).then(cb);
  }
  lastKey(cb) {
    return this.reverse().firstKey(cb);
  }
  distinct() {
    var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
    if (!idx || !idx.multi)
      return this;
    var set = {};
    addFilter(this._ctx, function(cursor) {
      var strKey = cursor.primaryKey.toString();
      var found = hasOwn(set, strKey);
      set[strKey] = true;
      return !found;
    });
    return this;
  }
  modify(changes) {
    var ctx = this._ctx;
    return this._write((trans) => {
      var modifyer;
      if (typeof changes === "function") {
        modifyer = changes;
      } else {
        var keyPaths = keys(changes);
        var numKeys = keyPaths.length;
        modifyer = function(item) {
          var anythingModified = false;
          for (var i = 0; i < numKeys; ++i) {
            var keyPath = keyPaths[i], val = changes[keyPath];
            if (getByKeyPath(item, keyPath) !== val) {
              setByKeyPath(item, keyPath, val);
              anythingModified = true;
            }
          }
          return anythingModified;
        };
      }
      const coreTable = ctx.table.core;
      const { outbound, extractKey } = coreTable.schema.primaryKey;
      const limit = this.db._options.modifyChunkSize || 200;
      const totalFailures = [];
      let successCount = 0;
      const failedKeys = [];
      const applyMutateResult = (expectedCount, res) => {
        const { failures, numFailures } = res;
        successCount += expectedCount - numFailures;
        for (let pos of keys(failures)) {
          totalFailures.push(failures[pos]);
        }
      };
      return this.clone().primaryKeys().then((keys2) => {
        const nextChunk = (offset2) => {
          const count = Math.min(limit, keys2.length - offset2);
          return coreTable.getMany({
            trans,
            keys: keys2.slice(offset2, offset2 + count),
            cache: "immutable"
          }).then((values) => {
            const addValues = [];
            const putValues = [];
            const putKeys = outbound ? [] : null;
            const deleteKeys = [];
            for (let i = 0; i < count; ++i) {
              const origValue = values[i];
              const ctx2 = {
                value: deepClone(origValue),
                primKey: keys2[offset2 + i]
              };
              if (modifyer.call(ctx2, ctx2.value, ctx2) !== false) {
                if (ctx2.value == null) {
                  deleteKeys.push(keys2[offset2 + i]);
                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx2.value)) !== 0) {
                  deleteKeys.push(keys2[offset2 + i]);
                  addValues.push(ctx2.value);
                } else {
                  putValues.push(ctx2.value);
                  if (outbound)
                    putKeys.push(keys2[offset2 + i]);
                }
              }
            }
            const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
              index: ctx.index,
              range: ctx.range
            };
            return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then((res) => {
              for (let pos in res.failures) {
                deleteKeys.splice(parseInt(pos), 1);
              }
              applyMutateResult(addValues.length, res);
            })).then(() => (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
              trans,
              type: "put",
              keys: putKeys,
              values: putValues,
              criteria,
              changeSpec: typeof changes !== "function" && changes
            }).then((res) => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
              trans,
              type: "delete",
              keys: deleteKeys,
              criteria
            }).then((res) => applyMutateResult(deleteKeys.length, res))).then(() => {
              return keys2.length > offset2 + count && nextChunk(offset2 + limit);
            });
          });
        };
        return nextChunk(0).then(() => {
          if (totalFailures.length > 0)
            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
          return keys2.length;
        });
      });
    });
  }
  delete() {
    var ctx = this._ctx, range = ctx.range;
    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {
      return this._write((trans) => {
        const { primaryKey } = ctx.table.core.schema;
        const coreRange = range;
        return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then((count) => {
          return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(({ failures, lastResult, results, numFailures }) => {
            if (numFailures)
              throw new ModifyError("Could not delete some values", Object.keys(failures).map((pos) => failures[pos]), count - numFailures);
            return count - numFailures;
          });
        });
      });
    }
    return this.modify(deleteCallback);
  }
};
var deleteCallback = (value, ctx) => ctx.value = null;
function createCollectionConstructor(db) {
  return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
    this.db = db;
    let keyRange = AnyRange, error = null;
    if (keyRangeGenerator)
      try {
        keyRange = keyRangeGenerator();
      } catch (ex) {
        error = ex;
      }
    const whereCtx = whereClause._ctx;
    const table = whereCtx.table;
    const readingHook = table.hook.reading.fire;
    this._ctx = {
      table,
      index: whereCtx.index,
      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
      range: keyRange,
      keysOnly: false,
      dir: "next",
      unique: "",
      algorithm: null,
      filter: null,
      replayFilter: null,
      justLimit: true,
      isMatch: null,
      offset: 0,
      limit: Infinity,
      error,
      or: whereCtx.or,
      valueMapper: readingHook !== mirror ? readingHook : null
    };
  });
}
function simpleCompare(a, b2) {
  return a < b2 ? -1 : a === b2 ? 0 : 1;
}
function simpleCompareReverse(a, b2) {
  return a > b2 ? -1 : a === b2 ? 0 : 1;
}
function fail(collectionOrWhereClause, err, T2) {
  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
  collection._ctx.error = T2 ? new T2(err) : new TypeError(err);
  return collection;
}
function emptyCollection(whereClause) {
  return new whereClause.Collection(whereClause, () => rangeEqual("")).limit(0);
}
function upperFactory(dir) {
  return dir === "next" ? (s3) => s3.toUpperCase() : (s3) => s3.toLowerCase();
}
function lowerFactory(dir) {
  return dir === "next" ? (s3) => s3.toLowerCase() : (s3) => s3.toUpperCase();
}
function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp2, dir) {
  var length = Math.min(key.length, lowerNeedle.length);
  var llp = -1;
  for (var i = 0; i < length; ++i) {
    var lwrKeyChar = lowerKey[i];
    if (lwrKeyChar !== lowerNeedle[i]) {
      if (cmp2(key[i], upperNeedle[i]) < 0)
        return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
      if (cmp2(key[i], lowerNeedle[i]) < 0)
        return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
      if (llp >= 0)
        return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
      return null;
    }
    if (cmp2(key[i], lwrKeyChar) < 0)
      llp = i;
  }
  if (length < lowerNeedle.length && dir === "next")
    return key + upperNeedle.substr(key.length);
  if (length < key.length && dir === "prev")
    return key.substr(0, upperNeedle.length);
  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
}
function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
  var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
  if (!needles.every((s3) => typeof s3 === "string")) {
    return fail(whereClause, STRING_EXPECTED);
  }
  function initDirection(dir) {
    upper = upperFactory(dir);
    lower = lowerFactory(dir);
    compare = dir === "next" ? simpleCompare : simpleCompareReverse;
    var needleBounds = needles.map(function(needle) {
      return { lower: lower(needle), upper: upper(needle) };
    }).sort(function(a, b2) {
      return compare(a.lower, b2.lower);
    });
    upperNeedles = needleBounds.map(function(nb) {
      return nb.upper;
    });
    lowerNeedles = needleBounds.map(function(nb) {
      return nb.lower;
    });
    direction = dir;
    nextKeySuffix = dir === "next" ? "" : suffix;
  }
  initDirection("next");
  var c3 = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));
  c3._ondirectionchange = function(direction2) {
    initDirection(direction2);
  };
  var firstPossibleNeedle = 0;
  c3._addAlgorithm(function(cursor, advance, resolve) {
    var key = cursor.key;
    if (typeof key !== "string")
      return false;
    var lowerKey = lower(key);
    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
      return true;
    } else {
      var lowestPossibleCasing = null;
      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
        if (casing === null && lowestPossibleCasing === null)
          firstPossibleNeedle = i + 1;
        else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
          lowestPossibleCasing = casing;
        }
      }
      if (lowestPossibleCasing !== null) {
        advance(function() {
          cursor.continue(lowestPossibleCasing + nextKeySuffix);
        });
      } else {
        advance(resolve);
      }
      return false;
    }
  });
  return c3;
}
function createRange(lower, upper, lowerOpen, upperOpen) {
  return {
    type: 2,
    lower,
    upper,
    lowerOpen,
    upperOpen
  };
}
function rangeEqual(value) {
  return {
    type: 1,
    lower: value,
    upper: value
  };
}
var WhereClause = class {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(lower, upper, includeLower, includeUpper) {
    includeLower = includeLower !== false;
    includeUpper = includeUpper === true;
    try {
      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
        return emptyCollection(this);
      return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
  }
  equals(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => rangeEqual(value));
  }
  above(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, true));
  }
  aboveOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, false));
  }
  below(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value, false, true));
  }
  belowOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value));
  }
  startsWith(str) {
    if (typeof str !== "string")
      return fail(this, STRING_EXPECTED);
    return this.between(str, str + maxString, true, true);
  }
  startsWithIgnoreCase(str) {
    if (str === "")
      return this.startsWith(str);
    return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);
  }
  equalsIgnoreCase(str) {
    return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], "");
  }
  anyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, "");
  }
  startsWithAnyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.some((n2) => x.indexOf(n2) === 0), set, maxString);
  }
  anyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    let compare = this._cmp;
    try {
      set.sort(compare);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    if (set.length === 0)
      return emptyCollection(this);
    const c3 = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));
    c3._ondirectionchange = (direction) => {
      compare = direction === "next" ? this._ascending : this._descending;
      set.sort(compare);
    };
    let i = 0;
    c3._addAlgorithm((cursor, advance, resolve) => {
      const key = cursor.key;
      while (compare(key, set[i]) > 0) {
        ++i;
        if (i === set.length) {
          advance(resolve);
          return false;
        }
      }
      if (compare(key, set[i]) === 0) {
        return true;
      } else {
        advance(() => {
          cursor.continue(set[i]);
        });
        return false;
      }
    });
    return c3;
  }
  notEqual(value) {
    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
  }
  noneOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return new this.Collection(this);
    try {
      set.sort(this._ascending);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    const ranges = set.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);
    ranges.push([set[set.length - 1], this.db._maxKey]);
    return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
  }
  inAnyRange(ranges, options) {
    const cmp2 = this._cmp, ascending = this._ascending, descending = this._descending, min2 = this._min, max2 = this._max;
    if (ranges.length === 0)
      return emptyCollection(this);
    if (!ranges.every((range) => range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0)) {
      return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
    }
    const includeLowers = !options || options.includeLowers !== false;
    const includeUppers = options && options.includeUppers === true;
    function addRange2(ranges2, newRange) {
      let i = 0, l2 = ranges2.length;
      for (; i < l2; ++i) {
        const range = ranges2[i];
        if (cmp2(newRange[0], range[1]) < 0 && cmp2(newRange[1], range[0]) > 0) {
          range[0] = min2(range[0], newRange[0]);
          range[1] = max2(range[1], newRange[1]);
          break;
        }
      }
      if (i === l2)
        ranges2.push(newRange);
      return ranges2;
    }
    let sortDirection = ascending;
    function rangeSorter(a, b2) {
      return sortDirection(a[0], b2[0]);
    }
    let set;
    try {
      set = ranges.reduce(addRange2, []);
      set.sort(rangeSorter);
    } catch (ex) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    let rangePos = 0;
    const keyIsBeyondCurrentEntry = includeUppers ? (key) => ascending(key, set[rangePos][1]) > 0 : (key) => ascending(key, set[rangePos][1]) >= 0;
    const keyIsBeforeCurrentEntry = includeLowers ? (key) => descending(key, set[rangePos][0]) > 0 : (key) => descending(key, set[rangePos][0]) >= 0;
    function keyWithinCurrentRange(key) {
      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
    }
    let checkKey = keyIsBeyondCurrentEntry;
    const c3 = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));
    c3._ondirectionchange = (direction) => {
      if (direction === "next") {
        checkKey = keyIsBeyondCurrentEntry;
        sortDirection = ascending;
      } else {
        checkKey = keyIsBeforeCurrentEntry;
        sortDirection = descending;
      }
      set.sort(rangeSorter);
    };
    c3._addAlgorithm((cursor, advance, resolve) => {
      var key = cursor.key;
      while (checkKey(key)) {
        ++rangePos;
        if (rangePos === set.length) {
          advance(resolve);
          return false;
        }
      }
      if (keyWithinCurrentRange(key)) {
        return true;
      } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {
        return false;
      } else {
        advance(() => {
          if (sortDirection === ascending)
            cursor.continue(set[rangePos][0]);
          else
            cursor.continue(set[rangePos][1]);
        });
        return false;
      }
    });
    return c3;
  }
  startsWithAnyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (!set.every((s3) => typeof s3 === "string")) {
      return fail(this, "startsWithAnyOf() only works with strings");
    }
    if (set.length === 0)
      return emptyCollection(this);
    return this.inAnyRange(set.map((str) => [str, str + maxString]));
  }
};
function createWhereClauseConstructor(db) {
  return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {
    this.db = db;
    this._ctx = {
      table,
      index: index === ":id" ? null : index,
      or: orCollection
    };
    const indexedDB2 = db._deps.indexedDB;
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    this._cmp = this._ascending = indexedDB2.cmp.bind(indexedDB2);
    this._descending = (a, b2) => indexedDB2.cmp(b2, a);
    this._max = (a, b2) => indexedDB2.cmp(a, b2) > 0 ? a : b2;
    this._min = (a, b2) => indexedDB2.cmp(a, b2) < 0 ? a : b2;
    this._IDBKeyRange = db._deps.IDBKeyRange;
  });
}
function eventRejectHandler(reject) {
  return wrap(function(event) {
    preventDefault(event);
    reject(event.target.error);
    return false;
  });
}
function preventDefault(event) {
  if (event.stopPropagation)
    event.stopPropagation();
  if (event.preventDefault)
    event.preventDefault();
}
var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
var Transaction = class {
  _lock() {
    assert(!PSD.global);
    ++this._reculock;
    if (this._reculock === 1 && !PSD.global)
      PSD.lockOwnerFor = this;
    return this;
  }
  _unlock() {
    assert(!PSD.global);
    if (--this._reculock === 0) {
      if (!PSD.global)
        PSD.lockOwnerFor = null;
      while (this._blockedFuncs.length > 0 && !this._locked()) {
        var fnAndPSD = this._blockedFuncs.shift();
        try {
          usePSD(fnAndPSD[1], fnAndPSD[0]);
        } catch (e) {
        }
      }
    }
    return this;
  }
  _locked() {
    return this._reculock && PSD.lockOwnerFor !== this;
  }
  create(idbtrans) {
    if (!this.mode)
      return this;
    const idbdb = this.db.idbdb;
    const dbOpenError = this.db._state.dbOpenError;
    assert(!this.idbtrans);
    if (!idbtrans && !idbdb) {
      switch (dbOpenError && dbOpenError.name) {
        case "DatabaseClosedError":
          throw new exceptions.DatabaseClosed(dbOpenError);
        case "MissingAPIError":
          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
        default:
          throw new exceptions.OpenFailed(dbOpenError);
      }
    }
    if (!this.active)
      throw new exceptions.TransactionInactive();
    assert(this._completion._state === null);
    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
    idbtrans.onerror = wrap((ev) => {
      preventDefault(ev);
      this._reject(idbtrans.error);
    });
    idbtrans.onabort = wrap((ev) => {
      preventDefault(ev);
      this.active && this._reject(new exceptions.Abort(idbtrans.error));
      this.active = false;
      this.on("abort").fire(ev);
    });
    idbtrans.oncomplete = wrap(() => {
      this.active = false;
      this._resolve();
      if ("mutatedParts" in idbtrans) {
        globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
      }
    });
    return this;
  }
  _promise(mode, fn2, bWriteLock) {
    if (mode === "readwrite" && this.mode !== "readwrite")
      return rejection(new exceptions.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return rejection(new exceptions.TransactionInactive());
    if (this._locked()) {
      return new DexiePromise((resolve, reject) => {
        this._blockedFuncs.push([() => {
          this._promise(mode, fn2, bWriteLock).then(resolve, reject);
        }, PSD]);
      });
    } else if (bWriteLock) {
      return newScope(() => {
        var p3 = new DexiePromise((resolve, reject) => {
          this._lock();
          const rv = fn2(resolve, reject, this);
          if (rv && rv.then)
            rv.then(resolve, reject);
        });
        p3.finally(() => this._unlock());
        p3._lib = true;
        return p3;
      });
    } else {
      var p2 = new DexiePromise((resolve, reject) => {
        var rv = fn2(resolve, reject, this);
        if (rv && rv.then)
          rv.then(resolve, reject);
      });
      p2._lib = true;
      return p2;
    }
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(promiseLike) {
    var root = this._root();
    const promise = DexiePromise.resolve(promiseLike);
    if (root._waitingFor) {
      root._waitingFor = root._waitingFor.then(() => promise);
    } else {
      root._waitingFor = promise;
      root._waitingQueue = [];
      var store = root.idbtrans.objectStore(root.storeNames[0]);
      (function spin() {
        ++root._spinCount;
        while (root._waitingQueue.length)
          root._waitingQueue.shift()();
        if (root._waitingFor)
          store.get(-Infinity).onsuccess = spin;
      })();
    }
    var currentWaitPromise = root._waitingFor;
    return new DexiePromise((resolve, reject) => {
      promise.then((res) => root._waitingQueue.push(wrap(resolve.bind(null, res))), (err) => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {
        if (root._waitingFor === currentWaitPromise) {
          root._waitingFor = null;
        }
      });
    });
  }
  abort() {
    if (this.active) {
      this.active = false;
      if (this.idbtrans)
        this.idbtrans.abort();
      this._reject(new exceptions.Abort());
    }
  }
  table(tableName) {
    const memoizedTables = this._memoizedTables || (this._memoizedTables = {});
    if (hasOwn(memoizedTables, tableName))
      return memoizedTables[tableName];
    const tableSchema = this.schema[tableName];
    if (!tableSchema) {
      throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
    }
    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
    transactionBoundTable.core = this.db.core.table(tableName);
    memoizedTables[tableName] = transactionBoundTable;
    return transactionBoundTable;
  }
};
function createTransactionConstructor(db) {
  return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
    this.db = db;
    this.mode = mode;
    this.storeNames = storeNames;
    this.schema = dbschema;
    this.chromeTransactionDurability = chromeTransactionDurability;
    this.idbtrans = null;
    this.on = Events(this, "complete", "error", "abort");
    this.parent = parent || null;
    this.active = true;
    this._reculock = 0;
    this._blockedFuncs = [];
    this._resolve = null;
    this._reject = null;
    this._waitingFor = null;
    this._waitingQueue = null;
    this._spinCount = 0;
    this._completion = new DexiePromise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._completion.then(() => {
      this.active = false;
      this.on.complete.fire();
    }, (e) => {
      var wasActive = this.active;
      this.active = false;
      this.on.error.fire(e);
      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();
      return rejection(e);
    });
  });
}
function createIndexSpec(name, keyPath, unique, multi, auto2, compound, isPrimKey) {
  return {
    name,
    keyPath,
    unique,
    multi,
    auto: auto2,
    compound,
    src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto2 ? "++" : "") + nameFromKeyPath(keyPath)
  };
}
function nameFromKeyPath(keyPath) {
  return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
}
function createTableSchema(name, primKey, indexes) {
  return {
    name,
    primKey,
    indexes,
    mappedClass: null,
    idxByName: arrayToObject(indexes, (index) => [index.name, index])
  };
}
function safariMultiStoreFix(storeNames) {
  return storeNames.length === 1 ? storeNames[0] : storeNames;
}
var getMaxKey = (IdbKeyRange) => {
  try {
    IdbKeyRange.only([[]]);
    getMaxKey = () => [[]];
    return [[]];
  } catch (e) {
    getMaxKey = () => maxString;
    return maxString;
  }
};
function getKeyExtractor(keyPath) {
  if (keyPath == null) {
    return () => void 0;
  } else if (typeof keyPath === "string") {
    return getSinglePathKeyExtractor(keyPath);
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function getSinglePathKeyExtractor(keyPath) {
  const split = keyPath.split(".");
  if (split.length === 1) {
    return (obj) => obj[keyPath];
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function arrayify(arrayLike) {
  return [].slice.call(arrayLike);
}
var _id_counter = 0;
function getKeyPathAlias(keyPath) {
  return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : `[${keyPath.join("+")}]`;
}
function createDBCore(db, IdbKeyRange, tmpTrans) {
  function extractSchema(db2, trans) {
    const tables2 = arrayify(db2.objectStoreNames);
    return {
      schema: {
        name: db2.name,
        tables: tables2.map((table) => trans.objectStore(table)).map((store) => {
          const { keyPath, autoIncrement } = store;
          const compound = isArray(keyPath);
          const outbound = keyPath == null;
          const indexByKeyPath = {};
          const result = {
            name: store.name,
            primaryKey: {
              name: null,
              isPrimaryKey: true,
              outbound,
              compound,
              keyPath,
              autoIncrement,
              unique: true,
              extractKey: getKeyExtractor(keyPath)
            },
            indexes: arrayify(store.indexNames).map((indexName) => store.index(indexName)).map((index) => {
              const { name, unique, multiEntry, keyPath: keyPath2 } = index;
              const compound2 = isArray(keyPath2);
              const result2 = {
                name,
                compound: compound2,
                keyPath: keyPath2,
                unique,
                multiEntry,
                extractKey: getKeyExtractor(keyPath2)
              };
              indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
              return result2;
            }),
            getIndexByKeyPath: (keyPath2) => indexByKeyPath[getKeyPathAlias(keyPath2)]
          };
          indexByKeyPath[":id"] = result.primaryKey;
          if (keyPath != null) {
            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
          }
          return result;
        })
      },
      hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
    };
  }
  function makeIDBKeyRange(range) {
    if (range.type === 3)
      return null;
    if (range.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower, upper, lowerOpen, upperOpen } = range;
    const idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
    return idbRange;
  }
  function createDbCoreTable(tableSchema) {
    const tableName = tableSchema.name;
    function mutate({ trans, type: type2, keys: keys2, values, range }) {
      return new Promise((resolve, reject) => {
        resolve = wrap(resolve);
        const store = trans.objectStore(tableName);
        const outbound = store.keyPath == null;
        const isAddOrPut = type2 === "put" || type2 === "add";
        if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
          throw new Error("Invalid operation type: " + type2);
        const { length } = keys2 || values || { length: 1 };
        if (keys2 && values && keys2.length !== values.length) {
          throw new Error("Given keys array must have same length as given values array.");
        }
        if (length === 0)
          return resolve({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let req;
        const reqs = [];
        const failures = [];
        let numFailures = 0;
        const errorHandler = (event) => {
          ++numFailures;
          preventDefault(event);
        };
        if (type2 === "deleteRange") {
          if (range.type === 4)
            return resolve({ numFailures, failures, results: [], lastResult: void 0 });
          if (range.type === 3)
            reqs.push(req = store.clear());
          else
            reqs.push(req = store.delete(makeIDBKeyRange(range)));
        } else {
          const [args1, args2] = isAddOrPut ? outbound ? [values, keys2] : [values, null] : [keys2, null];
          if (isAddOrPut) {
            for (let i = 0; i < length; ++i) {
              reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          } else {
            for (let i = 0; i < length; ++i) {
              reqs.push(req = store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          }
        }
        const done = (event) => {
          const lastResult = event.target.result;
          reqs.forEach((req2, i) => req2.error != null && (failures[i] = req2.error));
          resolve({
            numFailures,
            failures,
            results: type2 === "delete" ? keys2 : reqs.map((req2) => req2.result),
            lastResult
          });
        };
        req.onerror = (event) => {
          errorHandler(event);
          done(event);
        };
        req.onsuccess = done;
      });
    }
    function openCursor2({ trans, values, query: query2, reverse, unique }) {
      return new Promise((resolve, reject) => {
        resolve = wrap(resolve);
        const { index, range } = query2;
        const store = trans.objectStore(tableName);
        const source = index.isPrimaryKey ? store : store.index(index.name);
        const direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
        const req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
        req.onerror = eventRejectHandler(reject);
        req.onsuccess = wrap((ev) => {
          const cursor = req.result;
          if (!cursor) {
            resolve(null);
            return;
          }
          cursor.___id = ++_id_counter;
          cursor.done = false;
          const _cursorContinue = cursor.continue.bind(cursor);
          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
          if (_cursorContinuePrimaryKey)
            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
          const _cursorAdvance = cursor.advance.bind(cursor);
          const doThrowCursorIsNotStarted = () => {
            throw new Error("Cursor not started");
          };
          const doThrowCursorIsStopped = () => {
            throw new Error("Cursor not stopped");
          };
          cursor.trans = trans;
          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
          cursor.fail = wrap(reject);
          cursor.next = function() {
            let gotOne = 1;
            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);
          };
          cursor.start = (callback) => {
            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {
              resolveIteration = wrap(resolveIteration);
              req.onerror = eventRejectHandler(rejectIteration);
              cursor.fail = rejectIteration;
              cursor.stop = (value) => {
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                resolveIteration(value);
              };
            });
            const guardedCallback = () => {
              if (req.result) {
                try {
                  callback();
                } catch (err) {
                  cursor.fail(err);
                }
              } else {
                cursor.done = true;
                cursor.start = () => {
                  throw new Error("Cursor behind last entry");
                };
                cursor.stop();
              }
            };
            req.onsuccess = wrap((ev2) => {
              req.onsuccess = guardedCallback;
              guardedCallback();
            });
            cursor.continue = _cursorContinue;
            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
            cursor.advance = _cursorAdvance;
            guardedCallback();
            return iterationPromise;
          };
          resolve(cursor);
        }, reject);
      });
    }
    function query(hasGetAll2) {
      return (request) => {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const { trans, values, limit, query: query2 } = request;
          const nonInfinitLimit = limit === Infinity ? void 0 : limit;
          const { index, range } = query2;
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          if (limit === 0)
            return resolve({ result: [] });
          if (hasGetAll2) {
            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
            req.onsuccess = (event) => resolve({ result: event.target.result });
            req.onerror = eventRejectHandler(reject);
          } else {
            let count = 0;
            const req = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
            const result = [];
            req.onsuccess = (event) => {
              const cursor = req.result;
              if (!cursor)
                return resolve({ result });
              result.push(values ? cursor.value : cursor.primaryKey);
              if (++count === limit)
                return resolve({ result });
              cursor.continue();
            };
            req.onerror = eventRejectHandler(reject);
          }
        });
      };
    }
    return {
      name: tableName,
      schema: tableSchema,
      mutate,
      getMany({ trans, keys: keys2 }) {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const store = trans.objectStore(tableName);
          const length = keys2.length;
          const result = new Array(length);
          let keyCount = 0;
          let callbackCount = 0;
          let req;
          const successHandler = (event) => {
            const req2 = event.target;
            if ((result[req2._pos] = req2.result) != null)
              ;
            if (++callbackCount === keyCount)
              resolve(result);
          };
          const errorHandler = eventRejectHandler(reject);
          for (let i = 0; i < length; ++i) {
            const key = keys2[i];
            if (key != null) {
              req = store.get(keys2[i]);
              req._pos = i;
              req.onsuccess = successHandler;
              req.onerror = errorHandler;
              ++keyCount;
            }
          }
          if (keyCount === 0)
            resolve(result);
        });
      },
      get({ trans, key }) {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const store = trans.objectStore(tableName);
          const req = store.get(key);
          req.onsuccess = (event) => resolve(event.target.result);
          req.onerror = eventRejectHandler(reject);
        });
      },
      query: query(hasGetAll),
      openCursor: openCursor2,
      count({ query: query2, trans }) {
        const { index, range } = query2;
        return new Promise((resolve, reject) => {
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();
          req.onsuccess = wrap((ev) => resolve(ev.target.result));
          req.onerror = eventRejectHandler(reject);
        });
      }
    };
  }
  const { schema, hasGetAll } = extractSchema(db, tmpTrans);
  const tables = schema.tables.map((tableSchema) => createDbCoreTable(tableSchema));
  const tableMap = {};
  tables.forEach((table) => tableMap[table.name] = table);
  return {
    stack: "dbcore",
    transaction: db.transaction.bind(db),
    table(name) {
      const result = tableMap[name];
      if (!result)
        throw new Error(`Table '${name}' not found`);
      return tableMap[name];
    },
    MIN_KEY: -Infinity,
    MAX_KEY: getMaxKey(IdbKeyRange),
    schema
  };
}
function createMiddlewareStack(stackImpl, middlewares) {
  return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);
}
function createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB: indexedDB2 }, tmpTrans) {
  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
  return {
    dbcore
  };
}
function generateMiddlewareStacks({ _novip: db }, tmpTrans) {
  const idbdb = tmpTrans.db;
  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
  db.core = stacks.dbcore;
  db.tables.forEach((table) => {
    const tableName = table.name;
    if (db.core.schema.tables.some((tbl) => tbl.name === tableName)) {
      table.core = db.core.table(tableName);
      if (db[tableName] instanceof db.Table) {
        db[tableName].core = table.core;
      }
    }
  });
}
function setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {
  tableNames.forEach((tableName) => {
    const schema = dbschema[tableName];
    objs.forEach((obj) => {
      const propDesc = getPropertyDescriptor(obj, tableName);
      if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
          setProp(obj, tableName, {
            get() {
              return this.table(tableName);
            },
            set(value) {
              defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
            }
          });
        } else {
          obj[tableName] = new db.Table(tableName, schema);
        }
      }
    });
  });
}
function removeTablesApi({ _novip: db }, objs) {
  objs.forEach((obj) => {
    for (let key in obj) {
      if (obj[key] instanceof db.Table)
        delete obj[key];
    }
  });
}
function lowerVersionFirst(a, b2) {
  return a._cfg.version - b2._cfg.version;
}
function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
  const globalSchema = db._dbSchema;
  const trans = db._createTransaction("readwrite", db._storeNames, globalSchema);
  trans.create(idbUpgradeTrans);
  trans._completion.catch(reject);
  const rejectTransaction = trans._reject.bind(trans);
  const transless = PSD.transless || PSD;
  newScope(() => {
    PSD.trans = trans;
    PSD.transless = transless;
    if (oldVersion === 0) {
      keys(globalSchema).forEach((tableName) => {
        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
      });
      generateMiddlewareStacks(db, idbUpgradeTrans);
      DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);
    } else
      updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
  });
}
function updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {
  const queue = [];
  const versions = db._versions;
  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
  let anyContentUpgraderHasRun = false;
  const versToRun = versions.filter((v3) => v3._cfg.version >= oldVersion);
  versToRun.forEach((version) => {
    queue.push(() => {
      const oldSchema = globalSchema;
      const newSchema = version._cfg.dbschema;
      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
      globalSchema = db._dbSchema = newSchema;
      const diff = getSchemaDiff(oldSchema, newSchema);
      diff.add.forEach((tuple) => {
        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
      });
      diff.change.forEach((change) => {
        if (change.recreate) {
          throw new exceptions.Upgrade("Not yet support for changing primary key");
        } else {
          const store = idbUpgradeTrans.objectStore(change.name);
          change.add.forEach((idx) => addIndex(store, idx));
          change.change.forEach((idx) => {
            store.deleteIndex(idx.name);
            addIndex(store, idx);
          });
          change.del.forEach((idxName) => store.deleteIndex(idxName));
        }
      });
      const contentUpgrade = version._cfg.contentUpgrade;
      if (contentUpgrade && version._cfg.version > oldVersion) {
        generateMiddlewareStacks(db, idbUpgradeTrans);
        trans._memoizedTables = {};
        anyContentUpgraderHasRun = true;
        let upgradeSchema = shallowClone(newSchema);
        diff.del.forEach((table) => {
          upgradeSchema[table] = oldSchema[table];
        });
        removeTablesApi(db, [db.Transaction.prototype]);
        setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);
        trans.schema = upgradeSchema;
        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);
        if (contentUpgradeIsAsync) {
          incrementExpectedAwaits();
        }
        let returnValue;
        const promiseFollowed = DexiePromise.follow(() => {
          returnValue = contentUpgrade(trans);
          if (returnValue) {
            if (contentUpgradeIsAsync) {
              var decrementor = decrementExpectedAwaits.bind(null, null);
              returnValue.then(decrementor, decrementor);
            }
          }
        });
        return returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);
      }
    });
    queue.push((idbtrans) => {
      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
        const newSchema = version._cfg.dbschema;
        deleteRemovedTables(newSchema, idbtrans);
      }
      removeTablesApi(db, [db.Transaction.prototype]);
      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
      trans.schema = db._dbSchema;
    });
  });
  function runQueue() {
    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
  }
  return runQueue().then(() => {
    createMissingTables(globalSchema, idbUpgradeTrans);
  });
}
function getSchemaDiff(oldSchema, newSchema) {
  const diff = {
    del: [],
    add: [],
    change: []
  };
  let table;
  for (table in oldSchema) {
    if (!newSchema[table])
      diff.del.push(table);
  }
  for (table in newSchema) {
    const oldDef = oldSchema[table], newDef = newSchema[table];
    if (!oldDef) {
      diff.add.push([table, newDef]);
    } else {
      const change = {
        name: table,
        def: newDef,
        recreate: false,
        del: [],
        add: [],
        change: []
      };
      if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
        change.recreate = true;
        diff.change.push(change);
      } else {
        const oldIndexes = oldDef.idxByName;
        const newIndexes = newDef.idxByName;
        let idxName;
        for (idxName in oldIndexes) {
          if (!newIndexes[idxName])
            change.del.push(idxName);
        }
        for (idxName in newIndexes) {
          const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
          if (!oldIdx)
            change.add.push(newIdx);
          else if (oldIdx.src !== newIdx.src)
            change.change.push(newIdx);
        }
        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
          diff.change.push(change);
        }
      }
    }
  }
  return diff;
}
function createTable(idbtrans, tableName, primKey, indexes) {
  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
  indexes.forEach((idx) => addIndex(store, idx));
  return store;
}
function createMissingTables(newSchema, idbtrans) {
  keys(newSchema).forEach((tableName) => {
    if (!idbtrans.db.objectStoreNames.contains(tableName)) {
      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
    }
  });
}
function deleteRemovedTables(newSchema, idbtrans) {
  [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName) => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));
}
function addIndex(store, idx) {
  store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
}
function buildGlobalSchema(db, idbdb, tmpTrans) {
  const globalSchema = {};
  const dbStoreNames = slice(idbdb.objectStoreNames, 0);
  dbStoreNames.forEach((storeName) => {
    const store = tmpTrans.objectStore(storeName);
    let keyPath = store.keyPath;
    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
    const indexes = [];
    for (let j = 0; j < store.indexNames.length; ++j) {
      const idbindex = store.index(store.indexNames[j]);
      keyPath = idbindex.keyPath;
      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
      indexes.push(index);
    }
    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
  });
  return globalSchema;
}
function readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {
  db.verno = idbdb.version / 10;
  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
  db._storeNames = slice(idbdb.objectStoreNames, 0);
  setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
}
function verifyInstalledSchema(db, tmpTrans) {
  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
  const diff = getSchemaDiff(installedSchema, db._dbSchema);
  return !(diff.add.length || diff.change.some((ch) => ch.add.length || ch.change.length));
}
function adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {
  const storeNames = idbtrans.db.objectStoreNames;
  for (let i = 0; i < storeNames.length; ++i) {
    const storeName = storeNames[i];
    const store = idbtrans.objectStore(storeName);
    db._hasGetAll = "getAll" in store;
    for (let j = 0; j < store.indexNames.length; ++j) {
      const indexName = store.indexNames[j];
      const keyPath = store.index(indexName).keyPath;
      const dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
      if (schema[storeName]) {
        const indexSpec = schema[storeName].idxByName[dexieName];
        if (indexSpec) {
          indexSpec.name = indexName;
          delete schema[storeName].idxByName[dexieName];
          schema[storeName].idxByName[indexName] = indexSpec;
        }
      }
    }
  }
  if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
    db._hasGetAll = false;
  }
}
function parseIndexSyntax(primKeyAndIndexes) {
  return primKeyAndIndexes.split(",").map((index, indexNum) => {
    index = index.trim();
    const name = index.replace(/([&*]|\+\+)/g, "");
    const keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
    return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
  });
}
var Version = class {
  _parseStoresSpec(stores, outSchema) {
    keys(stores).forEach((tableName) => {
      if (stores[tableName] !== null) {
        var indexes = parseIndexSyntax(stores[tableName]);
        var primKey = indexes.shift();
        if (primKey.multi)
          throw new exceptions.Schema("Primary key cannot be multi-valued");
        indexes.forEach((idx) => {
          if (idx.auto)
            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!idx.keyPath)
            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
        });
        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
      }
    });
  }
  stores(stores) {
    const db = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
    const versions = db._versions;
    const storesSpec = {};
    let dbschema = {};
    versions.forEach((version) => {
      extend(storesSpec, version._cfg.storesSource);
      dbschema = version._cfg.dbschema = {};
      version._parseStoresSpec(storesSpec, dbschema);
    });
    db._dbSchema = dbschema;
    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
    db._storeNames = keys(dbschema);
    return this;
  }
  upgrade(upgradeFunction) {
    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
    return this;
  }
};
function createVersionConstructor(db) {
  return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
    this.db = db;
    this._cfg = {
      version: versionNumber,
      storesSource: null,
      dbschema: {},
      tables: {},
      contentUpgrade: null
    };
  });
}
function getDbNamesTable(indexedDB2, IDBKeyRange) {
  let dbNamesDB = indexedDB2["_dbNamesDB"];
  if (!dbNamesDB) {
    dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
      addons: [],
      indexedDB: indexedDB2,
      IDBKeyRange
    });
    dbNamesDB.version(1).stores({ dbnames: "name" });
  }
  return dbNamesDB.table("dbnames");
}
function hasDatabasesNative(indexedDB2) {
  return indexedDB2 && typeof indexedDB2.databases === "function";
}
function getDatabaseNames({ indexedDB: indexedDB2, IDBKeyRange }) {
  return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then((infos) => infos.map((info) => info.name).filter((name) => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB2, IDBKeyRange).toCollection().primaryKeys();
}
function _onDatabaseCreated({ indexedDB: indexedDB2, IDBKeyRange }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).put({ name }).catch(nop);
}
function _onDatabaseDeleted({ indexedDB: indexedDB2, IDBKeyRange }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).delete(name).catch(nop);
}
function vip(fn2) {
  return newScope(function() {
    PSD.letThrough = true;
    return fn2();
  });
}
function idbReady() {
  var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari || !indexedDB.databases)
    return Promise.resolve();
  var intervalId;
  return new Promise(function(resolve) {
    var tryIdb = function() {
      return indexedDB.databases().finally(resolve);
    };
    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function() {
    return clearInterval(intervalId);
  });
}
function dexieOpen(db) {
  const state = db._state;
  const { indexedDB: indexedDB2 } = db._deps;
  if (state.isBeingOpened || db.idbdb)
    return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db);
  debug && (state.openCanceller._stackHolder = getErrorWithStack());
  state.isBeingOpened = true;
  state.dbOpenError = null;
  state.openComplete = false;
  const openCanceller = state.openCanceller;
  function throwIfCancelled() {
    if (state.openCanceller !== openCanceller)
      throw new exceptions.DatabaseClosed("db.open() was cancelled");
  }
  let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
  const tryOpenDB = () => new DexiePromise((resolve, reject) => {
    throwIfCancelled();
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    const dbName = db.name;
    const req = state.autoSchema ? indexedDB2.open(dbName) : indexedDB2.open(dbName, Math.round(db.verno * 10));
    if (!req)
      throw new exceptions.MissingAPI();
    req.onerror = eventRejectHandler(reject);
    req.onblocked = wrap(db._fireOnBlocked);
    req.onupgradeneeded = wrap((e) => {
      upgradeTransaction = req.transaction;
      if (state.autoSchema && !db._options.allowEmptyDB) {
        req.onerror = preventDefault;
        upgradeTransaction.abort();
        req.result.close();
        const delreq = indexedDB2.deleteDatabase(dbName);
        delreq.onsuccess = delreq.onerror = wrap(() => {
          reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));
        });
      } else {
        upgradeTransaction.onerror = eventRejectHandler(reject);
        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
        wasCreated = oldVer < 1;
        db._novip.idbdb = req.result;
        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
      }
    }, reject);
    req.onsuccess = wrap(() => {
      upgradeTransaction = null;
      const idbdb = db._novip.idbdb = req.result;
      const objectStoreNames = slice(idbdb.objectStoreNames);
      if (objectStoreNames.length > 0)
        try {
          const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
          if (state.autoSchema)
            readGlobalSchema(db, idbdb, tmpTrans);
          else {
            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
            if (!verifyInstalledSchema(db, tmpTrans)) {
              console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);
            }
          }
          generateMiddlewareStacks(db, tmpTrans);
        } catch (e) {
        }
      connections.push(db);
      idbdb.onversionchange = wrap((ev) => {
        state.vcFired = true;
        db.on("versionchange").fire(ev);
      });
      idbdb.onclose = wrap((ev) => {
        db.on("close").fire(ev);
      });
      if (wasCreated)
        _onDatabaseCreated(db._deps, dbName);
      resolve();
    }, reject);
  }).catch((err) => {
    if (err && err.name === "UnknownError" && state.PR1398_maxLoop > 0) {
      state.PR1398_maxLoop--;
      console.warn("Dexie: Workaround for Chrome UnknownError on open()");
      return tryOpenDB();
    } else {
      return DexiePromise.reject(err);
    }
  });
  return DexiePromise.race([
    openCanceller,
    (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
  ]).then(() => {
    throwIfCancelled();
    state.onReadyBeingFired = [];
    return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {
      if (state.onReadyBeingFired.length > 0) {
        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);
      }
    });
  }).finally(() => {
    state.onReadyBeingFired = null;
    state.isBeingOpened = false;
  }).then(() => {
    return db;
  }).catch((err) => {
    state.dbOpenError = err;
    try {
      upgradeTransaction && upgradeTransaction.abort();
    } catch (_a2) {
    }
    if (openCanceller === state.openCanceller) {
      db._close();
    }
    return rejection(err);
  }).finally(() => {
    state.openComplete = true;
    resolveDbReady();
  });
}
function awaitIterator(iterator) {
  var callNext = (result) => iterator.next(result), doThrow = (error) => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);
  function step(getNext) {
    return (val) => {
      var next = getNext(val), value = next.value;
      return next.done ? value : !value || typeof value.then !== "function" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
    };
  }
  return step(callNext)();
}
function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
  var i = arguments.length;
  if (i < 2)
    throw new exceptions.InvalidArgument("Too few arguments");
  var args = new Array(i - 1);
  while (--i)
    args[i - 1] = arguments[i];
  scopeFunc = args.pop();
  var tables = flatten(args);
  return [mode, tables, scopeFunc];
}
function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
  return DexiePromise.resolve().then(() => {
    const transless = PSD.transless || PSD;
    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
    const zoneProps = {
      trans,
      transless
    };
    if (parentTransaction) {
      trans.idbtrans = parentTransaction.idbtrans;
    } else {
      try {
        trans.create();
        db._state.PR1398_maxLoop = 3;
      } catch (ex) {
        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
          console.warn("Dexie: Need to reopen db");
          db._close();
          return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));
        }
        return rejection(ex);
      }
    }
    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);
    if (scopeFuncIsAsync) {
      incrementExpectedAwaits();
    }
    let returnValue;
    const promiseFollowed = DexiePromise.follow(() => {
      returnValue = scopeFunc.call(trans, trans);
      if (returnValue) {
        if (scopeFuncIsAsync) {
          var decrementor = decrementExpectedAwaits.bind(null, null);
          returnValue.then(decrementor, decrementor);
        } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
          returnValue = awaitIterator(returnValue);
        }
      }
    }, zoneProps);
    return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then((x) => trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : promiseFollowed.then(() => returnValue)).then((x) => {
      if (parentTransaction)
        trans._resolve();
      return trans._completion.then(() => x);
    }).catch((e) => {
      trans._reject(e);
      return rejection(e);
    });
  });
}
function pad(a, value, count) {
  const result = isArray(a) ? a.slice() : [a];
  for (let i = 0; i < count; ++i)
    result.push(value);
  return result;
}
function createVirtualIndexMiddleware(down) {
  return {
    ...down,
    table(tableName) {
      const table = down.table(tableName);
      const { schema } = table;
      const indexLookup = {};
      const allVirtualIndexes = [];
      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
        const keyPathAlias = getKeyPathAlias(keyPath);
        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
        const keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
        const isVirtual = keyTail > 0;
        const virtualIndex = {
          ...lowLevelIndex,
          isVirtual,
          keyTail,
          keyLength,
          extractKey: getKeyExtractor(keyPath),
          unique: !isVirtual && lowLevelIndex.unique
        };
        indexList.push(virtualIndex);
        if (!virtualIndex.isPrimaryKey) {
          allVirtualIndexes.push(virtualIndex);
        }
        if (keyLength > 1) {
          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
        }
        indexList.sort((a, b2) => a.keyTail - b2.keyTail);
        return virtualIndex;
      }
      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
      indexLookup[":id"] = [primaryKey];
      for (const index of schema.indexes) {
        addVirtualIndexes(index.keyPath, 0, index);
      }
      function findBestIndex(keyPath) {
        const result2 = indexLookup[getKeyPathAlias(keyPath)];
        return result2 && result2[0];
      }
      function translateRange(range, keyTail) {
        return {
          type: range.type === 1 ? 2 : range.type,
          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
          lowerOpen: true,
          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
          upperOpen: true
        };
      }
      function translateRequest(req) {
        const index = req.query.index;
        return index.isVirtual ? {
          ...req,
          query: {
            index,
            range: translateRange(req.query.range, index.keyTail)
          }
        } : req;
      }
      const result = {
        ...table,
        schema: {
          ...schema,
          primaryKey,
          indexes: allVirtualIndexes,
          getIndexByKeyPath: findBestIndex
        },
        count(req) {
          return table.count(translateRequest(req));
        },
        query(req) {
          return table.query(translateRequest(req));
        },
        openCursor(req) {
          const { keyTail, isVirtual, keyLength } = req.query.index;
          if (!isVirtual)
            return table.openCursor(req);
          function createVirtualCursor(cursor) {
            function _continue(key) {
              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
            }
            const virtualCursor = Object.create(cursor, {
              continue: { value: _continue },
              continuePrimaryKey: {
                value(key, primaryKey2) {
                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                }
              },
              primaryKey: {
                get() {
                  return cursor.primaryKey;
                }
              },
              key: {
                get() {
                  const key = cursor.key;
                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                }
              },
              value: {
                get() {
                  return cursor.value;
                }
              }
            });
            return virtualCursor;
          }
          return table.openCursor(translateRequest(req)).then((cursor) => cursor && createVirtualCursor(cursor));
        }
      };
      return result;
    }
  };
}
var virtualIndexMiddleware = {
  stack: "dbcore",
  name: "VirtualIndexMiddleware",
  level: 1,
  create: createVirtualIndexMiddleware
};
function getObjectDiff(a, b2, rv, prfx) {
  rv = rv || {};
  prfx = prfx || "";
  keys(a).forEach((prop) => {
    if (!hasOwn(b2, prop)) {
      rv[prfx + prop] = void 0;
    } else {
      var ap = a[prop], bp = b2[prop];
      if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
        const apTypeName = toStringTag(ap);
        const bpTypeName = toStringTag(bp);
        if (apTypeName !== bpTypeName) {
          rv[prfx + prop] = b2[prop];
        } else if (apTypeName === "Object") {
          getObjectDiff(ap, bp, rv, prfx + prop + ".");
        } else if (ap !== bp) {
          rv[prfx + prop] = b2[prop];
        }
      } else if (ap !== bp)
        rv[prfx + prop] = b2[prop];
    }
  });
  keys(b2).forEach((prop) => {
    if (!hasOwn(a, prop)) {
      rv[prfx + prop] = b2[prop];
    }
  });
  return rv;
}
function getEffectiveKeys(primaryKey, req) {
  if (req.type === "delete")
    return req.keys;
  return req.keys || req.values.map(primaryKey.extractKey);
}
var hooksMiddleware = {
  stack: "dbcore",
  name: "HooksMiddleware",
  level: 2,
  create: (downCore) => ({
    ...downCore,
    table(tableName) {
      const downTable = downCore.table(tableName);
      const { primaryKey } = downTable.schema;
      const tableMiddleware = {
        ...downTable,
        mutate(req) {
          const dxTrans = PSD.trans;
          const { deleting, creating, updating } = dxTrans.table(tableName).hook;
          switch (req.type) {
            case "add":
              if (creating.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "put":
              if (creating.fire === nop && updating.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "delete":
              if (deleting.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "deleteRange":
              if (deleting.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => deleteRange(req), true);
          }
          return downTable.mutate(req);
          function addPutOrDelete(req2) {
            const dxTrans2 = PSD.trans;
            const keys2 = req2.keys || getEffectiveKeys(primaryKey, req2);
            if (!keys2)
              throw new Error("Keys missing");
            req2 = req2.type === "add" || req2.type === "put" ? { ...req2, keys: keys2 } : { ...req2 };
            if (req2.type !== "delete")
              req2.values = [...req2.values];
            if (req2.keys)
              req2.keys = [...req2.keys];
            return getExistingValues(downTable, req2, keys2).then((existingValues) => {
              const contexts = keys2.map((key, i) => {
                const existingValue = existingValues[i];
                const ctx = { onerror: null, onsuccess: null };
                if (req2.type === "delete") {
                  deleting.fire.call(ctx, key, existingValue, dxTrans2);
                } else if (req2.type === "add" || existingValue === void 0) {
                  const generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                  if (key == null && generatedPrimaryKey != null) {
                    key = generatedPrimaryKey;
                    req2.keys[i] = key;
                    if (!primaryKey.outbound) {
                      setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                    }
                  }
                } else {
                  const objectDiff = getObjectDiff(existingValue, req2.values[i]);
                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                  if (additionalChanges) {
                    const requestedValue = req2.values[i];
                    Object.keys(additionalChanges).forEach((keyPath) => {
                      if (hasOwn(requestedValue, keyPath)) {
                        requestedValue[keyPath] = additionalChanges[keyPath];
                      } else {
                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);
                      }
                    });
                  }
                }
                return ctx;
              });
              return downTable.mutate(req2).then(({ failures, results, numFailures, lastResult }) => {
                for (let i = 0; i < keys2.length; ++i) {
                  const primKey = results ? results[i] : keys2[i];
                  const ctx = contexts[i];
                  if (primKey == null) {
                    ctx.onerror && ctx.onerror(failures[i]);
                  } else {
                    ctx.onsuccess && ctx.onsuccess(
                      req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                    );
                  }
                }
                return { failures, results, numFailures, lastResult };
              }).catch((error) => {
                contexts.forEach((ctx) => ctx.onerror && ctx.onerror(error));
                return Promise.reject(error);
              });
            });
          }
          function deleteRange(req2) {
            return deleteNextChunk(req2.trans, req2.range, 1e4);
          }
          function deleteNextChunk(trans, range, limit) {
            return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(({ result }) => {
              return addPutOrDelete({ type: "delete", keys: result, trans }).then((res) => {
                if (res.numFailures > 0)
                  return Promise.reject(res.failures[0]);
                if (result.length < limit) {
                  return { failures: [], numFailures: 0, lastResult: void 0 };
                } else {
                  return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);
                }
              });
            });
          }
        }
      };
      return tableMiddleware;
    }
  })
};
function getExistingValues(table, req, effectiveKeys) {
  return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
}
function getFromTransactionCache(keys2, cache, clone) {
  try {
    if (!cache)
      return null;
    if (cache.keys.length < keys2.length)
      return null;
    const result = [];
    for (let i = 0, j = 0; i < cache.keys.length && j < keys2.length; ++i) {
      if (cmp(cache.keys[i], keys2[j]) !== 0)
        continue;
      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
      ++j;
    }
    return result.length === keys2.length ? result : null;
  } catch (_a2) {
    return null;
  }
}
var cacheExistingValuesMiddleware = {
  stack: "dbcore",
  level: -1,
  create: (core) => {
    return {
      table: (tableName) => {
        const table = core.table(tableName);
        return {
          ...table,
          getMany: (req) => {
            if (!req.cache) {
              return table.getMany(req);
            }
            const cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
            if (cachedResult) {
              return DexiePromise.resolve(cachedResult);
            }
            return table.getMany(req).then((res) => {
              req.trans["_cache"] = {
                keys: req.keys,
                values: req.cache === "clone" ? deepClone(res) : res
              };
              return res;
            });
          },
          mutate: (req) => {
            if (req.type !== "add")
              req.trans["_cache"] = null;
            return table.mutate(req);
          }
        };
      }
    };
  }
};
function isEmptyRange(node) {
  return !("from" in node);
}
var RangeSet = function(fromOrTree, to) {
  if (this) {
    extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
  } else {
    const rv = new RangeSet();
    if (fromOrTree && "d" in fromOrTree) {
      extend(rv, fromOrTree);
    }
    return rv;
  }
};
props(RangeSet.prototype, {
  add(rangeSet) {
    mergeRanges(this, rangeSet);
    return this;
  },
  addKey(key) {
    addRange(this, key, key);
    return this;
  },
  addKeys(keys2) {
    keys2.forEach((key) => addRange(this, key, key));
    return this;
  },
  [iteratorSymbol]() {
    return getRangeSetIterator(this);
  }
});
function addRange(target, from, to) {
  const diff = cmp(from, to);
  if (isNaN(diff))
    return;
  if (diff > 0)
    throw RangeError();
  if (isEmptyRange(target))
    return extend(target, { from, to, d: 1 });
  const left2 = target.l;
  const right2 = target.r;
  if (cmp(to, target.from) < 0) {
    left2 ? addRange(left2, from, to) : target.l = { from, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from, target.to) > 0) {
    right2 ? addRange(right2, from, to) : target.r = { from, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from, target.from) < 0) {
    target.from = from;
    target.l = null;
    target.d = right2 ? right2.d + 1 : 1;
  }
  if (cmp(to, target.to) > 0) {
    target.to = to;
    target.r = null;
    target.d = target.l ? target.l.d + 1 : 1;
  }
  const rightWasCutOff = !target.r;
  if (left2 && !target.l) {
    mergeRanges(target, left2);
  }
  if (right2 && rightWasCutOff) {
    mergeRanges(target, right2);
  }
}
function mergeRanges(target, newSet) {
  function _addRangeSet(target2, { from, to, l: l2, r }) {
    addRange(target2, from, to);
    if (l2)
      _addRangeSet(target2, l2);
    if (r)
      _addRangeSet(target2, r);
  }
  if (!isEmptyRange(newSet))
    _addRangeSet(target, newSet);
}
function rangesOverlap(rangeSet1, rangeSet2) {
  const i1 = getRangeSetIterator(rangeSet2);
  let nextResult1 = i1.next();
  if (nextResult1.done)
    return false;
  let a = nextResult1.value;
  const i2 = getRangeSetIterator(rangeSet1);
  let nextResult2 = i2.next(a.from);
  let b2 = nextResult2.value;
  while (!nextResult1.done && !nextResult2.done) {
    if (cmp(b2.from, a.to) <= 0 && cmp(b2.to, a.from) >= 0)
      return true;
    cmp(a.from, b2.from) < 0 ? a = (nextResult1 = i1.next(b2.from)).value : b2 = (nextResult2 = i2.next(a.from)).value;
  }
  return false;
}
function getRangeSetIterator(node) {
  let state = isEmptyRange(node) ? null : { s: 0, n: node };
  return {
    next(key) {
      const keyProvided = arguments.length > 0;
      while (state) {
        switch (state.s) {
          case 0:
            state.s = 1;
            if (keyProvided) {
              while (state.n.l && cmp(key, state.n.from) < 0)
                state = { up: state, n: state.n.l, s: 1 };
            } else {
              while (state.n.l)
                state = { up: state, n: state.n.l, s: 1 };
            }
          case 1:
            state.s = 2;
            if (!keyProvided || cmp(key, state.n.to) <= 0)
              return { value: state.n, done: false };
          case 2:
            if (state.n.r) {
              state.s = 3;
              state = { up: state, n: state.n.r, s: 0 };
              continue;
            }
          case 3:
            state = state.up;
        }
      }
      return { done: true };
    }
  };
}
function rebalance(target) {
  var _a2, _b2;
  const diff = (((_a2 = target.r) === null || _a2 === void 0 ? void 0 : _a2.d) || 0) - (((_b2 = target.l) === null || _b2 === void 0 ? void 0 : _b2.d) || 0);
  const r = diff > 1 ? "r" : diff < -1 ? "l" : "";
  if (r) {
    const l2 = r === "r" ? "l" : "r";
    const rootClone = { ...target };
    const oldRootRight = target[r];
    target.from = oldRootRight.from;
    target.to = oldRootRight.to;
    target[r] = oldRootRight[r];
    rootClone[r] = oldRootRight[l2];
    target[l2] = rootClone;
    rootClone.d = computeDepth(rootClone);
  }
  target.d = computeDepth(target);
}
function computeDepth({ r, l: l2 }) {
  return (r ? l2 ? Math.max(r.d, l2.d) : r.d : l2 ? l2.d : 0) + 1;
}
var observabilityMiddleware = {
  stack: "dbcore",
  level: 0,
  create: (core) => {
    const dbName = core.schema.name;
    const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
    return {
      ...core,
      table: (tableName) => {
        const table = core.table(tableName);
        const { schema } = table;
        const { primaryKey } = schema;
        const { extractKey, outbound } = primaryKey;
        const tableClone = {
          ...table,
          mutate: (req) => {
            const trans = req.trans;
            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
            const getRangeSet = (indexName) => {
              const part = `idb://${dbName}/${tableName}/${indexName}`;
              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());
            };
            const pkRangeSet = getRangeSet("");
            const delsRangeSet = getRangeSet(":dels");
            const { type: type2 } = req;
            let [keys2, newObjs] = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];
            const oldCache = req.trans["_cache"];
            return table.mutate(req).then((res) => {
              if (isArray(keys2)) {
                if (type2 !== "delete")
                  keys2 = res.results;
                pkRangeSet.addKeys(keys2);
                const oldObjs = getFromTransactionCache(keys2, oldCache);
                if (!oldObjs && type2 !== "add") {
                  delsRangeSet.addKeys(keys2);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys2) {
                const range = { from: keys2.lower, to: keys2.upper };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach((idx) => getRangeSet(idx.name).add(FULL_RANGE));
              }
              return res;
            });
          }
        };
        const getRange = ({ query: { index, range } }) => {
          var _a2, _b2;
          return [
            index,
            new RangeSet((_a2 = range.lower) !== null && _a2 !== void 0 ? _a2 : core.MIN_KEY, (_b2 = range.upper) !== null && _b2 !== void 0 ? _b2 : core.MAX_KEY)
          ];
        };
        const readSubscribers = {
          get: (req) => [primaryKey, new RangeSet(req.key)],
          getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],
          count: getRange,
          query: getRange,
          openCursor: getRange
        };
        keys(readSubscribers).forEach((method) => {
          tableClone[method] = function(req) {
            const { subscr } = PSD;
            if (subscr) {
              const getRangeSet = (indexName) => {
                const part = `idb://${dbName}/${tableName}/${indexName}`;
                return subscr[part] || (subscr[part] = new RangeSet());
              };
              const pkRangeSet = getRangeSet("");
              const delsRangeSet = getRangeSet(":dels");
              const [queriedIndex, queriedRanges] = readSubscribers[method](req);
              getRangeSet(queriedIndex.name || "").add(queriedRanges);
              if (!queriedIndex.isPrimaryKey) {
                if (method === "count") {
                  delsRangeSet.add(FULL_RANGE);
                } else {
                  const keysPromise = method === "query" && outbound && req.values && table.query({
                    ...req,
                    values: false
                  });
                  return table[method].apply(this, arguments).then((res) => {
                    if (method === "query") {
                      if (outbound && req.values) {
                        return keysPromise.then(({ result: resultingKeys }) => {
                          pkRangeSet.addKeys(resultingKeys);
                          return res;
                        });
                      }
                      const pKeys = req.values ? res.result.map(extractKey) : res.result;
                      if (req.values) {
                        pkRangeSet.addKeys(pKeys);
                      } else {
                        delsRangeSet.addKeys(pKeys);
                      }
                    } else if (method === "openCursor") {
                      const cursor = res;
                      const wantValues = req.values;
                      return cursor && Object.create(cursor, {
                        key: {
                          get() {
                            delsRangeSet.addKey(cursor.primaryKey);
                            return cursor.key;
                          }
                        },
                        primaryKey: {
                          get() {
                            const pkey = cursor.primaryKey;
                            delsRangeSet.addKey(pkey);
                            return pkey;
                          }
                        },
                        value: {
                          get() {
                            wantValues && pkRangeSet.addKey(cursor.primaryKey);
                            return cursor.value;
                          }
                        }
                      });
                    }
                    return res;
                  });
                }
              }
            }
            return table[method].apply(this, arguments);
          };
        });
        return tableClone;
      }
    };
  }
};
function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
  function addAffectedIndex(ix) {
    const rangeSet = getRangeSet(ix.name || "");
    function extractKey(obj) {
      return obj != null ? ix.extractKey(obj) : null;
    }
    const addKeyOrKeys = (key) => ix.multiEntry && isArray(key) ? key.forEach((key2) => rangeSet.addKey(key2)) : rangeSet.addKey(key);
    (oldObjs || newObjs).forEach((_, i) => {
      const oldKey = oldObjs && extractKey(oldObjs[i]);
      const newKey = newObjs && extractKey(newObjs[i]);
      if (cmp(oldKey, newKey) !== 0) {
        if (oldKey != null)
          addKeyOrKeys(oldKey);
        if (newKey != null)
          addKeyOrKeys(newKey);
      }
    });
  }
  schema.indexes.forEach(addAffectedIndex);
}
var Dexie$1 = class _Dexie$1 {
  constructor(name, options) {
    this._middlewares = {};
    this.verno = 0;
    const deps = _Dexie$1.dependencies;
    this._options = options = {
      addons: _Dexie$1.addons,
      autoOpen: true,
      indexedDB: deps.indexedDB,
      IDBKeyRange: deps.IDBKeyRange,
      ...options
    };
    this._deps = {
      indexedDB: options.indexedDB,
      IDBKeyRange: options.IDBKeyRange
    };
    const { addons } = options;
    this._dbSchema = {};
    this._versions = [];
    this._storeNames = [];
    this._allTables = {};
    this.idbdb = null;
    this._novip = this;
    const state = {
      dbOpenError: null,
      isBeingOpened: false,
      onReadyBeingFired: null,
      openComplete: false,
      dbReadyResolve: nop,
      dbReadyPromise: null,
      cancelOpen: nop,
      openCanceller: null,
      autoSchema: true,
      PR1398_maxLoop: 3
    };
    state.dbReadyPromise = new DexiePromise((resolve) => {
      state.dbReadyResolve = resolve;
    });
    state.openCanceller = new DexiePromise((_, reject) => {
      state.cancelOpen = reject;
    });
    this._state = state;
    this.name = name;
    this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
    this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe) => {
      return (subscriber, bSticky) => {
        _Dexie$1.vip(() => {
          const state2 = this._state;
          if (state2.openComplete) {
            if (!state2.dbOpenError)
              DexiePromise.resolve().then(subscriber);
            if (bSticky)
              subscribe(subscriber);
          } else if (state2.onReadyBeingFired) {
            state2.onReadyBeingFired.push(subscriber);
            if (bSticky)
              subscribe(subscriber);
          } else {
            subscribe(subscriber);
            const db = this;
            if (!bSticky)
              subscribe(function unsubscribe() {
                db.on.ready.unsubscribe(subscriber);
                db.on.ready.unsubscribe(unsubscribe);
              });
          }
        });
      };
    });
    this.Collection = createCollectionConstructor(this);
    this.Table = createTableConstructor(this);
    this.Transaction = createTransactionConstructor(this);
    this.Version = createVersionConstructor(this);
    this.WhereClause = createWhereClauseConstructor(this);
    this.on("versionchange", (ev) => {
      if (ev.newVersion > 0)
        console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);
      else
        console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);
      this.close();
    });
    this.on("blocked", (ev) => {
      if (!ev.newVersion || ev.newVersion < ev.oldVersion)
        console.warn(`Dexie.delete('${this.name}') was blocked`);
      else
        console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);
    });
    this._maxKey = getMaxKey(options.IDBKeyRange);
    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);
    this._fireOnBlocked = (ev) => {
      this.on("blocked").fire(ev);
      connections.filter((c3) => c3.name === this.name && c3 !== this && !c3._state.vcFired).map((c3) => c3.on("versionchange").fire(ev));
    };
    this.use(virtualIndexMiddleware);
    this.use(hooksMiddleware);
    this.use(observabilityMiddleware);
    this.use(cacheExistingValuesMiddleware);
    this.vip = Object.create(this, { _vip: { value: true } });
    addons.forEach((addon) => addon(this));
  }
  version(versionNumber) {
    if (isNaN(versionNumber) || versionNumber < 0.1)
      throw new exceptions.Type(`Given version is not a positive number`);
    versionNumber = Math.round(versionNumber * 10) / 10;
    if (this.idbdb || this._state.isBeingOpened)
      throw new exceptions.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, versionNumber);
    const versions = this._versions;
    var versionInstance = versions.filter((v3) => v3._cfg.version === versionNumber)[0];
    if (versionInstance)
      return versionInstance;
    versionInstance = new this.Version(versionNumber);
    versions.push(versionInstance);
    versions.sort(lowerVersionFirst);
    versionInstance.stores({});
    this._state.autoSchema = false;
    return versionInstance;
  }
  _whenReady(fn2) {
    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn2() : new DexiePromise((resolve, reject) => {
      if (this._state.openComplete) {
        return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));
      }
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen) {
          reject(new exceptions.DatabaseClosed());
          return;
        }
        this.open().catch(nop);
      }
      this._state.dbReadyPromise.then(resolve, reject);
    }).then(fn2);
  }
  use({ stack, create, level, name }) {
    if (name)
      this.unuse({ stack, name });
    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
    middlewares.push({ stack, create, level: level == null ? 10 : level, name });
    middlewares.sort((a, b2) => a.level - b2.level);
    return this;
  }
  unuse({ stack, name, create }) {
    if (stack && this._middlewares[stack]) {
      this._middlewares[stack] = this._middlewares[stack].filter((mw) => create ? mw.create !== create : name ? mw.name !== name : false);
    }
    return this;
  }
  open() {
    return dexieOpen(this);
  }
  _close() {
    const state = this._state;
    const idx = connections.indexOf(this);
    if (idx >= 0)
      connections.splice(idx, 1);
    if (this.idbdb) {
      try {
        this.idbdb.close();
      } catch (e) {
      }
      this._novip.idbdb = null;
    }
    state.dbReadyPromise = new DexiePromise((resolve) => {
      state.dbReadyResolve = resolve;
    });
    state.openCanceller = new DexiePromise((_, reject) => {
      state.cancelOpen = reject;
    });
  }
  close() {
    this._close();
    const state = this._state;
    this._options.autoOpen = false;
    state.dbOpenError = new exceptions.DatabaseClosed();
    if (state.isBeingOpened)
      state.cancelOpen(state.dbOpenError);
  }
  delete() {
    const hasArguments = arguments.length > 0;
    const state = this._state;
    return new DexiePromise((resolve, reject) => {
      const doDelete = () => {
        this.close();
        var req = this._deps.indexedDB.deleteDatabase(this.name);
        req.onsuccess = wrap(() => {
          _onDatabaseDeleted(this._deps, this.name);
          resolve();
        });
        req.onerror = eventRejectHandler(reject);
        req.onblocked = this._fireOnBlocked;
      };
      if (hasArguments)
        throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
      if (state.isBeingOpened) {
        state.dbReadyPromise.then(doDelete);
      } else {
        doDelete();
      }
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const dbOpenError = this._state.dbOpenError;
    return dbOpenError && dbOpenError.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return keys(this._allTables).map((name) => this._allTables[name]);
  }
  transaction() {
    const args = extractTransactionArgs.apply(this, arguments);
    return this._transaction.apply(this, args);
  }
  _transaction(mode, tables, scopeFunc) {
    let parentTransaction = PSD.trans;
    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
      parentTransaction = null;
    const onlyIfCompatible = mode.indexOf("?") !== -1;
    mode = mode.replace("!", "").replace("?", "");
    let idbMode, storeNames;
    try {
      storeNames = tables.map((table) => {
        var storeName = table instanceof this.Table ? table.name : table;
        if (typeof storeName !== "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return storeName;
      });
      if (mode == "r" || mode === READONLY)
        idbMode = READONLY;
      else if (mode == "rw" || mode == READWRITE)
        idbMode = READWRITE;
      else
        throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
      if (parentTransaction) {
        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
          if (onlyIfCompatible) {
            parentTransaction = null;
          } else
            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
        }
        if (parentTransaction) {
          storeNames.forEach((storeName) => {
            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
              if (onlyIfCompatible) {
                parentTransaction = null;
              } else
                throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
            }
          });
        }
        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
          parentTransaction = null;
        }
      }
    } catch (e) {
      return parentTransaction ? parentTransaction._promise(null, (_, reject) => {
        reject(e);
      }) : rejection(e);
    }
    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);
  }
  table(tableName) {
    if (!hasOwn(this._allTables, tableName)) {
      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);
    }
    return this._allTables[tableName];
  }
};
var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
var Observable = class {
  constructor(subscribe) {
    this._subscribe = subscribe;
  }
  subscribe(x, error, complete) {
    return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
  }
  [symbolObservable]() {
    return this;
  }
};
function extendObservabilitySet(target, newSet) {
  keys(newSet).forEach((part) => {
    const rangeSet = target[part] || (target[part] = new RangeSet());
    mergeRanges(rangeSet, newSet[part]);
  });
  return target;
}
function liveQuery(querier) {
  let hasValue = false;
  let currentValue = void 0;
  const observable = new Observable((observer) => {
    const scopeFuncIsAsync = isAsyncFunction(querier);
    function execute(subscr) {
      if (scopeFuncIsAsync) {
        incrementExpectedAwaits();
      }
      const exec = () => newScope(querier, { subscr, trans: null });
      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();
      if (scopeFuncIsAsync) {
        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
      }
      return rv;
    }
    let closed = false;
    let accumMuts = {};
    let currentObs = {};
    const subscription = {
      get closed() {
        return closed;
      },
      unsubscribe: () => {
        closed = true;
        globalEvents.storagemutated.unsubscribe(mutationListener);
      }
    };
    observer.start && observer.start(subscription);
    let querying = false, startedListening = false;
    function shouldNotify() {
      return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));
    }
    const mutationListener = (parts) => {
      extendObservabilitySet(accumMuts, parts);
      if (shouldNotify()) {
        doQuery();
      }
    };
    const doQuery = () => {
      if (querying || closed)
        return;
      accumMuts = {};
      const subscr = {};
      const ret = execute(subscr);
      if (!startedListening) {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
        startedListening = true;
      }
      querying = true;
      Promise.resolve(ret).then((result) => {
        hasValue = true;
        currentValue = result;
        querying = false;
        if (closed)
          return;
        if (shouldNotify()) {
          doQuery();
        } else {
          accumMuts = {};
          currentObs = subscr;
          observer.next && observer.next(result);
        }
      }, (err) => {
        querying = false;
        hasValue = false;
        observer.error && observer.error(err);
        subscription.unsubscribe();
      });
    };
    doQuery();
    return subscription;
  });
  observable.hasValue = () => hasValue;
  observable.getValue = () => currentValue;
  return observable;
}
var domDeps;
try {
  domDeps = {
    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
  };
} catch (e) {
  domDeps = { indexedDB: null, IDBKeyRange: null };
}
var Dexie = Dexie$1;
props(Dexie, {
  ...fullNameExceptions,
  delete(databaseName) {
    const db = new Dexie(databaseName, { addons: [] });
    return db.delete();
  },
  exists(name) {
    return new Dexie(name, { addons: [] }).open().then((db) => {
      db.close();
      return true;
    }).catch("NoSuchDatabaseError", () => false);
  },
  getDatabaseNames(cb) {
    try {
      return getDatabaseNames(Dexie.dependencies).then(cb);
    } catch (_a2) {
      return rejection(new exceptions.MissingAPI());
    }
  },
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return Class;
  },
  ignoreTransaction(scopeFunc) {
    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
  },
  vip,
  async: function(generatorFn) {
    return function() {
      try {
        var rv = awaitIterator(generatorFn.apply(this, arguments));
        if (!rv || typeof rv.then !== "function")
          return DexiePromise.resolve(rv);
        return rv;
      } catch (e) {
        return rejection(e);
      }
    };
  },
  spawn: function(generatorFn, args, thiz) {
    try {
      var rv = awaitIterator(generatorFn.apply(thiz, args || []));
      if (!rv || typeof rv.then !== "function")
        return DexiePromise.resolve(rv);
      return rv;
    } catch (e) {
      return rejection(e);
    }
  },
  currentTransaction: {
    get: () => PSD.trans || null
  },
  waitFor: function(promiseOrFunction, optionalTimeout) {
    const promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
    return PSD.trans ? PSD.trans.waitFor(promise) : promise;
  },
  Promise: DexiePromise,
  debug: {
    get: () => debug,
    set: (value) => {
      setDebug(value, value === "dexie" ? () => true : dexieStackFrameFilter);
    }
  },
  derive,
  extend,
  props,
  override,
  Events,
  on: globalEvents,
  liveQuery,
  extendObservabilitySet,
  getByKeyPath,
  setByKeyPath,
  delByKeyPath,
  shallowClone,
  deepClone,
  getObjectDiff,
  cmp,
  asap: asap$1,
  minKey,
  addons: [],
  connections,
  errnames,
  dependencies: domDeps,
  semVer: DEXIE_VERSION,
  version: DEXIE_VERSION.split(".").map((n2) => parseInt(n2)).reduce((p2, c3, i) => p2 + c3 / Math.pow(10, i * 2))
});
Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);
if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts) => {
    if (!propagatingLocally) {
      let event;
      if (isIEOrEdge) {
        event = document.createEvent("CustomEvent");
        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
      } else {
        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
          detail: updatedParts
        });
      }
      propagatingLocally = true;
      dispatchEvent(event);
      propagatingLocally = false;
    }
  });
  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {
    if (!propagatingLocally) {
      propagateLocally(detail);
    }
  });
}
function propagateLocally(updateParts) {
  let wasMe = propagatingLocally;
  try {
    propagatingLocally = true;
    globalEvents.storagemutated.fire(updateParts);
  } finally {
    propagatingLocally = wasMe;
  }
}
var propagatingLocally = false;
if (typeof BroadcastChannel !== "undefined") {
  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
  if (typeof bc.unref === "function") {
    bc.unref();
  }
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    if (!propagatingLocally) {
      bc.postMessage(changedParts);
    }
  });
  bc.onmessage = (ev) => {
    if (ev.data)
      propagateLocally(ev.data);
  };
} else if (typeof self !== "undefined" && typeof navigator !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    try {
      if (!propagatingLocally) {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
            trig: Math.random(),
            changedParts
          }));
        }
        if (typeof self["clients"] === "object") {
          [...self["clients"].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({
            type: STORAGE_MUTATED_DOM_EVENT_NAME,
            changedParts
          }));
        }
      }
    } catch (_a2) {
    }
  });
  if (typeof addEventListener !== "undefined") {
    addEventListener("storage", (ev) => {
      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
        const data = JSON.parse(ev.newValue);
        if (data)
          propagateLocally(data.changedParts);
      }
    });
  }
  const swContainer = self.document && navigator.serviceWorker;
  if (swContainer) {
    swContainer.addEventListener("message", propagateMessageLocally);
  }
}
function propagateMessageLocally({ data }) {
  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
    propagateLocally(data.changedParts);
  }
}
DexiePromise.rejectionMapper = mapError;
setDebug(debug, dexieStackFrameFilter);

// node_modules/openbim-components/core/LocalCacher/db.js
var ModelDatabase = class extends Dexie$1 {
  constructor() {
    super("ModelDatabase");
    this.version(2).stores({
      models: "id, file"
    });
  }
};

// node_modules/openbim-components/core/LocalCacher/index.js
var LocalCacher = class _LocalCacher extends Component {
  /** The IDs of all the stored files. */
  get ids() {
    const serialized = localStorage.getItem(this._storedModels) || "[]";
    return JSON.parse(serialized);
  }
  constructor(components) {
    super(components);
    this.onFileLoaded = new Event();
    this.onItemSaved = new Event();
    this.enabled = true;
    this.uiElement = new UIElement();
    this.cards = [];
    this._storedModels = "open-bim-components-stored-files";
    components.tools.add(_LocalCacher.uuid, this);
    this._db = new ModelDatabase();
    if (components.ui.enabled) {
      this.setUI(components);
    }
  }
  /**
   * {@link Component.get}.
   * @param id the ID of the file to fetch.
   */
  async get(id) {
    if (this.exists(id)) {
      await this._db.open();
      const result = await this.getModelFromLocalCache(id);
      this._db.close();
      return result;
    }
    return null;
  }
  /**
   * Saves the file with the given ID.
   * @param id the ID to assign to the file.
   * @param url the URL where the file is located.
   */
  async save(id, url) {
    this.addStoredID(id);
    const rawData = await fetch(url);
    const file = await rawData.blob();
    await this._db.open();
    await this._db.models.add({
      id,
      file
    });
    this._db.close();
  }
  /**
   * Checks if there's a file stored with the given ID.
   * @param id to check.
   */
  exists(id) {
    const stored = localStorage.getItem(id);
    return stored !== null;
  }
  /**
   * Deletes the files stored in the given ids.
   * @param ids the identifiers of the files to delete.
   */
  async delete(ids) {
    await this._db.open();
    for (const id of ids) {
      if (this.exists(id)) {
        this.removeStoredID(id);
        await this._db.models.where("id").equals(id).delete();
      }
    }
    this._db.close();
  }
  /** Deletes all the stored files. */
  async deleteAll() {
    await this._db.open();
    this.clearStoredIDs();
    await this._db.delete();
    this._db = new ModelDatabase();
    this._db.close();
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onFileLoaded.reset();
    this.onItemSaved.reset();
    for (const card of this.cards) {
      await card.dispose();
    }
    this.cards = [];
    await this.uiElement.dispose();
    this._db = null;
  }
  setUI(components) {
    const main2 = new Button(components);
    main2.materialIcon = "storage";
    main2.tooltip = "Local cacher";
    const saveButton = new Button(components);
    saveButton.label = "Save";
    saveButton.materialIcon = "save";
    const loadButton = new Button(components);
    loadButton.label = "Download";
    loadButton.materialIcon = "download";
    main2.addChild(saveButton, loadButton);
    const floatingMenu = new FloatingWindow(components, "file-list-menu");
    this.uiElement.set({ main: main2, loadButton, saveButton, floatingMenu });
    floatingMenu.title = "Saved Files";
    floatingMenu.visible = false;
    const savedFilesMenuHTML = floatingMenu.get();
    savedFilesMenuHTML.style.left = "70px";
    savedFilesMenuHTML.style.top = "100px";
    savedFilesMenuHTML.style.width = "340px";
    savedFilesMenuHTML.style.height = "400px";
    const renderer = this.components.renderer.get();
    const viewerContainer = renderer.domElement.parentElement;
    viewerContainer.appendChild(floatingMenu.get());
  }
  async getModelFromLocalCache(id) {
    const found = await this._db.models.where("id").equals(id).toArray();
    return found[0].file;
  }
  clearStoredIDs() {
    const ids = this.ids;
    for (const id of ids) {
      this.removeStoredID(id);
    }
  }
  removeStoredID(id) {
    localStorage.removeItem(id);
    const allIDs = this.ids;
    const ids = allIDs.filter((savedId) => savedId !== id);
    this.setStoredIDs(ids);
  }
  addStoredID(id) {
    const time = performance.now().toString();
    localStorage.setItem(id, time);
    const ids = this.ids;
    ids.push(id);
    this.setStoredIDs(ids);
  }
  setStoredIDs(ids) {
    localStorage.setItem(this._storedModels, JSON.stringify(ids));
  }
};
LocalCacher.uuid = "22ae591a-3a67-4988-86c6-68d7b83febf2";
ToolComponent.libraryUUIDs.add(LocalCacher.uuid);

// node_modules/openbim-components/core/SimpleSVGViewport/index.js
var SimpleSVGViewport = class extends Component {
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this.resize();
    this._undoList = [];
    this.uiElement.get("toolbar").visible = value;
    if (value) {
      this._viewport.classList.remove("pointer-events-none");
    } else {
      this.clear();
      this.uiElement.get("settingsWindow").visible = false;
      this._viewport.classList.add("pointer-events-none");
    }
  }
  set config(value) {
    this._config = { ...this._config, ...value };
  }
  get config() {
    return this._config;
  }
  constructor(components, config) {
    super(components);
    this.uiElement = new UIElement();
    this.id = generateUUID().toLowerCase();
    this._enabled = false;
    this._viewport = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this._size = new Vector2();
    this._undoList = [];
    this.onResize = () => {
      this.resize();
    };
    const defaultConfig = {
      fillColor: "transparent",
      strokeColor: "#ff0000",
      strokeWidth: 4
    };
    this.config = { ...defaultConfig, ...config !== null && config !== void 0 ? config : {} };
    this._viewport.classList.add("absolute", "top-0", "right-0");
    this._viewport.setAttribute("width", "100%");
    this._viewport.setAttribute("height", "100%");
    this.setUI();
    this.enabled = false;
    this.components.ui.viewerContainer.append(this._viewport);
    this.setupEvents(true);
  }
  async dispose() {
    this._undoList = [];
    this.uiElement.dispose();
  }
  get() {
    return this._viewport;
  }
  clear() {
    const viewport2 = this.get();
    this._undoList = [];
    while (viewport2.firstChild) {
      viewport2.removeChild(viewport2.firstChild);
    }
  }
  getDrawing() {
    return this.get().childNodes;
  }
  //   setDrawing() {
  //         if (!this.enabled) {  }
  //     }
  /** {@link Resizeable.resize}. */
  resize() {
    const renderer = this.components.renderer;
    const rendererSize = renderer.getSize();
    const width = this.enabled ? rendererSize.x : 0;
    const height = this.enabled ? rendererSize.y : 0;
    this._size.set(width, height);
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return this._size;
  }
  setupEvents(active) {
    if (active) {
      window.addEventListener("resize", this.onResize);
    } else {
      window.removeEventListener("resize", this.onResize);
    }
  }
  setUI() {
    var _a2, _b2;
    const undoDrawingBtn = new Button(this.components, {
      materialIconName: "undo"
    });
    undoDrawingBtn.onClick.add(() => {
      if (this._viewport.lastChild) {
        this._undoList.push(this._viewport.lastChild);
        this._viewport.lastChild.remove();
      }
    });
    const redoDrawingBtn = new Button(this.components, {
      materialIconName: "redo"
    });
    redoDrawingBtn.onClick.add(() => {
      const childNode = this._undoList[this._undoList.length - 1];
      if (childNode) {
        this._undoList.pop();
        this._viewport.append(childNode);
      }
    });
    const clearDrawingBtn = new Button(this.components, {
      materialIconName: "delete"
    });
    clearDrawingBtn.onClick.add(() => this.clear());
    const settingsWindow = new FloatingWindow(this.components, this.id);
    settingsWindow.title = "Drawing Settings";
    settingsWindow.visible = false;
    const viewerContainer = this.components.renderer.get().domElement.parentElement;
    viewerContainer.append(settingsWindow.get());
    const strokeWidth = new RangeInput(this.components);
    strokeWidth.label = "Stroke Width";
    strokeWidth.min = 2;
    strokeWidth.max = 6;
    strokeWidth.value = 4;
    strokeWidth.onChange.add((value) => {
      this.config = { strokeWidth: value };
    });
    const strokeColorInput = new ColorInput(this.components);
    strokeColorInput.label = "Stroke Color";
    strokeColorInput.value = (_a2 = this.config.strokeColor) !== null && _a2 !== void 0 ? _a2 : "#BCF124";
    strokeColorInput.onChange.add((value) => {
      this.config = { strokeColor: value };
    });
    const fillColorInput = new ColorInput(this.components);
    strokeColorInput.label = "Fill Color";
    strokeColorInput.value = (_b2 = this.config.fillColor) !== null && _b2 !== void 0 ? _b2 : "#BCF124";
    fillColorInput.onChange.add((value) => {
      this.config = { fillColor: value };
    });
    settingsWindow.addChild(strokeColorInput, fillColorInput, strokeWidth);
    const settingsBtn = new Button(this.components, {
      materialIconName: "settings"
    });
    settingsBtn.onClick.add(() => {
      settingsWindow.visible = !settingsWindow.visible;
      settingsBtn.active = settingsWindow.visible;
    });
    settingsWindow.onHidden.add(() => settingsBtn.active = false);
    const toolbar = new Toolbar(this.components, { position: "right" });
    toolbar.addChild(settingsBtn, undoDrawingBtn, redoDrawingBtn, clearDrawingBtn);
    this.uiElement.set({ toolbar, settingsWindow });
  }
};

// node_modules/openbim-components/core/MaterialManager/index.js
var MaterialManager = class _MaterialManager extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this._originalBackground = null;
    this._originals = {};
    this._list = {};
    this.components.tools.add(_MaterialManager.uuid, this);
  }
  /**
   * {@link Component.get}.
   * @return list of created materials.
   */
  get() {
    return Object.keys(this._list);
  }
  /**
   * Turns the specified material styles on or off.
   *
   * @param active whether to turn it on or off.
   * @param ids the ids of the style to turn on or off.
   */
  set(active, ids = Object.keys(this._list)) {
    for (const id of ids) {
      const { material, meshes } = this._list[id];
      for (const mesh of meshes) {
        if (active) {
          if (!this._originals[mesh.uuid]) {
            this._originals[mesh.uuid] = { material: mesh.material };
          }
          if (mesh instanceof InstancedMesh && mesh.instanceColor) {
            this._originals[mesh.uuid].instances = mesh.instanceColor;
            mesh.instanceColor = null;
          }
          mesh.material = material;
        } else {
          if (!this._originals[mesh.uuid])
            continue;
          mesh.material = this._originals[mesh.uuid].material;
          const instances = this._originals[mesh.uuid].instances;
          if (mesh instanceof InstancedMesh && instances) {
            mesh.instanceColor = instances;
          }
        }
      }
    }
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    for (const id in this._list) {
      const { material } = this._list[id];
      material.dispose();
    }
    this._list = {};
    this._originals = {};
  }
  /**
   * Sets the color of the background of the scene.
   *
   * @param color: the color to apply.
   */
  setBackgroundColor(color2) {
    const scene = this.components.scene.get();
    if (!this._originalBackground) {
      this._originalBackground = scene.background;
    }
    if (this._originalBackground) {
      scene.background = color2;
    }
  }
  /**
   * Resets the scene background to the color that was being used
   * before applying the material manager.
   */
  resetBackgroundColor() {
    const scene = this.components.scene.get();
    if (this._originalBackground) {
      scene.background = this._originalBackground;
    }
  }
  /**
   * Creates a new material style.
   * @param id the identifier of the style to create.
   * @param material the material of the style.
   */
  addMaterial(id, material) {
    if (this._list[id]) {
      throw new Error("This ID already exists!");
    }
    this._list[id] = { material, meshes: /* @__PURE__ */ new Set() };
  }
  /**
   * Assign meshes to a certain style.
   * @param id the identifier of the style.
   * @param meshes the meshes to assign to the style.
   */
  addMeshes(id, meshes) {
    if (!this._list[id]) {
      throw new Error("This ID doesn't exists!");
    }
    for (const mesh of meshes) {
      this._list[id].meshes.add(mesh);
    }
  }
};
MaterialManager.uuid = "24989d27-fa2f-4797-8b08-35918f74e502";
ToolComponent.libraryUUIDs.add(MaterialManager.uuid);

// node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent2 = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var OrbitControls = class extends EventDispatcher {
  constructor(object, domElement) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = null;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent2);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset2 = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update() {
        const position = scope.object.position;
        offset2.copy(position).sub(scope.target);
        offset2.applyQuaternion(quat);
        spherical.setFromVector3(offset2);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min2 = scope.minAzimuthAngle;
        let max2 = scope.maxAzimuthAngle;
        if (isFinite(min2) && isFinite(max2)) {
          if (min2 < -Math.PI)
            min2 += twoPI;
          else if (min2 > Math.PI)
            min2 -= twoPI;
          if (max2 < -Math.PI)
            max2 += twoPI;
          else if (max2 > Math.PI)
            max2 -= twoPI;
          if (min2 <= max2) {
            spherical.theta = Math.max(min2, Math.min(max2, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min2 + max2) / 2 ? Math.max(min2, spherical.theta) : Math.min(max2, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset2.setFromSpherical(spherical);
        offset2.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset2);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(_changeEvent2);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown2);
      scope.domElement.removeEventListener("pointercancel", onPointerUp2);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove2);
      scope.domElement.removeEventListener("pointerup", onPointerUp2);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        scope._domElementKeyEvents = null;
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = function() {
      const v3 = new Vector3();
      return function panLeft2(distance, objectMatrix) {
        v3.setFromMatrixColumn(objectMatrix, 0);
        v3.multiplyScalar(-distance);
        panOffset.add(v3);
      };
    }();
    const panUp = function() {
      const v3 = new Vector3();
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v3.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v3.setFromMatrixColumn(objectMatrix, 0);
          v3.crossVectors(scope.object.up, v3);
        }
        v3.multiplyScalar(distance);
        panOffset.add(v3);
      };
    }();
    const pan = function() {
      const offset2 = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset2.copy(position).sub(scope.target);
          let targetDistance = offset2.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, -scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(-scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown2(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove2);
        scope.domElement.addEventListener("pointerup", onPointerUp2);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove2(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp2(event) {
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove2);
        scope.domElement.removeEventListener("pointerup", onPointerUp2);
      }
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i].pointerId == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown2);
    scope.domElement.addEventListener("pointercancel", onPointerUp2);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
};

// node_modules/openbim-components/core/Simple2DScene/index.js
var Simple2DScene = class extends Component {
  constructor(components) {
    super(components);
    this.onAfterUpdate = new Event();
    this.onBeforeUpdate = new Event();
    this.onResize = new Event();
    this.enabled = true;
    this.uiElement = new UIElement();
    this._frustumSize = 50;
    this.resize = () => {
      const parent2 = this.uiElement.get("canvas").parent;
      if (!parent2)
        return;
      const { clientWidth, clientHeight } = parent2.domElement;
      this._size.width = clientWidth;
      this._size.height = clientHeight;
      const { width: width2, height: height2 } = this._size;
      const aspect = width2 / height2;
      this._camera.left = -this._frustumSize * aspect / 2;
      this._camera.right = this._frustumSize * aspect / 2;
      this._camera.top = this._frustumSize / 2;
      this._camera.bottom = -this._frustumSize / 2;
      this._camera.updateProjectionMatrix();
      this._camera.updateProjectionMatrix();
      this._renderer.setSize(this._size.width, this._size.height);
    };
    if (!components.ui.enabled) {
      throw new Error("The Simple2DScene component needs to use UI elements (TODO: Decouple from them).");
    }
    const canvas = new Canvas(components);
    canvas.domElement.classList.remove("absolute");
    const mainWindow = new FloatingWindow(components);
    components.ui.add(mainWindow);
    mainWindow.visible = false;
    mainWindow.domElement.style.height = "20rem";
    mainWindow.addChild(canvas);
    const main2 = new Button(components);
    main2.materialIcon = "fact_check";
    main2.tooltip = "2D scene";
    main2.onClick.add(() => {
      mainWindow.visible = !mainWindow.visible;
    });
    this.uiElement.set({ mainWindow, main: main2, canvas });
    this._scene = new Scene();
    this._size = {
      width: mainWindow.domElement.clientWidth,
      height: mainWindow.domElement.clientHeight
    };
    const { width, height } = this._size;
    this._camera = new OrthographicCamera(75, width / height);
    this._camera.position.z = 10;
    this._renderer = new WebGLRenderer({ canvas: canvas.get() });
    this._renderer.setSize(width, height);
    this._renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.controls = new OrbitControls(this._camera, this._renderer.domElement);
    this.controls.target.set(0, 0, 0);
    this.controls.enableRotate = false;
    this.controls.enableZoom = true;
    const parent = this.uiElement.get("canvas").parent;
    if (parent) {
      parent.domElement.classList.remove("p-4");
      parent.domElement.classList.remove("overflow-auto");
      parent.domElement.classList.add("overflow-hidden");
      parent.domElement.classList.add("h-full");
    }
    mainWindow.onResized.add(this.resize);
    mainWindow.domElement.style.width = "20rem";
    mainWindow.domElement.style.height = "20rem";
  }
  /**
   * {@link Component.get}
   * @returns the 2D scene.
   */
  get() {
    return this._scene;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this._renderer.dispose();
    await this.uiElement.dispose();
  }
  /** {@link Updateable.update} */
  async update() {
    await this.onBeforeUpdate.trigger();
    this.controls.update();
    this._renderer.render(this._scene, this._camera);
    await this.onAfterUpdate.trigger();
  }
  /** {@link Resizeable.getSize} */
  getSize() {
    return new Vector2(this._size.width, this._size.height);
  }
};
Simple2DScene.uuid = "b48b7194-0f9a-43a4-a718-270b1522595f";

// node_modules/openbim-components/fragments/FragmentManager/index.js
var FragmentManager = class _FragmentManager extends Component {
  /** The list of meshes of the created fragments. */
  get meshes() {
    const allMeshes = [];
    for (const fragID in this.list) {
      allMeshes.push(this.list[fragID].mesh);
    }
    return allMeshes;
  }
  constructor(components) {
    super(components);
    this.enabled = true;
    this.list = {};
    this.groups = [];
    this.baseCoordinationModel = "";
    this.onFragmentsLoaded = new Event();
    this.uiElement = new UIElement();
    this.commands = [];
    this._loader = new Serializer();
    this._cards = [];
    this.components.tools.add(_FragmentManager.uuid, this);
    if (components.ui.enabled) {
      this.setupUI(components);
    }
  }
  /** {@link Component.get} */
  get() {
    return Object.values(this.list);
  }
  /** {@link Component.get} */
  async dispose(disposeUI = false) {
    if (disposeUI) {
      this.onFragmentsLoaded.reset();
      this.uiElement.dispose();
    }
    for (const group of this.groups) {
      group.dispose(true);
    }
    for (const command of this.commands) {
      await command.dispose();
    }
    for (const card of this._cards) {
      await card.dispose();
    }
    this.groups = [];
    this.list = {};
  }
  async disposeGroup(group) {
    for (const fragment of group.items) {
      this.removeFragmentMesh(fragment);
      delete this.list[fragment.id];
    }
    group.dispose(true);
    const index = this.groups.indexOf(group);
    this.groups.splice(index, 1);
    await this.updateWindow();
  }
  /** Disposes all existing fragments */
  reset() {
    for (const id in this.list) {
      const fragment = this.list[id];
      fragment.dispose();
    }
    this.list = {};
  }
  /**
   * Loads one or many fragments into the scene.
   * @param data - the bytes containing the data for the fragments to load.
   * @returns the list of IDs of the loaded fragments.
   */
  async load(data) {
    const group = this._loader.import(data);
    const scene = this.components.scene.get();
    const ids = [];
    scene.add(group);
    for (const fragment of group.items) {
      fragment.group = group;
      this.list[fragment.id] = fragment;
      ids.push(fragment.id);
      this.components.meshes.push(fragment.mesh);
    }
    this.groups.push(group);
    await this.onFragmentsLoaded.trigger(group);
    return group;
  }
  /**
   * Export the specified fragments.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(group) {
    return this._loader.export(group);
  }
  async updateWindow() {
    if (!this.components.ui.enabled) {
      return;
    }
    for (const card of this._cards) {
      await card.dispose();
    }
    for (const group of this.groups) {
      const card = new SimpleUICard(this.components);
      card.domElement.classList.remove("bg-ifcjs-120");
      card.domElement.classList.remove("border-transparent");
      card.domElement.className += ` min-w-[300px] my-2 border-1 border-solid border-[#3A444E] `;
      const buttonContainer = new SimpleUIComponent(this.components);
      card.addChild(buttonContainer);
      card.title = group.name;
      this.uiElement.get("window").addChild(card);
      this._cards.push(card);
      const commandsButton = new Button(this.components);
      commandsButton.materialIcon = "delete";
      buttonContainer.addChild(commandsButton);
      commandsButton.onClick.add(() => this.disposeGroup(group));
    }
  }
  coordinate(models = this.groups) {
    const baseModel = this.groups.find((group) => group.uuid === this.baseCoordinationModel);
    if (!baseModel) {
      console.log("No base model found for coordination!");
      return;
    }
    for (const model of models) {
      if (model === baseModel) {
        continue;
      }
      model.position.set(0, 0, 0);
      model.rotation.set(0, 0, 0);
      model.scale.set(1, 1, 1);
      model.updateMatrix();
      model.applyMatrix4(model.coordinationMatrix.clone().invert());
      model.applyMatrix4(baseModel.coordinationMatrix);
    }
  }
  setupUI(components) {
    const window2 = new FloatingWindow(components);
    window2.title = "Models";
    window2.domElement.style.left = "70px";
    window2.domElement.style.top = "100px";
    window2.domElement.style.width = "340px";
    window2.domElement.style.height = "400px";
    const windowContent = window2.slots.content.domElement;
    windowContent.classList.remove("overflow-auto");
    windowContent.classList.add("overflow-x-hidden");
    components.ui.add(window2);
    window2.visible = false;
    const main2 = new Button(components);
    main2.tooltip = "Models";
    main2.materialIcon = "inbox";
    main2.onClick.add(() => {
      window2.visible = !window2.visible;
    });
    this.uiElement.set({ main: main2, window: window2 });
    this.onFragmentsLoaded.add(() => this.updateWindow());
  }
  removeFragmentMesh(fragment) {
    const meshes = this.components.meshes;
    const mesh = fragment.mesh;
    if (meshes.includes(mesh)) {
      meshes.splice(meshes.indexOf(mesh), 1);
    }
  }
};
FragmentManager.uuid = "fef46874-46a3-461b-8c44-2922ab77c806";
ToolComponent.libraryUUIDs.add(FragmentManager.uuid);

// node_modules/openbim-components/ifc/ifc-elements-map.js
var IfcElements = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};

// node_modules/openbim-components/ifc/ifc-categories.js
var IfcCategories = class {
  getAll(webIfc, modelID) {
    const elementsCategories = {};
    const categoriesIDs = Object.keys(IfcElements).map((e) => parseInt(e, 10));
    for (let i = 0; i < categoriesIDs.length; i++) {
      const element = categoriesIDs[i];
      const lines = webIfc.GetLineIDsWithType(modelID, element);
      const size = lines.size();
      for (let i2 = 0; i2 < size; i2++) {
        elementsCategories[lines.get(i2)] = element;
      }
    }
    return elementsCategories;
  }
};

// node_modules/openbim-components/ifc/ifc-category-map.js
var IfcCategoryMap = {
  3821786052: "IFCACTIONREQUEST",
  2296667514: "IFCACTOR",
  3630933823: "IFCACTORROLE",
  4288193352: "IFCACTUATOR",
  2874132201: "IFCACTUATORTYPE",
  618182010: "IFCADDRESS",
  1635779807: "IFCADVANCEDBREP",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  3406155212: "IFCADVANCEDFACE",
  1634111441: "IFCAIRTERMINAL",
  177149247: "IFCAIRTERMINALBOX",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3087945054: "IFCALARM",
  3001207471: "IFCALARMTYPE",
  325726236: "IFCALIGNMENT",
  749761778: "IFCALIGNMENT2DHORIZONTAL",
  3199563722: "IFCALIGNMENT2DHORIZONTALSEGMENT",
  2483840362: "IFCALIGNMENT2DSEGMENT",
  3379348081: "IFCALIGNMENT2DVERSEGCIRCULARARC",
  3239324667: "IFCALIGNMENT2DVERSEGLINE",
  4263986512: "IFCALIGNMENT2DVERSEGPARABOLICARC",
  53199957: "IFCALIGNMENT2DVERTICAL",
  2029264950: "IFCALIGNMENT2DVERTICALSEGMENT",
  3512275521: "IFCALIGNMENTCURVE",
  1674181508: "IFCANNOTATION",
  669184980: "IFCANNOTATIONFILLAREA",
  639542469: "IFCAPPLICATION",
  411424972: "IFCAPPLIEDVALUE",
  130549933: "IFCAPPROVAL",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  3460190687: "IFCASSET",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4261334040: "IFCAXIS1PLACEMENT",
  3125803723: "IFCAXIS2PLACEMENT2D",
  2740243338: "IFCAXIS2PLACEMENT3D",
  1967976161: "IFCBSPLINECURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  753842376: "IFCBEAM",
  2906023776: "IFCBEAMSTANDARDCASE",
  819618141: "IFCBEAMTYPE",
  4196446775: "IFCBEARING",
  3649138523: "IFCBEARINGTYPE",
  616511568: "IFCBLOBTEXTURE",
  1334484129: "IFCBLOCK",
  32344328: "IFCBOILER",
  231477066: "IFCBOILERTYPE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  2736907675: "IFCBOOLEANRESULT",
  4037036970: "IFCBOUNDARYCONDITION",
  1136057603: "IFCBOUNDARYCURVE",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1387855156: "IFCBOUNDARYNODECONDITION",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1260505505: "IFCBOUNDEDCURVE",
  4182860854: "IFCBOUNDEDSURFACE",
  2581212453: "IFCBOUNDINGBOX",
  2713105998: "IFCBOXEDHALFSPACE",
  644574406: "IFCBRIDGE",
  963979645: "IFCBRIDGEPART",
  4031249490: "IFCBUILDING",
  3299480353: "IFCBUILDINGELEMENT",
  2979338954: "IFCBUILDINGELEMENTPART",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  3124254112: "IFCBUILDINGSTOREY",
  1177604601: "IFCBUILDINGSYSTEM",
  2938176219: "IFCBURNER",
  2188180465: "IFCBURNERTYPE",
  2898889636: "IFCCSHAPEPROFILEDEF",
  635142910: "IFCCABLECARRIERFITTING",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  1051757585: "IFCCABLEFITTING",
  2674252688: "IFCCABLEFITTINGTYPE",
  4217484030: "IFCCABLESEGMENT",
  1285652485: "IFCCABLESEGMENTTYPE",
  3999819293: "IFCCAISSONFOUNDATION",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  1123145078: "IFCCARTESIANPOINT",
  574549367: "IFCCARTESIANPOINTLIST",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  3902619387: "IFCCHILLER",
  2951183804: "IFCCHILLERTYPE",
  3296154744: "IFCCHIMNEY",
  2197970202: "IFCCHIMNEYTYPE",
  2611217952: "IFCCIRCLE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1062206242: "IFCCIRCULARARCSEGMENT2D",
  1677625105: "IFCCIVILELEMENT",
  3893394355: "IFCCIVILELEMENTTYPE",
  747523909: "IFCCLASSIFICATION",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  2205249479: "IFCCLOSEDSHELL",
  639361253: "IFCCOIL",
  2301859152: "IFCCOILTYPE",
  776857604: "IFCCOLOURRGB",
  3285139300: "IFCCOLOURRGBLIST",
  3264961684: "IFCCOLOURSPECIFICATION",
  843113511: "IFCCOLUMN",
  905975707: "IFCCOLUMNSTANDARDCASE",
  300633059: "IFCCOLUMNTYPE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  2542286263: "IFCCOMPLEXPROPERTY",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3732776249: "IFCCOMPOSITECURVE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  3571504051: "IFCCOMPRESSOR",
  3850581409: "IFCCOMPRESSORTYPE",
  2272882330: "IFCCONDENSER",
  2816379211: "IFCCONDENSERTYPE",
  2510884976: "IFCCONIC",
  370225590: "IFCCONNECTEDFACESET",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  1959218052: "IFCCONSTRAINT",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  3293443760: "IFCCONTROL",
  25142252: "IFCCONTROLLER",
  578613899: "IFCCONTROLLERTYPE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  4136498852: "IFCCOOLEDBEAM",
  335055490: "IFCCOOLEDBEAMTYPE",
  3640358203: "IFCCOOLINGTOWER",
  2954562838: "IFCCOOLINGTOWERTYPE",
  1785450214: "IFCCOORDINATEOPERATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  3895139033: "IFCCOSTITEM",
  1419761937: "IFCCOSTSCHEDULE",
  602808272: "IFCCOSTVALUE",
  1973544240: "IFCCOVERING",
  1916426348: "IFCCOVERINGTYPE",
  3295246426: "IFCCREWRESOURCE",
  1815067380: "IFCCREWRESOURCETYPE",
  2506170314: "IFCCSGPRIMITIVE3D",
  2147822146: "IFCCSGSOLID",
  539742890: "IFCCURRENCYRELATIONSHIP",
  3495092785: "IFCCURTAINWALL",
  1457835157: "IFCCURTAINWALLTYPE",
  2601014836: "IFCCURVE",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1186437898: "IFCCURVESEGMENT2D",
  3800577675: "IFCCURVESTYLE",
  1105321065: "IFCCURVESTYLEFONT",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  1213902940: "IFCCYLINDRICALSURFACE",
  4074379575: "IFCDAMPER",
  3961806047: "IFCDAMPERTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  3632507154: "IFCDERIVEDPROFILEDEF",
  1765591967: "IFCDERIVEDUNIT",
  1045800335: "IFCDERIVEDUNITELEMENT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  32440307: "IFCDIRECTION",
  1335981549: "IFCDISCRETEACCESSORY",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1945343521: "IFCDISTANCEEXPRESSION",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3041715199: "IFCDISTRIBUTIONPORT",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  1154170062: "IFCDOCUMENTINFORMATION",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  3732053477: "IFCDOCUMENTREFERENCE",
  395920057: "IFCDOOR",
  2963535650: "IFCDOORLININGPROPERTIES",
  1714330368: "IFCDOORPANELPROPERTIES",
  3242481149: "IFCDOORSTANDARDCASE",
  526551008: "IFCDOORSTYLE",
  2323601079: "IFCDOORTYPE",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  342316401: "IFCDUCTFITTING",
  869906466: "IFCDUCTFITTINGTYPE",
  3518393246: "IFCDUCTSEGMENT",
  3760055223: "IFCDUCTSEGMENTTYPE",
  1360408905: "IFCDUCTSILENCER",
  2030761528: "IFCDUCTSILENCERTYPE",
  3900360178: "IFCEDGE",
  476780140: "IFCEDGECURVE",
  1472233963: "IFCEDGELOOP",
  1904799276: "IFCELECTRICAPPLIANCE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  264262732: "IFCELECTRICGENERATOR",
  1534661035: "IFCELECTRICGENERATORTYPE",
  402227799: "IFCELECTRICMOTOR",
  1217240411: "IFCELECTRICMOTORTYPE",
  1003880860: "IFCELECTRICTIMECONTROL",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1758889154: "IFCELEMENT",
  4123344466: "IFCELEMENTASSEMBLY",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  339256511: "IFCELEMENTTYPE",
  2777663545: "IFCELEMENTARYSURFACE",
  1704287377: "IFCELLIPSE",
  2835456948: "IFCELLIPSEPROFILEDEF",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  2814081492: "IFCENGINE",
  132023988: "IFCENGINETYPE",
  3747195512: "IFCEVAPORATIVECOOLER",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  484807127: "IFCEVAPORATOR",
  3390157468: "IFCEVAPORATORTYPE",
  4148101412: "IFCEVENT",
  211053100: "IFCEVENTTIME",
  4024345920: "IFCEVENTTYPE",
  297599258: "IFCEXTENDEDPROPERTIES",
  4294318154: "IFCEXTERNALINFORMATION",
  3200245327: "IFCEXTERNALREFERENCE",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  477187591: "IFCEXTRUDEDAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  2556980723: "IFCFACE",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  1809719519: "IFCFACEBOUND",
  803316827: "IFCFACEOUTERBOUND",
  3008276851: "IFCFACESURFACE",
  807026263: "IFCFACETEDBREP",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  24185140: "IFCFACILITY",
  1310830890: "IFCFACILITYPART",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3415622556: "IFCFAN",
  346874300: "IFCFANTYPE",
  647756555: "IFCFASTENER",
  2489546625: "IFCFASTENERTYPE",
  2827207264: "IFCFEATUREELEMENT",
  2143335405: "IFCFEATUREELEMENTADDITION",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  738692330: "IFCFILLAREASTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  315944413: "IFCFILLAREASTYLETILES",
  819412036: "IFCFILTER",
  1810631287: "IFCFILTERTYPE",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2058353004: "IFCFLOWCONTROLLER",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  4278956645: "IFCFLOWFITTING",
  3198132628: "IFCFLOWFITTINGTYPE",
  182646315: "IFCFLOWINSTRUMENT",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  2188021234: "IFCFLOWMETER",
  3815607619: "IFCFLOWMETERTYPE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  987401354: "IFCFLOWSEGMENT",
  1834744321: "IFCFLOWSEGMENTTYPE",
  707683696: "IFCFLOWSTORAGEDEVICE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  2223149337: "IFCFLOWTERMINAL",
  2297155007: "IFCFLOWTERMINALTYPE",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  900683007: "IFCFOOTING",
  1893162501: "IFCFOOTINGTYPE",
  263784265: "IFCFURNISHINGELEMENT",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  1509553395: "IFCFURNITURE",
  1268542332: "IFCFURNITURETYPE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  987898635: "IFCGEOMETRICCURVESET",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  3590301190: "IFCGEOMETRICSET",
  3009204131: "IFCGRID",
  852622518: "IFCGRIDAXIS",
  178086475: "IFCGRIDPLACEMENT",
  2706460486: "IFCGROUP",
  812098782: "IFCHALFSPACESOLID",
  3319311131: "IFCHEATEXCHANGER",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2068733104: "IFCHUMIDIFIER",
  1806887404: "IFCHUMIDIFIERTYPE",
  1484403080: "IFCISHAPEPROFILEDEF",
  3905492369: "IFCIMAGETEXTURE",
  3570813810: "IFCINDEXEDCOLOURMAP",
  2571569899: "IFCINDEXEDPOLYCURVE",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  4175244083: "IFCINTERCEPTOR",
  3946677679: "IFCINTERCEPTORTYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  2391368822: "IFCINVENTORY",
  3741457305: "IFCIRREGULARTIMESERIES",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  2176052936: "IFCJUNCTIONBOX",
  4288270099: "IFCJUNCTIONBOXTYPE",
  572779678: "IFCLSHAPEPROFILEDEF",
  3827777499: "IFCLABORRESOURCE",
  428585644: "IFCLABORRESOURCETYPE",
  1585845231: "IFCLAGTIME",
  76236018: "IFCLAMP",
  1051575348: "IFCLAMPTYPE",
  2655187982: "IFCLIBRARYINFORMATION",
  3452421091: "IFCLIBRARYREFERENCE",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  629592764: "IFCLIGHTFIXTURE",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  1402838566: "IFCLIGHTSOURCE",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  3422422726: "IFCLIGHTSOURCESPOT",
  1281925730: "IFCLINE",
  3092502836: "IFCLINESEGMENT2D",
  388784114: "IFCLINEARPLACEMENT",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2624227202: "IFCLOCALPLACEMENT",
  1008929658: "IFCLOOP",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  3057273783: "IFCMAPCONVERSION",
  2347385850: "IFCMAPPEDITEM",
  1838606355: "IFCMATERIAL",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  3708119e3: "IFCMATERIALCONSTITUENT",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  760658860: "IFCMATERIALDEFINITION",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  248100487: "IFCMATERIALLAYER",
  3303938423: "IFCMATERIALLAYERSET",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  2199411900: "IFCMATERIALLIST",
  2235152071: "IFCMATERIALPROFILE",
  164193824: "IFCMATERIALPROFILESET",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  3265635763: "IFCMATERIALPROPERTIES",
  853536259: "IFCMATERIALRELATIONSHIP",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  2597039031: "IFCMEASUREWITHUNIT",
  377706215: "IFCMECHANICALFASTENER",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  1437502449: "IFCMEDICALDEVICE",
  1114901282: "IFCMEDICALDEVICETYPE",
  1073191201: "IFCMEMBER",
  1911478936: "IFCMEMBERSTANDARDCASE",
  3181161470: "IFCMEMBERTYPE",
  3368373690: "IFCMETRIC",
  2998442950: "IFCMIRROREDPROFILEDEF",
  2706619895: "IFCMONETARYUNIT",
  2474470126: "IFCMOTORCONNECTION",
  977012517: "IFCMOTORCONNECTIONTYPE",
  1918398963: "IFCNAMEDUNIT",
  3888040117: "IFCOBJECT",
  219451334: "IFCOBJECTDEFINITION",
  3701648758: "IFCOBJECTPLACEMENT",
  2251480897: "IFCOBJECTIVE",
  4143007308: "IFCOCCUPANT",
  590820931: "IFCOFFSETCURVE",
  3388369263: "IFCOFFSETCURVE2D",
  3505215534: "IFCOFFSETCURVE3D",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  2665983363: "IFCOPENSHELL",
  3588315303: "IFCOPENINGELEMENT",
  3079942009: "IFCOPENINGSTANDARDCASE",
  4251960020: "IFCORGANIZATION",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  643959842: "IFCORIENTATIONEXPRESSION",
  1029017970: "IFCORIENTEDEDGE",
  144952367: "IFCOUTERBOUNDARYCURVE",
  3694346114: "IFCOUTLET",
  2837617999: "IFCOUTLETTYPE",
  1207048766: "IFCOWNERHISTORY",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  2519244187: "IFCPATH",
  1682466193: "IFCPCURVE",
  2382730787: "IFCPERFORMANCEHISTORY",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3327091369: "IFCPERMIT",
  2077209135: "IFCPERSON",
  101040310: "IFCPERSONANDORGANIZATION",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  1687234759: "IFCPILE",
  1158309216: "IFCPILETYPE",
  310824031: "IFCPIPEFITTING",
  804291784: "IFCPIPEFITTINGTYPE",
  3612865200: "IFCPIPESEGMENT",
  4231323485: "IFCPIPESEGMENTTYPE",
  597895409: "IFCPIXELTEXTURE",
  2004835150: "IFCPLACEMENT",
  603570806: "IFCPLANARBOX",
  1663979128: "IFCPLANAREXTENT",
  220341763: "IFCPLANE",
  3171933400: "IFCPLATE",
  1156407060: "IFCPLATESTANDARDCASE",
  4017108033: "IFCPLATETYPE",
  2067069095: "IFCPOINT",
  4022376103: "IFCPOINTONCURVE",
  1423911732: "IFCPOINTONSURFACE",
  2924175390: "IFCPOLYLOOP",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2839578677: "IFCPOLYGONALFACESET",
  3724593414: "IFCPOLYLINE",
  3740093272: "IFCPORT",
  1946335990: "IFCPOSITIONINGELEMENT",
  3355820592: "IFCPOSTALADDRESS",
  759155922: "IFCPREDEFINEDCOLOUR",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  3727388367: "IFCPREDEFINEDITEM",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  677532197: "IFCPRESENTATIONITEM",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  3119450353: "IFCPRESENTATIONSTYLE",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  2744685151: "IFCPROCEDURE",
  569719735: "IFCPROCEDURETYPE",
  2945172077: "IFCPROCESS",
  4208778838: "IFCPRODUCT",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  2095639259: "IFCPRODUCTREPRESENTATION",
  3958567839: "IFCPROFILEDEF",
  2802850158: "IFCPROFILEPROPERTIES",
  103090709: "IFCPROJECT",
  653396225: "IFCPROJECTLIBRARY",
  2904328755: "IFCPROJECTORDER",
  3843373140: "IFCPROJECTEDCRS",
  3651124850: "IFCPROJECTIONELEMENT",
  2598011224: "IFCPROPERTY",
  986844984: "IFCPROPERTYABSTRACTION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  3710013099: "IFCPROPERTYENUMERATION",
  2752243245: "IFCPROPERTYLISTVALUE",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  1451395588: "IFCPROPERTYSET",
  3357820518: "IFCPROPERTYSETDEFINITION",
  492091185: "IFCPROPERTYSETTEMPLATE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  110355661: "IFCPROPERTYTABLEVALUE",
  3521284610: "IFCPROPERTYTEMPLATE",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  738039164: "IFCPROTECTIVEDEVICE",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3219374653: "IFCPROXY",
  90941305: "IFCPUMP",
  2250791053: "IFCPUMPTYPE",
  2044713172: "IFCQUANTITYAREA",
  2093928680: "IFCQUANTITYCOUNT",
  931644368: "IFCQUANTITYLENGTH",
  2090586900: "IFCQUANTITYSET",
  3252649465: "IFCQUANTITYTIME",
  2405470396: "IFCQUANTITYVOLUME",
  825690147: "IFCQUANTITYWEIGHT",
  2262370178: "IFCRAILING",
  2893384427: "IFCRAILINGTYPE",
  3024970846: "IFCRAMP",
  3283111854: "IFCRAMPFLIGHT",
  2324767716: "IFCRAMPFLIGHTTYPE",
  1469900589: "IFCRAMPTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  2798486643: "IFCRECTANGULARPYRAMID",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  3915482550: "IFCRECURRENCEPATTERN",
  2433181523: "IFCREFERENCE",
  4021432810: "IFCREFERENT",
  3413951693: "IFCREGULARTIMESERIES",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  979691226: "IFCREINFORCINGBAR",
  2572171363: "IFCREINFORCINGBARTYPE",
  3027567501: "IFCREINFORCINGELEMENT",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  2320036040: "IFCREINFORCINGMESH",
  2310774935: "IFCREINFORCINGMESHTYPE",
  160246688: "IFCRELAGGREGATES",
  3939117080: "IFCRELASSIGNS",
  1683148259: "IFCRELASSIGNSTOACTOR",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1307041759: "IFCRELASSIGNSTOGROUP",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  205026976: "IFCRELASSIGNSTORESOURCE",
  1865459582: "IFCRELASSOCIATES",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  826625072: "IFCRELCONNECTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3190031847: "IFCRELCONNECTSPORTS",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  2802773753: "IFCRELCOVERSSPACES",
  2565941209: "IFCRELDECLARES",
  2551354335: "IFCRELDECOMPOSES",
  693640335: "IFCRELDEFINES",
  1462361463: "IFCRELDEFINESBYOBJECT",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  781010003: "IFCRELDEFINESBYTYPE",
  3940055652: "IFCRELFILLSELEMENT",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  427948657: "IFCRELINTERFERESELEMENTS",
  3268803585: "IFCRELNESTS",
  1441486842: "IFCRELPOSITIONS",
  750771296: "IFCRELPROJECTSELEMENT",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  4122056220: "IFCRELSEQUENCE",
  366585022: "IFCRELSERVICESBUILDINGS",
  3451746338: "IFCRELSPACEBOUNDARY",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  1401173127: "IFCRELVOIDSELEMENT",
  478536968: "IFCRELATIONSHIP",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1076942058: "IFCREPRESENTATION",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  3008791417: "IFCREPRESENTATIONITEM",
  1660063152: "IFCREPRESENTATIONMAP",
  2914609552: "IFCRESOURCE",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  1042787934: "IFCRESOURCETIME",
  1856042241: "IFCREVOLVEDAREASOLID",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  4158566097: "IFCRIGHTCIRCULARCONE",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  2016517767: "IFCROOF",
  2781568857: "IFCROOFTYPE",
  2341007311: "IFCROOT",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  448429030: "IFCSIUNIT",
  3053780830: "IFCSANITARYTERMINAL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  1054537805: "IFCSCHEDULINGTIME",
  2157484638: "IFCSEAMCURVE",
  2042790032: "IFCSECTIONPROPERTIES",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  1862484736: "IFCSECTIONEDSOLID",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1509187699: "IFCSECTIONEDSPINE",
  4086658281: "IFCSENSOR",
  1783015770: "IFCSENSORTYPE",
  1329646415: "IFCSHADINGDEVICE",
  4074543187: "IFCSHADINGDEVICETYPE",
  867548509: "IFCSHAPEASPECT",
  3982875396: "IFCSHAPEMODEL",
  4240577450: "IFCSHAPEREPRESENTATION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  3692461612: "IFCSIMPLEPROPERTY",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  4097777520: "IFCSITE",
  1529196076: "IFCSLAB",
  3127900445: "IFCSLABELEMENTEDCASE",
  3027962421: "IFCSLABSTANDARDCASE",
  2533589738: "IFCSLABTYPE",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  3420628829: "IFCSOLARDEVICE",
  1072016465: "IFCSOLARDEVICETYPE",
  723233188: "IFCSOLIDMODEL",
  3856911033: "IFCSPACE",
  1999602285: "IFCSPACEHEATER",
  1305183839: "IFCSPACEHEATERTYPE",
  3812236995: "IFCSPACETYPE",
  1412071761: "IFCSPATIALELEMENT",
  710998568: "IFCSPATIALELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  463610769: "IFCSPATIALZONE",
  2481509218: "IFCSPATIALZONETYPE",
  451544542: "IFCSPHERE",
  4015995234: "IFCSPHERICALSURFACE",
  1404847402: "IFCSTACKTERMINAL",
  3112655638: "IFCSTACKTERMINALTYPE",
  331165859: "IFCSTAIR",
  4252922144: "IFCSTAIRFLIGHT",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  338393293: "IFCSTAIRTYPE",
  682877961: "IFCSTRUCTURALACTION",
  3544373492: "IFCSTRUCTURALACTIVITY",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  1179482911: "IFCSTRUCTURALCONNECTION",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  3136571912: "IFCSTRUCTURALITEM",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2162789131: "IFCSTRUCTURALLOAD",
  385403989: "IFCSTRUCTURALLOADCASE",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  530289379: "IFCSTRUCTURALMEMBER",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  3689010777: "IFCSTRUCTURALREACTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  2830218821: "IFCSTYLEMODEL",
  3958052878: "IFCSTYLEDITEM",
  3049322572: "IFCSTYLEDREPRESENTATION",
  148013059: "IFCSUBCONTRACTRESOURCE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  2233826070: "IFCSUBEDGE",
  2513912981: "IFCSURFACE",
  699246055: "IFCSURFACECURVE",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  3101698114: "IFCSURFACEFEATURE",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  1300840506: "IFCSURFACESTYLE",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  1878645084: "IFCSURFACESTYLERENDERING",
  846575682: "IFCSURFACESTYLESHADING",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  626085974: "IFCSURFACETEXTURE",
  2247615214: "IFCSWEPTAREASOLID",
  1260650574: "IFCSWEPTDISKSOLID",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  230924584: "IFCSWEPTSURFACE",
  1162798199: "IFCSWITCHINGDEVICE",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  2254336722: "IFCSYSTEM",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  3071757647: "IFCTSHAPEPROFILEDEF",
  985171141: "IFCTABLE",
  2043862942: "IFCTABLECOLUMN",
  531007025: "IFCTABLEROW",
  812556717: "IFCTANK",
  5716631: "IFCTANKTYPE",
  3473067441: "IFCTASK",
  1549132990: "IFCTASKTIME",
  2771591690: "IFCTASKTIMERECURRING",
  3206491090: "IFCTASKTYPE",
  912023232: "IFCTELECOMADDRESS",
  3824725483: "IFCTENDON",
  2347447852: "IFCTENDONANCHOR",
  3081323446: "IFCTENDONANCHORTYPE",
  3663046924: "IFCTENDONCONDUIT",
  2281632017: "IFCTENDONCONDUITTYPE",
  2415094496: "IFCTENDONTYPE",
  2387106220: "IFCTESSELLATEDFACESET",
  901063453: "IFCTESSELLATEDITEM",
  4282788508: "IFCTEXTLITERAL",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  1447204868: "IFCTEXTSTYLE",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  280115917: "IFCTEXTURECOORDINATE",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  2552916305: "IFCTEXTUREMAP",
  1210645708: "IFCTEXTUREVERTEX",
  3611470254: "IFCTEXTUREVERTEXLIST",
  1199560280: "IFCTIMEPERIOD",
  3101149627: "IFCTIMESERIES",
  581633288: "IFCTIMESERIESVALUE",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1935646853: "IFCTOROIDALSURFACE",
  3825984169: "IFCTRANSFORMER",
  1692211062: "IFCTRANSFORMERTYPE",
  2595432518: "IFCTRANSITIONCURVESEGMENT2D",
  1620046519: "IFCTRANSPORTELEMENT",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  2916149573: "IFCTRIANGULATEDFACESET",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3593883385: "IFCTRIMMEDCURVE",
  3026737570: "IFCTUBEBUNDLE",
  1600972822: "IFCTUBEBUNDLETYPE",
  1628702193: "IFCTYPEOBJECT",
  3736923433: "IFCTYPEPROCESS",
  2347495698: "IFCTYPEPRODUCT",
  3698973494: "IFCTYPERESOURCE",
  427810014: "IFCUSHAPEPROFILEDEF",
  180925521: "IFCUNITASSIGNMENT",
  630975310: "IFCUNITARYCONTROLELEMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  4292641817: "IFCUNITARYEQUIPMENT",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  4207607924: "IFCVALVE",
  728799441: "IFCVALVETYPE",
  1417489154: "IFCVECTOR",
  2799835756: "IFCVERTEX",
  2759199220: "IFCVERTEXLOOP",
  1907098498: "IFCVERTEXPOINT",
  1530820697: "IFCVIBRATIONDAMPER",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  2391383451: "IFCVIBRATIONISOLATOR",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  926996030: "IFCVOIDINGFEATURE",
  2391406946: "IFCWALL",
  4156078855: "IFCWALLELEMENTEDCASE",
  3512223829: "IFCWALLSTANDARDCASE",
  1898987631: "IFCWALLTYPE",
  4237592921: "IFCWASTETERMINAL",
  1133259667: "IFCWASTETERMINALTYPE",
  3304561284: "IFCWINDOW",
  336235671: "IFCWINDOWLININGPROPERTIES",
  512836454: "IFCWINDOWPANELPROPERTIES",
  486154966: "IFCWINDOWSTANDARDCASE",
  1299126871: "IFCWINDOWSTYLE",
  4009809668: "IFCWINDOWTYPE",
  4088093105: "IFCWORKCALENDAR",
  1028945134: "IFCWORKCONTROL",
  4218914973: "IFCWORKPLAN",
  3342526732: "IFCWORKSCHEDULE",
  1236880293: "IFCWORKTIME",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1033361043: "IFCZONE"
};

// node_modules/openbim-components/ifc/IfcJsonExporter/src/ifc-geometry-types.js
var GeometryTypes = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  3940055652,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014
]);

// node_modules/openbim-components/ifc/IfcJsonExporter/index.js
var IfcJsonExporter = class {
  constructor() {
    this.onLoadProgress = new Event();
    this.onPropertiesSerialized = new Event();
    this._progress = 0;
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @webIfc The instance of [web-ifc]{@link https://github.com/ifcjs/web-ifc} to use.
   * @modelID ID of the IFC model whose properties to extract.
   */
  async export(webIfc, modelID) {
    const geometriesIDs = await this.getAllGeometriesIDs(modelID, webIfc);
    let properties = {};
    properties.coordinationMatrix = webIfc.GetCoordinationMatrix(modelID);
    const allLinesIDs = await webIfc.GetAllLines(modelID);
    const linesCount = allLinesIDs.size();
    this._progress = 0.1;
    let counter = 0;
    for (let i = 0; i < linesCount; i++) {
      const id = allLinesIDs.get(i);
      if (!geometriesIDs.has(id)) {
        try {
          properties[id] = await webIfc.GetLine(modelID, id);
        } catch (e) {
          console.log(`Properties of the element ${id} could not be processed`);
        }
        counter++;
      }
      if (this.size !== void 0 && counter > this.size) {
        await this.onPropertiesSerialized.trigger(properties);
        properties = null;
        properties = {};
        counter = 0;
      }
      if (i / linesCount > this._progress) {
        await this.onLoadProgress.trigger({
          progress: i,
          total: linesCount
        });
        this._progress += 0.1;
      }
    }
    await this.onPropertiesSerialized.trigger(properties);
    properties = null;
  }
  async getAllGeometriesIDs(modelID, webIfc) {
    const placementIDs = /* @__PURE__ */ new Set();
    const structures = /* @__PURE__ */ new Set();
    this.getStructure(IFCPROJECT, structures, webIfc);
    this.getStructure(IFCSITE, structures, webIfc);
    this.getStructure(IFCBUILDING, structures, webIfc);
    this.getStructure(IFCBUILDINGSTOREY, structures, webIfc);
    this.getStructure(IFCSPACE, structures, webIfc);
    for (const id of structures) {
      const properties = webIfc.GetLine(0, id);
      const placementRef = properties.ObjectPlacement;
      if (!placementRef || placementRef.value === null) {
        continue;
      }
      const placementID = placementRef.value;
      placementIDs.add(placementID);
      const placementProps = webIfc.GetLine(0, placementID);
      const relPlacementID = placementProps.RelativePlacement;
      if (!relPlacementID || relPlacementID.value === null) {
        continue;
      }
      placementIDs.add(relPlacementID.value);
      const relPlacement = webIfc.GetLine(0, relPlacementID.value);
      const location2 = relPlacement.Location;
      if (location2 && location2.value !== null) {
        placementIDs.add(location2.value);
      }
    }
    const geometriesIDs = /* @__PURE__ */ new Set();
    const geomTypesArray = Array.from(GeometryTypes);
    for (let i = 0; i < geomTypesArray.length; i++) {
      const category = geomTypesArray[i];
      const ids = await webIfc.GetLineIDsWithType(modelID, category);
      const idsSize = ids.size();
      for (let j = 0; j < idsSize; j++) {
        const id = ids.get(j);
        if (placementIDs.has(id)) {
          continue;
        }
        geometriesIDs.add(id);
      }
    }
    return geometriesIDs;
  }
  getStructure(type2, result, webIfc) {
    const found = webIfc.GetLineIDsWithType(0, type2);
    const size = found.size();
    for (let i = 0; i < size; i++) {
      const id = found.get(i);
      result.add(id);
    }
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesUtils/index.js
var IfcPropertiesUtils = class _IfcPropertiesUtils {
  static getUnits(properties) {
    var _a2;
    const { IFCUNITASSIGNMENT: IFCUNITASSIGNMENT2 } = web_ifc_api_exports;
    const allUnits = this.findItemOfType(properties, IFCUNITASSIGNMENT2);
    if (!allUnits)
      return 1;
    for (const unitRef of allUnits.Units) {
      if (unitRef.value === void 0 || unitRef.value === null)
        continue;
      const unit = properties[unitRef.value];
      if (!unit.UnitType || !unit.UnitType.value)
        continue;
      const value = unit.UnitType.value;
      if (value !== "LENGTHUNIT")
        continue;
      let factor = 1;
      let unitValue = 1;
      if (unit.Name.value === "METRE")
        unitValue = 1;
      if (unit.Name.value === "FOOT")
        unitValue = 0.3048;
      if (((_a2 = unit.Prefix) === null || _a2 === void 0 ? void 0 : _a2.value) === "MILLI")
        factor = 1e-3;
      return unitValue * factor;
    }
    return 1;
  }
  static findItemByGuid(properties, guid) {
    var _a2;
    for (const id in properties) {
      const property = properties[id];
      if (((_a2 = property.GlobalId) === null || _a2 === void 0 ? void 0 : _a2.value) === guid) {
        return property;
      }
    }
    return null;
  }
  static findItemOfType(properties, type2) {
    for (const id in properties) {
      const property = properties[id];
      if (property.type === type2) {
        return property;
      }
    }
    return null;
  }
  static getAllItemsOfType(properties, type2) {
    const found = [];
    for (const id in properties) {
      const property = properties[id];
      if (!property)
        continue;
      if (property.type === type2) {
        found.push(property);
      }
    }
    return found;
  }
  static getRelationMap(properties, relationType, onElementsFound) {
    var _a2;
    const defaultCallback = () => {
    };
    const _onElementsFound = onElementsFound !== null && onElementsFound !== void 0 ? onElementsFound : defaultCallback;
    const result = {};
    for (const expressID in properties) {
      const prop = properties[expressID];
      if (prop === void 0) {
        continue;
      }
      const isRelation = prop.type === relationType;
      const relatingKey = Object.keys(prop).find((key) => key.startsWith("Relating"));
      const relatedKey = Object.keys(prop).find((key) => key.startsWith("Related"));
      if (!(isRelation && relatingKey && relatedKey))
        continue;
      const relating = properties[(_a2 = prop[relatingKey]) === null || _a2 === void 0 ? void 0 : _a2.value];
      const related = prop[relatedKey];
      if (relating === void 0 || related === void 0) {
        continue;
      }
      if (!(related && Array.isArray(related)))
        continue;
      const elements = related.map((el) => {
        return el.value;
      });
      _onElementsFound(relating.expressID, elements);
      result[relating.expressID] = elements;
    }
    return result;
  }
  static getQsetQuantities(properties, expressID, onQuantityFound) {
    var _a2;
    const defaultCallback = () => {
    };
    const _onQuantityFound = onQuantityFound !== null && onQuantityFound !== void 0 ? onQuantityFound : defaultCallback;
    const pset = properties[expressID];
    if ((pset === null || pset === void 0 ? void 0 : pset.type) !== IFCELEMENTQUANTITY)
      return null;
    const quantities = (_a2 = pset.Quantities) !== null && _a2 !== void 0 ? _a2 : [{}];
    const qtos = quantities.map((prop) => {
      if (prop.value)
        _onQuantityFound(prop.value);
      return prop.value;
    });
    return qtos.filter((prop) => prop !== null);
  }
  static getPsetProps(properties, expressID, onPropFound) {
    var _a2;
    const defaultCallback = () => {
    };
    const _onPropFound = onPropFound !== null && onPropFound !== void 0 ? onPropFound : defaultCallback;
    const pset = properties[expressID];
    if ((pset === null || pset === void 0 ? void 0 : pset.type) !== IFCPROPERTYSET)
      return null;
    const hasProperties = (_a2 = pset.HasProperties) !== null && _a2 !== void 0 ? _a2 : [{}];
    const props2 = hasProperties.map((prop) => {
      if (prop.value)
        _onPropFound(prop.value);
      return prop.value;
    });
    return props2.filter((prop) => prop !== null);
  }
  static getPsetRel(properties, psetID) {
    const arrayProperties = Object.values(properties);
    if (!properties[psetID])
      return null;
    const rel = arrayProperties.find((data) => {
      var _a2;
      const isRelation = data.type === IFCRELDEFINESBYPROPERTIES;
      const relatesToPset = ((_a2 = data.RelatingPropertyDefinition) === null || _a2 === void 0 ? void 0 : _a2.value) === psetID;
      return isRelation && relatesToPset;
    });
    return rel ? rel.expressID : null;
  }
  static getQsetRel(properties, qsetID) {
    return _IfcPropertiesUtils.getPsetRel(properties, qsetID);
  }
  static getEntityName(properties, entityID) {
    var _a2;
    const entity = properties[entityID];
    const key = (_a2 = Object.keys(entity).find((key2) => key2.endsWith("Name"))) !== null && _a2 !== void 0 ? _a2 : null;
    const name = key ? entity[key].value : null;
    return { key, name };
  }
  static getQuantityValue(properties, quantityID) {
    var _a2;
    const quantity = properties[quantityID];
    const key = (_a2 = Object.keys(quantity).find((key2) => key2.endsWith("Value"))) !== null && _a2 !== void 0 ? _a2 : null;
    let value;
    if (key === null) {
      value = null;
    } else if (quantity[key] === void 0 || quantity[key] === null) {
      value = null;
    } else {
      value = quantity[key].value;
    }
    return { key, value };
  }
  static isRel(expressID) {
    const entityName = IfcCategoryMap[expressID];
    return entityName.startsWith("IFCREL");
  }
  static attributeExists(properties, expressID, attribute) {
    const entity = properties[expressID];
    if (!entity)
      return false;
    return Object.keys(properties[expressID]).includes(attribute);
  }
  static groupEntitiesByType(properties, expressIDs) {
    var _a2;
    const categoriesMap = /* @__PURE__ */ new Map();
    for (const expressID of expressIDs) {
      const entity = properties[expressID];
      if (!entity)
        continue;
      const key = entity.type;
      const set = categoriesMap.get(key);
      if (!set)
        categoriesMap.set(key, /* @__PURE__ */ new Set());
      (_a2 = categoriesMap.get(key)) === null || _a2 === void 0 ? void 0 : _a2.add(expressID);
    }
    return categoriesMap;
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesManager/src/entity-actions.js
var EntityActionsUI = class extends SimpleUIComponent {
  constructor(components) {
    super(components, `<div class="flex"></div>`);
    this.onNewPset = new Event();
    this.data = {};
    this.addPsetBtn = new Button(this._components, {
      materialIconName: "add"
    });
    this.addPsetBtn.onClick.add(async () => {
      this._nameInput.value = "";
      this._descriptionInput.value = "";
      this.modal.visible = true;
    });
    this.addChild(this.addPsetBtn);
    this.modal = new Modal(components, "New Property Set");
    this._components.ui.add(this.modal);
    this.modal.visible = false;
    this.modal.onHidden.add(() => this.removeFromParent());
    const addPsetUI = new SimpleUIComponent(this._components, `<div class="flex flex-col gap-y-4 p-4"></div>`);
    this.modal.setSlot("content", addPsetUI);
    this._nameInput = new TextInput(this._components);
    this._nameInput.label = "Name";
    this._descriptionInput = new TextInput(this._components);
    this._descriptionInput.label = "Description";
    this.modal.onAccept.add(() => {
      const name = this._nameInput.value;
      const description = this._descriptionInput.value;
      this.modal.visible = false;
      const { model, elementIDs } = this.data;
      if (!model || name === "")
        return;
      this.onNewPset.trigger({ model, elementIDs, name, description });
    });
    this.modal.onCancel.add(() => this.modal.visible = false);
    addPsetUI.addChild(this._nameInput, this._descriptionInput);
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.data = {};
    this.onNewPset.reset();
    await this.addPsetBtn.dispose();
    await this.modal.dispose();
    await this._nameInput.dispose();
    await this._descriptionInput.dispose();
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesManager/src/pset-actions.js
var PsetActionsUI = class extends SimpleUIComponent {
  constructor(components) {
    super(components, `<div class="flex"></div>`);
    this.modalVisible = false;
    this.onEditPset = new Event();
    this.onRemovePset = new Event();
    this.onNewProp = new Event();
    this.data = {};
    this.editPsetBtn = new Button(this._components);
    this.editPsetBtn.materialIcon = "edit";
    this.setEditUI();
    this.removePsetBtn = new Button(this._components);
    this.removePsetBtn.materialIcon = "delete";
    this.setRemoveUI();
    this.addPropBtn = new Button(this._components);
    this.addPropBtn.materialIcon = "add";
    this.setAddPropUI();
    this.addChild(this.addPropBtn, this.editPsetBtn, this.removePsetBtn);
    this._modal = new SimpleUIComponent(components, `<dialog></dialog>`);
    this._components.ui.add(this._modal);
    this._modal.get().addEventListener("close", () => {
      this.removeFromParent();
      this.modalVisible = false;
      this._modalWindow.visible = false;
    });
    this._modalWindow = new FloatingWindow(this._components);
    this._modalWindow.get().className = "overflow-auto text-white bg-ifcjs-100 rounded-md w-[350px]";
    this._modalWindow.onHidden.add(() => this._modal.get().close());
    this._modal.addChild(this._modalWindow);
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    await this.editPsetBtn.dispose();
    await this.removePsetBtn.dispose();
    await this.addPropBtn.dispose();
    await this._modal.dispose();
    await this._modalWindow.dispose();
    this.onEditPset.reset();
    this.onRemovePset.reset();
    this.onNewProp.reset();
    this.data = {};
  }
  setEditUI() {
    const editUI = new SimpleUIComponent(this._components, `<div class="flex flex-col gap-y-4 p-4 overflow-auto"></div>`);
    const nameInput = new TextInput(this._components);
    nameInput.label = "Name";
    const descriptionInput = new TextInput(this._components);
    descriptionInput.label = "Description";
    const acceptBtn = new Button(this._components);
    acceptBtn.materialIcon = "check";
    acceptBtn.label = "Accept";
    acceptBtn.get().classList.remove("hover:bg-ifcjs-200");
    acceptBtn.get().classList.add("hover:bg-success");
    acceptBtn.onClick.add(async () => {
      this._modal.get().close();
      const { model, psetID } = this.data;
      if (!model || !psetID)
        return;
      await this.onEditPset.trigger({
        model,
        psetID,
        name: nameInput.value,
        description: descriptionInput.value
      });
    });
    const cancelBtn = new Button(this._components);
    cancelBtn.materialIcon = "close";
    cancelBtn.label = "Cancel";
    cancelBtn.get().classList.remove("hover:bg-ifcjs-200");
    cancelBtn.get().classList.add("hover:bg-error");
    cancelBtn.onClick.add(() => this._modal.get().close());
    const actionBtns = new SimpleUIComponent(this._components, `<div class="flex gap-x-2 justify-end"></div>`);
    actionBtns.addChild(cancelBtn, acceptBtn);
    editUI.addChild(nameInput, descriptionInput, actionBtns);
    this.editPsetBtn.onClick.add(async () => {
      var _a2, _b2, _c, _d;
      const { model, psetID } = this.data;
      const properties = model === null || model === void 0 ? void 0 : model.properties;
      if (!model || !psetID || !properties)
        return;
      const entity = properties[psetID];
      nameInput.value = (_b2 = (_a2 = entity.Name) === null || _a2 === void 0 ? void 0 : _a2.value) !== null && _b2 !== void 0 ? _b2 : "";
      descriptionInput.value = (_d = (_c = entity.Description) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : "";
      this._modalWindow.title = "Edit Property Set";
      this._modalWindow.setSlot("content", editUI);
      this.showModal();
    });
  }
  setRemoveUI() {
    const removeUI = new SimpleUIComponent(this._components, `<div class="flex flex-col gap-y-4 p-4 overflow-auto"></div>`);
    const warningText = document.createElement("div");
    warningText.className = "text-base text-center";
    warningText.textContent = "Are you sure to delete this property set? This action can't be undone.";
    removeUI.get().append(warningText);
    const acceptBtn = new Button(this._components);
    acceptBtn.materialIcon = "check";
    acceptBtn.label = "Accept";
    acceptBtn.get().classList.remove("hover:bg-ifcjs-200");
    acceptBtn.get().classList.add("hover:bg-success");
    acceptBtn.onClick.add(async () => {
      this._modal.get().close();
      const { model, psetID } = this.data;
      if (!model || !psetID)
        return;
      this.removeFromParent();
      await this.onRemovePset.trigger({ model, psetID });
    });
    const cancelBtn = new Button(this._components);
    cancelBtn.materialIcon = "close";
    cancelBtn.label = "Cancel";
    cancelBtn.get().classList.remove("hover:bg-ifcjs-200");
    cancelBtn.get().classList.add("hover:bg-error");
    cancelBtn.onClick.add(() => this._modal.get().close());
    const actionBtns = new SimpleUIComponent(this._components, `<div class="flex gap-x-2 justify-end"></div>`);
    actionBtns.addChild(cancelBtn, acceptBtn);
    removeUI.addChild(actionBtns);
    this.removePsetBtn.onClick.add(async () => {
      const { model, psetID } = this.data;
      if (!model || !psetID)
        return;
      this._modalWindow.title = "Remove Property Set";
      this._modalWindow.setSlot("content", removeUI);
      this.showModal();
    });
  }
  setAddPropUI() {
    const addPropUI = new SimpleUIComponent(this._components, `<div class="flex flex-col gap-y-4 p-4 overflow-auto"></div>`);
    const nameInput = new TextInput(this._components);
    nameInput.label = "Name";
    const typeInput = new Dropdown(this._components);
    typeInput.label = "Type";
    typeInput.addOption("IfcText", "IfcLabel", "IfcIdentifier");
    typeInput.value = "IfcText";
    const valueInput = new TextInput(this._components);
    valueInput.label = "Value";
    const acceptBtn = new Button(this._components);
    acceptBtn.materialIcon = "check";
    acceptBtn.label = "Accept";
    acceptBtn.get().classList.remove("hover:bg-ifcjs-200");
    acceptBtn.get().classList.add("hover:bg-success");
    acceptBtn.onClick.add(async () => {
      this._modal.get().close();
      const { model, psetID } = this.data;
      if (!model || !psetID)
        return;
      const name = nameInput.value;
      const type2 = typeInput.value;
      if (name === "" || !type2)
        return;
      await this.onNewProp.trigger({
        model,
        psetID,
        name,
        type: type2,
        value: valueInput.value
      });
    });
    const cancelBtn = new Button(this._components);
    cancelBtn.materialIcon = "close";
    cancelBtn.label = "Cancel";
    cancelBtn.get().classList.remove("hover:bg-ifcjs-200");
    cancelBtn.get().classList.add("hover:bg-error");
    cancelBtn.onClick.add(() => this._modal.get().close());
    const actionBtns = new SimpleUIComponent(this._components, `<div class="flex gap-x-2 justify-end"></div>`);
    actionBtns.addChild(cancelBtn, acceptBtn);
    addPropUI.addChild(nameInput, typeInput, valueInput, actionBtns);
    this.addPropBtn.onClick.add(async () => {
      const { model, psetID } = this.data;
      if (!model || !psetID)
        return;
      this._modalWindow.title = "New Property";
      this._modalWindow.setSlot("content", addPropUI);
      this.showModal();
    });
  }
  showModal() {
    this.modalVisible = true;
    this._modalWindow.visible = true;
    this._modal.get().showModal();
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesManager/src/prop-actions.js
var PropActionsUI = class extends SimpleUIComponent {
  constructor(components) {
    const div = document.createElement("div");
    div.className = "flex";
    super(components, `<div class="flex"></div>`);
    this.modalVisible = false;
    this.onEditProp = new Event();
    this.onRemoveProp = new Event();
    this.data = {};
    this.editPropBtn = new Button(this._components);
    this.editPropBtn.materialIcon = "edit";
    this.setEditUI();
    this.removePropBtn = new Button(this._components);
    this.removePropBtn.materialIcon = "delete";
    this.setRemoveUI();
    this.addChild(this.editPropBtn, this.removePropBtn);
    this._modal = new SimpleUIComponent(components, `<dialog></dialog>`);
    this._components.ui.add(this._modal);
    this._modal.get().addEventListener("close", () => {
      this.removeFromParent();
      this.modalVisible = false;
      this._modalWindow.visible = false;
    });
    this._modalWindow = new FloatingWindow(this._components);
    this._modalWindow.get().className = "overflow-auto text-white bg-ifcjs-100 rounded-md w-[350px]";
    this._modalWindow.onHidden.add(() => this._modal.get().close());
    this._modal.addChild(this._modalWindow);
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.onRemoveProp.reset();
    await this.editPropBtn.dispose();
    await this.removePropBtn.dispose();
    await this._modal.dispose();
    await this._modalWindow.dispose();
    this.data = {};
  }
  setEditUI() {
    const editUI = new SimpleUIComponent(this._components, `<div class="flex flex-col gap-y-4 p-4 overflow-auto"></div>`);
    const nameInput = new TextInput(this._components);
    nameInput.label = "Name";
    const valueInput = new TextInput(this._components);
    valueInput.label = "Value";
    const acceptBtn = new Button(this._components);
    acceptBtn.materialIcon = "check";
    acceptBtn.label = "Accept";
    acceptBtn.get().classList.remove("hover:bg-ifcjs-200");
    acceptBtn.get().classList.add("hover:bg-success");
    acceptBtn.onClick.add(async () => {
      this._modal.get().close();
      const { model, expressID } = this.data;
      if (!model || !expressID)
        return;
      await this.onEditProp.trigger({
        model,
        expressID,
        name: nameInput.value,
        value: valueInput.value
      });
    });
    const cancelBtn = new Button(this._components);
    cancelBtn.materialIcon = "close";
    cancelBtn.label = "Cancel";
    cancelBtn.get().classList.remove("hover:bg-ifcjs-200");
    cancelBtn.get().classList.add("hover:bg-error");
    cancelBtn.onClick.add(() => this._modal.get().close());
    const actionBtns = new SimpleUIComponent(this._components, `<div class="flex gap-x-2 justify-end"></div>`);
    actionBtns.addChild(cancelBtn, acceptBtn);
    editUI.addChild(nameInput, valueInput, actionBtns);
    this.editPropBtn.onClick.add(async () => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h;
      const { model, expressID } = this.data;
      const properties = model === null || model === void 0 ? void 0 : model.properties;
      if (!model || !expressID || !properties)
        return;
      const prop = properties[expressID];
      const { key: nameKey } = IfcPropertiesUtils.getEntityName(properties, expressID);
      if (nameKey) {
        nameInput.value = (_b2 = (_a2 = prop[nameKey]) === null || _a2 === void 0 ? void 0 : _a2.value) !== null && _b2 !== void 0 ? _b2 : "";
      } else {
        nameInput.value = (_d = (_c = prop.Name) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : "";
      }
      const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(properties, expressID);
      if (valueKey) {
        valueInput.value = (_f = (_e = prop[valueKey]) === null || _e === void 0 ? void 0 : _e.value) !== null && _f !== void 0 ? _f : "";
      } else {
        valueInput.value = (_h = (_g = prop.NominalValue) === null || _g === void 0 ? void 0 : _g.value) !== null && _h !== void 0 ? _h : "";
      }
      this._modalWindow.title = "Edit Property";
      this._modalWindow.setSlot("content", editUI);
      this.showModal();
    });
  }
  setRemoveUI() {
    const removeUI = new SimpleUIComponent(this._components, `<div class="flex flex-col gap-y-4 p-4 overflow-auto"></div>`);
    const warningText = document.createElement("div");
    warningText.className = "text-base text-center";
    warningText.textContent = "Are you sure to delete this property? This action can't be undone.";
    removeUI.get().append(warningText);
    const acceptBtn = new Button(this._components);
    acceptBtn.materialIcon = "check";
    acceptBtn.label = "Accept";
    acceptBtn.get().classList.remove("hover:bg-ifcjs-200");
    acceptBtn.get().classList.add("hover:bg-success");
    acceptBtn.onClick.add(async () => {
      this._modal.get().close();
      const { model, expressID, setID } = this.data;
      if (!model || !expressID || !setID)
        return;
      this.removeFromParent();
      await this.onRemoveProp.trigger({ model, expressID, setID });
    });
    const cancelBtn = new Button(this._components);
    cancelBtn.materialIcon = "close";
    cancelBtn.label = "Cancel";
    cancelBtn.get().classList.remove("hover:bg-ifcjs-200");
    cancelBtn.get().classList.add("hover:bg-error");
    cancelBtn.onClick.add(() => this._modal.get().close());
    const actionBtns = new SimpleUIComponent(this._components, `<div class="flex gap-x-2 justify-end"></div>`);
    actionBtns.addChild(cancelBtn, acceptBtn);
    removeUI.addChild(actionBtns);
    this.removePropBtn.onClick.add(async () => {
      const { model, expressID, setID } = this.data;
      if (!model || !expressID || !setID)
        return;
      this._modalWindow.title = "Remove Property";
      this._modalWindow.setSlot("content", removeUI);
      this.showModal();
    });
  }
  showModal() {
    this.modalVisible = true;
    this._modalWindow.visible = true;
    this._modal.get().showModal();
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesManager/index.js
var IfcPropertiesManager = class _IfcPropertiesManager extends Component {
  constructor(components) {
    super(components);
    this.onRequestFile = new Event();
    this.ifcToExport = null;
    this.onElementToPset = new Event();
    this.onPropToPset = new Event();
    this.onPsetRemoved = new Event();
    this.onDataChanged = new Event();
    this.wasm = {
      path: "/",
      absolute: false
    };
    this.enabled = true;
    this.attributeListeners = {};
    this.uiElement = new UIElement();
    this._changeMap = {};
    this.components.tools.add(_IfcPropertiesManager.uuid, this);
    this._ifcApi = new IfcAPI2();
    if (components.ui.enabled) {
      this.setUI(components);
      this.setUIEvents();
    }
  }
  get() {
    return this._changeMap;
  }
  async init() {
    const { path, absolute } = this.wasm;
    this._ifcApi.SetWasmPath(path, absolute);
    await this._ifcApi.Init();
  }
  async dispose() {
    this._ifcApi = null;
    this.selectedModel = void 0;
    this.attributeListeners = {};
    this._changeMap = {};
    this.onElementToPset.reset();
    this.onPropToPset.reset();
    this.onPsetRemoved.reset();
    this.onDataChanged.reset();
    await this.uiElement.dispose();
  }
  setUI(components) {
    const exportButton = new Button(components);
    exportButton.tooltip = "Export IFC";
    exportButton.materialIcon = "exit_to_app";
    exportButton.onClick.add(async () => {
      await this.onRequestFile.trigger();
      if (!this.ifcToExport || !this.selectedModel)
        return;
      const fileData = new Uint8Array(this.ifcToExport);
      const name = this.selectedModel.name;
      const resultBuffer = await this.saveToIfc(this.selectedModel, fileData);
      const resultFile = new File([new Blob([resultBuffer])], name);
      const link = document.createElement("a");
      link.download = name;
      link.href = URL.createObjectURL(resultFile);
      link.click();
      link.remove();
    });
    this.uiElement.set({
      exportButton,
      entityActions: new EntityActionsUI(components),
      psetActions: new PsetActionsUI(components),
      propActions: new PropActionsUI(components)
    });
  }
  setUIEvents() {
    const entityActions = this.uiElement.get("entityActions");
    const propActions = this.uiElement.get("propActions");
    const psetActions = this.uiElement.get("psetActions");
    entityActions.onNewPset.add(async ({ model, elementIDs, name, description }) => {
      const { pset } = await this.newPset(model, name, description === "" ? void 0 : description);
      for (const expressID of elementIDs !== null && elementIDs !== void 0 ? elementIDs : []) {
        await this.addElementToPset(model, pset.expressID, expressID);
      }
      entityActions.cleanData();
    });
    propActions.onEditProp.add(async ({ model, expressID, name, value }) => {
      var _a2, _b2;
      const { properties } = _IfcPropertiesManager.getIFCInfo(model);
      const prop = properties[expressID];
      const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(properties, expressID);
      const { key: nameKey } = IfcPropertiesUtils.getEntityName(properties, expressID);
      if (name !== "" && nameKey) {
        if ((_a2 = prop[nameKey]) === null || _a2 === void 0 ? void 0 : _a2.value) {
          prop[nameKey].value = name;
        } else {
          prop.Name = { type: 1, value: name };
        }
      }
      if (value !== "" && valueKey) {
        if ((_b2 = prop[valueKey]) === null || _b2 === void 0 ? void 0 : _b2.value) {
          prop[valueKey].value = value;
        } else {
          prop.NominalValue = { type: 1, value };
        }
      }
      await this.registerChange(model, expressID);
      propActions.cleanData();
    });
    propActions.onRemoveProp.add(async ({ model, expressID, setID }) => {
      await this.removePsetProp(model, setID, expressID);
      propActions.cleanData();
    });
    psetActions.onEditPset.add(async ({ model, psetID, name, description }) => {
      var _a2, _b2;
      const { properties } = _IfcPropertiesManager.getIFCInfo(model);
      const pset = properties[psetID];
      if (name !== "") {
        if ((_a2 = pset.Name) === null || _a2 === void 0 ? void 0 : _a2.value) {
          pset.Name.value = name;
        } else {
          pset.Name = { type: 1, value: name };
        }
      }
      if (description !== "") {
        if ((_b2 = pset.Description) === null || _b2 === void 0 ? void 0 : _b2.value) {
          pset.Description.value = description;
        } else {
          pset.Description = { type: 1, value: description };
        }
      }
      await this.registerChange(model, psetID);
    });
    psetActions.onRemovePset.add(async ({ model, psetID }) => {
      await this.removePset(model, psetID);
    });
    psetActions.onNewProp.add(async ({ model, psetID, name, type: type2, value }) => {
      const prop = await this.newSingleStringProperty(model, type2, name, value);
      await this.addPropToPset(model, psetID, prop.expressID);
    });
  }
  increaseMaxID(model) {
    model.ifcMetadata.maxExpressID++;
  }
  static getIFCInfo(model) {
    const properties = model.properties;
    if (!properties)
      throw new Error("FragmentsGroup properties not found");
    const schema = model.ifcMetadata.schema;
    if (!schema)
      throw new Error("IFC Schema not found");
    return { properties, schema };
  }
  newGUID(model) {
    const { schema } = _IfcPropertiesManager.getIFCInfo(model);
    return new web_ifc_api_exports[schema].IfcGloballyUniqueId(generateIfcGUID());
  }
  getOwnerHistory(model) {
    const { properties } = _IfcPropertiesManager.getIFCInfo(model);
    const ownerHistory = IfcPropertiesUtils.findItemOfType(properties, IFCOWNERHISTORY);
    if (!ownerHistory)
      throw new Error("No OwnerHistory was found.");
    const ownerHistoryHandle = new Handle(ownerHistory.expressID);
    return { ownerHistory, ownerHistoryHandle };
  }
  async registerChange(model, ...expressID) {
    if (!this._changeMap[model.uuid]) {
      this._changeMap[model.uuid] = /* @__PURE__ */ new Set();
    }
    for (const id of expressID) {
      this._changeMap[model.uuid].add(id);
      await this.onDataChanged.trigger({ model, expressID: id });
    }
  }
  async setData(model, ...dataToSave) {
    const { properties } = _IfcPropertiesManager.getIFCInfo(model);
    for (const data of dataToSave) {
      const expressID = data.expressID;
      if (!expressID)
        continue;
      properties[expressID] = data;
      await this.registerChange(model, expressID);
    }
  }
  async newPset(model, name, description) {
    const { schema } = _IfcPropertiesManager.getIFCInfo(model);
    const { ownerHistoryHandle } = this.getOwnerHistory(model);
    this.increaseMaxID(model);
    const psetGlobalId = this.newGUID(model);
    const psetName = new web_ifc_api_exports[schema].IfcLabel(name);
    const psetDescription = description ? new web_ifc_api_exports[schema].IfcText(description) : null;
    const pset = new web_ifc_api_exports[schema].IfcPropertySet(psetGlobalId, ownerHistoryHandle, psetName, psetDescription, []);
    this.increaseMaxID(model);
    const relGlobalId = this.newGUID(model);
    const rel = new web_ifc_api_exports[schema].IfcRelDefinesByProperties(relGlobalId, ownerHistoryHandle, null, null, [], new Handle(pset.expressID));
    await this.setData(model, pset, rel);
    return { pset, rel };
  }
  async removePset(model, ...psetID) {
    const { properties } = _IfcPropertiesManager.getIFCInfo(model);
    for (const expressID of psetID) {
      const pset = properties[expressID];
      if ((pset === null || pset === void 0 ? void 0 : pset.type) !== IFCPROPERTYSET)
        continue;
      const relID = IfcPropertiesUtils.getPsetRel(properties, expressID);
      if (relID) {
        delete properties[relID];
        await this.registerChange(model, relID);
      }
      if (pset) {
        for (const propHandle of pset.HasProperties)
          delete properties[propHandle.value];
        delete properties[expressID];
        await this.onPsetRemoved.trigger({ model, psetID: expressID });
        await this.registerChange(model, expressID);
      }
    }
  }
  async newSingleProperty(model, type2, name, value) {
    const { schema } = _IfcPropertiesManager.getIFCInfo(model);
    this.increaseMaxID(model);
    const propName = new web_ifc_api_exports[schema].IfcIdentifier(name);
    const propValue = new web_ifc_api_exports[schema][type2](value);
    const prop = new web_ifc_api_exports[schema].IfcPropertySingleValue(propName, null, propValue, null);
    await this.setData(model, prop);
    return prop;
  }
  newSingleStringProperty(model, type2, name, value) {
    return this.newSingleProperty(model, type2, name, value);
  }
  newSingleNumericProperty(model, type2, name, value) {
    return this.newSingleProperty(model, type2, name, value);
  }
  newSingleBooleanProperty(model, type2, name, value) {
    return this.newSingleProperty(model, type2, name, value);
  }
  async removePsetProp(model, psetID, propID) {
    const { properties } = _IfcPropertiesManager.getIFCInfo(model);
    const pset = properties[psetID];
    const prop = properties[propID];
    if (!(pset.type === IFCPROPERTYSET && prop))
      return;
    pset.HasProperties = pset.HasProperties.filter((handle) => {
      return handle.value !== propID;
    });
    delete properties[propID];
    await this.registerChange(model, psetID, propID);
  }
  async addElementToPset(model, psetID, ...elementID) {
    const { properties } = _IfcPropertiesManager.getIFCInfo(model);
    const relID = IfcPropertiesUtils.getPsetRel(properties, psetID);
    if (!relID)
      return;
    const rel = properties[relID];
    for (const expressID of elementID) {
      const elementHandle = new Handle(expressID);
      rel.RelatedObjects.push(elementHandle);
      await this.onElementToPset.trigger({
        model,
        psetID,
        elementID: expressID
      });
    }
    await this.registerChange(model, psetID);
  }
  async addPropToPset(model, psetID, ...propID) {
    const { properties } = _IfcPropertiesManager.getIFCInfo(model);
    const pset = properties[psetID];
    if (!pset)
      return;
    for (const expressID of propID) {
      const elementHandle = new Handle(expressID);
      pset.HasProperties.push(elementHandle);
      await this.onPropToPset.trigger({ model, psetID, propID: expressID });
    }
    await this.registerChange(model, psetID);
  }
  async saveToIfc(model, ifcToSaveOn) {
    var _a2;
    const { properties } = _IfcPropertiesManager.getIFCInfo(model);
    const modelID = this._ifcApi.OpenModel(ifcToSaveOn);
    const changes = (_a2 = this._changeMap[model.uuid]) !== null && _a2 !== void 0 ? _a2 : [];
    for (const expressID of changes) {
      const data = properties[expressID];
      if (!data) {
        this._ifcApi.DeleteLine(modelID, expressID);
      } else {
        this._ifcApi.WriteLine(modelID, data);
      }
    }
    const modifiedIFC = this._ifcApi.SaveModel(modelID);
    this._ifcApi.CloseModel(modelID);
    this._ifcApi = null;
    this._ifcApi = new IfcAPI2();
    const { path, absolute } = this.wasm;
    this._ifcApi.SetWasmPath(path, absolute);
    await this._ifcApi.Init();
    return modifiedIFC;
  }
  setAttributeListener(model, expressID, attributeName) {
    if (!this.attributeListeners[model.uuid])
      this.attributeListeners[model.uuid] = {};
    const existingListener = this.attributeListeners[model.uuid][expressID] ? this.attributeListeners[model.uuid][expressID][attributeName] : null;
    if (existingListener)
      return existingListener;
    const { properties } = _IfcPropertiesManager.getIFCInfo(model);
    const entity = properties[expressID];
    if (!entity) {
      throw new Error(`Entity with expressID ${expressID} doesn't exists.`);
    }
    const attribute = entity[attributeName];
    if (Array.isArray(attribute) || !attribute) {
      throw new Error(`Attribute ${attributeName} is array or null, and it can't have a listener.`);
    }
    const value = attribute.value;
    if (value === void 0 || value == null) {
      throw new Error(`Attribute ${attributeName} has a badly defined handle.`);
    }
    const event = new Event();
    Object.defineProperty(entity[attributeName], "value", {
      get() {
        return this._value;
      },
      async set(value2) {
        this._value = value2;
        await event.trigger(value2);
      }
    });
    entity[attributeName].value = value;
    if (!this.attributeListeners[model.uuid][expressID])
      this.attributeListeners[model.uuid][expressID] = {};
    this.attributeListeners[model.uuid][expressID][attributeName] = event;
    return event;
  }
};
IfcPropertiesManager.uuid = "58c2d9f0-183c-48d6-a402-dfcf5b9a34df";
ToolComponent.libraryUUIDs.add(IfcPropertiesManager.uuid);

// node_modules/openbim-components/ifc/IfcPropertiesProcessor/src/property-tag.js
var PropertyTag = class extends SimpleUIComponent {
  get label() {
    return this.innerElements.label.textContent;
  }
  set label(value) {
    this.innerElements.label.textContent = value;
  }
  get value() {
    return this.innerElements.value.textContent;
  }
  set value(value) {
    this.innerElements.value.textContent = String(value);
  }
  constructor(components, propertiesProcessor, model, expressID) {
    const template = `
    <div class="flex gap-x-2 hover:bg-ifcjs-120 py-1 px-3 rounded-md items-center min-h-[40px]">
      <div class="flex flex-col grow">
        <p id="label" class="${UIManager.Class.Label}"></p>
        <p id="value" class="text-base"></p>
      </div> 
    </div> 
    `;
    super(components, template);
    this.name = "PropertyTag";
    this.expressID = 0;
    this.innerElements = {
      label: this.getInnerElement("label"),
      value: this.getInnerElement("value")
    };
    this.model = model;
    this.expressID = expressID;
    this._propertiesProcessor = propertiesProcessor;
    this.setInitialValues();
    this.setListeners();
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.model = null;
    this._propertiesProcessor = null;
    if (Object.keys(this.innerElements).length) {
      this.innerElements.value.remove();
      this.innerElements.label.remove();
    }
  }
  setListeners() {
    const propertiesManager = this._propertiesProcessor.propertiesManager;
    if (!propertiesManager)
      return;
    const { properties } = IfcPropertiesManager.getIFCInfo(this.model);
    const { key: nameKey } = IfcPropertiesUtils.getEntityName(properties, this.expressID);
    const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(properties, this.expressID);
    if (nameKey) {
      const event = propertiesManager.setAttributeListener(this.model, this.expressID, nameKey);
      event.add((v3) => this.label = v3.toString());
    }
    if (valueKey) {
      const event = propertiesManager.setAttributeListener(this.model, this.expressID, valueKey);
      event.add((v3) => this.value = v3);
    }
  }
  setInitialValues() {
    const { properties } = IfcPropertiesManager.getIFCInfo(this.model);
    const entity = properties[this.expressID];
    if (!entity) {
      this.label = "NULL";
      this.value = `ExpressID ${this.expressID} not found`;
    } else {
      const { name } = IfcPropertiesUtils.getEntityName(properties, this.expressID);
      const { value } = IfcPropertiesUtils.getQuantityValue(properties, this.expressID);
      this.label = name;
      this.value = value;
    }
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesProcessor/src/attribute-tag.js
var AttributeTag = class extends PropertyTag {
  constructor(components, propertiesProcessor, model, expressID, attributeName = "Name") {
    super(components, propertiesProcessor, model, expressID);
    this.name = "AttributeTag";
    this.expressID = 0;
    this.model = model;
    this.expressID = expressID;
    this.attributeName = attributeName;
    this._propertiesProcessor = propertiesProcessor;
    this.setInitialValues();
    this.setListeners();
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.model = null;
  }
  setListeners() {
    const propertiesManager = this._propertiesProcessor.propertiesManager;
    if (!propertiesManager)
      return;
    try {
      const event = propertiesManager.setAttributeListener(this.model, this.expressID, this.attributeName);
      event.add((v3) => this.value = v3);
    } catch (err) {
    }
  }
  setInitialValues() {
    const properties = this.model.properties;
    if (!properties) {
      this.label = `Model ${this.model.ifcMetadata.name} has no properties`;
      this.value = "NULL";
      return;
    }
    const entity = properties[this.expressID];
    if (!entity) {
      this.label = `ExpressID ${this.expressID} not found`;
      this.value = "NULL";
      return;
    }
    const attributes = Object.keys(entity);
    if (!attributes.includes(this.attributeName)) {
      this.label = `Attribute ${this.attributeName} not found`;
      this.value = "NULL";
      return;
    }
    if (!entity[this.attributeName])
      return;
    this.label = this.attributeName;
    this.value = entity[this.attributeName].value;
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesProcessor/src/attribute-set.js
var AttributeSet = class extends TreeView {
  set expressID(value) {
    this._expressID = value;
    this._attributes = [];
    this.slots.content.dispose(true);
  }
  get expressID() {
    return this._expressID;
  }
  constructor(components, propertiesProcessor, model, expressID) {
    super(components, "ATTRIBUTES");
    this.name = "AttributeSet";
    this.attributesToIgnore = [];
    this._expressID = 0;
    this._attributes = [];
    this._generated = false;
    this.model = model;
    this.expressID = expressID;
    this._propertiesProcessor = propertiesProcessor;
    this.onExpand.add(() => this.generate());
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    this.model = null;
    this.attributesToIgnore = [];
    this._attributes = [];
    this._propertiesProcessor = null;
  }
  generate() {
    const properties = this.model.properties;
    if (this._generated || !properties)
      return;
    this.update();
    this._generated = true;
  }
  update() {
    const properties = this.model.properties;
    if (!properties)
      return;
    const entity = properties[this.expressID];
    if (!entity)
      return;
    for (const attributeName in entity) {
      const ignore = this.attributesToIgnore.includes(attributeName);
      if (ignore)
        continue;
      const included = this._attributes.includes(attributeName);
      if (included) {
      } else {
        const attribute = entity[attributeName];
        if (!(attribute === null || attribute === void 0 ? void 0 : attribute.value))
          continue;
        this._attributes.push(attributeName);
        const tag = new AttributeTag(this._components, this._propertiesProcessor, this.model, this.expressID, attributeName);
        this.addChild(tag);
      }
    }
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesProcessor/index.js
var IfcPropertiesProcessor = class _IfcPropertiesProcessor extends Component {
  // private _entityUIPool: UIPool<TreeView>;
  set propertiesManager(manager) {
    if (this._propertiesManager)
      return;
    this._propertiesManager = manager;
    if (manager) {
      manager.onElementToPset.add(({ model, psetID, elementID }) => {
        const modelIndexMap = this._indexMap[model.uuid];
        if (!modelIndexMap)
          return;
        this.setEntityIndex(model, elementID).add(psetID);
        if (this._currentUI[elementID]) {
          const ui = this.newPsetUI(model, psetID);
          this._currentUI[elementID].addChild(...ui);
        }
      });
      manager.onPsetRemoved.add(async ({ psetID }) => {
        const psetUI = this._currentUI[psetID];
        if (psetUI) {
          await psetUI.dispose();
        }
      });
      manager.onPropToPset.add(({ model, psetID, propID }) => {
        const psetUI = this._currentUI[psetID];
        if (!psetUI)
          return;
        const tag = this.newPropertyTag(model, psetID, propID, "NominalValue");
        if (tag)
          psetUI.addChild(tag);
      });
      this.onPropertiesManagerSet.trigger(manager);
    }
  }
  get propertiesManager() {
    return this._propertiesManager;
  }
  constructor(components) {
    super(components);
    this.enabled = true;
    this.uiElement = new UIElement();
    this.relationsToProcess = [
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELASSOCIATESMATERIAL,
      IFCRELCONTAINEDINSPATIALSTRUCTURE,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP
    ];
    this.entitiesToIgnore = [IFCOWNERHISTORY, IFCMATERIALLAYERSETUSAGE];
    this.attributesToIgnore = [
      "CompositionType",
      "Representation",
      "ObjectPlacement",
      "OwnerHistory"
    ];
    this._indexMap = {};
    this._renderFunctions = {};
    this._propertiesManager = null;
    this._currentUI = {};
    this.onPropertiesManagerSet = new Event();
    this.components.tools.add(_IfcPropertiesProcessor.uuid, this);
    this._renderFunctions = this.getRenderFunctions();
    if (components.ui.enabled) {
      this.setUI();
    }
  }
  getRenderFunctions() {
    return {
      0: (model, expressID) => this.newEntityUI(model, expressID),
      [IFCPROPERTYSET]: (model, expressID) => this.newPsetUI(model, expressID),
      [IFCELEMENTQUANTITY]: (model, expressID) => this.newQsetUI(model, expressID)
    };
  }
  async dispose() {
    this.uiElement.dispose();
    this._indexMap = {};
    this.propertiesManager = null;
    for (const id in this._currentUI) {
      await this._currentUI[id].dispose();
    }
    this._currentUI = {};
    this.onPropertiesManagerSet.reset();
  }
  getProperties(model, id) {
    if (!model.properties)
      return null;
    const map = this._indexMap[model.uuid];
    if (!map)
      return null;
    const indices = map[id];
    const idNumber = parseInt(id, 10);
    const nativeProperties = this.cloneProperty(model.properties[idNumber]);
    const properties = [nativeProperties];
    if (indices) {
      for (const index of indices) {
        const pset = this.cloneProperty(model.properties[index]);
        if (!pset)
          continue;
        this.getPsetProperties(pset, model.properties);
        this.getNestedPsets(pset, model.properties);
        properties.push(pset);
      }
    }
    return properties;
  }
  getNestedPsets(pset, props2) {
    if (pset.HasPropertySets) {
      for (const subPSet of pset.HasPropertySets) {
        const psetID = subPSet.value;
        subPSet.value = this.cloneProperty(props2[psetID]);
        this.getPsetProperties(subPSet.value, props2);
      }
    }
  }
  getPsetProperties(pset, props2) {
    if (pset.HasProperties) {
      for (const property of pset.HasProperties) {
        const psetID = property.value;
        const result = this.cloneProperty(props2[psetID]);
        property.value = { ...result };
      }
    }
  }
  setUI() {
    const topToolbar = new SimpleUIComponent(this.components);
    const propsList = new SimpleUIComponent(this.components, `<div class="flex flex-col"></div>`);
    const main2 = new Button(this.components, {
      materialIconName: "list"
    });
    const propertiesWindow = new FloatingWindow(this.components);
    this.components.ui.add(propertiesWindow);
    propertiesWindow.title = "Element Properties";
    propertiesWindow.addChild(topToolbar, propsList);
    main2.tooltip = "Properties";
    main2.onClick.add(() => {
      propertiesWindow.visible = !propertiesWindow.visible;
    });
    propertiesWindow.onHidden.add(() => main2.active = false);
    propertiesWindow.onVisible.add(() => main2.active = true);
    propertiesWindow.visible = false;
    this.uiElement.set({
      main: main2,
      propertiesWindow,
      propsList,
      topToolbar
    });
  }
  async cleanPropertiesList() {
    if (this._propertiesManager) {
      const button = this._propertiesManager.uiElement.get("exportButton");
      button.removeFromParent();
    }
    const propsList = this.uiElement.get("propsList");
    await propsList.dispose(true);
    const propsWindow = this.uiElement.get("propertiesWindow");
    propsWindow.description = null;
    propsList.children = [];
    this._currentUI = {};
  }
  get() {
    return this._indexMap;
  }
  process(model) {
    const properties = model.properties;
    if (!properties)
      throw new Error("FragmentsGroup properties not found");
    this._indexMap[model.uuid] = {};
    const setEntities = [IFCPROPERTYSET, IFCELEMENTQUANTITY];
    for (const relation of this.relationsToProcess) {
      IfcPropertiesUtils.getRelationMap(properties, relation, (relationID, relatedIDs) => {
        const relationEntity = properties[relationID];
        if (!setEntities.includes(relationEntity.type))
          this.setEntityIndex(model, relationID);
        for (const expressID of relatedIDs) {
          this.setEntityIndex(model, expressID).add(relationID);
        }
      });
    }
  }
  async renderProperties(model, expressID) {
    await this.cleanPropertiesList();
    const topToolbar = this.uiElement.get("topToolbar");
    const propsList = this.uiElement.get("propsList");
    const propsWindow = this.uiElement.get("propertiesWindow");
    const ui = this.newEntityUI(model, expressID);
    if (!ui)
      return;
    if (this._propertiesManager) {
      this._propertiesManager.selectedModel = model;
      const exporter = this._propertiesManager.uiElement.get("exportButton");
      topToolbar.addChild(exporter);
    }
    const { properties } = IfcPropertiesManager.getIFCInfo(model);
    const { name } = IfcPropertiesUtils.getEntityName(properties, expressID);
    propsWindow.description = name;
    propsList.addChild(...[ui].flat());
  }
  newEntityUI(model, expressID) {
    const properties = model.properties;
    if (!properties)
      throw new Error("FragmentsGroup properties not found.");
    const modelElementsIndexation = this._indexMap[model.uuid];
    if (!modelElementsIndexation)
      return null;
    const entity = properties[expressID];
    const ignorable = this.entitiesToIgnore.includes(entity === null || entity === void 0 ? void 0 : entity.type);
    if (!entity || ignorable)
      return null;
    if (entity.type === IFCPROPERTYSET)
      return this.newPsetUI(model, expressID);
    const mainGroup = this.newEntityTree(model, expressID);
    if (!mainGroup)
      return null;
    this.addEntityActions(model, expressID, mainGroup);
    mainGroup.onExpand.add(() => {
      var _a2, _b2;
      const { uiProcessed } = mainGroup.data;
      if (uiProcessed)
        return;
      mainGroup.addChild(...this.newAttributesUI(model, expressID));
      const elementPropsIndexation = (_a2 = modelElementsIndexation[expressID]) !== null && _a2 !== void 0 ? _a2 : [];
      for (const id of elementPropsIndexation) {
        const entity2 = properties[id];
        if (!entity2)
          continue;
        const renderFunction = (_b2 = this._renderFunctions[entity2.type]) !== null && _b2 !== void 0 ? _b2 : this._renderFunctions[0];
        const ui = modelElementsIndexation[id] ? this.newEntityUI(model, id) : renderFunction(model, id);
        if (!ui)
          continue;
        mainGroup.addChild(...[ui].flat());
      }
      mainGroup.data.uiProcessed = true;
    });
    return mainGroup;
  }
  setEntityIndex(model, expressID) {
    if (!this._indexMap[model.uuid][expressID])
      this._indexMap[model.uuid][expressID] = /* @__PURE__ */ new Set();
    return this._indexMap[model.uuid][expressID];
  }
  newAttributesUI(model, expressID) {
    const { properties } = IfcPropertiesManager.getIFCInfo(model);
    if (!properties)
      return [];
    const attributesGroup = new AttributeSet(this.components, this, model, expressID);
    attributesGroup.attributesToIgnore = this.attributesToIgnore;
    return [attributesGroup];
  }
  newPsetUI(model, psetID) {
    const { properties } = IfcPropertiesManager.getIFCInfo(model);
    const uiGroups = [];
    const pset = properties[psetID];
    if (pset.type !== IFCPROPERTYSET)
      return uiGroups;
    const uiGroup = this.newEntityTree(model, psetID);
    if (!uiGroup)
      return uiGroups;
    this.addPsetActions(model, psetID, uiGroup);
    uiGroup.onExpand.add(() => {
      const { uiProcessed } = uiGroup.data;
      if (uiProcessed)
        return;
      const psetPropsID = IfcPropertiesUtils.getPsetProps(properties, psetID, (propID) => {
        const prop = properties[propID];
        if (!prop)
          return;
        const tag = this.newPropertyTag(model, psetID, propID, "NominalValue");
        if (tag)
          uiGroup.addChild(tag);
      });
      if (!psetPropsID || psetPropsID.length === 0) {
        const template = `
         <p class="text-base text-gray-500 py-1 px-3">
            This pset has no properties.
         </p>
        `;
        const notFoundText = new SimpleUIComponent(this.components, template);
        uiGroup.addChild(notFoundText);
      }
      uiGroup.data.uiProcessed = true;
    });
    uiGroups.push(uiGroup);
    return uiGroups;
  }
  newQsetUI(model, qsetID) {
    const { properties } = IfcPropertiesManager.getIFCInfo(model);
    const uiGroups = [];
    const qset = properties[qsetID];
    if (qset.type !== IFCELEMENTQUANTITY)
      return uiGroups;
    const uiGroup = this.newEntityTree(model, qsetID);
    if (!uiGroup)
      return uiGroups;
    this.addPsetActions(model, qsetID, uiGroup);
    IfcPropertiesUtils.getQsetQuantities(properties, qsetID, (quantityID) => {
      const { key } = IfcPropertiesUtils.getQuantityValue(properties, quantityID);
      if (!key)
        return;
      const tag = this.newPropertyTag(model, qsetID, quantityID, key);
      if (tag)
        uiGroup.addChild(tag);
    });
    uiGroups.push(uiGroup);
    return uiGroups;
  }
  addPsetActions(model, psetID, uiGroup) {
    if (!this.propertiesManager)
      return;
    const propsUI = this.propertiesManager.uiElement;
    const psetActions = propsUI.get("psetActions");
    const event = this.propertiesManager.setAttributeListener(model, psetID, "Name");
    event.add((v3) => uiGroup.description = v3.toString());
    uiGroup.innerElements.titleContainer.onmouseenter = () => {
      psetActions.data = { model, psetID };
      uiGroup.slots.titleRight.addChild(psetActions);
    };
    uiGroup.innerElements.titleContainer.onmouseleave = () => {
      if (psetActions.modalVisible)
        return;
      psetActions.removeFromParent();
      psetActions.cleanData();
    };
  }
  addEntityActions(model, expressID, uiGroup) {
    if (!this.propertiesManager)
      return;
    const propsUI = this.propertiesManager.uiElement;
    const entityActions = propsUI.get("entityActions");
    uiGroup.innerElements.titleContainer.onmouseenter = () => {
      entityActions.data = { model, elementIDs: [expressID] };
      uiGroup.slots.titleRight.addChild(entityActions);
    };
    uiGroup.innerElements.titleContainer.onmouseleave = () => {
      if (entityActions.modal.visible)
        return;
      entityActions.removeFromParent();
      entityActions.cleanData();
    };
  }
  newEntityTree(model, expressID) {
    const { properties } = IfcPropertiesManager.getIFCInfo(model);
    const entity = properties[expressID];
    if (!entity)
      return null;
    const currentUI = this._currentUI[expressID];
    if (currentUI)
      return currentUI;
    const entityTree = new TreeView(this.components);
    this._currentUI[expressID] = entityTree;
    entityTree.title = `${IfcCategoryMap[entity.type]}`;
    const { name } = IfcPropertiesUtils.getEntityName(properties, expressID);
    entityTree.description = name;
    return entityTree;
  }
  newPropertyTag(model, setID, expressID, valueKey) {
    const { properties } = IfcPropertiesManager.getIFCInfo(model);
    const entity = properties[expressID];
    if (!entity)
      return null;
    const tag = new PropertyTag(this.components, this, model, expressID);
    this._currentUI[expressID] = tag;
    if (!this.propertiesManager)
      return tag;
    const propsUI = this.propertiesManager.uiElement;
    const propActions = propsUI.get("propActions");
    tag.get().onmouseenter = () => {
      propActions.data = { model, setID, expressID, valueKey };
      tag.addChild(propActions);
    };
    tag.get().onmouseleave = () => {
      if (propActions.modalVisible)
        return;
      propActions.removeFromParent();
      propActions.cleanData();
    };
    return tag;
  }
  cloneProperty(item, result = {}) {
    if (!item) {
      return result;
    }
    for (const key in item) {
      const value = item[key];
      const isArray2 = Array.isArray(value);
      const isObject = typeof value === "object" && !isArray2 && value !== null;
      if (isArray2) {
        result[key] = [];
        const subResult = result[key];
        this.clonePropertyArray(value, subResult);
      } else if (isObject) {
        result[key] = {};
        const subResult = result[key];
        this.cloneProperty(value, subResult);
      } else {
        result[key] = value;
      }
    }
    return result;
  }
  clonePropertyArray(item, result) {
    for (const value of item) {
      const isArray2 = Array.isArray(value);
      const isObject = typeof value === "object" && !isArray2 && value !== null;
      if (isArray2) {
        const subResult = [];
        result.push(subResult);
        this.clonePropertyArray(value, subResult);
      } else if (isObject) {
        const subResult = {};
        result.push(subResult);
        this.cloneProperty(value, subResult);
      } else {
        result.push(value);
      }
    }
  }
};
IfcPropertiesProcessor.uuid = "23a889ab-83b3-44a4-8bee-ead83438370b";
ToolComponent.libraryUUIDs.add(IfcPropertiesProcessor.uuid);

// node_modules/openbim-components/ifc/IfcPropertiesFinder/src/attribute-query.js
var AttributeQueryUI = class extends SimpleUIComponent {
  // Is ok to use Type Assertion in this case?
  get query() {
    const attribute = this.attribute.value;
    const condition = this.condition.value;
    const operator = this.operator.value || null;
    const value = attribute === "type" ? this.getTypeConstant(this.ifcTypes.value) : this.value.value;
    const negateResult = this.negate.value === "NOT A";
    const query = {
      attribute,
      condition,
      value,
      negateResult,
      operator
    };
    if (this.operator.visible)
      query.operator = this.operator.value;
    return query;
  }
  set query(value) {
    if (value.operator) {
      this.operator.value = value.operator;
      this.operator.visible = true;
    }
    this.attribute.value = value.attribute;
    this.condition.value = value.condition;
    this.negate.value = value.negateResult ? "NOT A" : "A";
    if (value.attribute === "type") {
      if (typeof value.value !== "number") {
        throw new Error("Corrupted IfcPropertiesFinder cached data!");
      }
      this.value.value = "";
      this.ifcTypes.value = IfcCategoryMap[value.value];
    } else {
      this.ifcTypes.value = null;
      this.value.value = String(value.value);
    }
  }
  getTypeConstant(value) {
    for (const [key, val] of Object.entries(IfcCategoryMap)) {
      if (val === value)
        return Number(key);
    }
    return null;
  }
  constructor(components) {
    super(components, `<div class="flex gap-x-2"></div>`);
    this.negate = new Dropdown(components);
    const negateClass = this.negate.domElement.classList;
    negateClass.remove("w-full");
    negateClass.add("min-w-[4.5rem]");
    this.negate.label = "Sign";
    this.negate.addOption("A", "NOT A");
    this.negate.value = "A";
    this.operator = new Dropdown(components);
    this.operator.visible = false;
    this.operator.label = "Operator";
    this.operator.get().style.width = "300px";
    this.operator.addOption("AND", "OR");
    this.attribute = new Dropdown(components);
    this.attribute.label = "Attribute";
    this.attribute.addOption("type", "Name", "PredefinedType", "NominalValue", "Description");
    this.attribute.onChange.add((selection) => {
      const attributeIsType = selection === "type";
      this.value.visible = !attributeIsType;
      this.ifcTypes.visible = attributeIsType;
    });
    this.condition = new Dropdown(components);
    this.condition.label = "Condition";
    this.condition.addOption("is", "includes", "startsWith", "endsWith", "matches");
    this.condition.value = this.condition.options[0];
    this.value = new TextInput(components);
    this.value.label = "Value";
    this.ifcTypes = new Dropdown(components);
    this.ifcTypes.allowSearch = true;
    this.ifcTypes.visible = false;
    this.ifcTypes.label = "Value";
    for (const type2 of Object.values(IfcCategoryMap)) {
      this.ifcTypes.addOption(type2);
    }
    this.ifcTypes.value = "IFCWALL";
    this.removeBtn = new Button(components, { materialIconName: "remove" });
    this.removeBtn.visible = false;
    this.removeBtn.get().classList.remove("mt-auto", "hover:bg-ifcjs-200");
    this.removeBtn.get().classList.add("mt-auto", "mb-2", "hover:bg-error");
    this.removeBtn.onClick.add(async () => {
      if (this.parent instanceof SimpleUIComponent)
        this.parent.removeChild(this);
      await this.dispose();
    });
    this.addChild(this.operator, this.attribute, this.condition, this.negate, this.value, this.ifcTypes, this.removeBtn);
    this.attribute.value = "Name";
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    await this.operator.dispose();
    await this.attribute.dispose();
    await this.condition.dispose();
    await this.value.dispose();
    await this.ifcTypes.dispose();
    await this.removeBtn.dispose();
    await this.negate.dispose();
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesFinder/src/query-group.js
var QueryGroupUI = class extends SimpleUIComponent {
  get query() {
    const queriesMap = this.children.map((child) => {
      if (!(child instanceof AttributeQueryUI))
        return null;
      return child.query;
    });
    const queries = queriesMap.filter((query2) => query2 !== null);
    const query = { queries };
    if (this.operator.visible)
      query.operator = this.operator.value;
    return query;
  }
  set query(value) {
    if (value.operator)
      this.operator.value = value.operator;
    for (const child of this.children) {
      if (!(child instanceof AttributeQueryUI))
        continue;
      this.removeChild(child);
      child.dispose();
    }
    let first = true;
    for (const [index, query] of value.queries.entries()) {
      if (!query.condition)
        continue;
      const attributeQuery = query;
      if (index === 0 && attributeQuery.operator) {
        delete attributeQuery.operator;
      }
      const attributeQueryUI = new AttributeQueryUI(this._components);
      attributeQueryUI.query = attributeQuery;
      this.addChild(attributeQueryUI);
      if (first) {
        first = false;
      } else {
        attributeQueryUI.removeBtn.visible = true;
      }
    }
  }
  constructor(components) {
    super(components, `<div class="flex flex-col gap-y-3 p-3 border border-solid border-ifcjs-120 rounded-md"></div>`);
    this.operator = new Dropdown(components);
    this.operator.visible = false;
    this.operator.label = null;
    this.operator.addOption("AND", "OR");
    const topContainer = new SimpleUIComponent(components, `<div class="flex gap-x-2 w-fit ml-auto"></div>`);
    const newRuleBtn = new Button(components, { materialIconName: "add" });
    newRuleBtn.get().classList.add("w-fit");
    newRuleBtn.label = "Add Rule";
    newRuleBtn.onClick.add(() => {
      const propertyQuery2 = new AttributeQueryUI(components);
      propertyQuery2.operator.visible = true;
      propertyQuery2.operator.value = propertyQuery2.operator.options[0];
      propertyQuery2.removeBtn.visible = true;
      this.addChild(propertyQuery2);
    });
    const newGroupBtn = new Button(components, { materialIconName: "add" });
    newGroupBtn.get().classList.add("w-fit");
    newGroupBtn.label = "Add Group";
    this.removeBtn = new Button(components, { materialIconName: "delete" });
    this.removeBtn.label = "Delete Group";
    this.removeBtn.visible = false;
    this.removeBtn.onClick.add(async () => {
      if (this.parent instanceof SimpleUIComponent)
        this.parent.removeChild(this);
      await this.dispose();
    });
    topContainer.addChild(newRuleBtn, this.removeBtn);
    const propertyQuery = new AttributeQueryUI(components);
    this.addChild(topContainer, this.operator, propertyQuery);
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    await this.operator.dispose();
    await this.removeBtn.dispose();
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesFinder/src/query-builder.js
var QueryBuilder = class extends SimpleUIComponent {
  get query() {
    const queriesMap = this.children.map((child) => {
      if (!(child instanceof QueryGroupUI))
        return null;
      return child.query;
    });
    return queriesMap.filter((query) => query !== null);
  }
  set query(value) {
    for (const child of this.children) {
      if (child instanceof QueryGroupUI) {
        this.removeChild(child);
        child.dispose();
      }
    }
    let first = true;
    for (const [index, group] of value.entries()) {
      if (index === 0 && group.operator) {
        delete group.operator;
      }
      const attributeQueryUI = new QueryGroupUI(this._components);
      attributeQueryUI.removeBtn.visible = true;
      attributeQueryUI.query = group;
      this.addChild(attributeQueryUI);
      if (first) {
        first = false;
        attributeQueryUI.removeBtn.visible = false;
      }
    }
    this.get().append(this.findButton.get());
    this.onQuerySet.trigger(value);
  }
  constructor(components) {
    super(components, `<div class="flex flex-col gap-y-3"></div>`);
    this.onQuerySet = new Event();
    this.findButton = new Button(this._components, {
      materialIconName: "search"
    });
    this.findButton.label = "Find";
    this.findButton.alignment = "center";
    this.findButton.get().classList.add("border", "border-solid", "border-ifcjs-120", "hover:border-ifcjs-200");
    const topContainer = new SimpleUIComponent(this._components, `<div class="flex gap-x-2 w-fit ml-auto"></div>`);
    const newGroupBtn = new Button(this._components, {
      materialIconName: "add"
    });
    newGroupBtn.get().classList.add("w-fit");
    newGroupBtn.label = "Add Group";
    newGroupBtn.onClick.add(() => {
      const queryGroup = new QueryGroupUI(this._components);
      queryGroup.operator.visible = true;
      queryGroup.operator.value = queryGroup.operator.options[0];
      queryGroup.removeBtn.visible = true;
      this.addChild(queryGroup);
      this.get().append(this.findButton.get());
    });
    const resetBtn = new Button(this._components, {
      materialIconName: "refresh"
    });
    resetBtn.label = "Reset";
    topContainer.addChild(newGroupBtn);
    const queryEditor = new QueryGroupUI(this._components);
    this.addChild(topContainer, queryEditor, this.findButton);
  }
  async dispose(onlyChildren = false) {
    await super.dispose(onlyChildren);
    await this.findButton.dispose();
    this.onQuerySet.reset();
  }
};

// node_modules/openbim-components/ifc/IfcPropertiesFinder/index.js
var IfcPropertiesFinder = class extends Component {
  constructor(components) {
    super(components);
    this.onFound = new Event();
    this.enabled = true;
    this.uiElement = new UIElement();
    this._localStorageID = "IfcPropertiesFinder";
    this._indexedModels = {};
    this._noHandleAttributes = ["type"];
    this._conditionFunctions = this.getConditionFunctions();
  }
  async init() {
    if (this.components.ui.enabled) {
      await this.setUI();
    }
  }
  get() {
    return this._indexedModels;
  }
  async dispose() {
    this._indexedModels = {};
    this.onFound.reset();
    this.uiElement.dispose();
  }
  loadCached(id) {
    if (id) {
      this._localStorageID = `IfcPropertiesFinder-${id}`;
    }
    const serialized = localStorage.getItem(this._localStorageID);
    if (!serialized)
      return;
    const groups = JSON.parse(serialized);
    const queryBuilder = this.uiElement.get("query");
    queryBuilder.query = groups;
  }
  deleteCache() {
    localStorage.removeItem(this._localStorageID);
  }
  async setUI() {
    const main2 = new Button(this.components, {
      materialIconName: "manage_search"
    });
    const queryWindow = new FloatingWindow(this.components);
    this.components.ui.add(queryWindow);
    const fragments = await this.components.tools.get(FragmentManager);
    queryWindow.get().classList.add("overflow-visible");
    queryWindow.get().style.width = "700px";
    queryWindow.get().style.height = "420px";
    queryWindow.visible = false;
    queryWindow.resizeable = false;
    queryWindow.title = "Model Queries";
    main2.onClick.add(() => {
      queryWindow.visible = !queryWindow.visible;
    });
    queryWindow.onVisible.add(() => main2.active = true);
    queryWindow.onHidden.add(() => main2.active = false);
    const query = new QueryBuilder(this.components);
    query.findButton.onClick.add(async () => {
      const model = fragments.groups[0];
      if (!model)
        return;
      await this.find();
    });
    queryWindow.addChild(query);
    this.uiElement.set({
      main: main2,
      queryWindow,
      query
    });
  }
  indexEntityRelations(model) {
    const map = {};
    const { properties } = IfcPropertiesManager.getIFCInfo(model);
    IfcPropertiesUtils.getRelationMap(properties, IFCRELDEFINESBYPROPERTIES, (relatingID, relatedIDs) => {
      if (!map[relatingID])
        map[relatingID] = /* @__PURE__ */ new Set();
      const props2 = [];
      IfcPropertiesUtils.getPsetProps(properties, relatingID, (propID) => {
        props2.push(propID);
        map[relatingID].add(propID);
        if (!map[propID])
          map[propID] = /* @__PURE__ */ new Set();
        map[propID].add(relatingID);
      });
      for (const relatedID of relatedIDs) {
        map[relatingID].add(relatedID);
        for (const propID of props2)
          map[propID].add(relatedID);
        if (!map[relatedID])
          map[relatedID] = /* @__PURE__ */ new Set();
        map[relatedID].add(relatedID);
      }
    });
    const ifcRelations = [
      IFCRELCONTAINEDINSPATIALSTRUCTURE,
      IFCRELDEFINESBYTYPE,
      IFCRELASSIGNSTOGROUP
    ];
    for (const relation of ifcRelations) {
      IfcPropertiesUtils.getRelationMap(properties, relation, (relatingID, relatedIDs) => {
        if (!map[relatingID])
          map[relatingID] = /* @__PURE__ */ new Set();
        for (const relatedID of relatedIDs) {
          map[relatingID].add(relatedID);
          if (!map[relatedID])
            map[relatedID] = /* @__PURE__ */ new Set();
          map[relatedID].add(relatedID);
        }
      });
    }
    this._indexedModels[model.uuid] = map;
    return map;
  }
  async find(queryGroups, queryModels) {
    const fragments = await this.components.tools.get(FragmentManager);
    const queries = this.uiElement.get("query");
    const models = queryModels || fragments.groups;
    const groups = queryGroups || queries.query;
    const result = {};
    this.cache();
    for (const model of models) {
      let map = this._indexedModels[model.uuid];
      if (!map)
        map = this.indexEntityRelations(model);
      let relations = [];
      for (const [index, group] of groups.entries()) {
        const excludedItems = /* @__PURE__ */ new Set();
        const groupResult = this.simpleQuery(model, group, excludedItems);
        const groupRelations = [];
        for (const expressID of groupResult) {
          const relations2 = map[expressID];
          if (!relations2)
            continue;
          groupRelations.push(expressID);
          for (const id of relations2) {
            if (!excludedItems.has(id)) {
              groupRelations.push(id);
            }
          }
        }
        relations = group.operator === "AND" && index > 0 ? this.getCommonElements(relations, groupRelations) : [...relations, ...groupRelations];
      }
      const modelEntities = /* @__PURE__ */ new Set();
      for (const expressID in model.data) {
        const included = relations.includes(Number(expressID));
        if (!included)
          continue;
        modelEntities.add(Number(expressID));
      }
      const otherEntities = /* @__PURE__ */ new Set();
      for (const expressID of relations) {
        const included = modelEntities.has(expressID);
        if (included)
          continue;
        otherEntities.add(expressID);
      }
      result[model.uuid] = { modelEntities, otherEntities };
    }
    const foundFragments = await this.toFragmentMap(result);
    await this.onFound.trigger(foundFragments);
    return foundFragments;
  }
  async toFragmentMap(data) {
    const fragments = await this.components.tools.get(FragmentManager);
    const fragmentMap = {};
    for (const modelID in data) {
      const model = fragments.groups.find((m2) => m2.uuid === modelID);
      if (!model)
        continue;
      const matchingEntities = data[modelID].modelEntities;
      for (const expressID of matchingEntities) {
        const data2 = model.data[expressID];
        if (!data2)
          continue;
        for (const key of data2[0]) {
          const fragmentID = model.keyFragments[key];
          if (!fragmentMap[fragmentID]) {
            fragmentMap[fragmentID] = /* @__PURE__ */ new Set();
          }
          fragmentMap[fragmentID].add(String(expressID));
        }
      }
    }
    return fragmentMap;
  }
  simpleQuery(model, queryGroup, excludedItems) {
    var _a2;
    const properties = model.properties;
    if (!properties)
      throw new Error("Model has no properties");
    let filteredProps = {};
    let iterations = 0;
    let matchingEntities = [];
    for (const query of queryGroup.queries) {
      let queryResult = [];
      const workingProps = query.operator === "AND" ? filteredProps : properties;
      const isAttributeQuery = query.condition;
      if (isAttributeQuery) {
        const matchingResult = this.getMatchingEntities(workingProps, query, excludedItems);
        queryResult = matchingResult.expressIDs;
        filteredProps = { ...filteredProps, ...matchingResult.entities };
      } else {
        queryResult = [
          ...this.simpleQuery(model, query, excludedItems)
        ];
      }
      matchingEntities = iterations === 0 ? queryResult : this.combineArrays(
        matchingEntities,
        queryResult,
        (_a2 = query.operator) !== null && _a2 !== void 0 ? _a2 : "AND"
        // Defaults to AND if iterations > 0 and query.operator is not defined
      );
      iterations++;
    }
    return new Set(matchingEntities);
  }
  getMatchingEntities(entities, query, excludedItems) {
    const { attribute: attributeName, condition } = query;
    let { value } = query;
    const handleAttribute = !this._noHandleAttributes.includes(attributeName);
    const expressIDs = [];
    const matchingEntities = [];
    for (const expressID in entities) {
      const entity = entities[expressID];
      if (entity === void 0) {
        continue;
      }
      const attribute = entity[attributeName];
      let attributeValue = handleAttribute ? attribute === null || attribute === void 0 ? void 0 : attribute.value : attribute;
      if (attributeValue === void 0 || attributeValue === null)
        continue;
      const type1 = typeof value;
      const type2 = typeof attributeValue;
      if (type1 === "number" && type2 === "string") {
        value = value.toString();
      } else if (type1 === "string" && type2 === "number") {
        attributeValue = attributeValue.toString();
      }
      let conditionMatches = this._conditionFunctions[condition](attributeValue, value);
      if (query.negateResult) {
        conditionMatches = !conditionMatches;
      }
      if (!conditionMatches) {
        if (query.negateResult) {
          excludedItems.add(entity.expressID);
        }
        continue;
      }
      expressIDs.push(entity.expressID);
      matchingEntities.push(entity);
    }
    return { expressIDs, entities: matchingEntities, excludedItems };
  }
  combineArrays(arrA, arrB, operator) {
    if (!operator)
      return arrB;
    return operator === "AND" ? this.arrayIntersection(arrA, arrB) : this.arrayUnion(arrA, arrB);
  }
  getCommonElements(...lists) {
    const result = [];
    const elementsCount = /* @__PURE__ */ new Map();
    for (const list of lists) {
      const uniqueElements = new Set(list);
      for (const element of uniqueElements) {
        if (elementsCount.has(element)) {
          elementsCount.set(element, elementsCount.get(element) + 1);
        } else {
          elementsCount.set(element, 1);
        }
      }
    }
    for (const [element, count] of elementsCount) {
      if (count === lists.length) {
        result.push(element);
      }
    }
    return result;
  }
  arrayIntersection(arrA, arrB) {
    return arrA.filter((x) => arrB.includes(x));
  }
  arrayUnion(arrA, arrB) {
    return [...arrA, ...arrB];
  }
  cache() {
    const queryBuilder = this.uiElement.get("query");
    const query = queryBuilder.query;
    const serialized = JSON.stringify(query);
    localStorage.setItem(this._localStorageID, serialized);
  }
  getConditionFunctions() {
    return {
      is: (leftValue, rightValue) => {
        return leftValue === rightValue;
      },
      includes: (leftValue, rightValue) => {
        return leftValue.toString().includes(rightValue.toString());
      },
      startsWith: (leftValue, rightValue) => {
        return leftValue.toString().startsWith(rightValue.toString());
      },
      endsWith: (leftValue, rightValue) => {
        return leftValue.toString().endsWith(rightValue.toString());
      },
      matches: (leftValue, rightValue) => {
        const regex = new RegExp(rightValue.toString());
        return regex.test(leftValue.toString());
      }
    };
  }
};

// node_modules/openbim-components/fragments/FragmentIfcLoader/src/units.js
var Units = class {
  constructor() {
    this.factor = 1;
    this.complement = 1;
  }
  apply(matrix) {
    const scale = this.getScaleMatrix();
    const result = scale.multiply(matrix);
    matrix.copy(result);
  }
  setUp(webIfc) {
    var _a2;
    this.factor = 1;
    const length = this.getLengthUnits(webIfc);
    if (!length) {
      return;
    }
    const isLengthNull = length === void 0 || length === null;
    const isValueNull = length.Name === void 0 || length.Name === null;
    if (isLengthNull || isValueNull) {
      return;
    }
    if (length.Name.value === "FOOT") {
      this.factor = 0.3048;
    } else if (((_a2 = length.Prefix) === null || _a2 === void 0 ? void 0 : _a2.value) === "MILLI") {
      this.complement = 1e-3;
    }
  }
  getLengthUnits(webIfc) {
    try {
      const allUnitsAssigns = webIfc.GetLineIDsWithType(0, IFCUNITASSIGNMENT);
      const unitsAssign = allUnitsAssigns.get(0);
      const unitsAssignProps = webIfc.GetLine(0, unitsAssign);
      for (const units of unitsAssignProps.Units) {
        if (!units || units.value === null || units.value === void 0) {
          continue;
        }
        const unitsProps = webIfc.GetLine(0, units.value);
        if (unitsProps.UnitType && unitsProps.UnitType.value === "LENGTHUNIT") {
          return unitsProps;
        }
      }
      return null;
    } catch (e) {
      console.log("Could not get units");
      return null;
    }
  }
  getScaleMatrix() {
    const f = this.factor;
    return new Matrix4().fromArray([
      f,
      0,
      0,
      0,
      0,
      f,
      0,
      0,
      0,
      0,
      f,
      0,
      0,
      0,
      0,
      1
    ]);
  }
};

// node_modules/openbim-components/fragments/FragmentIfcLoader/src/spatial-structure.js
var SpatialStructure = class {
  constructor() {
    this.itemsByFloor = {};
    this._units = new Units();
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  async setUp(webIfc) {
    this._units.setUp(webIfc);
    this.cleanUp();
    try {
      const spatialRels = webIfc.GetLineIDsWithType(0, IFCRELCONTAINEDINSPATIALSTRUCTURE);
      const allRooms = /* @__PURE__ */ new Set();
      const rooms = webIfc.GetLineIDsWithType(0, IFCSPACE);
      for (let i = 0; i < rooms.size(); i++) {
        allRooms.add(rooms.get(i));
      }
      const aggregates = webIfc.GetLineIDsWithType(0, IFCRELAGGREGATES);
      const aggregatesSize = aggregates.size();
      for (let i = 0; i < aggregatesSize; i++) {
        const id = aggregates.get(i);
        const properties = webIfc.GetLine(0, id);
        if (!properties || !properties.RelatingObject || !properties.RelatedObjects) {
          continue;
        }
        const parentID = properties.RelatingObject.value;
        const childsIDs = properties.RelatedObjects;
        for (const child of childsIDs) {
          const childID = child.value;
          if (allRooms.has(childID)) {
            this.itemsByFloor[childID] = parentID;
          }
        }
      }
      const itemsContainedInRooms = {};
      const spatialRelsSize = spatialRels.size();
      for (let i = 0; i < spatialRelsSize; i++) {
        const id = spatialRels.get(i);
        const properties = webIfc.GetLine(0, id);
        if (!properties || !properties.RelatingStructure || !properties.RelatedElements) {
          continue;
        }
        const structureID = properties.RelatingStructure.value;
        const relatedItems = properties.RelatedElements;
        if (allRooms.has(structureID)) {
          for (const related of relatedItems) {
            if (!itemsContainedInRooms[structureID]) {
              itemsContainedInRooms[structureID] = [];
            }
            const id2 = related.value;
            itemsContainedInRooms[structureID].push(id2);
          }
        } else {
          for (const related of relatedItems) {
            const id2 = related.value;
            this.itemsByFloor[id2] = structureID;
          }
        }
      }
      for (const roomID in itemsContainedInRooms) {
        const roomFloor = this.itemsByFloor[roomID];
        if (roomFloor !== void 0) {
          const items = itemsContainedInRooms[roomID];
          for (const item of items) {
            this.itemsByFloor[item] = roomFloor;
          }
        }
      }
      for (let i = 0; i < aggregatesSize; i++) {
        const id = aggregates.get(i);
        const properties = webIfc.GetLine(0, id);
        if (!properties || !properties.RelatingObject || !properties.RelatedObjects) {
          continue;
        }
        const parentID = properties.RelatingObject.value;
        const childsIDs = properties.RelatedObjects;
        for (const child of childsIDs) {
          const childID = child.value;
          const parentStructure = this.itemsByFloor[parentID];
          if (parentStructure !== void 0) {
            this.itemsByFloor[childID] = parentStructure;
          }
        }
      }
    } catch (e) {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
};

// node_modules/openbim-components/fragments/FragmentIfcLoader/src/ifc-fragment-settings.js
var IfcFragmentSettings = class {
  constructor() {
    this.includeProperties = true;
    this.optionalCategories = [IFCSPACE];
    this.coordinate = true;
    this.wasm = {
      path: "",
      absolute: false
    };
    this.excludedCategories = /* @__PURE__ */ new Set();
    this.saveLocations = false;
    this.webIfc = {
      COORDINATE_TO_ORIGIN: true,
      USE_FAST_BOOLS: true,
      OPTIMIZE_PROFILES: true
    };
  }
};

// node_modules/openbim-components/fragments/FragmentBoundingBox/index.js
var FragmentBoundingBox = class _FragmentBoundingBox extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this._meshes = [];
    this.components.tools.add(_FragmentBoundingBox.uuid, this);
    this._absoluteMin = _FragmentBoundingBox.newBound(true);
    this._absoluteMax = _FragmentBoundingBox.newBound(false);
  }
  static getDimensions(bbox) {
    const { min: min2, max: max2 } = bbox;
    const width = Math.abs(max2.x - min2.x);
    const height = Math.abs(max2.y - min2.y);
    const depth = Math.abs(max2.z - min2.z);
    const center = new Vector3();
    center.subVectors(max2, min2).divideScalar(2).add(min2);
    return { width, height, depth, center };
  }
  static newBound(positive) {
    const factor = positive ? 1 : -1;
    return new Vector3(factor * Number.MAX_VALUE, factor * Number.MAX_VALUE, factor * Number.MAX_VALUE);
  }
  static getBounds(points, min2, max2) {
    const maxPoint = max2 || this.newBound(false);
    const minPoint = min2 || this.newBound(true);
    for (const point of points) {
      if (point.x < minPoint.x)
        minPoint.x = point.x;
      if (point.y < minPoint.y)
        minPoint.y = point.y;
      if (point.z < minPoint.z)
        minPoint.z = point.z;
      if (point.x > maxPoint.x)
        maxPoint.x = point.x;
      if (point.y > maxPoint.y)
        maxPoint.y = point.y;
      if (point.z > maxPoint.z)
        maxPoint.z = point.z;
    }
    return new Box3(min2, max2);
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    const disposer = await this.components.tools.get(Disposer);
    for (const mesh of this._meshes) {
      disposer.destroy(mesh);
    }
    this._meshes = [];
  }
  get() {
    const min2 = this._absoluteMin.clone();
    const max2 = this._absoluteMax.clone();
    return new Box3(min2, max2);
  }
  getSphere() {
    const min2 = this._absoluteMin.clone();
    const max2 = this._absoluteMax.clone();
    const dx = Math.abs((max2.x - min2.x) / 2);
    const dy = Math.abs((max2.y - min2.y) / 2);
    const dz = Math.abs((max2.z - min2.z) / 2);
    const center = new Vector3(min2.x + dx, min2.y + dy, min2.z + dz);
    const radius = center.distanceTo(min2);
    return new Sphere(center, radius);
  }
  getMesh() {
    const bbox = new Box3(this._absoluteMin, this._absoluteMax);
    const dimensions = _FragmentBoundingBox.getDimensions(bbox);
    const { width, height, depth, center } = dimensions;
    const box = new BoxGeometry(width, height, depth);
    const mesh = new Mesh(box);
    this._meshes.push(mesh);
    mesh.position.copy(center);
    return mesh;
  }
  reset() {
    this._absoluteMin = _FragmentBoundingBox.newBound(true);
    this._absoluteMax = _FragmentBoundingBox.newBound(false);
  }
  add(group) {
    for (const frag of group.items) {
      this.addMesh(frag.mesh);
    }
  }
  addMesh(mesh) {
    if (!mesh.geometry.index) {
      return;
    }
    const bbox = _FragmentBoundingBox.getFragmentBounds(mesh);
    mesh.updateMatrix();
    const meshTransform = mesh.matrix;
    const instanceTransform = new Matrix4();
    for (let i = 0; i < mesh.count; i++) {
      mesh.getMatrixAt(i, instanceTransform);
      const min2 = bbox.min.clone();
      const max2 = bbox.max.clone();
      min2.applyMatrix4(instanceTransform);
      min2.applyMatrix4(meshTransform);
      max2.applyMatrix4(instanceTransform);
      max2.applyMatrix4(meshTransform);
      if (min2.x < this._absoluteMin.x)
        this._absoluteMin.x = min2.x;
      if (min2.y < this._absoluteMin.y)
        this._absoluteMin.y = min2.y;
      if (min2.z < this._absoluteMin.z)
        this._absoluteMin.z = min2.z;
      if (min2.x > this._absoluteMax.x)
        this._absoluteMax.x = min2.x;
      if (min2.y > this._absoluteMax.y)
        this._absoluteMax.y = min2.y;
      if (min2.z > this._absoluteMax.z)
        this._absoluteMax.z = min2.z;
      if (max2.x > this._absoluteMax.x)
        this._absoluteMax.x = max2.x;
      if (max2.y > this._absoluteMax.y)
        this._absoluteMax.y = max2.y;
      if (max2.z > this._absoluteMax.z)
        this._absoluteMax.z = max2.z;
      if (max2.x < this._absoluteMin.x)
        this._absoluteMin.x = max2.x;
      if (max2.y < this._absoluteMin.y)
        this._absoluteMin.y = max2.y;
      if (max2.z < this._absoluteMin.z)
        this._absoluteMin.z = max2.z;
    }
  }
  static getFragmentBounds(mesh) {
    const position = mesh.geometry.attributes.position;
    const maxNum = Number.MAX_VALUE;
    const minNum = -maxNum;
    const min2 = new Vector3(maxNum, maxNum, maxNum);
    const max2 = new Vector3(minNum, minNum, minNum);
    if (!mesh.geometry.index) {
      throw new Error("Geometry must be indexed!");
    }
    const indices = Array.from(mesh.geometry.index.array);
    for (const index of indices) {
      const x = position.getX(index);
      const y = position.getY(index);
      const z = position.getZ(index);
      if (x < min2.x)
        min2.x = x;
      if (y < min2.y)
        min2.y = y;
      if (z < min2.z)
        min2.z = z;
      if (x > max2.x)
        max2.x = x;
      if (y > max2.y)
        max2.y = y;
      if (z > max2.z)
        max2.z = z;
    }
    return new Box3(min2, max2);
  }
};
FragmentBoundingBox.uuid = "d1444724-dba6-4cdd-a0c7-68ee1450d166";
ToolComponent.libraryUUIDs.add(FragmentBoundingBox.uuid);

// node_modules/openbim-components/fragments/FragmentIfcLoader/src/data-converter.js
var DataConverter = class {
  constructor(components) {
    this.settings = new IfcFragmentSettings();
    this.categories = {};
    this._model = new FragmentsGroup();
    this._ifcCategories = new IfcCategories();
    this._fragmentKey = 0;
    this._keyFragmentMap = {};
    this._itemKeyMap = {};
    this._propertyExporter = new IfcJsonExporter();
    this._spatialTree = new SpatialStructure();
    this.components = components;
  }
  cleanUp() {
    this._fragmentKey = 0;
    this._spatialTree.cleanUp();
    this.categories = {};
    this._model = new FragmentsGroup();
    this._ifcCategories = new IfcCategories();
    this._propertyExporter = new IfcJsonExporter();
    this._keyFragmentMap = {};
    this._itemKeyMap = {};
  }
  saveIfcCategories(webIfc) {
    this.categories = this._ifcCategories.getAll(webIfc, 0);
  }
  async generate(webIfc, geometries) {
    await this._spatialTree.setUp(webIfc);
    this.createAllFragments(geometries);
    await this.saveModelData(webIfc);
    return this._model;
  }
  async saveModelData(webIfc) {
    const itemsData = this.getFragmentsGroupData();
    this._model.keyFragments = this._keyFragmentMap;
    this._model.data = itemsData;
    this._model.coordinationMatrix = this.getCoordinationMatrix(webIfc);
    this._model.properties = await this.getModelProperties(webIfc);
    this._model.uuid = this.getProjectID(webIfc) || this._model.uuid;
    this._model.ifcMetadata = this.getIfcMetadata(webIfc);
    this._model.boundingBox = await this.getBoundingBox();
  }
  async getBoundingBox() {
    const bbox = await this.components.tools.get(FragmentBoundingBox);
    bbox.reset();
    bbox.add(this._model);
    return bbox.get();
  }
  getIfcMetadata(webIfc) {
    const { FILE_NAME, FILE_DESCRIPTION } = web_ifc_api_exports;
    const name = this.getMetadataEntry(webIfc, FILE_NAME);
    const description = this.getMetadataEntry(webIfc, FILE_DESCRIPTION);
    const schema = webIfc.GetModelSchema(0) || "IFC2X3";
    const maxExpressID = webIfc.GetMaxExpressID(0);
    return { name, description, schema, maxExpressID };
  }
  getMetadataEntry(webIfc, type2) {
    let description = "";
    const descriptionData = webIfc.GetHeaderLine(0, type2) || "";
    if (!descriptionData)
      return description;
    for (const arg of descriptionData.arguments) {
      if (arg === null || arg === void 0) {
        continue;
      }
      if (Array.isArray(arg)) {
        for (const subArg of arg) {
          description += `${subArg.value}|`;
        }
      } else {
        description += `${arg.value}|`;
      }
    }
    return description;
  }
  getProjectID(webIfc) {
    const projectsIDs = webIfc.GetLineIDsWithType(0, IFCPROJECT);
    const projectID = projectsIDs.get(0);
    const project = webIfc.GetLine(0, projectID);
    return project.GlobalId.value;
  }
  getCoordinationMatrix(webIfc) {
    const coordArray = webIfc.GetCoordinationMatrix(0);
    return new Matrix4().fromArray(coordArray);
  }
  async getModelProperties(webIfc) {
    if (!this.settings.includeProperties) {
      return {};
    }
    return new Promise((resolve) => {
      this._propertyExporter.onPropertiesSerialized.add((properties) => {
        resolve(properties);
      });
      this._propertyExporter.export(webIfc, 0);
    });
  }
  createAllFragments(geometries) {
    const uniqueItems = {};
    const matrix = new Matrix4();
    const color2 = new Color();
    for (const id in geometries) {
      const { buffer, instances } = geometries[id];
      const transparent = instances[0].color.w !== 1;
      const opacity = transparent ? 0.4 : 1;
      const material = new MeshLambertMaterial({ transparent, opacity });
      if (opacity !== 1) {
        material.depthWrite = false;
        material.polygonOffset = true;
        material.polygonOffsetFactor = 5;
        material.polygonOffsetUnits = 1;
      }
      if (instances.length === 1) {
        const instance = instances[0];
        const { x, y, z, w } = instance.color;
        const matID = `${x}-${y}-${z}-${w}`;
        if (!uniqueItems[matID]) {
          material.color = new Color().setRGB(x, y, z, "srgb");
          uniqueItems[matID] = { material, geometries: [], expressIDs: [] };
        }
        matrix.fromArray(instance.matrix);
        buffer.applyMatrix4(matrix);
        uniqueItems[matID].geometries.push(buffer);
        uniqueItems[matID].expressIDs.push(instance.expressID.toString());
        continue;
      }
      const fragment = new Fragment(buffer, material, instances.length);
      this._keyFragmentMap[this._fragmentKey] = fragment.id;
      const previousIDs = /* @__PURE__ */ new Set();
      for (let i = 0; i < instances.length; i++) {
        const instance = instances[i];
        matrix.fromArray(instance.matrix);
        const { expressID } = instance;
        let instanceID = expressID.toString();
        let isComposite = false;
        if (!previousIDs.has(expressID)) {
          previousIDs.add(expressID);
        } else {
          if (!fragment.composites[expressID]) {
            fragment.composites[expressID] = 1;
          }
          const count = fragment.composites[expressID];
          instanceID = toCompositeID(expressID, count);
          isComposite = true;
          fragment.composites[expressID]++;
        }
        fragment.setInstance(i, {
          ids: [instanceID],
          transform: matrix
        });
        const { x, y, z } = instance.color;
        color2.setRGB(x, y, z, "srgb");
        fragment.mesh.setColorAt(i, color2);
        if (!isComposite) {
          this.saveExpressID(expressID.toString());
        }
      }
      fragment.mesh.updateMatrix();
      this._model.items.push(fragment);
      this._model.add(fragment.mesh);
      this._fragmentKey++;
    }
    const transform = new Matrix4();
    for (const matID in uniqueItems) {
      const { material, geometries: geometries2, expressIDs } = uniqueItems[matID];
      const geometriesByItem = {};
      for (let i = 0; i < expressIDs.length; i++) {
        const id = expressIDs[i];
        if (!geometriesByItem[id]) {
          geometriesByItem[id] = [];
        }
        geometriesByItem[id].push(geometries2[i]);
      }
      const sortedGeometries = [];
      const sortedIDs = [];
      for (const id in geometriesByItem) {
        sortedIDs.push(id);
        const geometries3 = geometriesByItem[id];
        if (geometries3.length) {
          const merged = mergeGeometries(geometries3);
          sortedGeometries.push(merged);
        } else {
          sortedGeometries.push(geometries3[0]);
        }
        for (const geometry2 of geometries3) {
          geometry2.dispose();
        }
      }
      const geometry = GeometryUtils.merge([sortedGeometries], true);
      const fragment = new Fragment(geometry, material, 1);
      this._keyFragmentMap[this._fragmentKey] = fragment.id;
      for (const id of sortedIDs) {
        this.saveExpressID(id);
      }
      this._fragmentKey++;
      fragment.setInstance(0, { ids: sortedIDs, transform });
      this._model.items.push(fragment);
      this._model.add(fragment.mesh);
    }
  }
  saveExpressID(expressID) {
    if (!this._itemKeyMap[expressID]) {
      this._itemKeyMap[expressID] = [];
    }
    this._itemKeyMap[expressID].push(this._fragmentKey);
  }
  getFragmentsGroupData() {
    const itemsData = {};
    for (const id in this._itemKeyMap) {
      const keys2 = [];
      const rels = [];
      const idNum = parseInt(id, 10);
      const level = this._spatialTree.itemsByFloor[idNum] || 0;
      const category = this.categories[idNum] || 0;
      rels.push(level, category);
      for (const key of this._itemKeyMap[id]) {
        keys2.push(key);
      }
      itemsData[idNum] = [keys2, rels];
    }
    return itemsData;
  }
};

// node_modules/openbim-components/fragments/FragmentIfcLoader/src/geometry-reader.js
var GeometryReader = class {
  constructor() {
    this.saveLocations = false;
    this.items = {};
    this.locations = {};
  }
  get webIfc() {
    if (!this._webIfc) {
      throw new Error("web-ifc not found!");
    }
    return this._webIfc;
  }
  cleanUp() {
    this.items = {};
    this.locations = {};
    this._webIfc = null;
  }
  streamMesh(webifc, mesh, forceTransparent = false) {
    this._webIfc = webifc;
    const size = mesh.geometries.size();
    const totalTransform = new Vector3();
    const tempMatrix = new Matrix4();
    const tempVector = new Vector3();
    for (let i = 0; i < size; i++) {
      const geometry = mesh.geometries.get(i);
      const geometryID = geometry.geometryExpressID;
      if (this.saveLocations) {
        tempVector.set(0, 0, 0);
        tempMatrix.fromArray(geometry.flatTransformation);
        tempVector.applyMatrix4(tempMatrix);
        totalTransform.add(tempVector);
      }
      const isColorTransparent = geometry.color.w !== 1;
      const isTransparent = isColorTransparent || forceTransparent;
      const prefix = isTransparent ? "-" : "+";
      const idWithTransparency = prefix + geometryID;
      if (forceTransparent)
        geometry.color.w = 0.1;
      if (!this.items[idWithTransparency]) {
        const buffer = this.newBufferGeometry(geometryID);
        if (!buffer)
          continue;
        this.items[idWithTransparency] = { buffer, instances: [] };
      }
      this.items[idWithTransparency].instances.push({
        color: { ...geometry.color },
        matrix: geometry.flatTransformation,
        expressID: mesh.expressID
      });
    }
    if (this.saveLocations) {
      const { x, y, z } = totalTransform.divideScalar(size);
      this.locations[mesh.expressID] = [x, y, z];
    }
  }
  newBufferGeometry(geometryID) {
    const geometry = this.webIfc.GetGeometry(0, geometryID);
    const verts = this.getVertices(geometry);
    if (!verts.length)
      return null;
    const indices = this.getIndices(geometry);
    if (!indices.length)
      return null;
    const buffer = this.constructBuffer(verts, indices);
    geometry.delete();
    return buffer;
  }
  getIndices(geometryData) {
    const indices = this.webIfc.GetIndexArray(geometryData.GetIndexData(), geometryData.GetIndexDataSize());
    return indices;
  }
  getVertices(geometryData) {
    const verts = this.webIfc.GetVertexArray(geometryData.GetVertexData(), geometryData.GetVertexDataSize());
    return verts;
  }
  constructBuffer(vertexData, indexData) {
    const geometry = new BufferGeometry();
    const posFloats = new Float32Array(vertexData.length / 2);
    const normFloats = new Float32Array(vertexData.length / 2);
    for (let i = 0; i < vertexData.length; i += 6) {
      posFloats[i / 2] = vertexData[i];
      posFloats[i / 2 + 1] = vertexData[i + 1];
      posFloats[i / 2 + 2] = vertexData[i + 2];
      normFloats[i / 2] = vertexData[i + 3];
      normFloats[i / 2 + 1] = vertexData[i + 4];
      normFloats[i / 2 + 2] = vertexData[i + 5];
    }
    geometry.setAttribute("position", new BufferAttribute(posFloats, 3));
    geometry.setAttribute("normal", new BufferAttribute(normFloats, 3));
    geometry.setIndex(new BufferAttribute(indexData, 1));
    return geometry;
  }
};

// node_modules/openbim-components/fragments/FragmentIfcLoader/index.js
var FragmentIfcLoader = class _FragmentIfcLoader extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this.uiElement = new UIElement();
    this.onIfcLoaded = new Event();
    this.onLocationsSaved = new Event();
    this._webIfc = new IfcAPI2();
    this._geometry = new GeometryReader();
    this._converter = new DataConverter(components);
    this.components.tools.add(_FragmentIfcLoader.uuid, this);
    if (components.ui.enabled) {
      this.setupUI();
    }
  }
  get() {
    return this._webIfc;
  }
  get settings() {
    return this._converter.settings;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this._geometry.cleanUp();
    this._converter.cleanUp();
    this.onIfcLoaded.reset();
    this.onLocationsSaved.reset();
    this.uiElement.dispose();
    this._webIfc = null;
    this._geometry = null;
    this._converter = null;
  }
  /** Loads the IFC file and converts it to a set of fragments. */
  async load(data, name) {
    if (this.settings.saveLocations) {
      this._geometry.saveLocations = true;
    }
    const before = performance.now();
    await this.readIfcFile(data);
    await this.readAllGeometries();
    const items = this._geometry.items;
    const model = await this._converter.generate(this._webIfc, items);
    model.name = name;
    if (this.settings.saveLocations) {
      await this.onLocationsSaved.trigger(this._geometry.locations);
    }
    const fragments = await this.components.tools.get(FragmentManager);
    if (this.settings.coordinate) {
      const isFirstModel = fragments.groups.length === 0;
      if (isFirstModel) {
        fragments.baseCoordinationModel = model.uuid;
      } else {
        fragments.coordinate([model]);
      }
    }
    this.cleanUp();
    fragments.groups.push(model);
    for (const fragment of model.items) {
      fragment.group = model;
      fragments.list[fragment.id] = fragment;
      this.components.meshes.push(fragment.mesh);
    }
    await this.onIfcLoaded.trigger(model);
    console.log(`Loading the IFC took ${performance.now() - before} ms!`);
    return model;
  }
  setupUI() {
    const main2 = new Button(this.components);
    main2.materialIcon = "upload_file";
    main2.tooltip = "Load IFC";
    const toast = new ToastNotification(this.components, {
      message: "IFC model successfully loaded!"
    });
    main2.onClick.add(() => {
      const fileOpener = document.createElement("input");
      fileOpener.type = "file";
      fileOpener.accept = ".ifc";
      fileOpener.style.display = "none";
      fileOpener.onchange = async () => {
        const fragments = await this.components.tools.get(FragmentManager);
        if (fileOpener.files === null || fileOpener.files.length === 0)
          return;
        const file = fileOpener.files[0];
        const buffer = await file.arrayBuffer();
        const data = new Uint8Array(buffer);
        const model = await this.load(data, file.name);
        const scene = this.components.scene.get();
        scene.add(model);
        toast.visible = true;
        await fragments.updateWindow();
        fileOpener.remove();
      };
      fileOpener.click();
    });
    this.components.ui.add(toast);
    toast.visible = false;
    this.uiElement.set({ main: main2, toast });
  }
  async readIfcFile(data) {
    const { path, absolute } = this.settings.wasm;
    this._webIfc.SetWasmPath(path, absolute);
    await this._webIfc.Init();
    this._webIfc.OpenModel(data, this.settings.webIfc);
  }
  async readAllGeometries() {
    this._converter.saveIfcCategories(this._webIfc);
    const optionals = this.settings.optionalCategories;
    if (optionals.includes(IFCSPACE)) {
      const index = optionals.indexOf(IFCSPACE);
      optionals.splice(index, 1);
      this._webIfc.StreamAllMeshesWithTypes(0, [IFCSPACE], (mesh) => {
        if (this.isExcluded(mesh.expressID)) {
          return;
        }
        this._geometry.streamMesh(this._webIfc, mesh, true);
      });
    }
    if (optionals.length) {
      this._webIfc.StreamAllMeshesWithTypes(0, optionals, (mesh) => {
        if (this.isExcluded(mesh.expressID)) {
          return;
        }
        this._geometry.streamMesh(this._webIfc, mesh);
      });
    }
    this._webIfc.StreamAllMeshes(0, (mesh) => {
      if (this.isExcluded(mesh.expressID)) {
        return;
      }
      this._geometry.streamMesh(this._webIfc, mesh);
    });
  }
  cleanUp() {
    this._webIfc = null;
    this._webIfc = new IfcAPI2();
    this._geometry.cleanUp();
    this._converter.cleanUp();
  }
  isExcluded(id) {
    const category = this._converter.categories[id];
    return this.settings.excludedCategories.has(category);
  }
};
FragmentIfcLoader.uuid = "a659add7-1418-4771-a0d6-7d4d438e4624";
ToolComponent.libraryUUIDs.add(FragmentIfcLoader.uuid);

// node_modules/three/examples/jsm/shaders/CopyShader.js
var CopyShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "opacity": { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`
  )
};

// node_modules/three/examples/jsm/postprocessing/Pass.js
var Pass = class {
  constructor() {
    this.isPass = true;
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
};
var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _geometry = new BufferGeometry();
_geometry.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
_geometry.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
var FullScreenQuad = class {
  constructor(material) {
    this._mesh = new Mesh(_geometry, material);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this._mesh, _camera);
  }
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
};

// node_modules/three/examples/jsm/postprocessing/ShaderPass.js
var ShaderPass = class extends Pass {
  constructor(shader, textureID) {
    super();
    this.textureID = textureID !== void 0 ? textureID : "tDiffuse";
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else if (shader) {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this.fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
  dispose() {
    this.material.dispose();
    this.fsQuad.dispose();
  }
};

// node_modules/three/examples/jsm/postprocessing/MaskPass.js
var MaskPass = class extends Pass {
  constructor(scene, camera) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  }
  render(renderer, writeBuffer, readBuffer) {
    const context = renderer.getContext();
    const state = renderer.state;
    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);
    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);
    let writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);
    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    state.buffers.stencil.setLocked(true);
  }
};
var ClearMaskPass = class extends Pass {
  constructor() {
    super();
    this.needsSwap = false;
  }
  render(renderer) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
};

// node_modules/three/examples/jsm/postprocessing/EffectComposer.js
var EffectComposer = class {
  constructor(renderer, renderTarget) {
    this.renderer = renderer;
    this._pixelRatio = renderer.getPixelRatio();
    if (renderTarget === void 0) {
      const size = renderer.getSize(new Vector2());
      this._width = size.width;
      this._height = size.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio);
      renderTarget.texture.name = "EffectComposer.rt1";
    } else {
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];
    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new Clock();
  }
  swapBuffers() {
    const tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  }
  addPass(pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
    }
  }
  isLastEnabledPass(passIndex) {
    for (let i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }
    return true;
  }
  render(deltaTime) {
    if (deltaTime === void 0) {
      deltaTime = this.clock.getDelta();
    }
    const currentRenderTarget = this.renderer.getRenderTarget();
    let maskActive = false;
    for (let i = 0, il = this.passes.length; i < il; i++) {
      const pass = this.passes[i];
      if (pass.enabled === false)
        continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
      if (pass.needsSwap) {
        if (maskActive) {
          const context = this.renderer.getContext();
          const stencil = this.renderer.state.buffers.stencil;
          stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          stencil.setFunc(context.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      if (MaskPass !== void 0) {
        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  }
  reset(renderTarget) {
    if (renderTarget === void 0) {
      const size = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (let i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(effectiveWidth, effectiveHeight);
    }
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.copyPass.dispose();
  }
};

// node_modules/three/examples/jsm/postprocessing/RenderPass.js
var RenderPass = class extends Pass {
  constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
    this.clear = true;
    this.clearDepth = false;
    this.needsSwap = false;
    this._oldClearColor = new Color();
  }
  render(renderer, writeBuffer, readBuffer) {
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    let oldClearAlpha, oldOverrideMaterial;
    if (this.overrideMaterial !== void 0) {
      oldOverrideMaterial = this.scene.overrideMaterial;
      this.scene.overrideMaterial = this.overrideMaterial;
    }
    if (this.clearColor) {
      renderer.getClearColor(this._oldClearColor);
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }
    if (this.clearDepth) {
      renderer.clearDepth();
    }
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);
    if (this.clearColor) {
      renderer.setClearColor(this._oldClearColor, oldClearAlpha);
    }
    if (this.overrideMaterial !== void 0) {
      this.scene.overrideMaterial = oldOverrideMaterial;
    }
    renderer.autoClear = oldAutoClear;
  }
};

// node_modules/postprocessing/build/index.js
var MILLISECONDS_TO_SECONDS = 1 / 1e3;
var dummyCamera = new Camera();
var revision = Number(REVISION.replace(/\D+/g, ""));
var color = new Color();
var BlendFunction = {
  SKIP: 9,
  SET: 30,
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
};
var add_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}";
var alpha_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}";
var average_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}";
var color_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";
var color_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}";
var color_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}";
var darken_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}";
var difference_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}";
var divide_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}";
var exclusion_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}";
var hard_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}";
var hard_mix_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}";
var hue_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}";
var invert_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}";
var invert_rgb_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}";
var lighten_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}";
var linear_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}";
var linear_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}";
var linear_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}";
var luminosity_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";
var multiply_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}";
var negation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}";
var normal_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}";
var overlay_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}";
var pin_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}";
var reflect_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}";
var saturation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";
var screen_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}";
var soft_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}";
var src_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}";
var subtract_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}";
var vivid_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}";
var blendFunctions = /* @__PURE__ */ new Map([
  [BlendFunction.ADD, add_default],
  [BlendFunction.ALPHA, alpha_default],
  [BlendFunction.AVERAGE, average_default],
  [BlendFunction.COLOR, color_default],
  [BlendFunction.COLOR_BURN, color_burn_default],
  [BlendFunction.COLOR_DODGE, color_dodge_default],
  [BlendFunction.DARKEN, darken_default],
  [BlendFunction.DIFFERENCE, difference_default],
  [BlendFunction.DIVIDE, divide_default],
  [BlendFunction.DST, null],
  [BlendFunction.EXCLUSION, exclusion_default],
  [BlendFunction.HARD_LIGHT, hard_light_default],
  [BlendFunction.HARD_MIX, hard_mix_default],
  [BlendFunction.HUE, hue_default],
  [BlendFunction.INVERT, invert_default],
  [BlendFunction.INVERT_RGB, invert_rgb_default],
  [BlendFunction.LIGHTEN, lighten_default],
  [BlendFunction.LINEAR_BURN, linear_burn_default],
  [BlendFunction.LINEAR_DODGE, linear_dodge_default],
  [BlendFunction.LINEAR_LIGHT, linear_light_default],
  [BlendFunction.LUMINOSITY, luminosity_default],
  [BlendFunction.MULTIPLY, multiply_default],
  [BlendFunction.NEGATION, negation_default],
  [BlendFunction.NORMAL, normal_default],
  [BlendFunction.OVERLAY, overlay_default],
  [BlendFunction.PIN_LIGHT, pin_light_default],
  [BlendFunction.REFLECT, reflect_default],
  [BlendFunction.SATURATION, saturation_default],
  [BlendFunction.SCREEN, screen_default],
  [BlendFunction.SOFT_LIGHT, soft_light_default],
  [BlendFunction.SRC, src_default],
  [BlendFunction.SUBTRACT, subtract_default],
  [BlendFunction.VIVID_LIGHT, vivid_light_default]
]);
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var v = new Vector3();
var m = new Matrix4();
var c2 = new Color();
var HALF_PI = Math.PI * 0.5;
var v2 = new Vector3();
var ab = new Vector3();
var unpackFactors = new Float32Array([
  255 / 256 / 256 ** 3,
  255 / 256 / 256 ** 2,
  255 / 256 / 256,
  255 / 256
]);
var P = [
  new Float32Array(3),
  new Float32Array(3)
];
var C = [
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3),
  new Float32Array(3)
];
var T = [
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ],
  [
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1])
  ]
];
var area = [
  new Float32Array(2),
  new Float32Array(2)
];
var orthogonalSubsamplingOffsets = new Float32Array([
  0,
  -0.25,
  0.25,
  -0.125,
  0.125,
  -0.375,
  0.375
]);
var diagonalSubsamplingOffsets = [
  new Float32Array([0, 0]),
  new Float32Array([0.25, -0.25]),
  new Float32Array([-0.25, 0.25]),
  new Float32Array([0.125, -0.125]),
  new Float32Array([-0.125, 0.125])
];
var orthogonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([0, 3]),
  new Uint8Array([3, 3]),
  new Uint8Array([1, 0]),
  new Uint8Array([4, 0]),
  new Uint8Array([1, 3]),
  new Uint8Array([4, 3]),
  new Uint8Array([0, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([0, 4]),
  new Uint8Array([3, 4]),
  new Uint8Array([1, 1]),
  new Uint8Array([4, 1]),
  new Uint8Array([1, 4]),
  new Uint8Array([4, 4])
];
var diagonalEdges = [
  new Uint8Array([0, 0]),
  new Uint8Array([1, 0]),
  new Uint8Array([0, 2]),
  new Uint8Array([1, 2]),
  new Uint8Array([2, 0]),
  new Uint8Array([3, 0]),
  new Uint8Array([2, 2]),
  new Uint8Array([3, 2]),
  new Uint8Array([0, 1]),
  new Uint8Array([1, 1]),
  new Uint8Array([0, 3]),
  new Uint8Array([1, 3]),
  new Uint8Array([2, 1]),
  new Uint8Array([3, 1]),
  new Uint8Array([2, 3]),
  new Uint8Array([3, 3])
];
var edges = /* @__PURE__ */ new Map([
  [bilinear(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],
  [bilinear(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],
  [bilinear(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],
  [bilinear(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],
  [bilinear(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],
  [bilinear(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],
  [bilinear(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],
  [bilinear(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],
  [bilinear(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],
  [bilinear(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],
  [bilinear(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],
  [bilinear(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],
  [bilinear(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],
  [bilinear(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],
  [bilinear(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],
  [bilinear(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]
]);
function lerp2(a, b2, p2) {
  return a + (b2 - a) * p2;
}
function bilinear(e0, e1, e2, e3) {
  const a = lerp2(e0, e1, 1 - 0.25);
  const b2 = lerp2(e2, e3, 1 - 0.25);
  return lerp2(a, b2, 1 - 0.125);
}

// node_modules/n8ao/dist/N8AO.js
var $e4ca8dcb0218f846$var$_geometry = new BufferGeometry();
$e4ca8dcb0218f846$var$_geometry.setAttribute("position", new BufferAttribute(new Float32Array([
  -1,
  -1,
  3,
  -1,
  -1,
  3
]), 2));
$e4ca8dcb0218f846$var$_geometry.setAttribute("uv", new BufferAttribute(new Float32Array([
  0,
  0,
  2,
  0,
  0,
  2
]), 2));
$e4ca8dcb0218f846$var$_geometry.boundingSphere = new Sphere();
$e4ca8dcb0218f846$var$_geometry.computeBoundingSphere = function() {
};
var $e4ca8dcb0218f846$var$_camera = new OrthographicCamera();
var $e4ca8dcb0218f846$export$dcd670d73db751f5 = class {
  constructor(material) {
    this._mesh = new Mesh($e4ca8dcb0218f846$var$_geometry, material);
    this._mesh.frustumCulled = false;
  }
  render(renderer) {
    renderer.render(this._mesh, $e4ca8dcb0218f846$var$_camera);
  }
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
  dispose() {
    this._mesh.material.dispose();
    this._mesh.geometry.dispose();
  }
};
var $1ed45968c1160c3c$export$c9b263b9a17dffd7 = {
  uniforms: {
    "sceneDiffuse": {
      value: null
    },
    "sceneDepth": {
      value: null
    },
    "sceneNormal": {
      value: null
    },
    "projMat": {
      value: new Matrix4()
    },
    "viewMat": {
      value: new Matrix4()
    },
    "projViewMat": {
      value: new Matrix4()
    },
    "projectionMatrixInv": {
      value: new Matrix4()
    },
    "viewMatrixInv": {
      value: new Matrix4()
    },
    "cameraPos": {
      value: new Vector3()
    },
    "resolution": {
      value: new Vector2()
    },
    "time": {
      value: 0
    },
    "samples": {
      value: []
    },
    "bluenoise": {
      value: null
    },
    "distanceFalloff": {
      value: 1
    },
    "radius": {
      value: 5
    },
    "near": {
      value: 0.1
    },
    "far": {
      value: 1e3
    },
    "logDepth": {
      value: false
    },
    "ortho": {
      value: false
    },
    "screenSpaceRadius": {
      value: false
    },
    "frame": {
      value: 0
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1);
}`
  ),
  fragmentShader: (
    /* glsl */
    `
    #define SAMPLES 16
    #define FSAMPLES 16.0
uniform sampler2D sceneDiffuse;
uniform highp sampler2D sceneNormal;
uniform highp sampler2D sceneDepth;
uniform mat4 projectionMatrixInv;
uniform mat4 viewMatrixInv;
uniform mat4 projMat;
uniform mat4 viewMat;
uniform mat4 projViewMat;
uniform vec3 cameraPos;
uniform vec2 resolution;
uniform float time;
uniform vec3[SAMPLES] samples;
uniform float radius;
uniform float distanceFalloff;
uniform float near;
uniform float far;
uniform float frame;
uniform bool logDepth;
uniform bool ortho;
uniform bool screenSpaceRadius;
uniform sampler2D bluenoise;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }

    vec3 getWorldPosLog(vec3 posS) {
      vec2 uv = posS.xy;
      float z = posS.z;
      float nearZ =near;
      float farZ = far;
      float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
      vec4 wpos = projectionMatrixInv * clipVec;
      return wpos.xyz / wpos.w;
    }
    vec3 getWorldPos(float depth, vec2 coord) {
      #ifdef LOGDEPTH
        return getWorldPosLog(vec3(coord, depth));
      #endif
      float z = depth * 2.0 - 1.0;
      vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
      vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
      // Perspective division
     vec4 worldSpacePosition = viewSpacePosition;
     worldSpacePosition.xyz /= worldSpacePosition.w;
      return worldSpacePosition.xyz;
  }

  vec3 computeNormal(vec3 worldPos, vec2 vUv) {
    ivec2 p = ivec2(vUv * resolution);
    float c0 = texelFetch(sceneDepth, p, 0).x;
    float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;

    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);

    vec3 ce = getWorldPos(c0, vUv).xyz;

    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;

    return normalize(cross(dpdx, dpdy));
}

mat3 makeRotationZ(float theta) {
	float c = cos(theta);
	float s = sin(theta);
	return mat3(c, - s, 0,
			s,  c, 0,
			0,  0, 1);
  }

void main() {
      vec4 diffuse = texture2D(sceneDiffuse, vUv);
      float depth = texture2D(sceneDepth, vUv).x;
      if (depth == 1.0) {
        gl_FragColor = vec4(vec3(1.0), 1.0);
        return;
      }
      vec3 worldPos = getWorldPos(depth, vUv);
      #ifdef HALFRES
        vec3 normal = texture2D(sceneNormal, vUv).rgb;
      #else
        vec3 normal = computeNormal(worldPos, vUv);
      #endif
      vec4 noise = texture2D(bluenoise, gl_FragCoord.xy / 128.0);
      vec2 harmoniousNumbers = vec2(
        1.618033988749895,
        1.324717957244746
      );
      noise.rg += harmoniousNumbers * frame;
      noise.rg = fract(noise.rg);
        vec3 helperVec = vec3(0.0, 1.0, 0.0);
        if (dot(helperVec, normal) > 0.99) {
          helperVec = vec3(1.0, 0.0, 0.0);
        }
        vec3 tangent = normalize(cross(helperVec, normal));
        vec3 bitangent = cross(normal, tangent);
        mat3 tbn = mat3(tangent, bitangent, normal) *  makeRotationZ(noise.r * 2.0 * 3.1415962) ;

      float occluded = 0.0;
      float totalWeight = 0.0;
      float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : radiusToUse * distanceFalloff * 0.2;
      float bias = (min(
        0.1,
        distanceFalloffToUse * 0.1
      ) / near) * fwidth(distance(worldPos, cameraPos)) / radiusToUse;
      float phi = 1.61803398875;
      float offsetMove = 0.0;
      float offsetMoveInv = 1.0 / FSAMPLES;
      for(float i = 0.0; i < FSAMPLES; i++) {
        vec3 sampleDirection = tbn * samples[int(i)];

        float moveAmt = fract(noise.g + offsetMove);
        offsetMove += offsetMoveInv;

        vec3 samplePos = worldPos + radiusToUse * moveAmt * sampleDirection;
        vec4 offset = projMat * vec4(samplePos, 1.0);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;
        
        vec2 diff = gl_FragCoord.xy - floor(offset.xy * resolution);
        // From Rabbid76's hbao
        vec2 clipRangeCheck = step(vec2(0.0),offset.xy) * step(offset.xy, vec2(1.0));
          float sampleDepth = textureLod(sceneDepth, offset.xy, 0.0).x;

          #ifdef LOGDEPTH

          float distSample = linearize_depth_log(sampleDepth, near, far);

          #else

          float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);

          #endif

          float distWorld = ortho ? linearize_depth_ortho(offset.z, near, far) : linearize_depth(offset.z, near, far);
          
          float rangeCheck = distSample == distWorld ? 0.0 : smoothstep(0.0, 1.0, distanceFalloffToUse / (abs(distSample - distWorld)));
          
          float sampleValid = (clipRangeCheck.x * clipRangeCheck.y);
          occluded += rangeCheck * float(sampleDepth != depth) * float(distSample + bias < distWorld) * step(
            1.0,
            dot(diff, diff)
          ) * sampleValid;
          
          totalWeight += sampleValid;
      }
      float occ = clamp(1.0 - occluded / (totalWeight == 0.0 ? 1.0 : totalWeight), 0.0, 1.0);
      gl_FragColor = vec4(occ, 0.5 + 0.5 * normal);
}`
  )
};
var $12b21d24d1192a04$export$a815acccbd2c9a49 = {
  uniforms: {
    "sceneDiffuse": {
      value: null
    },
    "sceneDepth": {
      value: null
    },
    "tDiffuse": {
      value: null
    },
    "transparencyDWFalse": {
      value: null
    },
    "transparencyDWTrue": {
      value: null
    },
    "transparencyDWTrueDepth": {
      value: null
    },
    "transparencyAware": {
      value: false
    },
    "projMat": {
      value: new Matrix4()
    },
    "viewMat": {
      value: new Matrix4()
    },
    "projectionMatrixInv": {
      value: new Matrix4()
    },
    "viewMatrixInv": {
      value: new Matrix4()
    },
    "cameraPos": {
      value: new Vector3()
    },
    "resolution": {
      value: new Vector2()
    },
    "color": {
      value: new Vector3(0, 0, 0)
    },
    "blueNoise": {
      value: null
    },
    "downsampledDepth": {
      value: null
    },
    "time": {
      value: 0
    },
    "intensity": {
      value: 10
    },
    "renderMode": {
      value: 0
    },
    "gammaCorrection": {
      value: false
    },
    "logDepth": {
      value: false
    },
    "ortho": {
      value: false
    },
    "near": {
      value: 0.1
    },
    "far": {
      value: 1e3
    },
    "screenSpaceRadius": {
      value: false
    },
    "radius": {
      value: 0
    },
    "distanceFalloff": {
      value: 1
    },
    "fog": {
      value: false
    },
    "fogExp": {
      value: false
    },
    "fogDensity": {
      value: 0
    },
    "fogNear": {
      value: Infinity
    },
    "fogFar": {
      value: Infinity
    },
    "colorMultiply": {
      value: true
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform highp sampler2D downsampledDepth;
    uniform highp sampler2D transparencyDWFalse;
    uniform highp sampler2D transparencyDWTrue;
    uniform highp sampler2D transparencyDWTrueDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform vec2 resolution;
    uniform vec3 color;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform float intensity;
    uniform float renderMode;
    uniform float near;
    uniform float far;
    uniform bool gammaCorrection;
    uniform bool logDepth;
    uniform bool ortho;
    uniform bool screenSpaceRadius;
    uniform bool fog;
    uniform bool fogExp;
    uniform bool colorMultiply;
    uniform bool transparencyAware;
    uniform float fogDensity;
    uniform float fogNear;
    uniform float fogFar;
    uniform float radius;
    uniform float distanceFalloff;
    uniform vec3 cameraPos;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
       // if (logDepth) {
        #ifdef LOGDEPTH
          return getWorldPosLog(vec3(coord, depth));
        #endif
      //  }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }

    #include <common>
    #include <dithering_pars_fragment>
    void main() {
        //vec4 texel = texture2D(tDiffuse, vUv);//vec3(0.0);
        vec4 sceneTexel = texture2D(sceneDiffuse, vUv);
        float depth = texture2D(
            sceneDepth,
            vUv
        ).x;
        #ifdef HALFRES 
        vec4 texel;
        if (depth == 1.0) {
            texel = vec4(0.0, 0.0, 0.0, 1.0);
        } else {
        vec3 worldPos = getWorldPos(depth, vUv);
        vec3 normal = computeNormal(getWorldPos(depth, vUv), vUv);
       // vec4 texel = texture2D(tDiffuse, vUv);
       // Find closest depth;
       float totalWeight = 0.0;
       float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : distanceFalloff;
        for(float x = -1.0; x <= 1.0; x++) {
            for(float y = -1.0; y <= 1.0; y++) {
                vec2 offset = vec2(x, y);
                ivec2 p = ivec2(
                    (vUv * resolution * 0.5) + offset
                );
                vec2 pUv = vec2(p) / (resolution * 0.5);
                float sampleDepth = texelFetch(downsampledDepth,p, 0).x;
                vec4 sampleInfo = texelFetch(tDiffuse, p, 0);
                vec3 normalSample = sampleInfo.gba * 2.0 - 1.0;
                vec3 worldPosSample = getWorldPos(sampleDepth, pUv);
                float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
                float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0);
                float weight = rangeCheck;
                totalWeight += weight;
                texel += sampleInfo * weight;
            }
        }
        if (totalWeight == 0.0) {
            texel = texture2D(tDiffuse, vUv);
        } else {
            texel /= totalWeight;
        }
    }
        #else
        vec4 texel = texture2D(tDiffuse, vUv);
        #endif

        #ifdef LOGDEPTH
        texel.r = clamp(texel.r, 0.0, 1.0);
        if (texel.r == 0.0) {
          texel.r = 1.0;
        }
        #endif
     
        float finalAo = pow(texel.r, intensity);
        float fogFactor;
        float fogDepth = distance(
            cameraPos,
            getWorldPos(depth, vUv)
        );
        if (fog) {
            if (fogExp) {
                fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
            } else {
                fogFactor = smoothstep( fogNear, fogFar, fogDepth );
            }
        }
        if (transparencyAware) {
            float transparencyDWOff = texture2D(transparencyDWFalse, vUv).a;
            float transparencyDWOn = texture2D(transparencyDWTrue, vUv).a;
            float adjustmentFactorOff = transparencyDWOff;
            float adjustmentFactorOn = (1.0 - transparencyDWOn) * (
                texture2D(transparencyDWTrueDepth, vUv).r == texture2D(sceneDepth, vUv).r ? 1.0 : 0.0
            );
            float adjustmentFactor = max(adjustmentFactorOff, adjustmentFactorOn);
            finalAo = mix(finalAo, 1.0, adjustmentFactor);
        }
        finalAo = mix(finalAo, 1.0, fogFactor);
        vec3 aoApplied = color * mix(vec3(1.0), sceneTexel.rgb, float(colorMultiply));
        if (renderMode == 0.0) {
            gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 1.0) {
            gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 2.0) {
            gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
        } else if (renderMode == 3.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        } else if (renderMode == 4.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        }
        #include <dithering_fragment>
        if (gammaCorrection) {
            gl_FragColor = LinearTosRGB(gl_FragColor);
        }
    }
    `
  )
};
var $e52378cd0f5a973d$export$57856b59f317262e = {
  uniforms: {
    "sceneDiffuse": {
      value: null
    },
    "sceneDepth": {
      value: null
    },
    "tDiffuse": {
      value: null
    },
    "projMat": {
      value: new Matrix4()
    },
    "viewMat": {
      value: new Matrix4()
    },
    "projectionMatrixInv": {
      value: new Matrix4()
    },
    "viewMatrixInv": {
      value: new Matrix4()
    },
    "cameraPos": {
      value: new Vector3()
    },
    "resolution": {
      value: new Vector2()
    },
    "time": {
      value: 0
    },
    "r": {
      value: 5
    },
    "blueNoise": {
      value: null
    },
    "radius": {
      value: 12
    },
    "worldRadius": {
      value: 5
    },
    "index": {
      value: 0
    },
    "poissonDisk": {
      value: []
    },
    "distanceFalloff": {
      value: 1
    },
    "near": {
      value: 0.1
    },
    "far": {
      value: 1e3
    },
    "logDepth": {
      value: false
    },
    "screenSpaceRadius": {
      value: false
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1.0);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform vec2 resolution;
    uniform float r;
    uniform float radius;
     uniform float worldRadius;
    uniform float index;
     uniform float near;
     uniform float far;
     uniform float distanceFalloff;
     uniform bool logDepth;
     uniform bool screenSpaceRadius;
    varying vec2 vUv;

    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        highp float z_n = 2.0 * d - 1.0;
        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     return linearize_depth(linDepth, nearZ, farZ);
   }
   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
     return nearZ + (farZ - nearZ) * d;
   }
   vec3 getWorldPosLog(vec3 posS) {
     vec2 uv = posS.xy;
     float z = posS.z;
     float nearZ =near;
     float farZ = far;
     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
     vec4 wpos = projectionMatrixInv * clipVec;
     return wpos.xyz / wpos.w;
   }
    vec3 getWorldPos(float depth, vec2 coord) {
     #ifdef LOGDEPTH
          return getWorldPosLog(vec3(coord, depth));
     #endif
        
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
    #include <common>
    #define NUM_SAMPLES 16
    uniform vec2 poissonDisk[NUM_SAMPLES];
    void main() {
        const float pi = 3.14159;
        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);
        vec2 uv = vUv;
        vec4 data = texture2D(tDiffuse, vUv);
        float occlusion = data.r;
        float baseOcc = data.r;
        vec3 normal = data.gba * 2.0 - 1.0;
        float count = 1.0;
        float d = texture2D(sceneDepth, vUv).x;
        if (d == 1.0) {
          gl_FragColor = data;
          return;
        }
        vec3 worldPos = getWorldPos(d, vUv);
        float size = radius;
        float angle;
        if (index == 0.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;
        } else if (index == 1.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;
        } else if (index == 2.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;
        } else {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;
        }

        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        float radiusToUse = screenSpaceRadius ? distance(
          worldPos,
          getWorldPos(d, vUv +
            vec2(worldRadius, 0.0) / resolution)
        ) : worldRadius;
        float distanceFalloffToUse =screenSpaceRadius ?
        radiusToUse * distanceFalloff
    : radiusToUse * distanceFalloff * 0.2;


        for(int i = 0; i < NUM_SAMPLES; i++) {
            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;
            vec4 dataSample = texture2D(tDiffuse, uv + offset);
            float occSample = dataSample.r;
            vec3 normalSample = dataSample.gba * 2.0 - 1.0;
            float dSample = texture2D(sceneDepth, uv + offset).x;
            vec3 worldPosSample = getWorldPos(dSample, uv + offset);
            float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
            float rangeCheck = dSample == 1.0 ? 0.0 :exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0) * (1.0 - abs(occSample - baseOcc));
            occlusion += occSample * rangeCheck;
            count += rangeCheck;
        }
        if (count > 0.0) {
          occlusion /= count;
        }
        #ifdef LOGDEPTH
          occlusion = clamp(occlusion, 0.0, 1.0);
          if (occlusion == 0.0) {
            occlusion = 1.0;
          }
        #endif
        gl_FragColor = vec4(occlusion, 0.5 + 0.5 * normal);
    }
    `
  )
};
var $26aca173e0984d99$export$1efdf491687cd442 = {
  uniforms: {
    "sceneDepth": {
      value: null
    },
    "resolution": {
      value: new Vector2()
    },
    "near": {
      value: 0.1
    },
    "far": {
      value: 1e3
    },
    "viewMatrixInv": {
      value: new Matrix4()
    },
    "projectionMatrixInv": {
      value: new Matrix4()
    },
    "logDepth": {
      value: false
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1);
    }`
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform highp sampler2D sceneDepth;
    uniform vec2 resolution;
    uniform float near;
    uniform float far;
    uniform bool logDepth;
    uniform mat4 viewMatrixInv;
    uniform mat4 projectionMatrixInv;
    varying vec2 vUv;
    layout(location = 1) out vec4 gNormal;
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
        if (logDepth) {
          return getWorldPosLog(vec3(coord, depth));
        }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }
    void main() {
        vec2 uv = vUv - vec2(0.5) / resolution;
        vec2 pixelSize = vec2(1.0) / resolution;
        highp vec2[4] uvSamples;
        uvSamples[0] = uv;
        uvSamples[1] = uv + vec2(pixelSize.x, 0.0);
        uvSamples[2] = uv + vec2(0.0, pixelSize.y);
        uvSamples[3] = uv + pixelSize;
        float depth00 = texture2D(sceneDepth, uvSamples[0]).r;
        float depth10 = texture2D(sceneDepth, uvSamples[1]).r;
        float depth01 = texture2D(sceneDepth, uvSamples[2]).r;
        float depth11 = texture2D(sceneDepth, uvSamples[3]).r;
        float minDepth = min(min(depth00, depth10), min(depth01, depth11));
        float maxDepth = max(max(depth00, depth10), max(depth01, depth11));
        float targetDepth = minDepth;
        // Checkerboard pattern to avoid artifacts
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) > 0.5) { 
            targetDepth = maxDepth;
        }
        int chosenIndex = 0;
        float[4] samples;
        samples[0] = depth00;
        samples[1] = depth10;
        samples[2] = depth01;
        samples[3] = depth11;
        for(int i = 0; i < 4; ++i) {
            if (samples[i] == targetDepth) {
                chosenIndex = i;
                break;
            }
        }
        gl_FragColor = vec4(samples[chosenIndex], 0.0, 0.0, 1.0);
        gNormal = vec4(computeNormal(
            getWorldPos(samples[chosenIndex], uvSamples[chosenIndex]), uvSamples[chosenIndex]
        ), 0.0);
    }`
  )
};
var $06269ad78f3c5fdf$export$2e2bcd8739ae039 = `5L7pP4UXrOIr/VZ1G3f6p89FIWU7lqc7J3DPxKjJUXODJoHQzf/aNVM+ABlvhXeBGN7iC0WkmTjEaAqOItBfBdaK5KSGV1ET5SOKl3x9JOX5w2sAl6+6KjDhVUHgbqq7DZ5EeYzbdSNxtrQLW/KkPJoOTG4u5CBUZkCKHniY9l7DUgjuz708zG1HIC8qfohi1vPjPH9Lq47ksjRrjwXD4MlVCjdAqYFGodQ8tRmHkOfq4wVRIAHvoavPHvN1lpk3X4Y1yzAPGe8S9KBs3crc4GwlU1dEOXiWol/mgQqxkNqB1xd04+0Bmpwj0GcCc4NUi+c731FUxjvaexCkCJ0qhrJJ++htWqetNC4NewClu8aFRSwrqiJEGe+qtTg4CYCHaF1wJI0sy/ZBQAI0qAMyBvVjWZlv2pdkCaro9eWDLK5I4mbb8E4d7hZr9dDJiTJm6Bmb5S+2F7yal/JPdeLUfwq7jmVLaQfhv4tWMJAt7V4sG9LuAv2oPJgSj1nnlBvPibfHM2TrlWHwGCLGxW/5Jm2TotaDL+pHDM5pn1r0UuTZ24N8S5k68bLHW9tfD+2k4zGev23ExJb4YTRKWrj82N5LjJ26lj1BkGZ0CsXLGGELoPaYQomjTqPxYqhfwOwDliNGVqux9ffuybqOKgsbB51B1GbZfG8vHDBE2JQGib1mnCmWOWAMJcHN0cKeDHYTflbDTVXajtr68mwfRje6WueQ/6yWqmZMLWNH7P27zGFhMFqaqfg11Q88g/9UA/FROe9yfq0yOO0pnNAxvepFy2BpEbcgG+mCyjCC01JWlOZlIPdf1TtlyOt7L94ToYGCukoFt4OqwOrofamjECpSgKLLmrRM+sNRAw12eaqk8KtdFk7pn2IcDQiPXCh16t1a+psi+w9towHTKPyQM0StKr61b2BnN1HU+aezFNBLfHTiXwhGTbdxLLmrsAGIVSiNAeCGE8GlB0iOv2v78kP0CTmAPUEqnHYRSDlP+L6m/rYjEK6Q85GRDJi2W20/7NLPpSOaMR++IFvpkcwRuc59j8hh9tYlc1xjdt2jmp9KJczB7U9P43inuxLOv11P5/HYH5d6gLB0CsbGC8APjh+EcCP0zFWqlaACZweLhVfv3yiyd8R3bdVg8sRKsxPvhDaPpiFp9+MN+0Ua0bsPr+lhxfZhMhlevkLbR4ZvcSRP6ApQLy3+eMh9ehCB3z5DVAaN3P6J8pi5Qa88ZQsOuCTWyH6q8yMfBw8y8nm6jaOxJhPH6Hf0I4jmALUBsWKH4gWBnyijHh7z3/1HhQzFLRDRrIQwUtu11yk7U0gDw/FatOIZOJaBx3UqbUxSZ6dboFPm5pAyyXC2wYdSWlpZx/D2C6hDO2sJM4HT9IKWWmDkZIO2si/6BKHruXIEDpfAtz3xDlIdKnnlqnkfCyy6vNOPyuoWsSWBeiN0mcfIrnOtp2j7bxjOkr25skfS/lwOC692cEp7TKSlymbsyzoWg/0AN66SvQYo6BqpNwPpTaUu25zMWlwVUdfu1EEdc0O06TI0JmHk4f6GZQbfOs//OdgtGPO6uLoadJycR8Z80rkd88QoNmimZd8vcpQKScCFkxH1RMTkPlN3K7CL/NSMOiXEvxrn9VyUPFee63uRflgaPMSsafvqMgzTt3T1RaHNLLFatQbD0Vha4YXZ/6Ake7onM65nC9cyLkteYkDfHoJtef7wCrWXTK0+vH38VUBcFJP0+uUXpkiK0gDXNA39HL/qdVcaOA16kd2gzq8aHpNSaKtgMLJC6fdLLS/I/4lUWV2+djY9Rc3QuJOUrlHFQERtXN4xJaAHZERCUQZ9ND2pEtZg8dsnilcnqmqYn3c1sRyK0ziKpHNytEyi2gmzxEFchvT1uBWxZUikkAlWuyqvvhteSG9kFhTLNM97s3X1iS2UbE6cvApgbmeJ/KqtP0NNT3bZiG9TURInCZtVsNZzYus6On0wcdMlVfqo8XLhT5ojaOk4DtCyeoQkBt1mf5luFNaLFjI/1cnPefyCQwcq5ia/4pN4NB+xE/3SEPsliJypS964SI6o5fDVa0IERR8DoeQ+1iyRLU1qGYexB61ph4pkG1rf3c2YD6By1pFCmww9B0r2VjFeaubkIdgWx4RKLQRPLENdGo8ezI5mkNtdCws19aP1uHhenD+HKa8GDeLulb2fiMRhU2xJzzz9e4yOMPvEnGEfbCiQ17nUDpcFDWthr68mhZ4WiHUkRpaVWJNExuULcGkuyVLsQj59pf6OHFR7tofhy9FMrWPCEvX1d5sCVJt8yBFiB6NoOuwMy4wlso9I2G4E5/5B2c6vIZUUY9fFujT3hpkdTuVhbhBwLCtnlIjBpN4cq+waZ0wXSrmebcl+dcrb7sPh9jKxFINkScDTBgjSUfLkC3huJJs/M4M8AOFxbbSIVpBUarYFmLpGsv+V6TJnWNTwI41tubwo7QSI1VOdRKT/Pp8U3oK2ciDbeuWnAGAANvQjGfcewdAdo6H83XzqlK/4yudtFHJSv9Y+qJskwnVToH1I0+tJ3vsLBXtlvMzLIxUj/8LcqZnrNHfVRgabFNXW0qpUvDgxnP3f54KooR3NI+2Q/VHAYFigMkQE5dLH6C6fGs/TKeE6E2jOhZQcP9/rrJjJKcLYdn5cw6XLCUe9F7quk5Yhac+nYL5HOXvp6Q/5qbiQHkuebanX77YSNx34YaWYpcEHuY1u/lEVTCQ7taPaw3oNcn/qJhMzGPZUs3XAq48wj/hCIO2d5aFdfXnS0yg57/jxzDJBwkdOgeVnyyh19Iz1UqiysT4J1eeKwUuWEYln23ydtP7g3R1BnvnxqFPAnOMgOIop2dkXPfUh/9ZKV3ZQbZNactPD4ql5Qg9CxSBnIwzlj/tseQKWRstwNbf17neGwDFFWdm/8f+nDWt/WlKV3MUiAm3ci6xXMDSL5ubPXBg/gKEE7TsZVGUcrIbdXILcMngvGs7unvlPJh6oadeBDqiAviIZ/iyiUMdQZAuf/YBAY0VP1hcgInuWoKbx31AOjyTN2OOHrlthB3ny9JKHOAc8BMvqopikPldcwIQoFxTccKKIeI815GcwaKDLsMbCsxegrzXl8E0bpic/xffU9y1DCgeKZoF2PIY77RIn6kSRdBiGd8NtNwT74dyeFBMkYraPkudN26x9NPuBt4iCOAnBFaNSKVgKiZQruw22kM1fgBKG7cPYAxdHJ8M4V/jzBn2jEJg+jk/jjV4oMmMNOpKB5oVpVh7tK529Z+5vKZ0NSY2A4YdcT0x4BdkoNEDrpsTmekSTjvx9ZBiTHrm9M/n/hGmgpjz4WEjttRfAEy5DYH5vCK/9GuVPa4hoApFaNlrFD/n2PpKOw24iKujKhVIz41p1E0HwsCd/c17OA0H0RjZi1V/rjJLexUzpmXTMIMuzaOBbU4dxvQMgyvxJvR6DyF3BaHkaqT4P3FRYlm+zh8EEGgmkNqD1WRUubDW62VqLoH8UEelIpL7C8CguWWGGCAIDPma9bnh+7IJSt0Cn6ACER2mYk8dLsrN70RUVLiE0ig+08yPY9IOtuqHf/KYsT84BwhMcVq7t8q1WVjpJGNyXdtIPIjhAzabtrX03Itn29QO3TCixE9WpkHIOdAoGvqCrw1D3x9g9Px8u0yZZuulZuGy0veSY34KDSlhsO1zx2ZMrpDBzCHPB4niwApk6NevIvmBxU3+4yaewDvgEQDJ6Of5iRxjAIpp9UO8EzNY4blj4qh8SCSZTqbe/lShE6tNU9Y5IoWHeJxPcHF9KwYQD7lFcIpcscHrcfkHJfL2lL1zczKywEF7BwkjXEirgBcvNWayatqdTVT5oLbzTmED3EOYBSXFyb2VIYk3t0dOZWJdG1nP+W7Qfyeb8MSIyUGKEA57ptPxrPHKYGZPHsuBqQuVSrn0i8KJX+rlzAqo8AawchsJ26FckxTf5+joTcw+2y8c8bushpRYEbgrdr64ltEYPV2AbVgKXV3XACoD1gbs01CExbJALkuItjfYN3+6I8kbiTYmdzBLaNC+xu9z/eXcRQV1Lo8cJoSsKyWJPuTncu5vcmfMUAWmuwhjymK1rhYR8pQMXNQg9X+5ha5fEnap+LhUL1d5SURZz9rGdOWLhrMcMKSaU3LhOQ/6a6qSCwgzQxCW2gFs53fpvfWxhH+xDHdKRV6w29nQ6rNqd9by+zm1OpzYyJwvFyOkrVXQUwt4HaapnweCa7Tj2Mp/tT4YcY3Q/tk1czgkzlV5mpDrdp1spOYB8ionAwxujjdhj5y9qEHu0uc36PAKAYsKLaEoiwPnob0pdluPWdv4sNSlG8GWViI+x/Z4DkW/kSs2iE3ADFjg4TCvgCbX3v0Hz0KZkerrpzEIukAusidDs2g/w0zgmLnZXvVr5kkpwQTLZ0L6uaTHl0LVikIuNIVPmL3fOQJqIdfzymUN0zucIrDintBn6ICl/inj5zteISv5hEMGMqtHc2ghcFJvmH3ZhIZi34vqqTFCb9pltTYz582Y3dwYaHb9khdfve1YryzEwEKbI8qm62qv+NyllC+WxLLAJjz0ZaEF2aTn35qeFmkbP6LDYcbwqWxA0WKsteB7vy8bRHE4r8LhubWDc0pbe90XckSDDAkRej0TQlmWsWwaz18Tx2phykVvwuIRzf4kt9srT8N7gsMjMs0NLAAldabFf2tiMoaaxHcZSX51WPc1BrwApMxih227qTZkcgtkdK1h314XvZKUKh/XysWYnk1ST4kiBI1B9OlfTjB3WHzTAReFLofsGtikwpIXzQBc/gOjz2Thlj36WN0sxyf4RmAFtrYt64fwm+ThjbhlmUTZzebLl4yAkAqzJSfjPBZS2H/IvkkTUdVh0qdB6EuiHEjEil5lk9BTPzxmoW4Jx543hiyy4ASdYA2DNoprsR9iwGFwFG3F2vIROy4L5CZrl230+k733JwboSNBKngsaFPtqo+q3mFFSjC1k0kIAFmKihaYSwaSF7konmYHZWmchuaq15TpneA2ADSRvA07I7US0lTOOfKrgxhzRl0uJihcEZhhYWxObjvNTJ/5sR4Aa5wOQhGClGLb746cJhQ2E6Jie1hbGgWxUH7YSKETptrTeR/xfcMNk2WM12S0XElC9klR8O7jLYekEOZdscP0ypSdoCVZAoK+2ju2PHE869Q9rxCs9DVQco4BriiPbCjN/8tBjsah4IuboR5QbmbyDpcdXVxGMxvWKIjocBuKbjb+B4HvkunbG0wX0IFCjQKoNMFIKcJSJXtkP3EO+J16uh4img0LQlBAOYwBLupu5r1NALMo0g3xkd9b4f7KoCBWHeyk24FmYUCy/PGLv0xErOTyORp8TJ5nnc2k1dOVBTJok7iHye9dwxwRVP3c7eAS8pMmJYHGpzIHz6ii2WJm8HMTPAZdA4q+ugj3PNCL/N45kyglqvQV4f/+ryDDG5RPy5HVoV9FVuJcq2dxF9Y0heVoipV6q1LyfAeuMzbsUV+rsSBmCSV+1CdKlxy0T0Y6Om0X6701URm2Ml6DIQgJ/3KO6kwcMYRrmKsY7TfxWhSXZll+1PfyRXe9HS0t1IKTQMZL7ZqQ8D/o+en57Y9XAQ9C+kZYykNr0xOMxEwu2+Cppm69mQyTm3H7QX6kHvXF201r+KVAf354qypJC5OHSeBU47bM1bTaVmdVEWQ+9CcvvHdu8Ue5UndHM+EeukmR82voQpetZ7WJjyXs+tPS60nk09gymuORoHNtbm0VuvyigiEvOsyHiRBW7V6FyTCppLPEHvesan91SlEh1/QEunq+qgREFXByDwNKcAH5s8/RFg8hP4wcPmFqX0xXGSKY087bqRLsBZe52jThx0XLkhKQUWPvI18WQQS3g2Ra1pzQ1oNFKdfJJjyaH5tJH6w0/upJobwB8KZ5cIs9LnVGxfBaHXBfvLkNpab7dpU6TdcbBIc+A4bqXE/Xt8/xsGQOdoXra4Us5nDAM6v2BNBQaGMmgMfQQV+ikTteSHvyl8wUxULiYRIEKaiDxpBJnyf9OoqQdZVJ8ahqOvuwqq5mnDUAUzUr/Lvs1wLu2F+r4eZMfJPL4gV5mKLkITmozRnTvA7VABaxZmFRtkhvU5iH9RQ1z26ku7aABokvptx7RKZBVL6dveLKOzg0NC7HAxcg5kE1wuyJiEQLOpO0ma3AtWD2Q2Wmn2oPZeDYAwVyEpxuwDy7ivmdUDSL95ol3h2JByTMovOCgxZ1q4E5nwwa7+4WtDAse6bDdr27XgAi5Px3IWbyZ/vRiECKwOMeJSuIl8A4Ds0emI3SgKVVWVO5uyiEUET+ucEq0casA+DQyhzRc8j+Plo0pxKynB/t0uXod1FVV4fX1sC4kDfwFaUDGQ4p9HYgaMqIWX3OF/S8+vcR0JS0bDapWKJwAIIQiRUzvh5YwtzkjccbbrT9Ky/qt5X7MAGA0lzh43mDF9EB6lCGuO/aFCMhdOqNryvd73KdJNy3mxtT8AqgmG4xq7eE1jKu6rV0g8UGyMatzyIMjiOCf4lIJFzAfwDbIfC72TJ/TK+cGsLR8blpjlEILjD8Mxr7IffhbFhgo12CzXRQ2O8JqBJ70+t12385tSmFC8Or+U8svOaoGoojT1/EmjRMT7x2iTUZ7Ny02VGeMZTtGy029tGN1/9k7x3mFu63lYnaWjfJT1m1zpWO3HSXpGkFqVd/m3kDMv4X9rmLOpwEeu8r6TI6C2zUG+MT6v90OU3y5hKqLhpyFLGtkZhDmUg/W1JGSmA8N1TapR4Kny+P6+DuMadZ9+xBbv06nfOjMwkoTsjG0zFmNbvlxEjw+Pl5QYK+V8Qyb+nknZ0Nb/Ofi9+V0eoNtTrtD1/0wzUGGG5u2D/J1ouO/PjXFJVx6LurVnPOyFVbZx7s3ZSjSq+7YN3wzTbFbUvP8GBh7cKieJt56SIowQ2I577+UEXrxUKMFO+XaLLCALuiJWB2vUdpsT+kQ+adoeTfwOulXhd/KZ7ygjj6PhvGT1xzfT7hTwd6dzSB4xV70CesHC0dsg2VyujlMGBKjg5snbrHHX/LNj3SsoLGSX+bZNTDDCNTXh+dCVPlj4K8+hJ/kVddrbtZw26Hx5qYiv3oNNg5blHRSPtmojhZmBQAz8sLC9nAuWNSz1dIofFtlryEKklbdkhBCcx5dhj7pinXDNlCeatCeTCEjYCpZ3HRf5QzUcRR1Tdb3gwtYtpPdgMxmWfJGoZSu1EsCJbIhS16Ed97+8br4Ar1mB1GcnZVx/HPtJl4CgbHXrrDPwlE4od8deRQYLt9IlsvCqgesMmLAVxB+igH7WGTcY/e3lLHJ4rkBgh2p1QpUBRb/cSQsJCbosFDkalbJigimldVK7TIHKSq2w8mezku9hgw8fXJxGdXoL1ggma52kXzjP78l0d0zMwtTVlt0FqnRyGLPGEjmICzgSp7XPFlUr7AeMclQ4opqwBFInziM5F8oJJ8qeuckGOnAcZZOLl1+ZhGF17pfIuujipwFJL7ChIIB2vlo0IQZGTJPNa2YjNcGUw+a/gWYLkCp+bOGIYhWr08UIE709ZEHlUoEbumzgpJv1D0+hWYNEpj+laoZIK5weO2DFwLL6UBYNrXTm9YvvxeN9U9oKsB3zKBwzFFwDgid5ESMhy68xBnVa55sCZd+l5AnzT8etYjIwF/BGwEx1jjzFv32bk6EeJulESARh8RZ48o7rKw67UZpudPa15SDnL8AL8xMV2SC0D1P53p190zhCFkMmEiir2olwxcJppl/kLm6/0QSUQLNaxi1AC3Pg1CTosX2YQr73PjEIxIlg4mJ62vP7ZyoHE55B0SX9YrrrCPtNsrJEwtn6KOSt7nLT3n3DLJTPbLulcqQ1kETP6Huts29oP+JLEqRGWgnrqMD+mhCl1XCZifjgQ39AeudE8pyu2DqnYU3PyPbJhStq1HbP+VxgseWL+hQ+4w1okADlA9WqoaRuoS7IY77Cm40cJiE6FLomUMltT+xO3Upcv5dzSh9F57hodSBnMHukcH1kd9tqlpprBQ/Ij9E+wMQXrZG5PlzwYJ6jmRdnQtRj64wC/7vsDaaMFteBOUDR4ebRrNZJHhwlNEK9Bz3k7jqOV5KJpL74p2sQnd7vLE374Jz+G7H3RUbX17SobYOe9wKkL/Ja/zeiKExOBmPo0X29bURQMxJkN4ddbrHnOkn6+M1zTZHo0efsB23WSSsByfmye2ZuTEZ12J3Y8ffT6Fcv8XVfA/k+p+xJGreKHJRVUIBqfEIlRt987/QXkssXuvLkECSpVEBs+gE1meB6Xn1RWISG6sV3+KOVjiE9wGdRHS8rmTERRnk0mDNU/+kOQYN/6jdeq0IHeh9c6xlSNICo9OcX1MmAiEuvGay43xCZgxHeZqD7etZMigoJI5V2q7xDcXcPort7AEjLwWlEf4ouzy2iPa3lxpcJWdIcHjhLZf1zg/Kv3/yN1voOmCLrI1Fe0MuFbB0TFSUt+t4Wqe2Mj1o2KS0TFQPGRlFm26IvVP9OXKIQkjfueRtMPoqLfVgDhplKvWWJA673+52FgEEgm+HwEgzOjaTuBz639XtCTwaQL/DrCeRdXun0VU3HDmNmTkc6YrNR6tTVWnbqHwykSBswchFLnvouR0KRhDhZiTYYYNWdvXzY+61Jz5IBcTJavGXr9BcHdk/3tqaLbwCbfpwjxCFSUs1xfFcRzRfMAl+QYuCpsYGz9H01poc1LyzhXwmODmUSg/xFq/RosgYikz4Om/ni9QCcr28ZPISaKrY7O+CspM/s+sHtnA9o9WgFWhcBX2LDN2/AL5uB6UxL/RaBp7EI+JHGz6MeLfvSNJnBgI9THFdUwmg1AXb9pvd7ccLqRdmcHLRT1I2VuEAghBduBm7pHNrZIjb2UVrijpZPlGL68hr+SDlC31mdis0BjP4aZFEOcw+uB17y5u7WOnho60Vcy7gRr7BZ9z5zY1uIwo+tW1YKpuQpdR0Vi7AxKmaIa4jXTjUh7MRlNM0W/Ut/CSD7atFd4soMsX7QbcrUZZaWuN0KOVCL9E09UcJlX+esWK56mre/s6UO9ks0owQ+foaVopkuKG+HZYbE1L1e0VwY2J53aCpwC77HqtpyNtoIlBVzOPtFvzBpDV9TjiP3CcTTGqLKh+m7urHvtHSB/+cGuRk4SsTma9sPCVJ19UPvaAv5WB8u57lNeUewwKpXmmKm5XZV91+FqCCT6nVrrrOgXfYmGFlVjqsSn3/yufkGIdtmdD0yVBcYFR3hDx43e3E4iuiEtP3Me9gcsBqveQdKojKR//qD2nEDY0IktMgFvH+SqVWi9mAorym92NEGbY8MeDjp553MiTXCRSASPt+Ga5q7pB9vwFQCTpaoevx0yEfrq9rMs3eU6wclBMJ9Ve8m6QuLYZ58J41YG3jW/khW92h6M/vbFIUPuopZ6VVtpciesU74Ef7ic8iSymDohGeUn4ubT0vRsXmbsjaJaYhL8f+8I5EiD5l680MJbxX/4GYrOg4iPQqpKp0qddSu/HKtznHeVyxgTwhfEORMCwnaqetVSzvidaWN9P+fXtGXfEP9cTdwx2gKVfDdICq7hecgRhIs0qlCt6+5pGlCc6kWoplHa/KjP+FJdXBU/IDoKMxRjFhSYkggIkhvRKiN/b2ud8URPF+lB87AGAwyMjr/Wju2Uj5IrppXZWjI3d14BdKE2fhALyQPmHqqA+AXd2LwvRHcBq4mhOQ4oNRWH7wpzc6Pggfcbv9kqhLxrJKEaJqA6Rxi+TDNOJstd5DoRVCDjmVspCVyHJsFEWPg9+NA8l1e4X2PDvOd5MPZAGw6LRhWqeZoSQcPf9/dGJYAyzCmttlRnx0BfrKQ/G9i5DVJft9fuJwMi3OD/0Dv1bRoxcXAyZ0wMJ6rwk9RjRTF4ZK8JviCCNuVt/BqQYiphOzWCpnbwOZt6qXuiAabQWrS4mNXQ7cEErXR/yJcbdFp5nWE1bPBjD0fmG3ovMxmOq5blpcOs0DtNQpci1t+9DKERWAO53IVV/S4yhMklvIp0j0FIQgwjdUptqmoMYGVWSI5YkTKLHZdXRDv9zs+HdFZt1QVcdlGOgATro3fg6ticCrDQKUJC7bYX50wdvetilEwVenHhlr85HMLRLTD6nDXWId4ORLwwe5IXiOhpuZTVTv+xdkTxJofqeCRM/jcZqQlU0gFVTlYlfwMi6HKR2YG4fQ8TOtgR+yV+BMZb6L5OwDc/28/xdfD7GXFaVA2ZSObiIxBwT2Zev637EuvpM6rxcogdM4FJFa0ZhF7nrqtNsqWg5M7hZMORpjd4szf/wS+Ahs1shY54Ct5J1dOBO4sdEtSnRc0P9PhgyOCt6aQW98R22DpAcNTDe72AHK40vutKTPfpokghRPuGvz0dulBPKfC3O4KVDCyWrJGO7Ikdu06A0keKlVfi0tGcpO0NhzXEh75NHyMysAMV19fq7//sPC0For1k2uFEvq8lwrMAfmP7afR69U2RqaILHe7glpc8HmVf87Qb2ohsw+Di9U+ePdHLecS66MhB/0OwdcXR5WBcWTZLGq/kiAaT+bzkjR8GIpWdv6pfIgQ+Q0xdiKvo+gNB7/Nf9knNJGxnh7LeZEFtMn517tNc74PPS0M4K3I6HHZqNPA+VZcBc/g5a2ARyqKrJ4Z3krsuA+VOJJz2KJpBMgCCWFln3u7k6/q3DETAubKG/pt3ObaNT0NI0Qug90L2ip5dHnZJUjPTvK5E96aX/4mRU2u8n8kh6MKbY7ANBro3huF06U+JvfyELQP25oIaj+n0ITQ4KT9rXZD4EtBIOj95fYNldDN3io/VMIvWNj9P/b95WEMq8UAVfG2XG0N6fSYdnBEC7sUEbatbDICH9qA8TTuW9kEt9DlFOZFP7bdfYLa/khSY8W5K/AkIIAPXtMvyVKyESjKx9nfragssxC0jFMVY94d8lOAwRocdS/l/P43cBGa3IqDa0ihGPcmwS8O8Vj16Uy55rOrnN0shhRJZdW8I7F0Q0KeHc35GFo4aJOFc25gNafBu1V/VO0qS4Qkb6wjRrnlepUWjtYyaDABZceValuOMtoDdeIITWKOJiwGPpB12lQgwkmXh9M86podb0D117mNQ8ElluFvbaS8RTKQ6lyj88dUwoJU/ofOeubhoXWBF8eNumkVJu+As3ED/AvLlrV91UowIWI2m8HBG+a3k247ZKAGYsOcWe7fTWqL8eqwM5ZFuoXbeugPKuMOAtOsN+4dSwkhrSAlfGNTzFwEmCNWtzpa9CgPbYNcmoHtO8pj8qMvlGET6nrkJoQ2lp5MEUV1E2A4ZH70JUlCLXvqTIpZlzyxdr5p/GZiD1/BuFOGbyfFzhuxaC/l3lC2jjt6GNRBa06AqqPlYtdA7kiidYa5Qi0/XpXiMDyMXNOj3kmJEaXufW0GO8+DF8OoMULX1vvjCePKNis4AmxQKLCF+cjf/wyilCJvuiyLVPSdsuRTPZ0AhpdDF/1uFmDwG7iP3qYwNsKzqd3sYdnMolCOuQOIHWy1eQpWhuV+jmSeAC5zCc0/KsOIXkZPdiw8vtB33jEBpezpGDBP4JLY2wH1J7Fzp8y8RICqVd25mDT2tDb/L1mh4fv9TOfDH5dTeATqu+diOZi+/sIt18hiTovPsVQVaqXLPRx/4R/uH/86tBMcF+WBkThKLfblcVCIECc8DgNRVX97KdrsCeIK+CvJZMfwrftcDZDZyp7G8HeKl7bPYnTKX88dXAwAyz66O2chkPDHy/2K2XcT/61XnlAKgPwtI8yP9Vu45yh55KHhJu93mL4nfo8szp/IyDjmFHtSMqqoWsj8WaVhbjXgzZxcqZcyOe7pUK6aXF/Y32LnBOt0WN28UmHRiOpL525C63I2JQPX8vvOU0fz2ij74OeJ1Apgu3JRObfdo9xGDpp7cv3TdULEfNS6Gu3EJu7drBsBsogUqUc6wAUW3ux0/1hLVI/JEKJrAGm8g72C2aJSsGAsKFW4CBvBXVlNIKa5r7HvT1BeGYBfxTR1vhNlFFNN8WQYwr39yT/13XzRGiF2IsfE8HcN0+lN1zN/OnzekVBKkFY11GgrK5CLxrE/2HCEMwQb9yOuP2rTXiZzTEETp/ismFGcTWmbM9G1Sn2D/x3G74uWYZY4rgKB2Zo2bTKS6QnM5x1Yee66Y1L7K44AyiY5K2MH5wrTwxMFh+S8LzNQ25z6sunWZyiRwFIIvSnioltUXNiOr+XMZ6O9h9HcHxZJkfF0tUm6QkU7iJ2ozXARitiL86aqVsMOpmvdIBROhUoanPtCjgft8up3hAaKpw9Qs9MzYtBA2ijHXotzarkV3zKEK0dFFQUwT74NgCmGGuSCEDmFCezXPC9BhyGhmzNa6rQeQQz+r9CmGUZjIQEPsHwe86oCOQhWaHERsv5ia9rZvJ//7UXO7B329YUkLLAiqpLRsVV5XpcfdawlJqi/BVcCqO6dr9YJTFFRMVGhfUbB9YWNvYPY6RyaydAFYq1YIBQxuNAGfYWLMAHtt2XRHoOKCLz+qf5HCVBDOPOktQ3SdJBfxUkaiD585bmTzMwU3oeXUHZ55EC99Kz9kk4ZXMIENwVVpqW2JmGIcUiutIMj2KkpjE2QD+dIZUCxcX57kH7hiuUPnKCTdaw4KN95XPeFRvMcvo5L8LexWqvaJPECzwXCs/4XPAlSMpWUzBBjK3pEnkbueMkMJQrYcnXf7PjbAoJra1VLX4YuscQLpaeYWbT+h24hCFrfcHjxxx6WTSe4AGY/KHRZCQKqTuFWt0D8RmGWmvXSdg1ptIefYPshuIVZT7CV4Ny67fvjJugy0TNYHqoCO45CB88kxrvIsih19DqjD0UqiJsTFPcGW3P/ULOG3nb8CjpgVTIoa5nO9ZYEX4uEHu8hLXrJPjV1lTQ5xTdZVagg+Wj8V0EE4yPsTc345KM6lVXqLiHtm+G6edC4GVEiPgd98g+twSYm18gCsPnjqlLcFm9e72CLJbYD+ocIZOxuVjrX6IKh9fh7WqdIZ66x9PWkDGOVVGkx7jM76Ywe16DX9ng205kg5eq+R2q2MguTJxYv/wWHliD9mOYpzZKNXYC3Wr4iBGkm54hBwkPzFhiX/VBHdVH/KJ1ZIMOHxIN6arKdxrm6EBsgwDt0mPe0MX1HRUMq8ctcmysU6xX0bzM1J07kAvq33jw1q0Pq2cyMWme8F7aVkfhzZEFdyi8fVBQav0YZqvAjZ83WKH726rBx5Bn7GHFthR6H4lFsltu+jWmsAibJ3kpWMG/QbncU7n9skIBL0MuXXtj9sJg+4Dl0XhKJ1LcrMydaIgyrgZgScP4k8YQvcsBmD26X1iYXKLzMYfZn2IfRjznsrJ1e5cnl/3a5xiNoI6n1x1U36FWckJbyx+hiSZg0QqAqeeSvzFYMlZ2REnO/a6yoQhu7PdHMYEPFIvfyGeyCU8e7rpju4DrlOhszj9rOIpNsvCkuD+TLyf5J7D/wsPkBpscFVI1q7oUSU9bN30vH5AqnO7bsf+9rGhtVjOJQ32H9hHSAzR2ape4L0Cz4WxaySm4jvuGXwkFp5NMMLrgZ8LdA+5uLuyxO5SMOmJNDBcbbLefv7z6LyxBwltnfQLd7qqpG1MmNcoLUcx73BkNF/xpdS0cKd6G646ntChXSeTZJJTFYGw39T7fqXDPKoG2cF7/ZcTvME42gXLVjTqzAER1Rt5m7GYsh0X0+XgOeW9MJqE5j/rpGzY6vUu6ACcCTzDMdZHiWELpDnvgE1hmztLcSYz0MtNyUBLqvylUJJnJu79Sku9NMHCTkgqozTnhMFfduV2NLCSYvAI5HUvQp1h/M02vKFD6eosIkGTg6mujUo1W8hy5Knf/erkBQC9LzNqPAYCgR+hczgevta88NNqSlBZryq9QNeUK7RpbvHjoNhUKAAeNYH55LeTW36KyFaXdAkBvyNP9xmRuBokPi2OhqDby6IZ61mwfzG+GmACkS+G80A4WGON5izgJWeeDK91jzusfOi0RmEsVJXwbVUr8u/J2LCQaMnHhi+wJTEPN9tS2b6W4GRGCNmtjAMgPsP357nOeD3H2tcDAPu5xQBKMHf/j4ZhXlkvvy3YmBJsjsd4pSOlfPZCnw5JvzxEXM5JIc+E2mU4CgB0mdJnH4NEsCHYNeVRDXFNuyZUE4nuvaJf1h+11AWLdAZ72D9XNRcxfb2+XHZN/SN48U7yl+sNZhg5gn/PD8wkBtnRj1zBUPIWnoMP6yGUEEzuT+VaX3x2jEIZAZsr3rs9wCfY1Ss0EdIFFzBbyruUup4EPanbSYew5tf16/ZWVup5iykttuqL4xoC/jdZWsAZeSfDSd3fP9kbyAFYXkf0Q2lmxaTkKRZrCo9XCoiUG4yP1URJ5G7+HSOhhJp0Anz0N07QZtyFUye6rcgiOFbtyoO1lkuV0iQ602MTyFK9xLqNHtNy4cJaTO6hjtiwNynVc34ZA6H7k8ai6S6eF6jIG0xJx+JfP97lzuCZr8vU5SIzImaNpiQhyvDbz23//PJcOk7hD4iIvJzfIgOGIR6ZPEJpWHZQoacbF+omeHw8aWHaNOfaIyGeG4lEryMfhtNmWh4RAIpn8dLs7ZE2eTVDwK++xDoSUgh47WDmKlZ/k6OosEUoQjk7Q+Kp7OxwgMFShAv6z4pTW8loVj2+qXLQ0T3hmIue8qHy1o/HXjm089m71t6mrrUyDftqMYtmfvQXKDlZ+K1HR/FkqPSqcjGlcPPIwbMw3wIFKBdVMJ4pFLt+oOIkWZMw8pkoYZ3byw4LmAF+7BdicGXFcb5PWtDw5XNNVc6eB9dv0rAEpgr5J+bLr010bpfGw+IkRoxDbkDFmQdEQUSElP5bViLo1ur/23KN0jEwl+rGC6AUMKxHcv+T9F1Ktpn8jSSrKxJnVkK8UD/tH5DN6nXB8mjUdFU539e9ywLtLYCwmHYVEVqnFmdubduaSd1ivIo4pTsX+mJcOAkrR1D60RIoocCBIdwJhCBM1rOE2XSlPo0U+khALvw+zfxYzwzd4roWlLJkZheFRR8QB8v4USwmAcDswUZ2P/7v7Xa51Fs7orYebYyww4YW5869Y/c6Kq2eTR9HLSjYuChTkXaDygoo8nz/yJ0KzfX8oowaNAwz8HvQdlLU9V9hjqYMURyYvPzZ60G0itmUdZwB+sY6rUkMAZZtWStbDFmnk/dQorhwr3121XQWffrK3as0g29ASwxbsZ3dZAq/96b7/XWckbjmo8+jwdE680DzoEUUivnBgowMuBQxHXoGyp+w/cSGY88rWtmwoyNNIvChs/QsZRnbdV7y8x7t2RkliJV/j8e6qfctrTsMV22zoqgQuTSNFh7U7p/Q49L0kygXNnEYXCBDgi5BeNWxu7VjULcUHI+lGj+OTCEATzWrDmaynq3wT9IAejtvh3esCu6sEu9JOsXxMDpqxm4Tzl+pt2Wa5Bq3TM5TKH4N7KLir8FGIPA569+uJ1VEL3fW8Jyigz/nEUjAVYrdCWq2MnS4hQVgcvXq9aF7Xke/k++rAtIQqckPNwjKrV2t7HCOrA1ps88Y5Rw1Zp+9itnB71j8tNiQc7mV1kUCQXkoi5fOsq1uC6hUPUL7Z69NAM6lg0c/aeiifHoi35v+pVBh7CDM1XfvYpiK5JIbIQFHafmnhHfRTnMagKcjdE7zzgtxkTPKVrObTySTT51g9bB5ro/dzn/sB24fNM2LGJuRQsmC49PLi1jTRfZaLpo8Txxxczij5Pl2vur+S1wQW3W5qyVcIUySZHtFDQHv+EYDoZG1T1J7D91vEIV8dHzUBzW1UyuxRbP+M/CM/vsas6RzmS5traXnQ0Jzv9hYXxKHcs15TQCP744XsLjzFjILYURXFnhM+nnV0iO6nwls9TR4tlz1J9/NvE8FGg5mgpZA4htS05AK0NnU2gxuqf2vjCyWlm3ypKvaX4vxh8Um1MHGB2NTeAFhbDyGm+5w2zqJAWxVlj6dVePb5yR+aMhuz05YubCQJ0BOtoYQ6PoDoW5fCwCtXj5SHvCgL/3B5z2mcXWaRTf8/GsFAfX/ntdWZWFc2xg8MJeenwZ4dZUToce43If4zVb1ex3BMAWGhgkPwR5EgktZhW3Yi+nsnZTUr9FYI160YhAraB0zMV+ouHz6hYm25/ETDM0MTmcypoGgZISSkfwYAQaHGY45yZ91K4A4Mm4fnbMk8GTc4orypT3NLBqAxYdcY/qCH82PpIkmVOEHi1NoYaUymuImLLcib5pmd2MHTB3JR+4rLdRc3gtQ9zeFdciciRiWviu3HkqaLSxJeI2rgc7OKQslItumACQow89elXmi4P3gTZeCauvMH5nF4VrBcLjjwGD+KlKqe/RWIEgT2wGqAgSuL6b+RTTPnQZzxZ5y5HQJkEEKJp5NfoB8hJBM8qn6xbOFtyzBjVBrwSS1zCJR3lEc9ODQ5Wu/xct9/2Q6qLHnmNx6XwZus/i8rEd6UsVxGtoDrm+Br0L5oUojlwdcqyVV4PIMsR60JhZwJtgX7izQWj+GOeF9DA8Wexdmv6DWjgR8LEBp9YuPAM8tJDu3uCumNqHnF2ATYX/tuVO55OgQuiUhmDmJbF9jJyifBRtxOVI9DCNLUY71IXZYTuiYcnILQ/XHuVJ8aHDStL0N+3eYNvXwHi2vEiTPnBqzsC4TsPnFVnYY042j5i7C11AVdBZ1pGSa52jM9dIL119rry0mgGxFzI8xPs+7bmMfYKh37A4HtA081olG1m9S4Zch2hoNCGVvVhd6UL7C2d5hKIBHoB+Uxarq/4aQXhh7IWjSj+ca7Vhqb4+ZwY3nHXh2S9JH4XZxQojbe/eINxYlozTYtT2rpU/xbj+W2hXjFQ+z+dQ8wh9751MP0UpjutQdxz3/FJYAEG5BF400JXWCBs7KrCRf/l+F+d9EuwVk6thOPDB+HNS9iWlLmDgXvY6K0vgiyoeA3An+jWufdAG1suUMBuJT+/w0FNJZbObUT8c5q5WtQxASQF6E+/u8UwVBs1eo8jTamCrcdhZJlADJbqn3crcDHQlBQNGq7btcGKiJXW6q0cn3F0xzf+k1JJS2testB3rx15ZPTDXm8QV5XE2qxBOdM2n6t5YbxyNOmEdsHx+hMp+y9pWkcgw1NikeXuafJvzcjaNwE1Ad6gG79S68aO7jWpKgBETYLmV4ONHhBk7Be8tjf2WVvWMDQvQdOnk448yeMv1tQKU1xev0L171e/qxkMZbmkfKnd29XRCK2hgNNJhwt1qiYWZGKz7Di6K3fGDT7DO2YQ7WU33svE/WKGbWQEvzUV2w+VNYDocI4yxQ6i3i4zU2TjmjCwu5Pk+Ja9HSwLpEoUswq3tFJ1jimthgMXd7KjSl6Qd0K+vxWT8G4/+xITHsWDGSfQTSdFQth5uVVfa8wrkDZHTGVgpJys2ik+3I0dSf6TNo6A/sVptyY/kx1hdAWKPI6t/xj6s+fPMU3hg1vkEB0RRHq/tCy3KUUhzU/d0JKxTyjvUms5iy1GbOFco0NA4t83SK9sBmtLWm4kOLLflyxqgQYP08iyXwYXzKnlQ6VTipuaspSJ9g5H5Lu3eLMnPKbhcwuEg0VZ80ppJWjUnhS3rL35erzysp+fJhxsUs86m28/UwW+IgrS5Y0zWaxlFJ8xML5wk8sg1ragF+eNajyI0Y4mwStxt1RZH2BjaAhvu+SnNNIK88thEgZEsoHv+ii+OMmXJL7dnAiINVDz3tCnqDgpQX9OguNGgZj3axcjq1UgxDw785yNIpqNiLgv57399jVmJ0/RStNswaFIs6FtnkilFZldxj6m562jL4p5g3Y9XCiXRJX6nq2PGJFifFR7EyPG4jDMnBM4t+O8ZpEp3th7TCxEw+ZG4afHl4sNFaqxyLh6+979tt0Aq9BrqI+CS2U7HJoKiGmyVU1lFa3/0O5mNC1bzRgNMy+GXyifLwJP7FwUSUmxmVRpn+gnXWoIuswPutsiciurvN6lsMG7yqEc2Y5ZI3jrPgPq0xEKPZpF7teJa0TQn8BQL4Th+hjv2ByfwKookyXEmj0d1KMcsmfKaeKK3cZZubiYqmSCrnGpYTwgPk5itKucVtjViuswQsDR6TuyGSIHYvlz7wkLg1Rr0K9kV1o8RgABlhbLrN74cVWJW6TnfXN0q12JFMpUbEa8t1+j440FA+17o8qa8PQ9igkctVROVIfB3jU5vtGm5pYYHYSDvU2TEc15pIz19ka1q6c/7WXfF8+POkApdOw7nn7Kqz6V4tru7NXgnA/u0g6+fPRT3hp/QrDQwMsjwNCZxdWrR6pgCBDJNc7/KAlwC0UZ4yWQs0KsuwbbOgcTxQPK54wiXr7s+221hzZ8RVxfoRUKM3e4lpxHC83JllxlrV760tl06f7/65qhE1jhMfivAUXIXfRMe3uY/G2TpWYzDrw5Cm5cS062Bx9lhHq9gtJp8xZwAtSdSuW/Kd7+orEAiswA76N8ezmVGYgNaYlQ/xk930LAWAtKVBC4U6R08L45IohB1kFia7XJs0TcaT2zBZoLFuOGu4iJaoAnfjL3uS6gnRH7G7A+aT6ETlmkYUfgrBuaSLLDJfhPJe01PfN0oqBTeQURasl3N8BZiQSgdr0aDv3hPTiog4NSyfAUyy98WP7dnTDWQTY+Qwzgk1uxwRqHl5MpC/84Cuw1TXfRlgJrwPop10kCHjmffnFdxCe2J3R3J5j+3H/sZn3IUu3Suy+I+dAOMWvzwExNR3RRPVelZAhtarKlXPWNjPRIVP4JsAFSRXs3o/fSYAPaV/zP8q6DltH47/rYhCLdy/LrpOsbaLf09eACcClJosNefetNElkSFSuCgeY7oTAAl+8Y2zOXJb/bgEDpoDXfQqc6lnlBr/WsmVznkBS1M7ufiqpxvKXjwvR4WxLbh5NbMNy8LsnX4UiuAi8XonbSUcVZKQOWBYUecSOMj6jMG8gHu7WNreBHY90lV7FocDprSrSbexkAtMW9KlXcnrOyLnZdodGYdxz8aw71HztIqLhRdCOB6NyzHPoS2hDy6wLk0I5Jr2t+U0A+A7EsgSn/Ih03A5CspHnVF4MOic+Lck3m61Um+GHDEe4DrHBhmgtDlRQl1XJ/V/VumCHtUDDcZCkgjVMBOmVOGYW0Rcdi1ahdjhBcFlfjA+5cRjBop1aNDvdrf7CxkLVgxiCxhRctW8wczM8+kVmIrGtkaHGlr8y2D098HXE23r7fnJFUU68zyeyM265igNOGPzFG0dIgUDWN6S3ZcfMERJdWVvpGhVEHXNLeWqHiTcF3wOt0FbJY4XHEpmkoG9MQPJJ4ueQ01+MB+SR0rCSGzlE8zod19q75LlLWgzogpnJoD4gPxUYcX+Gpc5Ly4nk+Zm8LDXcNR7SNVxLh6NAcx8ekjb/AC7ADlRnfuHaHJaBodZr7RBX9FLTvocY6kY8bavdAkQicE9bbwGLkZu6whTCJ56lOvM39ijehpTOFqR3V53nQx4hfOvwRPU2y2w7UU8yiRbcyaX6jGJ9CRvl9ybV1tebTp5MMuMnwLcx/lven0w9T0atJuiUE2WtYGiVMaP3EchABl5AsyaCpu/BKAWDFvU2vaCL2/fJBKCKLjxG6xzT4Mh4wHhH3/EqsGSoQAHu2wbHmXHj2LvoW19GXDa2oyeKRwGG1PU+S7mE/S+UmjHiDF1oqJ0R5QsdjAZYN1MzpNX5YDqWYfhfdjAXyFQaVyGKkp1oEGTR8MK6jaGfRDFd41u2Ex8ac8jKPYu3pXsk8gu+m9tr1RVzTTuDsACW4S1h32yFHX7qpXSmA0QVEcR8W9j2Juu0pcYqTmdis88VgT3gq7iYue5Hx/3K6hFQa9rZrNSDcjaSQlNn4LSqs20bypnKqpzvnnxjMdz5StbzvoAJKgVZa4DLCVoJW765/KyTF4s4YztmAT1c0pTmKJHTpa106FegDo8p2zD6uOnwpYi0vJlRMDe9wPT6964UfAf6lq3qWypUOx9q6BbKEYt7K3gWMXDNN6wAm1fNnSOnZ4JkbPq7jLQrl0wL1V7QwO/sXneKGfTgUL28I5iPVG9dA2gS7Ki005JUR7Vmw4gX4TJvy1WS74cIXD08LCF5obqcZwamuoZ+FPMJEck0TLHjyH1baPr55/Cy0ptDfRJ7d89pbP48tLMHG5dO11Z8xSSpPGQSgXDWmpsNsmm+MvxJjMCi7OFDHxxpmTtjgnOCq+c7Fi1DybfhAntviKccz+sj+OPKPYOKeYYPLvq6MpUx/chSvBccg9dfbeqetQNCs3eiCFZTU1mrDido/mib64STMgsa+IKLk9PyxGGbVSQB9GsHto6f5prAFIbRDSItDedz3t5+Nn69FFS0nEfmkF7hKBmNVce5xv65USKGBoHYxJyutSGnRIq7vMDsAMvirOEJOzNi5Kt7fypuSU2c2Npo6UH5jMOkePH0TwgpammO3Fb2FX6f11309z/mqRmQ949HHRj/wMzKNx95M9pwKf+UQkMEwisL3YVotvHhCv4y00Ui0Ql8dR7tGqFcSdYtmoAOuAodkBNs4PZSjAAF7S/szwLddFMdCyB/dWPgFUiUE+WmUUCjYrKfJLQfNNpQ4NKaF57w7Kp/isZVwQPUJyjJavN3fQNKU+F74jVBJYQEcEdw0Niinyea0l9PJ1/AcTm/LI91RZjDvLI81pnat7RKU2P4/TnIAa3hIEfeg4iGQ+wTDlURK6YjNpN5s5VkQW9w7sDYKU4XmjyZsCQLxztqd4SDQvLyuPDhURAJXKfR1c7tq3mRu4usFHPqz7HgS0X7kNxiWWR3fb3uVwbgKpmgLYkwKrXKt09COw4MjhxeZlDXKy7nNLHXAIKPtferWQnZLboonQXK81x+BB3oUidBehK1swSXxVbscj/LsfONu/xYEXYPM3aMqIYd+2hAnFvDHbdrJLhGEd3sG5PyxqhzejhQJo9wauFK3xmPYqxB99J8zYU9/yzrEZNzzbvPoR9vUlE3Ha4zspVDzHHffPZMJ1VLZkKqGCf8ZqupqMt6T+NRPfmPm2xeDgvzMrRJEL4/zzlu7Z35smvzbgeC25VP2CUrZkRxEi15A0769ojdO1d7C9OG+swj1ROMM3NgKdeBADoRMeJkRZcZ1FbQu6C0BS9NNSaoxtFzYT4lX7+PQ7BKa84yrN+ujVVef+SgnEie1G0N+eOtbZF/UU+wkeerWjloYqFiqo0vBnmxh+TwNMo9I/8lfU2XTCT0K4OoWE08ipyNHjxHvfhY6qa3x4HzdQ8+jkiO5+j91YkihS5memfpFREHP/2veN5XcRue2zCVuAub8V6vDlOvyP+PBm+owyRhMmng5wwGGIXsOkQekXrXpE/6dFjkHwwoFoj5bIFiqp+4wHpSWRbv2xGrRpd2c87FzMP6Hfj/3LWIBqFiNOAxBw+AAP1XqUBszdZhzOSQrQS4Ein4fyV7MaGsB0VsMF4bPb4lx/foTGQRJv45LpoxDd84xCawHaX7jpXUrOdkFxx2oUvY2xqpgIvcVufwd+zAnaaVTnEyDXD7S/o/xrrk4mgTjXhcjj5Rzrbr23NmuZQvpdNzny5MCR9bwvIRIqzOZZLsstZSCDYa56JTvzxgBs20dYTtTUbe21uljlWqGfSh2bYAzOpf6UguK30ZxNXgLHs6Y6urtxFA5iLYvlue5mDONW0MOtQjhqr8fRbCkYneiDkvzHkQVT4F9v9vxh2SIGPBH8bZb8ugo/BSgXojeSdNXbBAIDsB6DUNSXnwlu/bFLaCqSbvu4+YLplwO1JbtrMf9ZUfsxerAZjB7E/zl3qwgK27FswemUmSM4i37YAVhQSocuV8AcDI/CSeCDNPavESshDQ8A/lVIrAJAMdP/rHXouiNU8RL/TIvfQiuZEb6dkIKMGGOW5kT8vO8pivWnT4v7qmwuJo52AS1r/RyQ2g/7c9ZJgmMIzf0GvJJRfMNu1utRNuLWHOm9JIMcJK3qiDtVpGCDP45W1oTTMUnMC91kYhP0GHjhCW8V38xhjHgFFBfuWMsmSQ9MvNqKXiqtUhDAkIy0PW7YSKaKUv6zctAiIk+Jt17kG6LpNVOeMvJnlVBaJSkKe0HTJJUMvf8R2zna35/yh2wNlWLzIP3BJR5aRNxkV94ICOlycI1/JYRZtzvWMNoIpQrdNvyBuBydhSwhRwPo079Xk/XQZpbhzN/KK4NbdJQV0JIMP+Y5UBIM3TTYlFGYVjcvA5yVozkimco91Fx/eo+ydgAx1gMezTh+bYxCtXPYkMoPdtaElRusxlmdSV9zgF4Np+iylun3LVxCycAFxGCFsmARf6y4I6zXY0tx81aQyalr3/ih+ZjxGNWdhItgNLdEZ/BOIJpPoAveh2bKbEFxU/M0+4xqDo3Ox8MnNn8Lmv15NJigSvJV+y2W/ZogEXNiv0/nuFzZGr0pKujOShzcdkEVlMw8mNZXZCbtM9V+mfawtLxCTvo+enFWhJcFv8LVTFycDjPGBXRQKNN+z68HJtYdpH++g5WdhQpCO+DE7Qdu6TmZgtetrpU2ZlgpslOx+4hb3aXaqbdc92LCh51er8vm1GQ9uWD9+fAPRV50ixhgc5zi2Jsg1xQVxzlaELRWJ5biyF+eCwNV0oFnTbBHr3Glm9qlGVOpoOsQC8hlNG88fxeAekkCGnHFn6i5WzyO7ShDYbZ2KM4eqndyy01v+6TFhmkxgc0dndt7EzRCcEfBxSaWZwcev6MDZcuvSZQ9CNSd4Tx25TY6UAbrhikuP1vNFfPdZhCG1pe6vx4D6Ez3zIb0zDa42FPpxWvIpEeXb7YTcfZOahSpSYaWLH/vq0F3U1KO7ZxliZpoMBBYJs91IE0bOkrPNQ/USYY0qKCO3CU+AFbOYxzKWBkIglrX34377BZ18MKQCv1KWfIHEeguSpvrNH5RQOD4LeiH2gdx1MOAKphlL41F4RpxaU4dy8xERFgqoyICQq9XmQ8WJSokwqvhQM0fLtsvyCO2PAkJ3BZg5IqoR5q/GdTLgOWPFR53Nqw9Ma5vBzZcQ4+iZgetmKg5ZIn+/7Jbi+VlViXuD9CaAUtdEmnwWTS7wZWuskVvc/SDaaKV+Jz6HrZTHo3UrAu0IZDBkXWmL+mTTjdTb1A+MdhKkY/hvFNwXj1FzUngsN58u/kTdJ3Xi0hy7efR6faAOi4SKGaiOty8lxDFkiD9wq2GW1EZEsoWGw/WzxXhWDzYY8CC7WuLFHc+x19jhH+FiLXwDIARRtnkJPF2BUPZ9+grZ3tjqAWhhN3h74w5pooRQUNATy05A9HDLnILGSCtfESoSilqtqAIQ/TV2t3KhOc+teDf5t+DqZDdB8Ob9YXyklrSO73pR0QAxPvQj57c6FIR5dOciqeHZ2LRABMROo8Jk8V6JFewCL8TCd/A5MSbXLky1cW7mXobqgeEXdFDoEydKo5oCuyn+2JYI/7pIGFAzErlHZ5hOaiT17HC3zp2HpJwsIAb4/oIoZ8x8ak43Yp83Ermq55Dg8HxKGHXbXs47sh0PzQELTGFsf5eO3lYAuJjMneoYWk8W/3tW2WLntEKBZEW4hOFgo8K58Rj0vk5KLyezu1d8SO/JcuxpOJqFUM2sxBmbQ/9qqwb90R0WulpR/Ju84bQ5/fTh7po/pbBb7AQaYNdK3fatD3K4TLHAaa66MQzp/+ZGyCjzo5OXRzJ8UHyg/YpNHvvlOpwQIOjakpLHwGV4WsLDPjEIqG23ily3LL0dlkYQxj3Xx0ApCo35zYGoGOtIclYS83MnI5TwVdQ+Hg453WFQN694DaqhGaL/dm0KncXYqXLi5polgT4DOrzD4oSVhrkh8GW2PaXjOFDCLPcn4RQj8dRGIJuV81LxMPZ0UL6zpkaebhbFBxcRJe38UiTbUPDjFWk2jBqzrBvXcKmgdDcmRyJhIpuq+3DQY464AlY42z2EM0yIK0I6b+VgpanMfpdWo7OxKY8RM5tSJv340/qD8SxrYsybMuUkF8fHj7HcvxEPC5YYrH4LW1YKg6QaeFZLvPbrHZHvi4OXLKkN8cGQO8019OKqcv6QnBlj01e7qS5evoGm53rv+VmDxxCXDiOrDg+IaPeMPrn8TJ1oReXYI3yb+4HQbikxP5TQXHk4YXPUv95+KmkxGsRgTwP71YiMpqNXp0loHZeXRp9i3euKrVtxMM0e6XAoACwNtcc6sOuhZVb1htBLudzahrDFt5GkdlwHjZl5y0LbvSHwII+qYeDwRKTTzyXaInHIM+8rc5TrjUlPRVwB5LKFpQnV8e7vLv7T7V/iJTW9h9TnRtNCSGcofBWYm5P7wZcAq3AFamEW/GMbo27ldz0plt5HI53ddWkn9IuCZY+Iy0MATUh3YenRTbVgdLYtu893SuN6EL4e9V4NhlzUjI8nOS6B99ecyC1Ot8sDahQpWHbmt2YvWGyL3S9tEVLKYs+LnghBmmSl2uPWfqPobPwBHNLW21LUjfZb7jfLMTsMp3icGO1npK/rCsUgdBVKVg0Ys+/WKuTmVJoC8Oe5h3PK1TQhbpZ2ytP9nlutQPtLAEt+CVT90DfVkn7lHLOX8AfS6HLzfHeAhu1alnl19RHKV1LI0G7RPzYgVaSpX7th9f06uo2WpxjL86i/2uzK2qj/ClHbGDyQr3F9/axmq4kJ7zZFVXVVwfiFr5bhUGVZeQJHKFAcsnqPKsb8vHyB9SpFpT9U1U7D4aS9vYgqajxhC+hOkolJV2dKAxysCkWBo3SPiPUrSQYZxOWwWCoQzbV0oeaDEcgUtqI3nq9TSmpQ688/+wb26P2CHLY1H7q5lypXSrnwnnztq/jN1o9lyvLmLyGguV0VJnDCREkiUNrZqGG06MsyA+Phd9CuFoM5M1Pyk7S6TJaHdTw0ni3n5ysAup0kyxr65lFc81NcH8xSmpp+iOEtQZrH/y01k1rGMRJAGFhi+nDecpUlnrh+qBOCMZCcSCovOPJrxjZnZJDMLdpMVu+tBSVS1nKxsYjY9Dtq1/++riVfLUVhzofIcIgQQPOqHioELxU3EpCcZMoL9laa5YlOZAMEp5apx7CphrkL+fyKbBAf8ctwVd93FTo7F5Oc/alNsCgK6lHruPROtN2RybiLqx8P5LTUZXU+Aoyz08zYHasR3U8hPDKj+6arWXR9yWdJoMn45prCSURKKy3+JHgvs2Ot6v6GbEtdCumgCttv2VNoU3KOqUwqNIWHqYm4eMijTM9VWB7umEyp7UPOI8fduHJY0W9xSCZdvc2xMjo3Zdu2o/WZKDMOSh9UmLvo45IBppD2dG++HJu8kbfFdlwuIxk2KHhgHQeNKcHhFkYGRzL2VJVMOAb0Co64wvds5CaYl9ZmBm4zuGDeaO2eI1XM4+rD/HmZyRF62SabgAe8TF43VuMutigJJMfbW2UK0azGLFbOfujnHD+GGBYmSmOQbUCOY99HYvswBQA6r9hrc2jtsUUxLVjxnZ4JnIrTwIVdWCTPtpJpvlA7m01/4tbUMyz9mv1jdN1jkiHQCJXXKg8bJ+aqW6rbwbn5yDSHBTcFXIegrhHGAjJOZI1pyP83Z3vMYTAJoo8V9IwyS+U6OVg78+IhSYHDYjRs8FrF8smHQ9h4qAYxp49rRP2d5uxLAuP72GvZaYvfeLOkMrcg0PkPuq7NsXhMFmiZa6PKBH1l+oKHI5DBLdZCvCwTPdXqmnz8gLzVRb/ixLTSdit2nrzt0x+5rDeZT+ac31NKNskQs6noKlQccyD3UxzfVZFmcbpmrfPsZD0Ve34xpKWk/E9Khn4A5yVPVq+dwnv0EyYecPqXGU7R8suTW0A6NJWweLI3iSGDlQXzMYsSWkSMhFTfyA2vTDt/3wXk+mVU6bRNkZvNnyVHYiA4tmnNwdh/RVsk/EgSerfTIf5VBmuAc2IKSeL5Nbrg3acgFj80mI8SWsc3dNAGCBLLMP89gH5UnLTKq78d9SxQH/g7DVnBh/qnBdw5CDrw/uMzcdXSxWqGIFcnQZt/1aOHxUg88MN2w+FPx/V75gy2wzEVe6G51PQIR2tZsxbv62HhgjwtlzrVREw/yzlaAiuXC26cnpvQzWXp2mOgihyPCWqq38nEadX2T7f1Y5zGxEGBaT//IcL/BsquAJX5EDbX8X1p8nLWR2yyjFRvqC/jssoCJBCDJOsZvoBfXqQSEKhNARH1YfueeKBslAwLi24/wAO1BHptlf1kQFNsOPlDvlYednrEp3a4SAz/G7LIVEsZBu0EKWZu/euB/XKdkGonP6t6lgEcCOw8mceuzvEVzyoPnMyzrqoNQXJb9C8ZCXSiedKiCgNwfNkpVlHbUgE2Rb9WFScOeEad+T+jT8XlSc8rcvkIuhAv/gxRu2eb2GonLTyokjcGF1EBpCJbhy2H3lhL0rdZIw1okA5pBg2oRfQceXTPzhuNKorTEF7t1UIgDqIo7/loxyTgbtKu29o9K9KujvCqUGyPY7upcfiZLNBVKh5uXAAZjQjhlhBp0ukmO4Avxu4xAVhCtnsOIA/tAm94U3HEuSr3wq+ZLo8pyoC9EB/q3pOzQRyCTkozmJwo1Ln/2xEbtNnS2S0NUIS3yz3/mBIdxONHxqP9FW+uoGI1F415lI1nZwK0SoPA0+flaokBGEoXgZnO4GOExU7VOjdPns59ekmDxqNhEHeAF5i5N/3W2NC1XGFjTpqLrnCECiwVkOTrLtp2ehUIaejOG6+1336YQSKMSsL4zhUjw6SQKryVRz5Ldn3R5/r8AOi02RJkQXPdvPsl/FMg96E/cJmIFLmEDzr1Gkh9G3zisG4pqM/MV6XIz+CtDUh6hmJB97VzN8jaPSS90vgDjvnaNlKky2/zIhE9ObugwrftI+Oi2a4VVaB/Mwn3VmaWjsU9NOf2usbcN/GLQMjvfeU/YvyEERPKw1leXZWWk1HXzY3P9MUq6MZq1hkEgFzds51mv8mnp1i4pQprPwY0TId1szXwe5TG+R5mMD76nGPQr7/EhQWksjsgGs7Zy5QYvMcGV5tcXJR+6hlHFIAc/M6XjkKYtwm673Bi+K1tNO9i1YBePTur4I+gMsOK7f7980mcJXhgdWdhNzUN2JvFsvXq3zZRG2V30sJtJYxj0aUv1u4/ppVHi1iHnTY3gDHsrQS8YwMX5XwZ2gcFYYe2wd7ZO9swr0gb8zf/fXx8QWKPXcK1UdJk3760B/TMlpWLCbhkqVoSTsOqzgkmFmFteCCTGhNyvFhw1RrTIWzRxq8Tj5FirvKvtkp2GAVhnZ7vnr71pyI0rKwQbVxKZuqM7GAvn2mRBj5p8djlHUsh/r/eBECptpbbjP5nFyuN4mvQLZCaxeTkDUzd/kNGLIzBFv1CElQO+xmf7Dzt1f7GM1Bh+wLDCJZlhcVDXbtPuGssdEie3lZNiWcXMTjZtWAT5MCmpq6JCRuFSHZYGKcSFZ9kOYJfEqLIcWdzpTA+Hmu+ktgSUwXVSwkaa/aHdZXh7IOyrudCBalCZpgXGRNbhN2XpEY60DXXO1Ci5ayZSoxtG0WRCC50+XtgWz7qgX5MRA5S+jzXCYy7O7Nn0ljVxiBxQNCZKZMTqi6mPfy2LZx76uyRUXHjnpJJEimflHDUxyX7fFg7iJvSrsZMH6Uv2xbfQNx5eCbx3oKycUrBY22KPmgfg/w07CDVsw6tb5VxPg5/X38cQtXI47U7MAGGjO28II12T+PjaXHlstPtkUQNn0DKkCYis+kVAkA1wyAJgYKLGnKD3nlVCarYqCkNIZbiVwO2Ydjl7N6iOtvvbAfuq7VKZLo0jEdw1YdsRaHcuJQulgb51JyELzYBkP1hd03IDcZfPg5XmNvYQSOINsCSn3BuLtkCPZRalK7+S97zxvJHiJCZJM9XP785NZ8B8fqDe/Ot0BS3PH1ptErwxBtpgfOj4d/41nrSjJQf9bV1kfdBHJxYbHILxOsWkZvoP/Z4Sl0Yx3bDjTF96xf96+6uIoQ351Ce6DeTwTnkPr20YwATlnhskWIddUohklNITCq/07zkiEc3B58uiBG6d9YAc4h/7s44FN2RG1UuZWeojrOZIhElvDP4KqHcOYbqqS95o7ilQH5ONJfy+aYiB+sPpn35HfHG3duLpNvBjXc+Klf4IKrFHjeVty02xPTNnbdL4gtkqPqMLhSgR/fDXzxJbSScqewiF1wdVoJ/fGL/nGWZfVlDHOQKD+/i/mqwXqvNqxtZeRHwoe/bodk66B9soOnZp36gdzVMRRQsQiBFf+HXjRcrRf9FsGghw3+qoN0JeeMvDJrkSBPsESDai/uVOzn2Ohge+UVdi050fdWpsjP0D/QuTdYs6QyI9xnhU8WT2+KBKzoZ7Bq8fOdKPeLulUhJjT34/EOnUloqus8+pzqNh/UdUOhgTlrbkuTfsaIYDm87u/GNIl3N53uaU8bgaBjpz0jdu1f59K4KFDtwUUeEUoeYx6DEkWKHdi7dtHhQF44lbysk7PqERrsuAQu2D5tDMl7kFoGdI8r/s8rMytJzYBU40wqeFvTl0ZVLdOB6Ya9E/f8VPbGx5MdpYqYMLMyB0QxVdnoJ+tgAQVWfH+jtOHD3PsjuT8dOTSrupuvHWRHQoGI1Qj1Hc6k+Mg84FAZ/gzl3SEzuGWZKFwuo2D3EiG95D2Z1szTqAuFRmT1nEh20tkC4ysmXx6JtN0taK1iRR62s2uNW5rSAvMEJ8yotr3UhJe22brlQn8Gvcq1I0aODaHJucQKVe6SXyfcDWODMw8xf+2C7Zx5a4Qlh7pJs550DictL4OxcDXKvVmLgVWRwb3moxv4kcxzm89EERJXCl7X/BziBkGQWOHPGF+6K5NFJYOFVv4+NyFq+OPMaSWZKoydplufY+CYyL63T8MCMmwqLTmAE8h0prhi174wnx7DHZWYuRJSYZ63uz97AGOzyI3aebclnud77znbZetbWUripe+AadLQeZPtWsF+FNiaXCy/98km137lWewyc7Gamai1Hd3Ls+KMMVh0R3NKTQ08TIClDfMKwUGKy/7YZlJHU3uW60X0r74Afh02v5MJgVOYkjmors6GAaDU7yKHydfkXYd6nEjYc76xws1LDLWCNNKBtUHNyLseOyNDgmHiJ41lXvq638RzDGis8WIniOb/pbTs+HsQVGPi6mxG+CU+oflMR6/qx3pVP+GPgqa0U0lo8MVmI1cBgSnPGgrh+J+m9TVg8nivua0EQP7xai44ruC5gsAVOp9bLsDXfHQujo6IpBmpfbbU8PDavZpTuJtmflVQuOImnRQ5kKoQz2NBFjdiHH3cF9QLgDP5vz/W5trCy22Uk+TCjXjdbCCHB3rJhKYTwiyQUf8xu6yTKtIwrbw4tzFgXDODmWYEnnpDupk3b4AP3qz4AZ2En5wi6aZV287AgCF4vH8TlWLni1E5Hd93vLxSYLBWSuj3eXGFtWyWpBkIeKu+YsBh19VeakA8OePM0ILu6dYYl9DNIK3kU1ybH+A5xYhFI/EqSX3vtNs6V5eQgxYLvu0hYFjiG+n8JzqLQVROiVa8XNQDYJtDAetPFSuEtGI3B8rnbbrNo9TJn/z3lRYq0ecBIe7a03vLESwhKOm1bGTk2kPMv/Sh9wyCOmIore7JhSFT9HIjonBfi+gcdDLfFt7dpShJmW1gkcXmitWwm1cC480CraHm/or2MHphB9Q1bmt/SBXFqXJdcv5GTt3IS2fRgqThhInCjRkh7Dk1iS2vMBLSGtRPppb4FEu762JehUMQxxLQre365CKoJGvJwVde91XQ+bDp5ZsMu/QHmLgITmwGXSpQFQlQBajqquxlwIOe2cyfezaSHIoRNLcwjW+epnmAtmmWA9KU29v/cA2iuWbj9ZV7HR4anhHkjbxnzKPHnIZ7Mm5wAf2o/3xUhnfH++quS20TdhalHgNhusidPKWyKWV8ZjFLgb1fX2r7ifLyUtxuKHHIfCWXQJ/DKeU61vxmPT34MTi2Q9r7/sK1CYuHVqMBsgtfenn31bUzCoyPN89KiO5wHveqnk3uyHnJSUBVTQQ3NyRPmeRKTQvWEBZ4QWcSgMyZF0RQgvUXRcp6KflF056fwahSioP622TdcTVYi4cAwSZLWDvfjoKFLMowPQpzn6ogXHc93fFA5NZmnwslSuesOyNI1EE3RM8kzat6thkmpOiGmm69Yn8yNuxz1YuuPWekoybkee106T9WTPXo44ea9E5QH2Ig6FZn716DBa2FyXHG1B+YfnmhbEpANlOi61BoGO4+G3WMJDokJXj9GhNsFqdaLjA1pkhLP+/mGCZoYsxNI+A+sMvWyoj+PMWeR8koRz+r9pNVEWT70WhiAkNTrojdr0sBLwxIM7D4zT+cVy96ZE+ABi9CqkM9VK7iOfkJVp7AqCqQ9EZ9emn8rB8zfoQZUBrVd6YS2AqiTFt0nJ8HfPGmnBWf3Xi5CgyWoLAmHJp/AfTdHB0+Ns5DlhL6UJ+O/6xys+CWVKtL9S8fVHkpwZZMJn6jVtiUTtXjywmiVXw9a6f/G7Qd4tZtcoS3aytxXYA9aGGmEeBobjiammhUaMDicH3nlOkDvvz19NqWOvHC2SMv7OQHtDIykYerPuoLz6SQNOBtw6oX2Sj3ZLITBDcWNx9CuZYYVaE+vleXnATrwn+PnuQ34jL52tp85aIOk684SUlQ8uyO2t+eIOHndZ3oxD+BcMAba/JVxRYUAUZoEw3D80WWOz0/ul+fYbhFnffx3PgOy2LLiu82D5FMSpi+Pd4EkIFTgfv7p/0vnX1wp0VpNzyXs/5S/4z0RFS21vIF67k1ERTfFuhLM/8fdbKognohMqTNF/+oqvXXLuJB7IHeDdn1X2eParLBEpz8y9CAN2g5VdE7EimekAOhkw+tTzqeEsgyQL4iVDnWrP/RcBd6CDm16/5t+I1SAxCn9wo8knzmpg8DYP8V/vHw8Stu7cliAt+G/VR4XPNZXWF2rZBeQO75os2jFJrbtkfhN9BzHT4HGgXTjyTy8NGsiQdeOw12GjYKCyxP+34kRHZqYsn0pFvVubB0+/emKRgiGXNRWQwMSvAB1xvTprD0Zyt08BjP/4W9HGNfNBcA0Qb9qF5hdQ4dDqpKAFLoIW2gFEVKOganw3M9/4WP9ckP0/g6kaJDRurtxNgT+PjvWYEWlFa80wKYCkd/0ZChV94njjGyg0t98Pz3AL2AFAhvRRiJwdfRcQqqhWkv/o6X45d5w1YLJOye3v7rgta7Ya0jAl/an42ng5Wz4S5we7n2+1W94JnpoGyV8WW2HYjKLkKmp4hBKlNtb5y4W1MrsG/wfq2N5Xrz2kqhdPQL/YoxgCQd6Y2KNkADVu7TxugQRWVuNL0BUj3JRFyWNeCmB74Wsz54OPnbq0GFFxzSkoiJ3Rtq8yEJMKvOMMalFKH7YFHKjb2nwrKVfuUUuRtTfJDiBuaEHHoX+MUrM2bBaAsSdnY5PjqcMBn/wwojQxzt2MoOCC3OEArr09ghhsj2M0mue5ntQcmcC1R/sK3zfShGJuazS+mJUeKxk5u36CYj8+SJCq8ZEv7bNf1+BywGeDQoTDGq6Yh1xW3Suwo2O/ykazTPK/TdVOICyiwK8MuQpK+FX3mqSPzxfLwFJ/iYDjs0WgW2kqXYgm+gkNToB5+jYH83Xlt0cbtEmkkBaVGlHz61rVuWzrK1yjn5nYHKvKCrBPPRth3AKDQQB83fdrbgIeIfB3iHya5NPpEyxbzmtN5Dnk7GqrQ4uu4h3QSoHU+74zs31cWqIx4SZ2bwWLvIxUtR6gufZhNZoMcmSB5z1O9TKvHMORD+VmuiqzsyJKA1OaApB+b9x6u9FTvUkalgl0r7raV+wRqimc2D7B1z/OiSagdd5UME2igLGUcgPlMSX1VsKQp/9yDiYei87KTBA2NPCUmgaLwVdvQFFFxWp2vGCY/KCUvxt3FOu6xIgwS4Vybvbj6feUCkrQPpO/wPHJPhAobSj/aa5YrUvjHMcQkDZwfc9mvghrk/PIPvcJa5InhVBfjh3Xr9vIvA4ac+m+pywS/EqkSX55xgiyj0TB1EE0NT3W2CPFdVD88P72SpdFzHS/6XsmbGtM8JE/m8eojzd4PM1bNADliZ+XG/9hbcKg6PftVKyKKt/8Bz4lGsHyT0VKj2vDGp/qDGBajSHrqzmpEjW5LXsb5kTV6HgbMcnPW2dzQju9N1sI/gPVlgGmk0bHKOX2Ws1q4aPizhcM/XiJ5EZNUK6bZNUeFaUJVTvGxglRUY7vdnoVOe0Raho3huh1XDeTlHpk/2gBjjhUQXe8FN5A4zcRqkNtKpSVq0xyw9j3yQlQxq/Lnqklpz8lXmzHkz8sX9HJjHwyn8UAjblvN0ZFIk4liejx0lVACoKvpsT9+pQoLY4weMHRzcuVC60DUFkaqLfclS4UJti5WK4FE3dYcc0OilX50uscLJomlR6pXriD6ELNNBWOSMt50CJjPkyt3Zn/xj1dlPVP1t6XExK+b3jMoULLPOrEGvjELfAMM1qcuBb0AijkIuFca8f8xapUlkvLjmmJW7RK94r8HaPzvmHHSqX9MXdivNI4A+JHy0VCe79UZZJvzMGzpnsj+Q6k3EItDBiA12fTMlSbEOMAWCdQq9TtyUiAaAqJozMzryEg0k+yVHqCc/DyJcCE2V4WXIhEnsOc5c8f4ChWfUaONhPPWogpDs/lyVCvp3m0NSfrAJKNiVy5aNC9gZ6c9BqwYgj/cDO3kdam6gCjhR+akALFYmt4ixHkWxKhDTGs5K+CwRiKJnvxP9dbxRPCBHbiVa8gsd2GuiNHZD98MNwXMdMC0MubVodd7dnyk3UQFfCIIL1osPxY0ZJ6DvZXwtZ2I0th6aqlTMULVo+lhSIU/5qO63lTSa3MgPRJEOi0AJ8/UlZuvgqLw9dyEDQoHTKWOsq+6fzoAyvIpv14fLaY+braPd6NkSaq0RClMenK1QLH87NZriUaeuCo6SZ7/CfUt2K6VOt0AjIK2jR0vorf6R8+TVzxZb+QdLimH9pU5tQc73xW93QRPMGy/gCK+R+YzmV4fHK52GWBEBL05EEoTY6OYG1WWji66dWnVTg0uPNw839p/yjLxkCfdTaH+v6hVUCd6HlROj6W8Mil6AYGC7NI2+qkZvJh/dAw/iQspXQNwwWHr6slLIp0hBHYTDh/J7Ba7ZR6cp3iU4bSXdmzhTahYDev4yKiIHyN64EANhI5OHYv1G4KXfIOvQizYWchPhzQg5eVGNMxsqrvWVxjtIbkKuHzE+IcA2NZ83GKz0D8z5zmgRnoJGKigseP9TmMS7BgAqtqyixA/SLc1KEUWrhXOQ6kA5ZQRazp3wwSa404cppBnfsS8EsEpbr/gXyW36cZ9pt1RhzyxGxDUmnZeBz/Uf1AP+gyLIg9x04u1fThm2w/H1ZXGvVqsO1VqutV5gUhFkdkwoCjzz3F3FUr1v0njGYT2mSZYvoF/fSd1W11c5VIhkEO06US5wYRmHVPYXmZnbK5YHQ8pkIDJ0yqssqFK34CuHE8RWb+Dr4omk779QOOcYomAMYQ9ILt2KUk2uNlahW/IjGtenuGLxb/t3aFoVz4oNwMZ7iyp4td8mdzgJAfnCcYtklubGAUB9k6bGC5DSkf5VFarnGEBWz600VGR8QywZ+jIYFZbtKT2QdDOYP6k7D8qVgEZByGmRedZRWaQDTggLyNgDD6pQwEeSs82+hTxWypqwU3zuAWqfwil+mytzVnKztyvMFJyJwPFaPr4Z3mTjyxCR2Jv674JVGGMUSWb0l+GtcYtd+NBGChwr8mB2hlyccget9liJhQEb0XgXfgVRlHlbO+jlZ9CcAew0Nw+tRcWgNnz/GL9Kur7RohRhaYZBBmQA6JhvzkazHRcdZDn0zDkfBmYP1PfQjP3d6qqx6gE7vrb3lBKEfK3Y/nCe4COdpr23oZCoIpssGXmqE8CGpO2bEwkSN6uqeqR4UtWR+xsgOzNeR49PTLJpFEAkXha5YaecJ8t/KR+eG7/HKV23zPZAMvHDC1rdxQ0l+6wlIgZbUybjBe6yusL7isRuuYYwg4+8+4lia2ox8RCdvmXlt00ZshBnAIfLkSwIqUzCcsD/d1ZG6Az728L4FCIqBKpbA6bzkJ87lYQpbaHpwPpqu3S0UqNDCwgg3q9MEn02X16E4xibz/rLx7NMDtHcwMOt9r1dVU6Hws9TvJVH7THrnSFESgN5eBy53Nq2Fdb8mySTxz5CitvVE+ZjHaYS3hq9Bax+uS7TxMIT4qJE7HGdsHM1/9uPNBylhP04Lck39JMe8v2dPOSJzyQoy8m/8Fc6h+X+5/mBVA9jAsG4vmx/KdUW+NXxgRt//SS2Ib7aGILsjOz+ZZQu/NMeuAsP1pFRTN90rqIVULbJ20ZJlrjoZD1VxHEoDFFGVWCVOT3jGK+vFD06gc3yDUSnZ7ZHjGmw4ZiAglY2nm78aUpXxI4BfUHqL6YQKFDCazUIryLi53RczlaTh0ry7WN4WpWK9sPJ0J49fu6RGUMYZd3+NrRvEdOrS5n+EJOTkr4lNzo8vawcYnR/n1Dq0rCHu5o2BGBEHABJbsFLi/mlWFO1MjpvUu6UPJjXlXse6MtBROT/mQfyegWGmFRQ7Q/O+rJp471+tQF10+bvkExfBoTQrewd5UwhAUODpyeW+aK6vx2AroUo2bGBZ/ZjcsJFfMYEMsm47LdQSq7T7peI2Ex+4/9oIAJGfhidbXA9UYPNhxigFTg83CETNYfYVkoambj3vv4MZNtE/wrIfTguBNqkQk9ebLPTmY2U4UCzbYqPKO5vjaZXeVksobDAJzhVjoU7p9TdFmNMyLyCQJryBSOcm0hFk/pcwcV15KZ/+IIqeQGPkTbiY1haWSnuQYBeyW5uSPHGtYw28cQS/v3rToNAUGVBSQ6zpBt4CHvaOfEJhuDJYZCcxvPeOStdCzaoSQn9nDe8wDc1MXrJ0+9N9TAKcS6u8ANLCLY4UfHLGf884/LFIn4OLOlRcNl7FS1IJgu1/vLm4INkgHt5ISp2vC3MFJHz1zJnopnKS1AgJtCmhJRZDaW6wis8CJ0KAJW0Yy0+kWI3lJ9N8yqJht68FMNVgkgaAGi5LuKmkZWm+ztKvf9gT8hJrXZkM/QdHI6wy9BqVeWa7g7ZM1YLbUv37YSnLmGsCrl/UVi/tG+fZbzY4bGye0zH08VQpGmyd/v++fS9EtasmbkQEIYnmLZLxO+tNHp3myIGwYBZVXjlWvrCiQcsP/Fu9l0HWmLBu3gvuJ4phtJsXXllJdM8iZIQR8Z6zEMs+cqVL7+TYhxDd0c0l4sbyIEw6N+V0v3ZbUlidyekdcz/aIomGdZtmdI+1QUrrHw7eDXT+G3zbTZMXxpEgJc4zY5bH5az8eHzwoo8QUleUKpVRrsErGmSF6GPJ2OltKYL6/C4zx4rHdcfsrQTcWBmrBWMMiFiU4NGtpYeACqYafRyu8j8x7ltp3nxVbsPO0MSoaR8tv61/q+YCqHX3h4vy4HzjCYEl+4ZDtj2+mawuj4J0rBpcDw+spzuCQ2khFbks09lPGxK8HYJl0Y/lNLUxGLZ+2h6+EFSaD22bYzF7dk/EhCWh6u/v1HUVKC/r/Wl6JHtd1V68J9zdOTgbvJuQug4r4vUV3JJolQQ5tecHKqcNoYjOIs6BZTlfB+yHGfGdxTKsGxbU/4taKuH8Qpd/M7fIG5zebrpiDHV97T4jiUNt7K64/u1e/+erXV34aOjfddcKNO76EzIf1pfD+KivBsRlzlsjj17aDPq/lnKHQCLsD+3TK021HNzhZyuwpLRKS3KE0XH/0TqUOr3VqLMcsSZM6349QJDznPG+sUqeS6wwMWp28TAoDKdmjzW6f+2au71HsOzLIeWencRa5JapKkVTYpvwMIC8u2L+/hYGJmk0588rq6Nnqe041NMzU6lj1K5KmSj0ZRiVpzu2FSTl4PBYHAuhe5dtwnRQwvvNqIELVxKMFWedxxB7UO4zpYRe2x0zH4X6pI2m4g6YdCs08vR9B7omy/goQUYbUZA+wJamq7/c0FhkNm74Mp05NSCK1Dcy1+9qp82p8XVkUB4+SsVRJ/Tqtn8v2esmemr7zjCfjLicMb05JqNoL6zzz0KaYkXeStBrF9+T7EbZTo2Fa/wS5NhJvRoZc8QUfS46HX8HIZ8A6LK8zKtROnakAnEEFoonVlvYR71xYuBAXbjtxfu/bteN8WkArB3//qp+3btpi2SIMyK6rX03iCLnzOd2OrPnD6xqgVT35e6NUMpN7EJSz0DRRzyze1J+Dx3cfx0M577W84qifD51mZG8VNbBf+5PxmGGrGOmkO+Q41YnCkx51D+X3CXsNAjaz/XfcPJUXJ00vaQyfYDtmFq4kU1ZHdnep48T4IskzPsYT9or3rd/ubiYLqeBqjnGbuNWb9ZdPDxkeBmJwYTjsTU+VugQmtz5+C3QBX0piVh3d7BK+Hk4mO3q8qJVQXeIqs4hKuRvBfIwwUyKg9W1x8dv+EwESuk2Bgs1+Zc3wzx4eGasynWs3V360wH3fKXZFTckeHZdgtzTqcQPC2hCHhSXyFMyljvrneLE+c+b/YQ0XcDBam1oAPzvKmmcgER6AqnyC32Ic4HMP4FQN2rh4Y2ntrawByV+9oq/Z8hdwQEPYRYiELBCnuGGXDQbl3ZLuUo0vfKU/AuMwYfNXmNM2vkn/GRrpc5WDP+MEL80tbJDZfDNBRfpfcvVpf75u0LrkIIjnU4adaolZWzB2yjIVwNrF7zF//n4N5xHeaGc7Vh1EYRdc0h2l23qFvLBNQ5kHbmX8Yta2Vj4DU6eBN3XyJBvJf9iL4x+hw1hx/7Ej5U8EZr/Qhgoni5r9PxBfU3fdvXICGW9DzST7GV141bvyMDXblFG5PizNjJUVAWNSxIAStz6+eDAbkYeAKTj6DIR6ysFvZAloBLCgSdMFd3ol/WXDQh3BbBtLqO9hp08BfumZjLpTJGRAIHzDizXZfhbgqejNSS27BIXQLV0muwzgXGqYt9McSvtLWo1Fos3k6Nu2qGyFftqQyDz0/bmgvtZyiFce/SLYnjt2Q9BnlmUVBWOtbDPvUgOSizvJDhdiSkbLLP96MJ7dKO3eUK2nZnpb4s4b2XGF4T6gC4qo9TDv9z2SY4Rffb/RjPs76P0YiWADpPB/nQjC2tDRlxt4sdNCIjmMsLgU+cr8cpyaMSYI9maP4HHww2jTPkGKvF6H6+DFAF+jAZKT9oi23gpZ2zavE0xXPkF7a2FTNJ3bwxvsJV+o0fXZAkmouYq6B2+6ccHhnUIeL10QtZaPoZPJB7/Xry/2Nv+JJFmQ/p2NSiO5bYGA8ej1vh5QlWhaX3JMs5gMBnyyIfXIMf4im0WEUnCPAJzq9q04Tmxzy7nGKKEf31kAp6IFk95aj0AogL7iljLVJlOXNvV7BwZn4dKfuZweSEZBqy+Mvual0TVDHiwHuIuXbvaw+OkU7aeAfck0Hc6H0jgt9g6Rxb6dAuaiKEN1cUYtD88y0b9Arq1q6ML9B20/FunTnZNF+IHgsg641FfllDFpQ+dqrIPKQ8IkLx/2ppx0ivQSrehNaf5dwtBjnPHroRGzG/RWOdiW0COPzepxIqcsWjhfmBXSUD7YCvPm/qTGcSnhcriFKew6a5s0AgK03I1gEifX6y90cJBY9REbQ7yW/XB+zAXN1XZQVEs7r+0ajtx8KvVBKJksKj5YFGdhEennMbwgCJJIMdt/pJD6FIcNVegt2LiQS70DAJeiNNG86dQVNYNZmYEfo8oa002xKLh1+rHlBX40iY8Wlv7FqswQFktpyLn5oSdo1jBRz8V3aRIOmhSnrs2wxGwGBEVEXvRm8RZVvSQ0xlKMVWs9Y7nnmJ9jEVuDL08D2ES3plzvCNP3FpKQeSknFeVBXv5T1Yk0/X5vdj1J1LYa6Ffxxrv90ObLHARkCI+tz6+0i5cZTinvgIYLMVnV/OL+m4RCsTy/+9VQPsYv6X2qSSlVdQ3KM1SOntMNUBpb4C0MsDh10xHQ0cbJK0gsR6X93ru63BDYbRZmPISt1casVwVVE7+u3l55XJGJ0Ev6S+2zpNqOAH66RuzpVskXE6X8x6wHOfp5PAI/7YG3Zozh1U27IXGEEKIm13Rt/nTE3pKWA7i1NFdVQKQ0CNdqEsBkjiuM41dd5rIbR4DMnoDva07v1esxYBGU4JWJUJQyejYbI9p7pqjrpHZUNlz2exX1lTAks+WxY6CExoPlSlNNv6AIsE0VdPmHOj4m0a8bigDelTpIL1WoePLhblmhRlkPDKiZvkzz6eG8vLeJjCGJL1+VFa4QREBVyuhcpZm1ygJm9kuQ+8v4yEMw0VO+TKee6sMFRVc/kS4IirJupnw48LoR2aRk+GuDBZ25xnKFxdSYqZqvWlEcemsbzl7wvQg5z2xKxEUsquyGziyzd/X+XFl/ct9KRLzyyb6ComIL8Wam9x6LPNZXvhO0QQZmQ8T2MFjmRJ42WyRzfyLGkJKft94uO0Yy6Fflo3AoIEon3XBygpi3Je932ToU5EKoikvqkeLFACpsBN5dseemiMdHxOJKrVJDdTS0qCcTzPCyz506oyENFdelskwdghmUnWyXK2WeJX2CBXudNUBON/i8kMdtJm52REvmGqVmxe5aricuTCGLbgZtYvigT++E7xltEh/ZgUoMP+d8vaPU/HdhZaUjsgQ8OoqZeezvNR2JFm2on+IliVyYQ/58LmZ2stgKoBbs4SllwiTpNRw7ecL2WR8bbg05aTN00C8aGWtReWSsYsirJ0K0I97flI2gJRRN717wESryWahXUAFZAdyD08j9SIZQm+wq5GkoUkK5cQ3wk1x01x4fKLPgPIj6D6lZiylqvWGtl6KxCfoSQXlNZIHeDsrIRqhINxdrCinM0iMMkveNxhqrEzhnBn8F6nXVY5zUDLzOXpp338I2HycFa2pueObEof3HQgFEMnHS3/CDKwJAyYl3HyA4X5vXUE8MMa79gYELseTf0IEUJRsfSa873vl6n29lFq+GCqF1I+mB5PSyLFvgHv6hG5Hd14PAHTKhY+xzCgOwwRZxygPwNET0UiO9ynH0p3j7GAFEs+VSjl4ArhHJbySohRLfm6B7FxxYJLJxJlQr5UdD+5Vs0nM6CehSZZNYw4FzcpYoL6nS+wGGSNKLVLXgbgvzAbT4B1J4GMS16IKMlo5S/dzM/NM4NI+a1Fuk4qwaewoHqGp78vgp+SkuhLyAVhI2Or50Id4LlHwRon9o7JT3D2pibchFvFi2VTEx6cLX/qorW2YGSSmnu9+M8teW9DIRH1TfabuDIuLk16NFz3kNr5QLPGAd0JzN2IYFA140yqfi9LfBcZI3aUK/Gt2bfMMk8eqttN8c92OmUYKUaHbB9C9cpEwaOYs49MztuGtI0VMqDDHN8HiRP55BpRIJtIWbSyi0/LOC94XhzqGVyuzaVaBfg0f++sV8wy7ytxlQYA9w1ejE0XaCkpM9zbOrymf4OrEaIyQX84Z9e6wQ1czIvOihnSaq/fcFdkxJcMzE2kWcARwWT1U80dW6B+v6HdclWMyMWLYr49iKWrhm7o1yumJKxVGiv1Rx3Tw61jrh+vuNjikpFRxa0F9G7ZWs57nuhaIeT8ZRjYzuyq4WZBEXs4CyfvmZxGcS4/G2aWon2O/UkjqrfdbBUF0yavSPdNJacaaZxFQNejGDPK7SCF82XxiahbNpwFs/t07gbCJkDUvvKjqaYv1SNJBa21RKsOuGJNKO/F6HTjc1Q5t8lqLL4e83gWTT4aubYGtE+D4e9zdPPo2R3dvG7bDrCQosp62YhTaV3B/kEQGqtzvu59fbgA6lFyGe7urhYr3TWCBFYBmrEpB78fWnXUEd1z0LSzMcWL6vuh4CJYR0tg1jX4H0wkw9mkbM07MXopLJ2Rt7/aL3Hl3MjO8h/1lqNlK74QTbgkurmgd23XflEcMhjO52Y/Wsz+CqwkBCDN8SUcd0hvJ6srikURdDKw75ZZMyms8NdzvzfsXreeCzpVaPKbkgWo0BlD+qWqaXziVa7YTSezNkCD1UBphMwE3IFwG3+Oja0AILbwR+VMjirrIkRPt+DMtp+OKLpkiE15AVv3jn19brZGZkhhAsuT2sTiWSjLvxJkMICAGdQY6CcJ1bmQsycrXCCxoxrME8B5k7aYQkl31h4kmnvmUA1Uo5bGEJkzebQNuMeVIRwKr7shM3Y3iowzuO8Jm833ALhjeDbR9i+ajGdiv5nuQcBDW0PZ0CB/GHvnmE702e3iEmWKin/StmkbfvsVh9mXnjLzZCRfht3g5Fu6OpDSsq1DSVUie4hNThGTSTWkOhTKbARv54Bxp1m/BqW0CfvfUJMQYci+HzQBrAw7lHJI8klNzq1wbwtxf0zzTFIpYQcsU3ddDWDMuciKmN+BHJ47B6FkgX4uR5QSWzLqgN2wQK1aLp2hgMJGqMII4rLK56VcDk89QQhw6cy8PCM19olNpuDwdrQFvP+77wiyyKx8Z4MVJNxV5vJWOwvF+aDouZMW5HNno5d960qcPPO89qYm6Zh6UO7MyFx272aWYtu/0+UZ6eThOP3s/uMGRarrYNGVN2bkl0VbM7ZArP2AnCQLuPoIbkry4nTS/RsIdFmPg98zeYI4R0RY41FQsBym1OXnJcHtmKPjfEXuujVQGfCPrCZsaT+vFbMFWIvUy7OxquIvdi2DVp3+q3E3NGG06d/cz77wgHGWrfcy5LJIzCMZHkk6m2QnZCXYVXwMsVhJI9nJcgG/CrU5lgDb/DlVEsXG06BHIuqVfnTyLdAQZYmJlEEk43pdgF69V12XC+sB9W5Tfm3jPwiHn/VmGszkYx+Er49CLbyk3hDBSKuzDj+nzCo77ZO40EIP4ZROdSwWlf5S8wfYcAzjNdj/aZ8uknw3tur126RfCzMA+cUo5mPaZL9cVp33X0mRTUIS2vgtwDRgsSSX5xcJUWR8gZbdeqyqQEEAeDu3+BMlrgYP2SH/le2u1yfVFn5JX9VQ04X9mmABR/KOd3rAYqR+OQwLWao9MXVS1y+0OKo0FlXuirKuPaY1BQbY3Vo05Gf/+N+u4rDcFBQqiCrYhgRAEjvVW9eNCaOsukcJWEaDuo/pWCYGJLadm4ssTCPvVVEJNBfVXAcTIxH4EFtWFMJUy5of50QNXNZBl+oRuFIkdbt04DeU6j2A3vzzP+IkMahLD6zBVJv+xRBIc5fODvnJMmJRMI8kcyMFqxpeWZAHxC68tGFNyl6yyGN95SwNYXwDSIQCPlL9bzjZaWNWvs5puiP2lbEBlDw5vCHtVmb/sD8QBgOhRassChwM5o5g4lhlD4u86wmdmVmhmEXnCyLeQJ0rRtqYIWRhg72ieDnqmPvOkDTWtKR38TeJwrK/7IRYfbNspygrU6yV9YtJyw3I3uEkDgbPrpcNUpISYvzv3beFg3ZN+swedqf3IVKkcdiAezu/KpHGHPyvX9oT6qzTS342/DenW9ctM197UfFl4rk21KxSma1KnLIWlGGasMF4+G3dxTnqBscul4CqNda6Qy8ita7HCzKlYa86yljm+HQA2B5ArJoZy4LNxeT9izFuQhEoEhUTNJQj2pCc/O44h8GpQX6XgpaAvAQJLVNq0yXGFbzb3O54XQ6sm557+lT3A+VWPyCJn1MLbsssHIdFhJcMtBFQYi0bS+exQ4Rq74xNE2CIRSzi3nj5TNy2AoO0gdyBC0/2iH67UB581jmM92OHqgD4EzAzyxDauPnlIdZu0nWwB4dtxWN+meq/faIuQpK2hoRP/ULwIJ9r3xyxtXxfFwJ3YquXldSEnxoPiYD85u0OAHvKOG6+3eBraUiOgvdfp1EjiroeSLLFutuPPV9XqhAReYPaRy87OAkV5tzSqvyfufCvOMTtkpxApWsJ9n+cNM2uBWu4lj1oDjGasCfCt6cfgCzh6UbZanbL/qCgf/iHjKYaavIiRLJrU2BuzdsP97XHkXLYbbfsHVTlXSohKOXOJ+3LiR6ix9UFLo9qieejYk+P4e5wC64jGQLSxJzYt3cErx1Rtc2+xlJaEBynLN4hLl/qOrgBM7a+yswC0Mh2OieA4SR6MfM9WK/FOWbVyoUBIUAKOhhIZp2LOgukk0/DInn7sF7dRP6Nw77MaAcYg6k0gdjQN9/1wtGVSBm+6LwkI+xfcK9l+JiWepXul+/EEdV7XXp/9lUsW4RQmIkda9H38FJj3EYJTrG4hEU9YWtNd2lKI1683cXFVzSMkh+2nuu9K0JUBoAnrYkKVZpAKF9G7y5n/KMZrP2xPuUFSOaruqriffSEX9Euj/k5dgewEyQCFTif83LhkIjt5qJ1LyI4ynIznWl1SoAdecEp+I5WmKBB2fr5yw33NX94q6HIP0jW3Np2E0r1f7fUjqdxV+iCRULU+yAwPXFvTL7HqfFLj+wCfIbOg+nsW03rGTf1haLvAZA/nC52pSDnC4f0qOiA6WtK20BldZUaA6GO3m5ZOCGyemGK4a12hM3BXnbladA/yTRV+pH7IiT/9WOijGGNXzV+K4wmdmRjU3It+QwUCRat2mGkEHhOcQY06pWeQqBGjHkWcceX8/drkk+tYysHMXVk8hLhLGjUVgivK1Ra4K+RtUcZO5fkVkWQ4W8fyo2tafhGEDSsflUH7yj8wsATBE9YpskR+r7Ac8xqdxtEAfRioGXSprjbLI2DAZZz9HAYR7rUHzvh/UPpFvrLbd/hFf7sF3RimWNpiGsQRZ11RqfZkck9IJu/FPU2DYr/HWUdskJHuLufXCvDbKn0F9sM31Hn3zIuAMTUc+tQsO9ll6jnNnW9Ulo7d32jEQMqJIrWQL5+Se0a8lKRp+XhYp4IfyUaTRC58vFEjKupeFEpU4EOp1AjeALc7vZV0ovza8QSl3ru6xFpY0/ckElMOChkhLWSDHLCKaFK/qC/SIfT50GJZnkCr5SgXZRddXq8Gc6XNjIzSdCF+9YlUFKMiri/sn1Gp/dEMhARah97GidLqitLNBlF+H8XoQmdrM3GXBSCN6izNn2ON0OzpCxOuM917OZCw2ZC0DSvNuTOFCGGYf1TYgUbgK2KKc4zm/25dz3GhVpFqs6x4yhZBbiy/6FD1vXW/aIcDiSUoIhwrUtxuGGZijb47Jz8JfUTblzx4eNPbXeYpygkQo1xXonjeouTuJvAH/zH+FK50zOLAtbN9AO6xjfX09CsjKitMVlHWmmQybLoBHBPkC5IbAZxvs3cH1VAcy2X90WL6y/0SXNsGeLBdr1OWVuYg+/wUNiR7QnP2ec7jNrZZOosT6Olwn02Dh6zSwKoDnMFLfk7lBO0p9mWjex7gEFXNfxFO19qmaoISUZEgdTuy7sHgrD/36o3XeFdzLFoFnOJa4yaENBXdTSmVZacz+5IGdVkEgjQt/TxuhNGHGtQuzNDfM4iNZ28Ly9S9WkUGMNAfDRLr4ipZkJxUA6HnlOi4Yb04/Ze8rB+HEXpDGC5Jpr4fN62LQh8o6kxknE1P5/rNmz43jehFlRUvCyNi3Y5St7lC7a2ogCt3Za6M7AshQdbVV2+R2DuuiLEJz0MLhnn/1/F2Z2U3h560PrnhR0Gc/5GW5DwO/DGrR/4PvL046BKjUp1lfrtKfE4osRTS9/oB0GrNW3cYgvhU8ld61sHhKOf4P94t4n7h9zdRXDaFv4ORPHokkY+NA9QA49RmsGMfJLu1/RXuluq0J4fsUUBoa9dL9T0yDJXvGtuoln8aYrNzoapa7E8cR73/wX6KwBPpwCUUlxsBtOj0rnca7zu5FqJC5W0U8Yt529SAI0S6nmWnS8zguQLRzf/gRLaqSQ6E9T6Q84u1cs56dzBMv2eBG+zAKw2V0x1NJX1gC8M2MYZpScdXEKPG1442UFWTEUlkM9OjbR4FurtJNV4IqEu1htlgltESO0SeZMHZ1JM7bNtYegevwPSCmW+S8uEGj7FTSSV0HbDg1rOnt4Ws8DxqN2T/HOXNd5NGboZ8VTSD6g6rLWcoWOwsyeG08GPG6KHPiLRunEdTPNmY74ObRGT1VCHP7nmBYmjnH+kqK6rDyrEoNjdqc8uG8yZrHWBXU9weqD5rpQ6S/annq7P/GiYepA2ZDdJA/GbdxpHYatPgkXt5sop564gVHZamW6cq/cdADaLCXWt1WgK7y11WaQR90YOen8BECQ56pmJbLvzzfWBhUUJP+dAEEK4o4wZv2+IBAFEdNkNF3mKntsLE5PDLA/IEiV0rziyORzLJsoxRMCQV/HlpCkXsaizcHT/vxU9iadf2hOkKehGum3973fFs7uRlqxz/oDerFL0617PqG+VYIxjeRb2IRLZJGH8vp8ITzF7U7HUg8Crs3WpVY5r8wxn8tzGvUUwY5csVu15Vmm1xcs0UL/lUCkrOXdLtlaa4pHLeQgpd/vu1ZzjMOcgzfQaIwiZK+fMZjRLAHUf83TSCOkovb3xPkD0jElmb4TBqFrwn8G4KWr+RM58qhCnlVimQ390m8YLz+fNHbBRDs7GJgHSK+v5Z9cwZq4glnR2eTjnqTy8Wo7BEg24CL/RT1AKzOIE7muo8oegzn8R6qab08LzTcbb0ippsScfjQoJhsr4jKG2pMVczpCYqptZcGD5rxTHFbL3+NDnEUptRMyARhF2FMiM7pgaB/IpAna1AHa5EPt7oBdzMGg7kOdSOpxrPXbdP3l/+QCfCLMpCsxFd3VAxA/IPVvK8JaenCYCadhyZ6rJeGxTUh11+OOAjrXIJxb/EbIy8rv6h7hywPp9ZhPCcgt9BN808JhGIaKwtL85jO5nipQyAF690xJ9A2DMuCx55TSG88fN6rqBMYDI+I+DtFmoAqJB27B/xxN9xMLnQwLcLCHOx4GIFCq3/6i7gwJePjoG/HKNb0XjhuEQmYFzTgtt/uIo1bBX4C+y1jrb+R0mRj+RyaDkRus8W4WW73qbcjpjIh2tGUY6KJyhEaKiK+LHG5euQeYZO4zXoKbZOWiJTvJNNVrWugpXkIIIE4zK/g4JKATQjtaC1qbJ6khaJHxOTS2goU5zGyjmaPKvVPrBh27E7E2iZ/6omwpBARV/9EKeU1m4Msz8Q7y3MzEF0C8VIIqAxB+Fk8qG970lhV/ZIX6CsxiHqybemqil3Qv/cWKm96fPoMJWSA1dcF03dSwSyNMdvKKBCYVYLuqr2pISKPaNRJJw2R43RNE6avh/TNA1tGJ/ilW/e4LbOvIh7cS2OsbjyXcD6WS0DYaDa+og0lSxehZQiDSt2fVdtF+DO7/cEUAM3uju47Fl17rUPkRPaheA+6/jpSYK5Nh6rSwO8Pbi1y4/L0L5SStva0NcscpH0pw/3Y9+Eqw1SDVvRn2r2d8vRC6YhQywdhKWraKGBMILqjiU2l5d3jb1tnQIwi95QiTJW7MAjJD4Plr9FGRGlM4NQyAiG8wSAKUbRCpmxE+zk9YhXjiC/Rbt983pV0VzovJW+90dH65IOb2VS+Wk+MpsRgZ86uEuxeGPyB++07HlAwqFjq0sm5Lvom/rcHSaLduJrDdabujYJRWbbY2QZptvGwTHAiaqsAafE9NQa2oq6hV8+E2YRbdEcrirxyx9JVWpti7CsFfA/egMevH0MR40/X1jQzMYbw6mr01MI833RiE3EuU79cpspC8tuN6QxFB7ExHF8yrFQ4vRniEkTgKc8kT2tC2HgNJJ+l/FwYXky6qbHj1cMtBGVOw3SFMHn5l5odYVrLqhL6R4DujKq/CEsEj742QjUogvrSb9DOh1Mm5Z7n6MI+YHii3bWp2abi25FJIiX3GM/137MQVr4wwQ5IQETnYx0CoXX1nLeqLjQ2VlOulhy58iVxN5d0Q2TEV6MPr+wA6lluGEC5890db42elDUvTbbMcjHGrT7WA4eEhNLqVT35NhLruSPkwg1UCAUz94Dj23i6dqS1MPh40Oyi0W+wfoWYXIw+siweU3qKdQM/IWLUwDjgMQuiK+CTyRgR/Cg+XmfazCLiF1JChK7C2x+ROCl4t2WjYngGRxBWRQqqrNqx1EesLx8Z8GOimBJK3Ip3O0TWp1z6fhibUBvCtBpCBH7Wz0MrsYEtW/6gd/rLbB2IcMxOrxgW5u+/ZBOjd+9Zg9SRf7ln5tqXgM7wZE2rj4u7BOezWvuyca2TpJkQOR8U/bR+LRjmN6RAS7MCfYSPtJWSbZYnQL8vGmJb39SyiYiER2Via1nlShjJEe3JgCwTOTiIQJ5h+NQeEs7qWkpIDJiQHb7VwcR7T1gLGhKAqUT5DPO5zvGPny/DOh+Lo+Xhxf5wTkF5p5yY0vM1gw2UZQ2nhCedQ+PBxACaAeuBYTyBs9aNWvYATPBLUtXJ3H/+rMIUQ3Xz5MJKdV6OhLEEK73rb9hfjPlA0gKO4j120U6VHh4AJvL3WqjaY/KCbwpCzUCADZmnJdpD4p4U5ry6/YuhcWXcVV4dFm5J8qADBWw9jPITjUtkf0lhIJkzhXLTcXQBZaaunvCCxyWh6ifYzNTTCGJcUD6DyfGam2zj4qdBy7DwBaL2S2IxicF7F2ubPDvx0+DEQVydAIF4Utn+/niyxDQpGlaaG5eRQcfYEHaZeHBOfZ8x6KnSsZnB8YZbLVBcEF3Mv/87cj4r/BYDYAaUWrrm/rWPImSVpvPlB3xQvVG305B+bCj4kIW4ZWzFnX7/nApDibPZxncAV04laDsD872g54z55DZylkUKHXF7Y5iFwsc0HDovYpJ1P+XIAb4pKZnw/e2BrTZn6jCeAAvAt6Z8EdXqS/KoRwK37xhZL7w17n2PYpqnoCtRAvnU/CocUq+el+PFEwM2GkhLBAJXvVbqxBMfPWlA8XMNY1+dfsV9Uy0C+WgSzcXw/ylN23DlELK9DPZ1nzFCvyDWygh1ABv0LXhuVuDEraYOrX0J/NpbYoxjl/mfncXN1DorfumMjOo/dWEk/OvdZ8w/66CtISpGM2htGRpT929qEz+kRM+2XpAqcSS9GOrLWVVUVIm3Ez/yIqAWm019Td/ytbE6eeYJaY+mJpelcp0h+4Y1hmcF9J6cZQEJi7foY8n1psVTCzE0QYMX+ScYxKxb/bU9eproUaSNTxHeNhomtba4y/CfLAZYXndn5ndeIjFIsRWRpwX3HwrIsKxRgd52tRs/iun5uy44w8u2wZgayiPbOTWGXUn/BDqak5EZebXbdQHyE0yEhUO5HcDnE6xlAuZFDSKLDTTZz9bWcfe1wy8KhSOwh15cBRibt+faUQgl7/5na6Nl5d1o7iUWTjOhjQa4z2Pha1PNGSn0hZFeICMKGtHJ6EGQbB+HF6+M2e8YSQjJ2cnG2SVpdzXlnkzxYqwXv0s0WM8nggSh7Viq5joXNiF3RJ0A9637p1HFJd2I7GrQ4ZTOWRi8jcZaL/25Pox9feMT7VDPV6TT++0Ri3a1aLS8IABZh2dWfxnBmXDWPdvrxmBiF3eePVqd2ZM5bI9YAN23/3qVLElDeD61xvgRdjkXkl2tqif3zsX1gGp9mzEm6suh1kWL75XC2kXlrCreiNi2pfI+iWVFJDXPd3MBNp7VSAZRp1jpt3ug1pQEM470lZXwotpDljklvGxuNeKwTuKNJw0EK74nc0d851QXL9P4pxZdM7pkmbA7IU2S2Xa/AJRP2VOz3Kyp9oW6FgoQi4noNkoHeNnprbQod8n+dQSSbMzNRZIuL/riHaxoOHkaGYwROCZwqcbK1tUnU2Qt1J+3UTvklj6wOD/d8lrZG7ucjZiCyHxK5XVtzq9lDJ4N1FvARCTUfnLeOLc5bmrtGvb8mmsr0lDDyR5607k41wzglZH1fExfmsXrEjiNLSzSKGb7FVusl07/BgeCclDsQkds2G654GVeUpX7UHaqQBEmJsIyvfxvz85+WyRaoYuQfSH9WpJLeUoXpUt7+Crnl1Jqz+eARyCmzL59OUUBwBuoQAl5VddIrfG6xvDA/RZBOV5AfwjOrJ2xRo4N42rCSFCcnOY7xfewl6tVLetiM2tGLqRLc9k/owyHriX1A9BnluzfDc5xdEUKyuwzWPG+tZGNDV0WLl1JyHPflzcBpj92G0AR0lGaMSZuKui5/LUMn69X9wPKc6FVkNEHEjHjQKPQjuFCokjN+N/6DlMscpE48IhHIa0Ghrc36GwGEiPRymXWKD/di92yfjZjDM3fdHBdwSxJRSBVKHSwh6Ey1/zWZRZ4kk+KMS8HuroIw1UPa+PDVpsSIKvmqZnZisbfHFWNW/dl9n5+wM4VIzhmrETz3k9WU3s+z84SHh2f7dGT/G5WvoisBYAgwm+pqFS0A8xyhy4PiKfgS+6TgnQD5hDEerpzgFSaMcw3yvDZ0+xfL0yznf0uY8N6APiqHdoJZOWqTPnTIbeBLc5dvFdh+mvD+sDtl8BAWzYR7QkSgnx30Ru7TH5a/g4byacurCNvG0lTgpkj9w42uqBp1zMsKr2riOCQwfCRKkuSX9CGADOYGqCHh1JUsk6RwvI9OvM9fCJoL7Sap8NUQ7mAvdB2ougA01NdqxVo8NeGta0R9C7QybiN4uAtDxw2zLTG9+0we68JkqZrj9tJilUV/f4wOLc83GfstXOVF2bAJ6zf56YworQQEDj6QnC+lqyMkGAr0QuAikm0jqS7fy9bYSBz5hekPILc94b8aUau3Kt69QI1kFEmcb19aFQA4bSegA9/hFi61RDIVQ7iOBqViYdGaK8d3zH5qWIjed0hR9e6o4zELdXWhOVOcPCmZIYYXvgUsAyGUoCszsCiTdwOaPEL2kRnYh0mNSZGb6/kr8XfbyUdbEZ7mDBYy0yTDxhkrpIoJmVutN6FHk/E4cTEolaGnv7x+QxQIKZus8IEygpdtBDxj+lC5M6HaJ313pLDYbjpCA+oYl11ISRJ/fB2oIdDBHFLefQmF1uHk7vtSmIyI7Q9HG0qxu8QRWecP8ipKR1o4bGrAhR2KcGEDE6k8r2F7N9lNUZCswXi/EXaOlPb9fdsaw1Sspku1xrmyADIImEs//XiPqI3Jl8BlrsHf1mAVCBmlqE7usMbDEpilt45ia5CXzVqlIZ95Fesu48LEATS3dyXVEjwQAqVbFBttbLfXvX4LhaGKv6P3XBsKWvqEFfq1rPYdohHtQH03ehlVMpZ/BRCBFV6dffGCrIa7OngRAbORd6wsIcR/gQSxhfrfHFmb9Ws3Pk/SikwIvAIYljNbXbvIpKTROSiPcmBDp4hxLkrjR+MfBFZLV5I4usLY6WYmjhT2kzW9XAxxLYCELLIf6lg6p/GFgpoRTm+yQ6PYtmKVvdTHyBxv28y3vTiy+reYBZqmC7x0TDasiMCcA+TxdKgDY4s61MpZyI1+RUzeMfx1qh9MBXg1tI/HSKpcUj7+qTrwp35J3ezefo6UZiEWMPBtx0/tJyaej7NUmUHVRBJfB1q0bsw4yHfui2ZOPNh/6R2/I0j09t9QGeRxpuJzB6DNbaPTOmER6WTXYEGXq7DhzkvCP247uSz6r7MfaasDs419fVF4RAt4XoxkFRmk3sjrhpNSeuDoG5RpjE4pI3rH/ESPaF6RIIJBiAbVU/ct/nKrDmBQPBYlNob0WmW07GhOvvz0m/BXTsPB8qA8Iesm6PsDuOLEEm5+jbniDFyXfndwIXHgWBB1GCyGV52MU+5iXguncQS8T+WyxaPDqCCXMjwPJxGObdF8mBkG2+SpqaBQkeN+1IL8Cbb72d3ySQUR/uO+N9v36KAiKVEPx8EERU0vfKi53JWN50+LSYqgHmF0UrnnHCNpcwfX8ezokGL4sK/rgFZlXnIqg6a8EJh7DfMOwMgTwRjjZ+TrXsj7SA6EaMRroFgxXRIOGDPYZgkadllrCosfuVZqNQwAY1cDJzuD4ocR7PgZYXbCA3g9Jd1PRx7PyRTNad56qFMVIv/9AYYd32opL/KQOuEa2LIoyMUHWsHVeJEgDnTAizkdfigKSmZVUDrztoGXA+B+9B+MYT2q5BETXJUKRLiEw3upTpXnlh7hkEk8/0D3rV1lUxxSlnDzLfFArxdnXRhBNu085RxiTwTISjItGPuj0MQknBfLTi9AeLTT9QUKRG7bxHm7P2Kei6fVAeNBP31q/OVsTuBJZfKaxLodsCxObxFdyJNLV2tAt+2SCAO5/VWcDOd7Or0wzbVGwbXJr73+/PYn3VfNQ4CSxdqgXNPWDqh9ZFVRQbSeb+bFmOpdkO7C70y6dTSHVuHlIY33/KV1QHDJ226atG4ltS4fk0ZNDrmPZ2Lps6qyMYO+Wkmsyw/ECuxfXcZ0zM7vmLjkk/LsX/XG0vaL3KZb2C51I5TVf8fBJmMxHHzKvaXDwSTGiya0f8ZZ3olqbqcd2cjXM0jicXlX0cJsaB81POyuItwEiYZwsHn4gymrnlD0mfAro2YoSC7KxDdL1DQVO+0a7fN1fLkv8ElaXx46Z8EGJ/W6akIr6uEuiFIQB9fHujgNzIzAgaDEYVITJJO5XQkyimdgaTBvra1hUbw4jb8imqVpd7G9dSoQVNPatqBlbm7NLsdI/einfpw6HdFlo9bpLb/wBxf2BGK/YWhn6LhzEvBuRuBZJTDv7HV9WfnA2SyT3HV/F6f+23aOYC8rxO7QQ1FI4/0m/OAHdCwYedzx6F6TIlSh668B+Id3ZxNP3V+Z82Tt/AHYSzDsxyYC8mxyk+Za4Q6u8y70AKpUm1NPP2WMeSHfqCc5mUcG67RR+sJWZg7P5iG4FPnFmWKv1nwwk+fM0IIA5p7xmHnj1zbj89sN0hc81tzI6enBjIyPd6P5GXzsmp9IRHKS506SAEK7IxfjQLxkNK1x+M8YAYLrD1qWXqo03kTvXgYllmtbguZX1FQGpXYjbZzgqSLxcXTKqQ/GhYqBJzZtvPaYGODBTozt0Rw6/vP+hTUJGOAYcEWWr5Mqy4792lLWmElkf2k2HiF5268DSkEL2oQl+VXl2NXgbfa8xxQoI7lpuNkURcA/pNz/go3LD+w41q4eQy20ecjCwekr0XfODump0XPUm2vvNfk4P/tAVA2PLhl21zoFOrSKjd6D1AiMtz/f41uWlBWCDDY4tDRMhyGsls4GW7P8b0/dGx6VTgC6oCCWxMyJyOgl5RPaFDE/EzGGGL9XUm5X9L3crn0DvEELm/Vx6HwlGWtnfZK7dA8/zJkr9b7PBgLeFlmXyfUBxZHF8kxgW5tcxvkEz0roS70jNLvk3QNCTUIwCHnqk5NRDEaewDCzjTR5lKzNzx1RHHJNiZZJ0lXrAsSM03iKPyYNdJfMwUAvRlKP49yIx7XS9cvseBWVvGNAc2I0PmR6Xc9KjqauqjgG/Q8i16OIPtQ2Ll3qDkunTNq2O65AEFG5qycHaB2/159N4n67iMEpyNowNdkq/ZlDxsX4dRKNvBUJaYqhID70qa2Rgq8+AzqTaJhuYrqrDDO1n/0rWggrBcFsYwo7ujJZblKGamFf+3B5MTAXNUOKn5PW91Gx56gtqTqz1dYMML1dFR/KZUZom7Wky7v9EfKnYbBseAvDuBFBFFCuXnhvWc/JS4ipUIe59Ls/kL+W5lteo1xt5bkJYfug17vGw6cqrOjTG4nQXZ+RbEDCMTf5JZ4DBcuVv+tGPyucc3B6R9NMF/lc4ubulrqcBPhRUjGBILbQ+4uBJ9eUHMAj2ijfMskRMLcV5FdgqIWhiEvxNVlZSRrzTzySfBUjZHCJQtbgDZ8nRWLwk6rQKWD5aSHuJh0vBgvlNTP+a4P7p59l0FYBPtoNpiFl/dOo05KHesQCueTxj7IB6io9sqTWxTu2PK2C3ACiXWNyxs52441hxg3eco87pSRV1NUvQeac35o3tgUpXtmtl2yHh3QO1mQ55wSqIri3PtVxJ57l0nOuyav/0ixzLEq3QlLZmLb8Y2JVlrdQMjhpcC1j0DS+VHrYIB4JgyXacVu9PCRoC5Y2+p8qfeJA3OFreaabxWxz5omyn/l55+ufQkO5e9iODCdLWl2crwLrUpaMCi8EUcVXGb3Z8oBCUdwuuohn1sivwQp1O+DaRFYXIbHQibdPfq4dU8WeiYJ4WKMlNEuQr/BRIGwOrAIM3Ppjmzvh27Lyx6xK14sUHgNy2ggNG57CBbXznFP/0NVrUQef5mMdso3AJ33SJxInqYebzcZ2pEVYHYczXE/+mcptBHb4ANtGohwQabL1xmFHav/wFH/al8TKjzGnYiFLEifJHL7OJD0x/rtzWuCrDToEWPBNtRKXFZqz/kBH6gsxzy/TUzP6R+C/A456FbGm8soK/uYyafgNmX0re6fgXeehUvtDCXdAUJElJt7AMv+VMdIrrOK7TAaHo6E8Khx1rq48yOqMqtC08so9cQh/AV760CiEtSm6PBL7JKCZBV4m7t8Gbbc4TQRawpuwTFyS/vt1JBnAQUBDPdEddlJlVAfbGy+OKkohOw9BB/JY9rDZQK1o/kpfl82umHijUnj0gVqhJCsrzUxYl+ygkRPDEPZqUIo/+AtsGplmBSxL8bUE1iBc8lCtShF2iqMC1DdHIH1DcucbSNtxOF9LY4IMng4T9eTYzDr+gnOPVxWBYMambJUexTzxyvFOneFg3r4FBEHqG3QZRgnKISYUQKv9B23A8vhFRe8uNZpBtiMtXqOQlVEbO/HzkRbqVaGj4s2XRVlhO+ewkvEaTp4pNLXG1OVF6ncxf3Fq94KmGuG29LLsFI1fuX35J0TsRNGo+TCioyTrXLVEjPztNVQL1/q5tGSrMPhfJEaQxHcrnqhVVqN1gfF+JK9Pgcud/lGa+Ig7eKQpJuUN+PYhBYQ/b6ahi4nLNe5+d8rQlfK/gl3OQ3WDGWuUMOt1YlBKoX+99JWlZr6tTAVgDF0NSHs5fqbU0euO7cXKnvVB3taBFHP6/KKZCBfGqzNo6DgZgiAELh1EYOni64dmOWUuwAQCKu+L8tnTFLlL6uKkaNtO8YGlOBVU9mQFYx4aGPgGEI/HTycxYXBClfKbmSErtcsuhalOh73FnzRz/thPjvRJcRwPtZmCHs1nYjivLMWWGprl4fRUOlrCDiwNU+9TZuaVsuCxj/4DzKfcla139igH7Z+0uskWkEq/c0mrsRLlVpl8ln0G77hwK9rLKc+RLeI6KLKy3Um5C6Of3qiKNoY/7ad3EFvdP4VICsuTMTii/bee9efmKAiym0A+l3hS7SofuEJ46In7BEO+Kf597wnd6s5mL1d5zNRBdOEmfNKyPdUuCW3u/SfFQes7nYlfV/B1DOE9p/pmgK+bx+eZdZUMu44uBGlaPvej5wxU9aumiyt/uCCZ4PyO0OYfFAMMqTaYcI8GxYeHO/3tDJsJisLleLpS/gvPLbEksIm3R4OCJ21S4P//uyzQ4EJZyYmWZjtknKJbz0vFEi0zDWnZHl4kvpMSPlVI8cEAG5r0JoNN59joEsMhUcPZ1YtIDYX9cnR711x6SQEnBGgTz6d3b1iebIdotlgqE03w87xlD0+qEykcVizaOB3Z+ocaMGWybZTIdpR4niV9mDm65EzKK8VQq59iMlABk54A7zAlMdkYNmaRuWJN+bLJ7RqEZf8vrpM0+3cwD0NctuwJJA13JIJVFlPStNIXzAW4pp1OnTx3rMZQfF+o4p92WDkF2tx1MUdC14Er9l1RlYsEYnOubj2IotL4tkgKwnE219ZsjXb8PJFkzakaWhRBJAkgbR6myiYFsJgC/lellsN9g1ML0j4HX4rwIzHbq20FDkBdfqN9SUnIbJf0QQr+QxHx4f0kRekXaqKZYUXYMbRKa6OObLPOaKGft7xFAgT2pHuSw7kdfloER91zsJPWQJbkAzyDFkkgUg80kW7n7n+WBN3CMXA3lU6QR23Ipx/98577h2OGkpcp5YiTX/TikBkcza+iwBGNBi/j+GwW8tGbKxpiSNEQqUDdqfscbVMQ+OSYGoeQKSLwREfUGDjR/emc+ZAJsy3sraTZkpHFZAI69dwO1dvsOw/Q+O/2lgghmEsk6NKzmfI+OYuOG2UoagP9Le/y9UABk4VHk54+6fW891qe1yVDT2KUc5hNeePBaQwVb5BQYPt/+2xEpqsHC4GY37hXyRSGvfwYa7DGUDbMKd8vud28h67mpOl7fe4uFRe/HOKf3TFs+9RX+QpL0+C2b4R/8VfkUQOABt4tcaDV34nU/UFXBUDvPYMYe0F24AZPIWphY9bLwt+tWvmuWwhvAgPN1rxvo3hpXvQNSPsVKgFUKENrmSCjWPYCUoQfJFpepI6oqpsVwJt6IlBFGO4soABNOS2KtnF9P7E9sSLK1WWOdGvYNhxKO5/D5ACMSM3oLy6XvjzPe57hP26DKKsIbhLZqcz8tJOcm1zlVKV87cVqDh5iOgGkNIKp7JU8eBp4VRPvv6peu3DR+ROhro3GOnpo6Cdltkq395hUi+pDXzwcONA2YjC4BKvX3JGZi77wJboSzwwPelRCe5297Gau3hHdjkNfDMaoCdfo4BX1IthlFNEHUm2nTsuiPe/rOux7FSlxIwT09NqnvyBmWQYcleqlPEreuoCZRFvXL07v84AxlxNdJM/atDmCjpmzumIoYOf4uVqV/8ZnSwV78WW0S0R7AwI0EDq4B6IaI6AUBwPrNLY0eeSw24zQ6qVAgBGW5aK79Mg+Skj4XxdPl8axMl4x6nwmnAfEBIju1ssp4yr/gdi9kl+ScGW3r5NVqJ1fXRkW9O0A6JBottvWGypQioSH2C46bepNpt5dXRK28XY0hseEnW9fDBaUMHziavWy8Q7jttulrsjOd5WunqGz20rPiwX/3fdKuQgv0g4CDqGBMamo9htCyKqN0qTOxWP5MmZG0lur+eIMwtcrfYqJujT19J3dps8mrCySt1MRdmlNIykG8cIMszw/nMlRV1DmpxNn2zf3gflXm1sXSH00EqrICj29dnyNSbIteQOqjPLqBf2QDDVVCAgcCz7vER9m5X4XkTIeB4ppqaFa2UHE05QSkAhs7FkyPf40UFGlKG8GnrdKq0ZLUk9m5jleTBwhdDsYP8HCDKRE6LS48qLHD4pvSl3XFvmH8KBEmyeyNwwJzAJQd8MqhmKsdandB6Ec1bHOw8agmVGP/vvY2C60X8AnR2r2HhdkUbclW9+ozjmxmipA1AJIZnqxg4aa1Le0RHfU2vkpf68y/rFMYgCXue7eNqxoS0NkOw9a9/WcDFJOh0Grb8zYjPgaSDENIFMCM0H5OlIqq2r2FKGkaQSMzVm87r9L7fysa4xxVMD0h7CIExLBVbCe1/r/WavK3yPhHVe3XBjyVTDOqI4/90N/Cm5KnqxFrVYOHbwMIXa3GwNwVME+38OpXvNwD6l+jN8BDCRDEjGDFC+WObTdm+5/tfm0QeEfVUYFtA7gTobiCnl8rywroMyBHNClofz+W7OhssrGuos+fRhh8kBA+Ni0fYdhKK+qCZaY0LUDpn17UUKCX6dOZccCYzSsD2iSQP74pFnhlkOzACsapdT20zbjF6ZqLgELUPT8IglaX38zP6zfdyBF+NjNf247XNtmIz4QCO5iRy/GcS8jjaWMfTxI3EbUvzrprtgRQDOz/eMnyVQVbbFiTMZfhfQLeu+j6iY0Qs/QYGFdHefwzAYuVpPhVZK/tXsy6DAioLlmNDzAu1eQ5ihCnobO+MOZtSD0+uTpiOAvPwGWf52xDUHj4zbdFtZULPV4c1TmWflDGMkg/Ia6kPHprHErwFTGoBg+1D6oX8lSPdz5srAF0RbktUTmq44+USAYYowZQOVbM3BWMc603Oy9SQD3buNTgzJ7yaMBbo/pjkzVrpW5xYH0Ra11ykiz32vo4nBg9Zvm92KHWhJm7uQJV5DMPA1JHBWBMcjz/uZupwXqjoTffeHZ17N3waXUaR7cZDs94ewlhsbQrmI7/A4zJDUZj0qKiVQhn3f3AneEhDwl6GUdCBdKY14q9n6ay58twW2PRXXPJ6UE6TUs6oqH/0xgDpP3bx/mfcCUy5oo91agCPtpTfowGZ0tyw5mIOsUqvdURDhjuWLX/WIqaPlYx3zmJ3ahTcxtC5xQgKWrQskF57LaOvwYN0lzIwz/joNYkiZwLyB7Joi0CsWWRC6SapEN5TClIisNQtNPmfwKaKYb+Hguo76RtcQMXdRZWjEJNHq8KZKeg/uWWDOW6aygLP9JDrNNW7JfWDyHPR8GL+29zBAD5FY1WZXsmYfdKU1VTLLzAHERJJGTpwKZH5k0uZrDYM8zG9WX+RVDM8bsmN8cI2wKz0Td8GEq9T4DvY6FuhMsqPGHC1tkLdxuwBYP0Lu2RvjXaxodrZhKfkkIwGcfm+lFS4WMFPCz3FwWwuvNLNqv7c85xnk3aXWl49yCW0YTzTqwyKuKWSIFJum5G8BBjvxx2yDOZMh18M2WhRGX5VA0p3eAilBsGa54P+iEat2c0lLnTrXg7fzDLJrjO/213hRmT/92zHwHShntUiR+9KUWKWRcx9OrMWfefEo/p2FR7dbNWoP/P/se7JJUfBzJixcPvTzMvSTQrccDAmpwoLnh6pnsAF37U9Cakvwb0EZzywhYhfUyAZ4oAu4R1X55yrbJifKRbLIC6NaYqZxbpzV9ec4/SFSjJKEvmVGa9tHfUJayAvrPPbVHNaxlbdJOOn7f43GTTdGGufXu/daAhuYtol2y5rFVUxlDpyKCfYRz3fOyJZEjhxizetlF5kpK8kUuEpKNWnSG9VEdmcn7Tu0/U9Pho+IZiTincXepD9zQXGusmr6j19TKRCe4dmbGmRl1cDDNABYeOKT51fHc6+d1Q9T2n1UMmkd+aiSUgNIrogqtnInezaEs7HmtmpjKttWg7ulLhPvEEnGE5TqPY3iCItPzYojGET4V755b+cNmqdG6OBTlbYjDs4AAp+ho1Iq8R/eWa0/FOyB4K5JLQ/WqwpaNPuaoufHcJMEld4peiw/7uIRZ9U4otV2lACBY2PfSUUu7vJ/iZUtvPoJmd8K/BmbnNo2iumTtQxEeARnjsHdzf1JrE1L6NGFsI7t81c5GCgmWILKM5pWDA5HO53I6aju6916JkUl1YcYyk9Hwwf/waKzGbNaeXD2d1jBd+rriDyPgR5p32kxAb41vjMM5QjUrVztISMmbVDBnx2qArnLJ6ECRGZcfK4U6LCAMxRtE+Y32MobWIYqbeJLCsaF4pCXyZjPABVmN36NRAavX8RXO80JuF2m/Snmg2NL0dSW67EVH9I4fcFSjpL73r6ohLh/V+uK3786Tpz4u9p1byZEEFVjn4eK4wBNeQ7DGhdbFbRTt6/9b55EBMfJGakrqZ4U+Fgnh2uIpidUcG+iBjHE5HMRX2ZKkKLyYQElkw/Kbj2w8OvDaxd8rzWoSUnwkiP9DB4L1FBdrrf9anTqNfPehHTBlyG9cgcQLrR8tQEZN9zuxs8BV1Zf+cIk9kSStcCODphQCbZP7NYhgTuqPh967gyo6DhJVEeM/gq2arEo3NkVtX7D7mzM4zzsjwEazeZbygY6xwP5F5NLqPJ0Hxncni2XMn/GdHQmTbQF1zee4LOhZaDlBzMZLsKXcJ3sJsBmPODcSW/FKYiVgzz7wLdz0C3bFpTwedWpIZzG+H0kpS6hOFF5yNj/xUGHEQK75qxYUFuXq2vFITPVf7aaAWUF+eBV5VbBqFcUccHNaTmGaDdRTdXTurKJ8ATxX0DHWz2qNhGP4nrYJRCKI12hvvahdfR6RlR+zca42mjybVuHEEGrU2KvnHy9+mmlQDH4jYHZKC6knkne5Q28ldgrISAF0p2u8YVTy2bGLZqUkIV6zWDXi0DuZMiQhOJwUgZQNnrjzpboxif7CaCAFdxHukA5fPTubF6aLOTWCnS/EP8ZSOIyNGpkn86BVLEgxNoCo5XDdJHdnSB0Zy+5O4NQSsoKdZzikwg0eSvXAE6j6WW27irlXjNHHxiuOY/LaFsSgXv62JfK2/O09r1DMjpxv32Y457Wd8wFBf9V6i6CdLP2Z9qNFsxcP88S7N6b5FAkZAkO78T3f4mpUVnXed/QQC1AAudBr+gg118i202+jHf4m1tBvD2iwt/8PqoAWQSajReU2kDJ91lZ9cqfgKVbzge5mUlKDSh7aeClFOoVz9UEdTQyNyjj+u7JaX9DWyqtt6955fcvBJF1aKEjjPQjYV4+FQr9Fnd8NqWavBRL91OUcILzXVselzvLQtPmmvtdhkUNi8G+O+b/qcVyHvls9lJjRGbe0YWtuq9zXA02yIjtBjoQd1vY0EmEFvb3u3xiPt9Wix6NZ7ljWQVbw229SAPrh/hsIECHTLmxKxWD3/K6TUieQeqJIfpcIoOQcgmvHDyyRUevzKImeikRzg+ly1+qSicz7hh/DCm/39Fyk6M86XNkhcEgJKANNt1matUHBPuMmqkqR0Irsee0uIofjg8efSzC4Ml6OzAV1PuydANODV+SaVqKrg8qTvT2ROpiQHqoOAq3EdFRo1QW+1ak/AYmGEVA4cF99A82GRm5mLHhLHqOSqBVNF5d+tjFko2morW+bAtWqE3Mhi2uYPJEeL+puWOoJaLV9uHtQIj2GvjqEnPiF3gSNk2kq1rb+v31DDwcalu1nsmfE1n7J39uQgliDyyoBoudkZrUtnIUrDsC6iGs/DA1YU+EpC8VYQ4iw91D0O8kJIRK0Zo3YzUzYnm6vxq+9EDAP5SWf+Eyupwlhcyq7rgfu0UcsS/cyy18bZBvpooyg1q0GNkTJ+MwtXBtDoaChHEqMdF/a7GjUgboSb8jHDJrfqRhQ/bbI62r8nHoOa6UgOaJLxxg1EhXpXmkd3Rch7uNxgpPzxP/mBdrGsygnoth1z7Q/YLYJb7LwpuGREdhP+ef4imi3CBmJrq9pWR8/s43S4uxqNYHUv9ha9RBACBhuz+S4xTQTZaCKSoDHnxC8CxGhiHczvJUTlt4rrWQpu9+AvsrR2wMvwqpTTd2ETTsO/P3JJiLBUvcs0TXCPCRY2h9Nx8ZqMz8XSEqa9ByDLoNM8PxxK/62v/Wkztb9dlxfHsl4u4UjIZo5lD7knNDevOZvFRYHhwFE22lXrX+Sffrt3y9R1DKaG/GlAPLQQX/Hetzpmce0TT69U3cFZSUWj1hcJa25OoCXx3O5jXSizjPu68eF6JRu4ly0GPmihJAcdY54LAu+PeTtHdGWaRfb6RVp9zxwP+2PoTSQm+qFhD5LkhsYuT1IwWLIAUjU9P0z7IOUj2QP4sYABt2vX5hJCVUnjOBPVGQTmwyR8LSRc2WvhlmD4DMitovW8AmruHvsuxxMnY/ybXB0f6jgvY+7tMu0sJN5r4DBEBXa37SH5PepbiAlY5L6+09qF9dbg57qZdXr+Lkj+9ODwIdoY9Ogs9QXAMPBK9sNLNDM1mFaODMVpqeBBx3+/X8BkyPofOmxl+kYJsG1PP50FDBXj0A4uVUwSXOnyDvjHd5pupMiy5DyOMVDjPDi22YVTeKKPxtGz5/wLm/x/DzHO4PBKlriUyR2fdazZ8MZwZO2yzm40RwLqezNhsNT7aqhOqWBMfTbYcyVtVzrROKLQ/cw8h9MBYgLQZ5m7RtajLhjAmwWRubbOysVY9+MbTxulvSqQymjxTj0/yGmowXOk8LorLHbyciHZbi5Wipq5e028xOnXPq0SO1Ei/BmXFCr+iw4toQwld1d5KXZJaq1eDPduqLEuVRpKA9CzB7KJsTTpdrYpMaOsIFM7Wgr9Oh/caoRAohQN6A6HSrmbUuxffYlS4ymc4W40QYfauuqpQ/JTXe2l3gW1vBU3Q0CQWi+YnGMAlM7QCe806vIrrgQmejgYb3z21bFn0KNZj8qMbtk0fubcrDYYwmBhjZezZtAK7N3MQKKCODWwtmN/WYEGctudKJzRB3xrBGIXPbh2oyOsQ4psvw2packPl36ulG2AlW5rvS3xsDrZG0jPgcLNOBZVquBKudvtx5EyYnivmLREWPn30cbkfL4RsfTwuJVSFZZJFh6UkofGq/bkz/WqbPwyDk8xppCVNz7JQstijvxEWrb40THMQJebLnzyY2q2jx2SLecaR7/0b676f5ddR3aDQqQxzS6YlPvFcYbw+8vic5SAk75H9CSsEorQCVlJSk7DU5HBRkzDnV2QtTJe9fsfqy1sQNBXqUXzv+3HDVDSjlHNPKEmNGm5+zlEP/Pa0mLR8hxOG5PeuHfsO4YAaC+btxGwKVWC9Se7tv8fBJBx1n+Kox6GyPB1SVukkNQkjh9dl8s6dR8uwRo6Ep3zrpyoDHwNvpGU0zV5/27gpveUjCyrt2ZF4TOPsS/WygLkfE2dbNXsNDXjU0kggbh+REnbrOGVNbeYAoc4ZX0aRdyTYOFzlRKaGo4MoHLkMH9FMwYlY+jItBYVbIzsByLIUmu7xM7N3q4VtOAzdBtYpwYx/5yTIIJ9yh2VZWg/uPZimDRgASUeaIeF/TU+n3NBLOkQvsf4CKuJi9s4FqpE2p0HLaw6yIcFU8mcl8Jx6XPWv+eL9Uv+Eyr1QVYQfaJcVwJ6kjFn9GSZ3uvbIxaZMwi7x+nNLp60sgdzogotqc5oVT+LDsygUDk+S361me7L2BWYFkcDER/Rx+J0tgDZ6wwKRu7kFtxCpqtt19WgsF6LzpqmDlLORvOsY68JnuZgBdo7ozFmFR6uGXxbySNeCvPKl92vkVsYEYjZ70nSsNQz9WiIy0pcd4Cjnd16gHVj3X+IIr+ZH/gTnYy0JQvVtpoQKA3yqTH8ZK5WAWFLSXjNeHCwtYmaan6uJoOWW3ktmR0n9j0uxSEniCHfobcaa4adhh6U65iKCHer9DsvpoFJxkj5jhGLhPSjJ+hLddzatV/1Ocn1CE5uZoZAMtgkhUYN5zk9+VUjJxOTjDsX8kQFan+fCSw0rK8IhXNp3dynfHXSYCNq076Pn60lpsgbLC41pl75UNjAtdkXJ0OFBP9SOFxYd/qxoACmCf2c4BNjgll3P8P77ikGQPLbKe6Bprf5RR7SLTcoLj+WEriYD+XvlnCQ6gwN09MIkc6PH+xS8JfJD7iyBoSsLx/L/1AzaxG7e0eIP2dxroERhpC6jg8arrg7XQBksDHIJZIPRhy16WjWaucMUOLtxrgBU9rezETjoCtMnBYdaOAagkVHdueRkp+p0+SRoZ4ejQaCwhOiYRYYJC7NsV73oO8dwYLioC3qILoo9B/eMud5uERJdTB+L3gaZcXObntZ43fegezhpmSwHyw4dM10xfsXF1MY5XAR1XmGR9Qz8Yrc2BSBiUUf1wSye1tGQLKtmsheBI0zWEKzJu8/tdWQ84lcWgnXo9INPwDU5XiJi0OyBQbwRH1ahR14L10g9kAYWlDK/0N3VzcgYYursjTtw/2wSHmfTGJsx5NOXmMmVliBLLHGu6G0jFBLZtUkH7EzFzorhlKhKRrLqXXlXpO8crQ3CHEcZLu9XzwCc9SvkPe94gxwonijdizLHtGfLLKLF1cdtXMFa7Mf4P/JQHiBZIRXBzCKoqPaIuvh7X4/SQdEJnxbsIECUF90ZnrLUpBjTXiX4XAc3Mse7eTXKyZp8Q3Sf1S3esZyDQl+BBER4PmbGOeQ+K1112FbEeyqQZg56WiQ0jRCUmP+Kew9A1ZxSjutLVOfkpuBwoSkP4RGNoe7WrmyTXKI6nk1Tnz0oe2Vm3PjBDf8Gwhe+fwAYSAjlPra1TtCj1uu1GcdIAm6ViQn9Srqf1ym9fPIxInLxt48mCIl6DSTi4ZJ+XkJrz2dXWQqhpSF4nNWapdIjJH+p1Opedufkw0xHlr4vORb9BCJ3W8vAPdZSqI7VxbNaaOfqhI/8w7L9horVKv7MLnEr2l2XgUM6+i5Ix58xgRlYVxa+ltEdaupD5yktPEOlldMIatEHTM9j7h7hxVvQPEbtQP6BmDdVaPz2u/o7+Aiy4lsXGE+Km2ss6828uqY4y28croxcwQBaemP2+4hEA88WmmXnQTmIMFje/i5qVzP/dynhApy5GEB55hU7+jPdveexxyrULupZB1hjyqISvKscuKXOXZUnp8dPLlTkOIlOhMu9t4Vx5PLPIDK0SdUiZ95AlS0+/1macnq6hXYYejgXigt9NePxN2PY9CC0HftH0q8httvBeLZ48ootbmSIZgK7/Wm1zqq/lUDZBL6CYC5KDyLg/WfRKIQMNyN2X432uLr/f/9AoV132hvDNWvIbdgJKmzFwnqjd8+MjwrCINW480Y/0ve7EpvtXHg4WzJv5MuILg89gjdMk86QRO9Q/YKdmb+HV6eMqRTq/oudO/E6zvH3NzGgHNz/zI4Clc1kXUMDTrnDpBI2KbWe//7iI6d1A8nhX4F+4tGki7hfsA4VOK83fdLmcdAGqQRjtItVXa3J7vhE+x0h3K+fVJpM2FZDdY7gVF9ME1rtQmyQOE+F7b6vQAUregqMnIegpxtIKRhyTvfx+DFWZLf+VUZHUO+CicH8sE+9LpldACFUpG+WMfE56X+8xIB5l+Eu4ij2kBUNYythq4o1kyIEuD1kt9XQ97gS9+waaIHokWae6jm/Y8Govgmk31Z2M0SBZAIeudbA/y6RkBys3zsWVHoPxD73jIs92cougppJ3Uxf/pQcoOw/qt20epdVJgHhT5/Rg5mNf+bvQ4LJnwSxs7VE9Qc/myZF4IFBUAom49bMTIghVW6RJ2gfXkP6ovc0THTEpxZWx4zTkARVTfH75vftaIkZptS+h3ERciwL+zFBfxojqrdRqqdkYWAVmXpf+ueckOfXPrN5b9eEwl8OJWgoXwyPM73RDn5ix09+qYTUbhIRquBAIHnO03H3q5TFdSXzP+sPDF+FV61ALiJwLttts7/NF2qhFJI57p4sixeZfoEtm0Dg5wGwPCH6tc6aqO8oe5R+IkDR8TuyFEN2w2kBdTxxvejaSoap3bQlCW4svakUIjVrpe7zCbbcGL0xSe/T3hysCfb20Xj0oFitmmY1Q+1QAbHJj3MfeeZfxuvYYoF7mLnb9sF2SPQEFrRwt08qapY0ODw4ReEM3TamVg4j3BvgKWWLIeWrMXPSM+I3hBzjUn6TbqMNWIPDWj5FBYrWBwXYB71BOpmX+5iYomjHoQ7LUcQ867QRS3qZXYnBbLy/FO2tEGfzE/rGyNxED2nvMySIIs4Fx3fZIsIZn/tCkocG9krZ5TWha4eDI3zmyCQeBMYsXlRDNsMfjEEBFh6/Qhq12c9IUp606kEY5bwbG/QnU+IAyJhlftn2f8iRL5A7v4R9oAJGU2GYjNHqZUGg2z6az4YMtQyXcV9X9WBRlaYnfVIRsmuVGDhDBIoG6C8AkCK6LdXd0NgeShgVCNpx7iacd6L5r4rVi1Gco6rCBwBfwyIJs4Fhnq8IZrURn9zhkJ2FenUPijnbIom4cDNJT3zqMfvySGt4ko2KqwoGDH25QLfuWMbcuRhuQwYKgCX9VgClxETR6DM5DNjTv7F3ysG0kI8NKZ5AZDzjJnJD4VVPwVR/fNKHpzgM8QQGSapVEbQCuiSw0xjHphp0eDxZeames1Mp9WwQ2puhmhj5ql1Lv0eYJEpN8RFa01yfNY0KZkTpYzcO/Ckhbb36k9esVXSMPl1G/K7/sR9Mcqvz7tEmdFwGaO02c6azfLxlRg6byx5y5aqHXBgH+N8X+0pGSjHsaENs0tEcJU4XtLrRLBJGIFVEe3TvIYkvc3siaU1d3xi9t7TPq1L/+hMRqojqmp8jBLyo7KEuYZeOKHFM3mUkV+XkyhiFhmwxtLgSsGMbh8fE6hCR2rTOIinlmsF74yj7IpViQkLbyCbrvDt5/yX6I7Y1abrFs7QBI3D9QnlxlwbgZHvFTKeaFKcI3NvUQFQURMimQ5M+eF6vwSlYff+7/cWpYmvPrIh9BVONzVYOe2tQdAWWT5fJSYL5Upt0L6Dl/pZObBEdo+FPC4b2+iU09eJ6vb/kc2/uq9CvCUV9KB+C/CPAJdOu7vq8wf/Yxy8081PEnm7VGsIzzoFYnDvfYTUyPhdXV2yICWljxWqkyEe4e1n+SZCRACDyiLTdzj5Dq5ThMdA+CNJhV09iM2iW1Pgf2XiLDkIpNo8ugDtNdVTMEBsO+uHzrqEI+EwMOFr2gevD8TkmyjvrYH9Bw6rkARUFwc7DRpOCIaACn2Edjv7bmiS3MFeVgdj1y0Rv+v1DYqY6EwHst3CNlpq6XBW7Q/fu+F1R20aHUR5Z1LIZ7wvY0E/w99bKzAyUjG7671ZUYF6F5+Ynv4Cm0twLZ+GTrBp8VL/LMeq8XYgzYldrklMglyWJS7iWBhdA5GraO3m3rO2AorN4N62bHcpIhG8kbvIkybnRVTEWt5a5f7iIYJN61OO1gLp+lMKa9CuaUR/y9eoF3/jHgqh6iPSadglFYQ/GTsLkzIXMTFtBelXwJHtvmQtoXItuOsLGvL2IK/M295YD8SaNfSND8zTfgUXGYQRyrzsPYC1cxWOto+YkW9R3EinZBFUy/5HWXF6WeqLcPADGeJH3U642mjV9hMqA/GY+7DcN2bpls25VizlGv+FyH0qhDmmd0gUS8y90rDX+Xk6y6McJ6S7gM/DYcoTHv/2NeKg4rjMw8TqrlL9LBcLKWQxtuJxVX7ObKDCs6fNlfUj6iRrGPFdJD+ziFknCJKgixZ5RJQEQZi2MefRmUYi5crYu3Oh50a5Jf+upvNzFAo7KhxO8WRvoqnLO0wvvdcPsaVUOIcvfZoUierdTyFyoxwnJI91KCBroEodybtBGshuLseewOL8RJP+H2Oqsca/SYdeeRtivXY+FFQeTQ33eeX3DdtS0+wgHXVCCQk/CkG/az4aY+ExO9eyJRmpeKAXose57USPZEoRKo6m3uIY0rsGhjw0xAS7X1DuBTFVuo29v3dChgu70cPjpl5/xQmrPdA36PXNZRWOszr9FtTYYxG7dHUooremnYo1QnUGWsN/xygLq9TDGLLhVH/pc4pD+15uGiALFzU4PINmfD25G8LAsJea1dQlpC1s7rkYJUQqIwFNDY4Eh0dawLn8fCol/rhUCEbEHM1dJlCBpXxKfm7zt/ZpsbXgy68nEkEoLjs9rk0E9GFFZoYLZv/4qZR7nl7qBbeALu0FWvdWoNb4hCvlkME+i5nbMafn9uVxxXlpXBlOxHA7IKvKJLMXQanWkuK9A+2VI1JSDoY06+R0/g5TPJIHfO3roljfhM9ncx6Qrk66xY1H0+2UgF+oQgm28A27u9+T4rGo0sT6suA8Jdwthg1T9gojZro33dFb5pubkZ5ZHchLzsKkibaR3DHxf769V4iImNuKKrpgMMK8vcvF4YgFx9Asca63MVyNPtp5+zXPASns3bwdmsxnn1S54GTdkB4DwX4L7JXMnQGqIaS+mPgWxbIZbFcDNIrMilEIEGFczfvcACtmReTyzqnpITyfsh5QK4RKX9ZWtvUy4bWXjsLYbNV7MrrZsT82c9cmf4f8I0sSYqVIlcUYgI782imxBuEKs3OWcogWDmwlr9TGLtVSSTlyzHUW4PU9f7Wv06gLioBSoAf5esTj3FD9kKtTKQZfTKEIOcCYWcfIk4IkcfoFGKSLqsHhBpBOTfEJ6dxkBJXCSlknDrb8XJYO4/96XFd4ThAg4/Heg3u5p1kP3QG2yMuUrty2cFQaT3cWMABIB2diEu/1KfFFSKbfjTp8aUhb99C/ZA5m7h8JWsGwT5Ml9Uhw6CmNHyRA15TyVwIsOH0I1tFeVqQaoqT7wGjyqrJ9bI+WtpjMv5CAGQfj+k2aPOJZ/zLvxAtkd/Bzh9BZPEwVE0I0DI82uWK72P5+mHKig5zbXYrQE5bSNA9/gHvSND2qLV3hLPnoJp5q/NeZX7mhb2aWf7qkF8iM4HEHQ6YiYA+E+kPmfMGabHq62QBi8sSJ3yb68iTcA4YT6f+gJb6G3adGkY9eeu7XQZiQEi2fXRSKUOj/zLkyh4R3hOAX6xhT1yCvCHT2Jb9tAzSMxe0RFbM3g6b/VHgP8nyZkt45j1ZYBTwOpQIaFU7nU5focNbiclNOds9b6I+FOnBXwyAf1ViJPMKBBofmR8wg+77g5o3CiYUzQ+KdNxUo14XQc58/GKrIq3XSIefM9azql5sX7KlTsU8DGT1HlHIYnd10cJYsAEHoN0mLKcHTySHsjTFesKWsmK+siZFXhlavE6F44mweXOrX6FBoELRrvIrsst4OH+O47VaML4CK/cNrjlTodfRr3u2XZsHCcw9kXLGX/15sm10DYmP3G3387x7LDyVoplrs0pzIvfcy41eb2Ob/wM6tQNLxQKnfSbL0eyYL+RWR09qeHT/lWpCFvcISYlmdF/jMaIWDyxE/LA1tguYOSiQtSqHfgqHr1n/k5nFhnUBnU1J1eys/8qySmWwIplgfD3uNcFHlg6trf2B11Om/f7E9onO53sWHhas4nNuhBJsUn2OjOnOAFZi2dcAvexHytVxIdybjHcEdXUcp0jkab19hwZ0RddTUGjtyulBmpbfGD+4d+oynTEjmMlYS/pfoCyhEk9XbgbBf7wtFs5qleFrCmB0NrUYZLxmw+2wFqYEUy2hYP3ZxY8uhRZeFXZfhOD58zGBx7lo4yMjiBc0zvOGqVQm8d4tk1CRpyGJOGJWVU4EpHPxqgMP6hV7f0IxJugziIEJHavrZauRXe0/THYEOKpl/a4jm/fah+oAzHRBqwetjJBSjNp5LaZ3ZUNQElZJBDOF1e4muumSHF6da394Cvppq45QN1B2wYBfbx4Y9fnq5b+heTNTCmP9XhMQGniDhmdhGzfPUY5YPvTUhEcaaA2ucNDUO/xvaUVhXDIodrM/05R31bnFkjUjn34N7Aiuagl9VB9SjYsu83Ws9eoevaZVwZMC4uiZko2GtNzZCyMHRq6GKhvEGBiM1gLyvMZk3eR2dGcn19YX72JnDBY6RWncG7lGAg0YZR9lyoCyQ13gtnyBi05gPlO9yOeIYGqQrhgRpR+pAvx4czdaBMpVI7SgZMAhMSsdPUEQ9stTtwSabBmrln0uHsOMhDvi0bNRUWUmqnu3eiLgzk2XKGyTaHCe59vZZcmDkk8aOO6pTw5H+DWALBPMcCOmfIz4cF9E5zesXbQkQNDFk7vlnAcetbpid+Ce9MnTb3Clhv0lL7lyusJYCpLpalVXmQ67YNR+IIDh9vW7XeWnU3FFfdnO0yqCON1josSLVMTTaH/T3Q7Y+gOUofDwwXaGyGRB+4GRC2kk7zANlgd7PmE5kXda4IpmTbP2OqUJ/O9EXW4aslQR5PtYy3tNMamtk4Lwzb6WIFll7MVBneG5vPfEGslblvK4unzLLIvceI6WxhiZNc/nr10k9nn8ikKPz5jmA9oC+lWIE8QR4XYTcO6WZ7VMORykmWLBbTE1NQc8/TBpYSaYjlsyOK50EEwZC6/hyMiltFDU/OcVfSs/4s0Rk68qJkU5mIFxzQcySQSzLKmqQzkbb2ZlC8MLMP8Tt/ui2UK3r3IoyOWjDNfAV+2/iYAbaU/gcEuC9PqZbBCpHpobrsMSJpIpAbdk+lZArMaQfdQP2kY9Krk6TsjNb/ad7Ghc/HTlJyxRISEoijGyuLhUJB5Ch35PrR1oibmRE3vvhC5cWj/AFFMlliT5ELHoj9ieMLEG0BOkVRUXKuv2bfaF8AdXORnzTtMfXYqB8UVY5TvybX4Mkg9YXaiDDrp7KV8wVHpmx3MIlmRkznG4Q7DbYNTZBEi2yxQfQW37NrAOyCP8AXP/EHi/BLLFg/ip1tleZLojlnpdzKgSmJyi4IRDWNifCtFxTRjzh2z9DNa3KUZLZnixrksQWHwp2gRkmuu7HYPHYIQrdjih0WnNb7CL7hFDLjbfGaVLQh5Fu7SHtZTqDYzgY4QnM/x2PC8v6+qmCAMbOvWxZOIxjgpUF1ud2/e41K1bJAXPTZ0ctJLsigJDqNH6fNsXGGXNx7cwJPgP6INK3Qxc3ylfv0L1e9m37k+CqkJJTN6MvvQuae8WjO1l0JvBh6yHIrZgf/Bt/DNS1QULgHfUCLdwH6GVXxn8JChzrTEJL4dTZGD6nCwPWD+eeU/jxNc/wph/HYngIZcSTOnA7ZoHemc7pUYXx0Nr45Sbce9CyAvFnCzoIYbXxoDXYVwt/7sf509VEfvoLzjbFrRKr4vntb5dgeDiwRX6neO0yQZsOSoVjVvOOSAuP4PT+ezKgOTL5CMeBFh5fTyCTneXHNexLrs1pBpLHH3kmt/Gi6938ByjJyGR1wM7/rvRQQoS1drQjQ0vefqIJKlavxUAyi0PuILAyGGfaeCzz00DKjY1cowpRuwwf7rYPEZOByjttnqj6EUZ84F5gZp+4HJmTpMjNq0q/lyKFhwHKG0wkVp5h+gESx82VKGR+mbao8YOh23JnEy+eNJ45yos7d1gFc6GC67dt+OzE5TpAYicEpe2YtuuIHNt0hQpdLBdS8eqx9D9RSrya3h16jYIp9Ogfv58USTrQa6bOJgC6Fuw3VSohoUOQpQ/XY+PVKw2eV8Q1N6yxzymT6QIiLizm3kcA+jtFVJVj/IlTTGr7Tj6P8fQmh0ag3AJfRbLs8nmEQ1QHGUtaUv9djTgKNG5hVLyiujHLL77tNlHcYLwqquU6Z2V+WMoDwfBiMDqK39/tNhs7dXQhQTHYkold5VgNmV+WJr8ETyoKTHTS8g1RZL+KCbZw1LZoGTgR6eNleq+XGRggG9pbw1+WcW0jzJpvQle+pDWTA3yPaJogeuohg7EijR/48Se6kjwNpGStelAHWNOtzrfgmNxtH9r1eSRWLz79nRNF5th43Vy+rZ9FcwK7PlfJojQmk6yDIgDVpS2IJtFflHkl2pdrA/ZK4Grks9dfURGUNk54HimplKaYEZX5dE2M9W/60vxTLBE6XeIZ01h4YiHBHGMX+eAHZAHpSk2dFZUbQL/ylbq8VdzyOCnwzB532xAsz2XqmJFNJCZ6YuvEpyZtLa07GuhPki8MeZUI63KN4jC30SSX7/bWpsMyfpqrzmMI+cCYlmRUB0Mu4kG/untuIlFzWG2JnuSThOvNB87WuxDF4K9MPLtApA2nPV+2yMqZtQu/5eBgMzg8/6FBhddJz3kV0onK4Jbo71w6dhI4czF3ksh7/wVe0vAH8B/pVGb1v7xscPIhg6KL+hvTtq6g1+kCPpBURUhkj6yrfPgZ3/Xtc22MaQJp0ouI8smF0IW7P8ZfkCNRlxyoz5rOlXJ2YoBYf+hZJACLpIW6Ecg7s2fptIWtvuAgGvGV7dSNLkYv17ghjkJQx6tLucnApd6V56PAKNj/7Yyi6MOC9uwvXC4HnQSolMT49c6/5ZRIfWauOyw+arQBxET3gqjgZPldHDuhPDdYxffuJ1ityuwa75OUwVzCfQ3DhhKAfuieBFYqqN1i5usxjNFwKad4V39gjt2wLjcS1yX59qz0LCyVW9KbSYU9A28hy5DC7hdtdQxRU9PX4vfg8R4KZzpT7OhJe4Rwnuob88KsYJT3Xdb5uQj/iI2b9k+IAL2RazReg2nxwi3ia771jH8mWcStAs1NJu+cMgx6oarFqLe8b1HSRxQ7za0WtQhVKdhOSo+l5MyUbO7l4rtMf8vOidRDYSBoESyiDirZR/lirb7mNwOHR9B00U3KDHjR+/6/p0FjHCVpWNOzJcWfIRQkZ6XmbdXoGNbYi+/6K31kVQSpEiFHlf0XTAzQKDh03BJv6aoldSXInQfAEINY34mN7TGvaILI1iq1F8qQD9LdUyM1y1GkmIcoViAyaqPmTF6srtanuyTM4L1D0wyuj0tEVAfuycGdwEON4fnsCqlt5T6S1obgnUutprS4s5WpzQgzd4U9TRXJErli2+o2bS7A/uISBZhgh/679K/zLda6gWtuZwAvTGNdCbAN9uwZti3Hk9kKWrIq/zDHz00+fSYLcc5sgjgY5sWd/F9nGirgGojICMTxUzGmVVyjsC+0iZ7i++UKuLA2KCekIgylXj+DAZVKUFgBgXYW5+1bwyASMUltB5MhCcaMuivyyhZw3MJ7OjjmJyH+sH7zwWOwFaztw+KQpl6ETunGZ4wgXDkkep9RDpXHKdERy5R1KfOfi61l4kXklOVi+UvIPbGuKxTqSuKxjgg5aUU0X3V/EKdOugbYyeYKlYTyfe6Py6u2Z+A0k4k2giHiUVqkoC8MKxTXxmChSs68WryAMhUxyo84ORdwTONcLdmrVJbnyH+ugmyyx9iKEPADsMijuo2U3uJDa7Wnfr9gcycQq006VxIwrhk0FV/BDjqzquNOsEJXdrimGw0G+JVU4/5BNk+lE5kSCYz9cOOfNBtbtPUoVHnu1jfPwwGlaTc7GUxPcDFnEgwaHh5znVnSwPAAdXz5o6vI34Epz0NKfx11wmUjfW8nTAn60/CwPV4XjHM2yzXbq/EA9hUimpPyH+gMWQc8fiEpaTtk7l1iADxvDO8EMdlaQ0nXdXnhCuCrsoC+Uvlb9IaXpTbhDyzTzYYUPRsJ1khYU6+UMPk1YHn7mE5V3/F28Yia/wrwDdF+R6TmVzsqudzix7NyUGk46wXs0WaHIURcZDicGiV7SEhoVNTU0zgBoaSd49LNnCcmSgWRMUa0JKdpcVnfovdDcIyEcqOXD4VeP1baW1O5XKi8DuZzNuEL/drafxlkHz2RIla0Jp8ILNn7S3fdeg9UhAx9q0+SKtkZq2KsJrdjjyAjr3GfTjVIDAz98414NxYOtS7EWs2ZaFK7+4WBYoC5Hkeq4b/TVXen2W5sxGUXGVbea0PfIOieEzqtacY9iZH8JBwrLvaO9mQx8S8Xs1qoQA5mRuhLUFIcDGMj1wJK/K+vclB5Bl071Plrpq5+L4WJ77f/haemR3QBDVN+DYo/NMMFkqokI7b1nRwuzDmI5dEx4XMlGANd6UtZZVQ12+CHjwiLfAM9yPWaei6wRjGbxBRZUWxyt/lA3BanlqVbrdSdMBG5p3j4Pa9sSfYjUr77zB9h2qpnC6V8u1+XFmGBTP3y97KCCHykGfB6mbCNng2OYcDfFxSp12MaqtqOwry+xB9gUkHlnfW9DENAGqcYOxFOWwZHAJEeIuPuyLr3pc8euQGkJA6K1rmHJDoeAl370hmHY+Wk02WBNr6bOj8owlbEPXZobBQ/xU4JVN9l2GH0nnIedokXyCvBiq+jOf90wECFhhyXgaKiOos+J5t5i72+cySCooSeyr88ULT2mwUuMCLDw9Pty72PByiEtatpiqNeZF8Kladg4jD+8iY+w8ru/PveAVmrABMft/YevFyzmyB1LNidUz8yrnolKmitwK2bPJrQzSfyMg7RCZtnj801QmxB2Hh1RdODJ04NYCR84mkyeVmLrySQsPfWBiZawIPusj3W803YTrCIFZh55a7RhYSAh5uolGsv0TMC+pfZ8CJFMfhrjIkPX4iPlpoVij0m+1EDPaObMhssohxiQLjAb8un88eH/6Z8SnJxoDDY9JjIkM28xe9G9BMqE8CdRizNqXF+yzFoq+i0JXmGCunk6mGwVz7dw0Aht2yZLXL1jgrrUpP84ikBVljLiJmABWcOUt5aq4e2FLPP4IYwNw6/6kBGhUw92jqGvzzSz2IXFoSGkFThCZ6Hdi95k3hbTR+UyOtNXxKf3qOHtoG1+tO5u2H6XvCe4OZ0IsSdV2C22f4X0XRjnoLI9dkAJcmaPzyLbgrWgj/dizWHsrNz5PzGCCZ7zywhZMyk6RrEJ5ucZ5k4Fosm8+U94ZyJFHYaHthMhJSLgoHd9plpggxNFeaBMx2BdSg8d0qM1P9s3xHTr7n+uvFsfU5qJafAkyfAi/gC+OLxCw0uMl/XJ+id3bpdG4VxQwyKvZaxCWrPaRHIy9KcdR43jv9jfykGUTzB9KjyF1G0SkyMHMeY5wgAmcEp9B8ffD92GR4FQExXAD/Rm70xyf9mrg0HowJ+Y5o1trz3gJx6Em+pGPt0PvCVSXsmyA7BLMqIiL8iKyvmFzR0O7FJPoUD5dZJ1eKn4tDUJJ4Umb72XTHqR1qs8KsHPpu1Bas2jM6FoTMyoX5aScTz2RVJH0xso6SkxxuMBg3uUblz4fj83SnK1GADX8ZJtrY6l5lrbF1/ZuSi1BShVAdFnfBB3Sh1SW4KQz2mL+Y4svWwspzeGp4W6pTFKdMDjOxHzkJHkAfLjLjqf+T1Axa9og+Cl7gRTi70bSWjsQM9F19HqH1IdJOoerLMQTLpuVpFU//G6/hsxG6sFsnzMJ7n73SbIizBrcriqJQot6sKe+uP1gONUVuBIPlDJA49atkvafSdkS4NR+zciAFrwoHjdIsVSJKqDxAVrM15uFJb4cUI1Z5j3Wgo4gLqLZDMdNtYKJ1P7oBTGSBKZGTqguAYXj9FtcQ4sSbuwAvEKj0iSHfGzNYpAzMhIVEl+O5tVLe4s/3uEd9Gsrl6bogS5HKQwX3XK8Vnj7lf+5qIQiTSzRnfkEpdxxgU0LAZG7OSxjiHkVD2gFaZ1GjKhIedce7dFUwac8qA8Ut250wwH7O4rKHFECWEhhPfyyNNFFWeFrcIjCB9QkpXuz0U80DXFirexggv6bCvxlzrpYL2A02HykHogeIIum14ATyzZnKSfKNZqYUHkFr6qN2/mPO1WK01C9CpwXcl3fLEficn+qMiFNH5a/JFJBAF2ZZWJ5EP8mGzPCF9CDlr0z0YHruP+6bAUG47CNw5yDdR0WDTjq/DqDE8W+/fc6iTB4r9945YbHjR76ZqoOFAkp3KnRniRLdWK5iKvLCCH/Jf9vzHnX4LfdHlAiEucOADd6aaTJnMDTB0DnLoW9pvA/TvJPoH2GYOwUyBgDkGv7VLqRPzjz9nIWylnnWqIlm7L9YRAuucHIleKaTQCeUrXP0Wnyp2nmBxzeDiVOPsap6l6MYLHO4xg8HBAK3J1dgvBpIjcYDKZexJV5mf8c0hpw5ODKTwdkKCeeTezcPXh/9nI/FlRcIYy8sH3nKCQ0EEucVi+uinLNXGTmZXSuB5jYC2k1R6X8FYDLSs7G3qg+Wa30/SZZVsN+vbIWPDRqs9HMz/V2eXRrxClGwzMRZTnpwuqrD1GTjLUluOf9uPygJGxe+/EB6Ak5UCCsCWe2GLD5iZX8ywqGyaP9CGKOOsQ504tSVjAMPPpKo7Ex8LT3xYdh4QReijfasLvMKd8/bu689y+WY+S8IO9LXV7KYzmOOycnb7imsjeiBPCZgNd2Hd2fLIQOaLorPkKjFZcGRaNO6lp+pBPTMvw9QIbYuQZBlhu48VmV3i/3Y0m71BChUWR3cdNSS4D96YC5J0Y7ZFqMHBW6G9p9pf1EMvsoq2dzX2wSvNYXqdP47zyePLrk+nreb97cBNao7U34lHDXeFQ+HqT8XvcE26g42SyQZmHFRlH2UZ0kohpcgm7Li2wAo0IHMre/0XfRV0HtarB6og11KC3Z7/RUcqKzEPA7ZEJQgZNgBZE02MFT702HN67p516Nvqkm0Gjx83wQdQMeqxlml8LDK0V5SdTdnatEK7C+bhiQ3CLRBupVuTeGYhJY/BbrqiE1SY1vdXZ2SFuvNbcrI6ErGJV8/qH1acDEtu58Cm9IYXlR4R//8FS+sjKjiIPcuzVQ+9bV25MODrRYTzxFJYbLhp2Um/HKOncgLdKHj7tOrMZfxR6CrV1qRAGh+vD5dMMDkqvh3RtFI8M/B+95gOm4879zLjARkfVycAOqjJdoBfgWjWNsJnafTkmc7B3nIQv/Doeol9zaGW/DlpeEHHLSCVAFpPcoRFbXqIB0NIfCnsKcK8GmaNVe1S1WmDjR9kV2WjYdDpu3d+gX3edjZ363f9jQEbUhFXtuRXOQv+gmYCubqBrqUoagUdP7xj0HIFEZg93/KZ2CrZfN9t0A6WcpUJBI5WLyoLnqf11jJxzi7XP7icTGifXh8HPdPwOvmb7A1BFcfY2H1yrgpQ9LL1WPc8f4dqfuE91BNq8DtcEql3/06rGk4gsNyWI77GnH9IKwUsAFlrpUmA3zzUPojorig8/2Cbd3TjsCKM9wxliCLyKPngKsM1KFkqM6bMFtyxYYrU2eewcxYM6RkLIzuCbt2tjjkrWkSVoIS5lGaeH9ACsgsCD8uBJTg2FG+jOXwTTSCvGIWOiSPmrIKKcqEISVvUcMWhHEeUKjXTMdtBmPl8s4WipwTYa2j7rmaa0RNf7IXAOT77NGep/q0h0KdWRo5UPERTufgAqHgtum1dZEPq6OH8ILA+nokd8MXPhCko+zgkNqNlrLQew5ugiVBI+TSaF0+Nh/0lIpsCoBQWlDacVD+Vx3x3aSXTbkp6URafBo7r4W0YMJYL0MnwFM5mzSBvH459mHAZ0yzT09dEXgjVW9/ggg2LxRO6yGo5FTpGQS5EwMSjG3crtd3U4X4CO+KX5W46TC5B/X/DpEipFhWLaE6rpYO0r44KwsS9Ge9H2dfFY3QNvXA1sWHN6WR25HgQ091u/FmxcmTXpvXerH0b5xRi1MwmGmrK4ZAT1TapoD8+smzXuW4xfFWkVDOL7zk9xNtB53A3+dJrIzc5OTB601UXSFtQkX3hWaSnhB0fIWaxp9w7vGQDYtDAeTTDigrLMhVNfLUpJcIxhrMjO0Amicb+Ubauev6gApJbByzVQRTWq047GGRSYgxukHnlk5+xWTYTi31cQQCJ9ILZRJ3tV05M1AIgNeeDW2H8IBJqkzSl9nnKSajGYOD7eMyjHHWbG4SEV8CvAH8Iew6SodPSlX4spOyb4O8XdYQ2bne98jMMolgBIbc8j1VfPhmdPcqVcmf5qMjZcC2VzGSMF9s4863hYPVGq86Huy5cmg6zBz+qDU3yje9vmEr3yJ6kZhF5z8UdlkJdjq/581O9VuCR2B3lyEAfQoUZot9HdVILawreyRxAy11JlpE3UoO/fi5/5omkUs0A7Gvb5+bsteFVIW+9l+qR2dINow47smAidv0bLLEr/yqKcUanjvixyzAQCM5CVzq0r7rDR9M7wjLxBq9eBWRVmyK9TfSJqXHjL8T3l8phqzWGZrkRC5oiPO6C5Wf59fFDP+ituUaiEqytebX0Feyu7U5Leql5gBMTdDPsmK7KUOyA5TuWxjGc7dN7kJKEYpro0VWRhjMArMIGbutu6vN2OSHb6nvd508S4Q34uCRKu96bSAD7YHASNVhzXv8N8jroYf5Y7E9s4wTpkvo3BZkkWqpF0M1vka3jjUC/JuZvw9V8avX+D9bciICl12vr/bQJxDe+TN9MQwDJwOe5HRWZKtCtH/1/2brHVDE381FF3JIILjZf20UTFL4MLwmZtFv3M88Bv1x6hEyoaAlZ5p5QEWzlw8bJBt8orARhiododtduYtJBSF7octT9JzbeKdozaif0LBWL/u9RjbeVNLZ8UV44Ye6Sz56Vn8QlwftWL01WoPryii3ZZ930Zx6Ins/HGvGQmHAD+2qvuKQAs8Y6ublb+Dvhp3Y2NNMjsuzOvb6m4YtkPzbhlctKadex8tBQuo0zhmSxfDIZm5VnEDdG2vZ6kcykYFxgAz3wrkVyXQnwxyQIeYMIHQYT+257jBWD0yJIiC3PqmohMzTC/65XVgSsowG2kgnlR7pYY18nBQ8aVfJ64D79rH2pymM4xMU1Zk/OS14XiDcldhO0c0RhQxiPSY72XYxpiaKVYmzOcEvI1PzQa7+LVZ6pBIwn8ffWvhqa38b3IskTs4RBkYs9i+i9/AqdAQg2IOeWv2fuo5tEcFyefI9nATJXQchbBEQO2Cj3kaBe2X+81o97B22kYSwjOkgZybf53qZFQ6p/N0dL/VnuL1cYTGi8k6rMpkKGx4j+Mc/fcHUVNXTKhyO10FkvHiN+qSbJGepJ/aLXoLZ8RET0Bshv/4hAQgzeS7yl0n74cedqdnmAeHmQ2CyXvMM0MWpEvA2ezZIKU+WvUSaGpTt1kvMloerqnqxHLfT01Yh2n3iD29EWnrQsyjedi1I5SUgvQKBM9G+oAai15cO1con2QFz3UK7w7ZgzM+vPmbk2QqR87fzlbdTSAhrLXzqVfLnWBA/4+5aC+0BRMZ6iX9lH3QXtKU9D01K3HprdilL456y5lsl38VQaMbz9hk0LgquziMY01Znz2WE4ClHG9cF/e7stVmn89oNFUE9NZ1RAc97KzDEWHLoKwlCG6L20/2Gj7/M6PDhsvhY+FMzYRg+v/0jo2gPT0UTCfaLBDRVvKQgUSYPMG1dr6ox7ohepBUS0msHq/V7A6Y9WfKDgSLatqTzwhOXnuXAoFc1LsdlV/Nv7XHqg5TAohZGa1mOn44SyY1fyPMCxL1QmxvhBC7mxDyj9DUnBpbjdAzrBW0mUzZ51brDVW3f0A8oKL6FYBf0mwK6YxDMJogq94OPgpZyKHKBYvJXMfs6u0pYnEn/jPeTVQMK6uY9Egww5setjqwdQmwi1ea0/uoNw7QKPorCWZohFt4VB+HUy/ObjCDdxryIg/y0wXGMwFyftSyf0v/ESOVaUNOHg1aA0SQ0KOwx/oqBneMvSoxZc7SqvQaHcx3ZLg7I0FQgQ9799KuVGTfGNgWvzIMnHqMNnCyCLJMNoNQK9XA4Wkq+6tVuCUREehKj+szE6KlaSwgAPfb6JeGqIyBrjJK/wNw2yPaYB9wHia3A56M5r4OplAvdVjO1vrsc4I8LAy1zqqpo0yM1hfixHeLNDG6ufXaX/4mWxYpqL3hBHpPbnox49P3jj/wGgdZFaJe1JTer036xd0Xak5qCI6SV86xqAdAChv6sj7ESw0SU7w0leCi/08lfYfucRQHdzjO3JkA7lvHw0ouMCSCweP+ms5HlStT1HLlgQ/pkLQ0HiDkuoPtTY6fDW0UPlH3ebKJKJsiIlEwAnWQ1ExfQhfs1IRdbEO6sgyC7u2YqSye9WFoH3s0+d4P2X78UPcUsRitbiSflMds3+5ixk47wEAbwHOouv3l0AUb9zZIP32hh+8n3fJx3LXT4wqErJXRmufydvyJuKW5IkA+rD7B5y3hJGUFrf+je8x2WEZ93MMZZjKF3R4hY4E82J7y0z9znWEXqtnGce0dejOBkrf6CbP1VCh4ixhRvmOXO9yA0A2XQqeWYNfk1eUkRWlybRDBiE5SOOtjudxOpqC6Hv0XRqdL58/dsrEItVoppvb13l9MrZRKzOe/vtw9JP9aAkOa7ra6MbT/3YE4LlEJ5ticKWKe+rOGibg+N20Vx6Vg7J3byZG9+hIpULnZWH4Tq3LmlMA+oUfgAbbzPl3twbDuQozSElI95KSsXaBWevUxIWPQdY+4eolMlTtLwn+51SP6BWFEiioYy+r2Rza4OqKJPMbx7t0CZCtpMKxYQ5JCowbAH7J4Y3Eh3C04j1H/2a7qH3cVo01mg0KjVVR59qENmLLCnQ4LNMS3i2XshEK7QAIvi4D+egZPpMUywog3s+tqRiaGXIEMFp3rd3TuvLXVT9tpJGxjgQLGMKXmGL1MVjoN97by2NaOn0JoIbOQqeBIHTVbBYNON5DD3XP+rStPIfVbuHd+90TJpGh8BlfV0dLneK2wDMnndVGVvQLhvaQxu6sL3XsvtxmQzeFWUSHLeAlmTc9yNQKkXtOJWS9faewS8yotiXdJQ6EI1vpVOHgh46gljSllVDRx9qlH7i2QFU/dKpaQEbpAFUBI/eSUGbpgT2ORGcUGXXDWjQJQo+nCkQVnIMRUCP367os5Iw4Rb3LDvOi+/mwcBozzUa4WkjVcSIURKO3RTFCiY9j3O6C5MBS6Y0WbBooC0nOzhKxL8xMIIaM/tnyEzIdlABrz3f9XlCiQ0hh+C7/bNp14eUvnjcHWjBOSw8E7BjzeXkRQkpIuZSOriwZ8PiOLZxCkXFOQ4hbXa4Tu69lccJ9Hd0F1lxkg5QnAhhfx5WdcTkBH3SibBUMCLPb/cYypz6s4GGDMV5smYibldp//j9gbCEhqanpxLsoexOMik4SOt879z21iz+8V3wgG8CicQsmxcsqCc5QUqOZhnpO4qAFgzHF+noxN835P4xf5EsOcPvYWwtzK3WEYVGy5tuvxE5WZB246SGIDgeC4sMge0B4p70Tse4b6NjlPHW+90GmqnySqY83r0ilaew46qmwi4RzmOcPehbn4YPCoISjQ44RURV++dfU53vcKhkSj6cWuh75tdSSUNMysFwoP+lN2gGTwxOfrha9wWxDPpimhEBVrt6dcBIvdoUbCLTDQDZuUOVVhZP4sATqq8z7Ai0STnGxzKmAHG+3I+/tvrDN/OOTHwR6W5aWSRj+M5wmS5hfdvimlus2z4pE6RV+l6scSEX3XjFUVgbSuuufln4qZfmgBxNvIZmkPtMh4WHAtuqRVdgDOLksqdhjqc9jrNVpRsYL4L5fXaKhNXYNJfTorxbaoSpoqj6ZEp05xsc4y4Qryx7BRs3iYvuHRbCUsiCPmmGdUPXDn6H7woEjiz1YeriH6NPF5au5aVrtcw0DvEgLLKMuVq6QvzE1mu+x9AFhhIEE3jVvzGWs7x+IBGJ2hfG8Kb57q5sDsPmddrc0s2doavGt3j59SpKkbETAVxcSwwHbpAEsYTNPM1KhVl7EPpQp+gNotyPx7hI11xG47CrYE7+4xlCFpaDwvf9FWescjE9qNrcgCXvSeme0GAOo6QjsttWQcRguwWZb6OG1VPN2xZcfyUeEGLHhPkrziDDf4SHNaCcXXJ9CtFdyRMVueZNWqaoSKhpFI91MMLSXju3pGbSzJlM8FPf/oxZbRADvlZZCyb8fbb4mQVBZZ3GWV4hj4PCrLA1qQvEqs9XLsRnoal9WaSQhWRzLJmCurnGGRc6wxyAAejp0pAR70k0M8R+ziXphTbSz5jU2xp2cFe1EhegrqPqjFAtYWbYwsm9X969oYf76RSVpD5DfI8iDfFILBkfvnZaZtHikQ2tfNY1T0QOYafZ+dfiQjWZxqrDxXDWbc/jYZSbOzpgJ0HvC9wodOgTk5d5d9dmNrnM0LH8bvtI4zgktUZdf/DkYM10EF8yMhbFqvpMTi+TaLBUNd9aLSzSGAqu41xsKxsEYHFPhxozYZMPCafc4U5t8Ja7k34czb9pTsN2JFnwl8AmZSpI39KzBoEcD8fz0CAcio2KlaDIhPF8V0HkEbwc2c0mkpBazhOMI1d4cxnKG15nlJ+haP4D9g/H1z7jIEHS7enL9st+r19iJpqLFuJiKD2NT7LXyBzaAcFxIJ/fo4roeZSvHUyfgqUjSVcPiszEAuk4Fgqjxih+ln6TZW8b5sbDIvrB1Ul++c1B63XbFgHdVJTaRPzIXeh5f5u+QYvfa7pHyQV0ZUIv4SnfFMvTC0g0/fdaaBd9rcpxu/CBpbobKZgCIyVRDZGdPlZs8UGyu7+Hxb64E/k0YIIyG0d7ZSIcU1dOwyAQt25Ow5B4W/oUhgU+Gf+qB/Eqf+V11+GylEkiyGag2sSabnAwgaqTr549u7USX8FH6EnKLv1g9jl2zIU7C6GM3aeDn8kP+9aBM0Agrl165RV4/UHaXPnrBjs3YOHlrMK9jziNkwwt6+rC5FPPvSm2uVuOQouD4+Rk/8X2VoT+8bijB9PNpfsOsNhiSOVgntu7dzfzJItraFExs2ylPt0vanTgZJP3SIxPvZsgaDSBNmxIh0KPLS+EZkJ1Xy0gY8WVOZDbYF9v0GJta6+GUy7ek8lisYumJ1nyw90NF5n7L6H1aFMYqA/WI2COJA7pWaf9Ugf5pniETIJNyNXtonwZOLeCG380p2a2m5Fs4WDJIbVCtkJ77ah+h3HMvJJ0fzW8OXfnZDuzbWB935lP5zr2+vOc7CL44LjNt8p2deJJKd+d8n1mwKwxWxUjkxJRVlpIqwq1a+Sfeu1oNGDaOXyS/LVoiWAi4/RFFK77j8sVBWyTeqc13DCYWKdEbHTgEcIdtBewm3fvU99V8J4gYLJijdis2O/D+3FBz8kG/SwAXwjzKgO1TmXuA3syLPxxfnEUxttkUPpzQJgAzcN6o79tpHr3QWX3TVy4USKZJPX/G7/sFv7TB2RKaM9LvG8518UTl/oNK6/mqMpSOqsv0xRVzNjumgamqz/e3LG3e1lkrW5SquqlrDJIrN90AProjO2hsva2vAv1ZNPbHVfvH6K8KnMmDbXcZImS+YAXafdXLVILS/Q0MSKuRaLPQABT6AsH1SpBlkiSLXyhT/gT5IbfD6Z1Jx0n7l33o2uGW4lgd8BRn8WUeEHBHEn2SCXVQwlREQtvN7iSC2y8qSngF4ytc3vgOucrGccauebyUn9sdKmkhMom+XHRGLg4yr7NW/ZAq8UDCTjimw0unj204NYoihtZTNdXwgmCpqzA6Y4a3S/braI7FEXELgpjVSnB+dqkyFq3Tny2G8lAz1OtN0TZdE3wgbqL8XtsE5Ut1NayTqmPNmEhJVC0f6ZfMop0HP5VawTxA+lq1XoeRAoIGH0ojuV+9O13sh2V2zoxj5jVyNGuZDtqZVlEeSIRI05PVi7nZfKw+EuT5YTkdX/qnx/AmQXABJR8mEbt5A8Oab2RqMdG+P0zvDI0gODnGDSO2w4ZOrD1zi5LnYaIljibbOMhpDWcwsd6Ry5eUmiLQ24OpaErO6a3/sYLybm9xOJLqfn7DNg/5SKBxEfKNyyUYP4KtkSMQI5Xo7dHcIhqH4l3CRK/gB7WtFU6bj0mReNJIitL8grYbUyZpqDuMDT5s5WQsWjOEmRSbMiH7HIkEIPvRu0WxMnRCJKjGFWdlKGqK96T7jlsEHCjsPjk/9VEQ4W5qB2tRAFGJ5YGgbmyYxqxGxduvkNdd3IZKcIbvtEtH4X7aHeyV4Dcn4wkEzUNRRhISM51Av5I1mwi2lj3DP8d6K9iFzNVDCSb+eb9pBu+SEqYrvFC8WKSi8OcZDj50KV871120hgz6n6OZy1KOh8OzKNuCKFt9mVlUfJKzD9gcuL53q+oTHGGIKFz4+4/zLC13N3l3y4Fn9dzM02uGyBGoJXmF3jrwW9OguOsh1FVykE1suM6kC/e005VRngkgcn29tixbfGSx7k8JzTId+5wTXE1HgKXCtGlwA7L6FxS+RUGGP2az1Em91D7THACjjqlVdoDOltQ7Yb4S8n4kG/m/CvtFfQB0e/e/JMgICLGKds6v5THENB7WYOdJ0P5s3GQzdbeXjUAG5Y2WCUBs5LZ6xDZzv1L7jfUHqBbmnHW7U4g+UTYB/tW7B0Ya0JAbpzWFSoVQH6CbY6q9fM8ccelwWdxeWdjZm+TcmBAHpje+emw8T5mUgl7Omvks7D2xk04/HjynzVyBN2dI3dBgxTkB1keL9tMN0WgyjY0ddKI8pigHP9lOa8hb7F2bZIa/FqS6JJPPHnlyPbVl+weIG7j4ocmWH/OkvaT4qtcbnafk2ocwOkjSqUob66ehit1UDMwKXreD2R92MZugTHNe/PWAZesANg9eBbm2p+4kqK52j8MW3AhqaffDN+kK195DUM4FLVYm8BQhOF+OWoM5tTD8LImCNRenutbU6qRxpaMDXCBU37/K3Y7eobcg/IaZaBuw44FteI67Hdgufk5VqCDjlK7jDBUtVq07hpPI9ymWW/m3nNLQlusNGDSBNYXOUBDRWNnHira/1eo9GEwVgpXn2tG1PUUxT15p/fbfGXCvpsj0QlzwErC0ge/Oqlsh7E0QhpqDAcvlBJOiXDD/bv01SkM269rmghWHJPUbmpq4trj7H6cCMXMIwWgOLaTXR0w3tamzJpReC8FXDNwkxSCbmg/ag17JdPyptz7mR3k6KvXor6tFCfEv85TW7CDWLEap1AC12Ym+LK9/CxdKPnXz9Qz4xNXGn3sG1wAfthifQfjDyiCnLo2uhuMzI9yKxH4PUTt52mReMLmnHFrrLpDYcPC+cU7ge55guYhGv/ANB92YzoXrI+Hs6gdXnnfE8GGhfydGwvKBKCtpDecGnu41Mz28j9/LTVtSV9WZEoxANMgPGo4BDbY2p69ixYGQWATdyg9TRDAK7f/Lrlubat60yuVZ9wcwqZ7NBP71mX6NEgdvfK1EgMnkZzsDQl/wWDHdAoOYCo4pKwY5I/V26cKTO4aMYcV/YDdgglOtas2KtIXBJAcgotsV4YfF+CDN4T5WdX808VdXh3/UXLrAdcMDF3QIXj1HyUHIOkXBH7DXICbJt9eNiowRXiuB0d1J/FqjPFe2IlNdXnwFwpRusB5PLSv0Lk/AdI1gQmao8wwLmnoh/L9riMbMMsWAOI+5B71d+lGTKlxx4hQn4ixRfedyZUUsRcpGrgAS1XqCKzggl0/LFuyQpe9BsgvZGkEHQ4ELkl6bcLtiHZ+7uFxmRjnV7v8PP1Whug1igIT3OTMnmb/dGJPuGKY5fRdvWoatxfNU3ABi+fY7eHiPqC0gQDpAC19twVfWBtBur+ST+y7fzmSE5Q0C3mcp8/31XIdqm7sEZJHtFnXBgaTyG+fWRGAY70K10IBvKH2TE6IMzm1k92/Cn2payTupKTtojgP3uaWIgFVgV0lD0WGR0PanqiKtrBFwqznvb/rz2PgpSjWd2BESLQpxY+6tmKXZnjvY9xfR12CQ8o/aKz1t+XxCSzy0uE5f/kaFUCrwxjL8gT7SEUJshp//5/yvPFJHgJlgsvXp+gRQCSzz+vS6rl3BhMsbj/HzwJYz8GsWppOQDGVswlOHEaFE/qhImhDrt2DUfNxtt21GW7KwJRn9/mtYIjlnnwgESPEpwoLyTru3SsVGzRxnZG6x+BiseUs57lTdb3H8KG7UPeH1SSjy9wZHELnar9x5cOtOR7lOvyjWm4Ab18Q+qoMxxLCFit0V8SmOu7AU8XGY3eSXb6Ly+kaQmDkRlOstgmcj+rD34KNz7LTvLL0O1Z9J/nCjp+1flOFgtbd7Yg0t5eNrPuppxYxJfSpnJRNL4S3YTffnV+x+zVsuioseET/On2wNi/TnL2rAQIKswi7Er3Sv48D/+PLsa2WJOSk6DqcCLmusILDiz0FwKEhMewrxtNyM2IAE0/6hiopIQoUgC6U8CLirhWbfVibSnCGZlF5uywIcaUlcEaYP/evokbi1NSquO62XNnWR4+fB3M1N7LaI5pwdHYOKEjg9OaSiTtEDypKGOVxZhdQS0jEvZ46foNS4SBpwZfPn60p6pQldNUmimhWeU5LUnEpZYjPJU6hmAsh4AKaLFfJANrZ9ou428yoEIFuiY9UgOYkqtSUocWxyijxK+NTtuDdbh7NJcyLIl6CUBWQjZiL34Bk0Qe3vmT9tpIKus3r5CvEdEu5Va2Wxm8CQJT9bESzuFBeH0QIRybKFAUVqNa9tCXukd1jwLXYKWsuMuFda8R1UjVG2cvAZ+R3lBV+nLksL4Ti6lubX3hKFcSyFsG5rK9pJt5nlSGIkBLP/HFqLL/KX0S96NdOo4CS+GYPBk+lBZxz6Yie12vvUj8l4t1ik/5PmvbLOTPCcaoPeZ7APUQIKIcxcNUDin3R1okbeAUGwt7Ja3G0ntQokBhlajisyXeqbfPLrTTKpTauclKp+DGdyBsbzFHEYtIqZnlLe5wjluF/UID6EgwWPGj0FVKM59Jom3+0Y1QTb+IKqHZv/0FIEEuVItlJHSixdza2w0UN80Hyc/eUGv6SBybC/EEs9cOcLBR1eeQXXe7p7hfIhtxxBrGhk9n7jom/4LXF125WzPmMCUiNyE8iO7sVSmRf/iSNFBveZWGPeCirfJ8a43fk5jCfA3NPEJyMAamu3Q5im0DKo8aonWXtye9iE8vraixlVTAGSXFMjP3+XiOE9jrnXTDzARnt7+9gvHctQpaAI0za6N7bq9R1lb55jILwmx4Ih4OA0K1/Xx7B9jytPFBRhEO8xqXLhxotsIRjnGRvnkMK/KJ1YhE9T2mNmclLYgMSn+7dzik8BzoHt+EcXstV8yNpTspqsnS96ATq3A66NbF449w9JqViBt4gWi7yVzt3kR4XSJ8iEB5anMqG+EsSyrMQVv0sMeEysGx+yYs6G2xPJw3zqTq4RzDQXPhYra/VMlt7E8zzl4D7L3HS3kkWf4ZkmFmnjcENPQdkmohl6p/gqkOg+8McyzNxxb5Fl19DsSr3MTuSMqhSKDn95ibzYCEdrZXJiKaqu7BFBuju+jSObOPchog2IsE/u/3U/UK2mntvSnD0qNkPYoRTskBnLJ3NJamL0V4sEbryX8NMr7MKMJ0+h2+xMKY4KERpvUrd0c6ABXWHqLdY1QTugC/5dhdoLy3+KwgG5FnL0MZw6qvOvHkKQRoQrcKLuwUld15s05QxurH67A9eAr02a/vUWNBIgP6vOa69ZZuZKElWttIerRDGIAkZ54fw7HBctSZtfspPxaliwbOEH/Laxot3ZQonzvXknSVodzZHA1Jw7BcNRsYvl+KJ0Y6pMRPpIbaN/QSuHtnjUoej+vlVhq5021xMUPKxCK/D8rSRbOmduHG85/JrIimgo5wXWP83lLvRaxwCxeTGVt44fTUqsfUARmQcS3f5DbHR9SZ4nJYIEvcCjIqLezJ3I6S7xBop57j3ZyMQX0Xxr5mc6IUmrlOXM9fJG5iDZQQ9rWsGZ0Y26GzTAEsD6pjPuDa1XAT1MRpxyZ8zN53sl1YEV0E0EHvZqcnBnqMTXRh6zC9PwDXEk3OHs2zLLIjBhY5+7lDxp1X0qcm8XtWorat33mUx+kEDDgaDUdpclQq/ZM6mMYoF433nKbCKDxCozugSPVaRjNPosMDy8FujvIJSb763XuBGBIYLS9x+HZhYiUa9xod0xKV9aRt7yczWWlLgfK8qn4fULHMBSP48m/wTWfDBdTH8uDAKt5WM033+2bCpxDhmZtE+d7XP65yBTOf9/EWaCG+Gs9/5kVbWS0JlfoDH6Si2tVCzCRGfV0XZAUWfXOMJ5F9dkMagbwaeqVqqbVONDQGg8zID5MUV7IkazdAz4JLOXsn1RuZnoZNIGV2Na15+dRKYUAmXFmkWBJpPMBwT8N4bd8VZwBnhm3WzH9S0sbpoP0sgf2OmPvQ6smMyfkVK+OLjXYubmtioAhdwDb5/pLRg3PGwfHEz6v9OOe4AK8iw2cma49tV44In8Rc9jGcqSQlFXPdlC8366ke4U/ITFy0/SQBl1vWvGk40KycwWGaLf8cCtEi/4X2W8961i6lYnpfNQhGcQyC8s2oIOW+Pw545Thq3ZBEyNC8YDr/pzCEmBI8U3A4IiQJoHiD9kUMNd8wfzysC2Kqc4OGeWYsJxmDev4Jn4HV+vqpgN6xxSEMABhRMdTteHiJAgnQEX9BR2V1sNqh5EcMvQNYYa5+bblQn7Rli1UFCtQkP6ECmGkxmPNkg2CGS2mmf0/WEuTZSyPMtbbrnftPgleOmJ3jSm0m1EU9fQHQo1NZti+KczpJ8mSYIVtXzXh4rNJcL3Fm7Bbftpjmj5UnuDpPk8HvqKOj2DGJyk4R0Md1x7umiH0DTOXaLwO0EI94k7n6R8nfqiwekgUQZ1rRek0HViM5YN0JLWp4f4NRE8ErcGNSHZd58+9Kx8lmkc9ogfQmX0rX1kB8QQzNbH+eVDee0jOQNUgQcew3y+0QbifXrtLHXDIxsqsej41Kz7vfcQRE1zUnY2phYNILK8a657zyHNMzPiRhxs28s1JX2kiCMEloubOXnc8BzU+n7LM9wztf63eFWN/eWHXVivSdCWg5DfWsk2CF8aFJrOP277QEPdkWlOlewCVEkLjyd5wUn9ZzaKOJKnDQDLfliiRLTKlU8TOeQj8jOU8FfpM9tayJTDpxw6sVlZuJRAILfxn+QAGIB/W1FGDjuuVu62hFDBdvzVSfge95Ebf9pclp0GrpV3S+gwBWn5J7aGiim/fRyIN7YVVXJsnAnVeq90vDdAV0XearTqjT2Ck/AMkBW6T/ls/6VUVnFWs01wxkahKR0tRwyLRKgHefm3RWie/pTVQpUMZw+/7ozQSW+7vuZd8lsvT1iX5rwlpiaFnOnDbHsr1As6vLETd5HVbcBCGbJHcS7ax9Byd50jdYyagUtjAaHYX8ryyuR/bDkw1o4j8+hXMfbzy+CVmgrfRDyl4dn+5LxrqRAXLoDKpQREAHqdLSsVSJh1s8KnZ/SsUVq27cq+O6LMSBmhT4X3E750rmWwCsoCre6bT//oFWYALjp2SbcxnULBaTvnYDHtfEbO1m/3c9nJk8ZO5KHQTV88ivTWN/S2EXwmisTPdcupMrvI8e48QZdkZu9WHyKron7MKhGFJw6Z0KZ3tleVrvvJo89siUwByPY+Hs4gkKPBQbLQOaedcv/xeM+Ih8rl1eHEC/C65xWVciToVqSGp9HfbhVzFSrO6kBnv7mJwnRLvMEwqiNankVdJJMw4icU3lKyw/ecNSWIUddqlbThYMiq8nHjRRufs+28cq0OI9zhpvxFvFgSZE/eAYvm0x+9lZO+EH9NkBngaqU1NMYhdombNuy3awUN9p0mJQ//e9L65YbShgoc+ZUlNy+c6F6gDEHXV0JrzevPIZFAe2RyRa2dNqzLvihAAMCszYueqszzXRkSyobx5+LTLK2V3lfg3wbS9DzP3QW7VHdHbjZcttQRvtjrGveJnNn2DE2ZDIbvkCrT0H8RzbGDdmIq4P1ey+hoY/W6NuZKOz4dv4HUNznxdKV1Wf3MvqUv35r2jTKvpPWBUWNm5fytX/QJwp6qkIOsSx7Y67BSCbCDVLM8/VcMG+T0j+INrgL9sfT1ICtACH8BI0G6ViUZPVzzCmQHW2oVIwZjAoFl6+meO/pD8teO1E+1y03mCpYfW9S8qhtH2GhlFlebPf4NbezVv9xbXKWz0xezRNQWqUqtYRTUbuzK7KTvjG4rQHfzBpVmK4wDLnSIwdSzTSk1fPNeY0WOpPZTLlvQ59xwgfFrb326vT2hS1JAZ9E6sujFtKTiJ7bxI6o4cBhDaX+adXREThhR+MwA4TqD7rga/o9iY7d6TVRe14CS2S3iSQsD0R6ApnhG/2Wa0A0AY2NtWTjmabdKU+KgIRDP9RQYVjXiF1qC+xyNVG03I9vpmEpY/G/zC4nLOKgXAZ/uTikHI9Afbkhfgfgo9arWbix5eH7WUo9RQygDzwCnVSjbXc7MihEufVj6WGbK963pw8VjY3RS8IH1cy2yZbIcKLO5CgAUcXJfF2+McnDLKtXxyZaf7SPA6KJq+zF2NHyfoeTOwHhGqNcnHVr1hT73pcoyXyfvCYBnG1Bp/aR9t8hoI7CXM3UZOisWGA1SHZ2jf7k9GlRnp3mF/c1AV+JjvUsnZrsybEOQJg/dn/9eJkyykQHjbF56zgcPX6DdMG03WKUMlYz+uOZ+5DZy9E9MZOZ9GMoLFdrIPPQQLjv+GlCMpoyHPXkzIODjHAID2PrnaRpqWVHh0rnieDILKq+Emrd5RnjgE9pDUXWTmHaKuqqYlcgEz4zbi46dbWrAAFBjsQq1rLHIiPJEcwFLCOY4JNlXRXQJqCUKXk2d1RSBGzDP6HDSpo863BhVRFFF6uIpjQV7j5ebFe3UkkO/+coIo2BTAcgBqOtQ134s9a4QJvofuqBYMGOBMsWZ+sn/2AOxDx6SfAnDFGw==`;
var $87431ee93b037844$var$bluenoiseBits = Uint8Array.from(atob((0, $06269ad78f3c5fdf$export$2e2bcd8739ae039)), (c3) => c3.charCodeAt(0));
var $05f6997e4b65da14$var$bluenoiseBits = Uint8Array.from(atob((0, $06269ad78f3c5fdf$export$2e2bcd8739ae039)), (c3) => c3.charCodeAt(0));
function $05f6997e4b65da14$var$checkTimerQuery(timerQuery, gl, pass) {
  const available = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT_AVAILABLE);
  if (available) {
    const elapsedTimeInNs = gl.getQueryParameter(timerQuery, gl.QUERY_RESULT);
    const elapsedTimeInMs = elapsedTimeInNs / 1e6;
    pass.lastTime = elapsedTimeInMs;
  } else
    setTimeout(() => {
      $05f6997e4b65da14$var$checkTimerQuery(timerQuery, gl, pass);
    }, 1);
}
var $05f6997e4b65da14$export$2d57db20b5eb5e0a = class extends (0, Pass) {
  /**
   * 
   * @param {THREE.Scene} scene
   * @param {THREE.Camera} camera 
   * @param {number} width 
   * @param {number} height
   *  
   * @property {THREE.Scene} scene
   * @property {THREE.Camera} camera
   * @property {number} width
   * @property {number} height
   */
  constructor(scene, camera, width = 512, height = 512) {
    super();
    this.width = width;
    this.height = height;
    this.clear = true;
    this.camera = camera;
    this.scene = scene;
    this.configuration = new Proxy({
      aoSamples: 16,
      aoRadius: 5,
      denoiseSamples: 8,
      denoiseRadius: 12,
      distanceFalloff: 1,
      intensity: 5,
      denoiseIterations: 2,
      renderMode: 0,
      color: new Color(0, 0, 0),
      gammaCorrection: true,
      logarithmicDepthBuffer: false,
      screenSpaceRadius: false,
      halfRes: false,
      depthAwareUpsampling: true,
      autoRenderBeauty: true,
      colorMultiply: true,
      transparencyAware: false,
      stencil: false,
      accumulate: false
    }, {
      set: (target, propName, value) => {
        const oldProp = target[propName];
        target[propName] = value;
        if (value.equals) {
          if (!value.equals(oldProp))
            this.firstFrame();
        } else if (oldProp !== value)
          this.firstFrame();
        if (propName === "aoSamples" && oldProp !== value)
          this.configureAOPass(this.configuration.logarithmicDepthBuffer);
        if (propName === "denoiseSamples" && oldProp !== value)
          this.configureDenoisePass(this.configuration.logarithmicDepthBuffer);
        if (propName === "halfRes" && oldProp !== value) {
          this.configureAOPass(this.configuration.logarithmicDepthBuffer);
          this.configureHalfResTargets();
          this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer);
          this.setSize(this.width, this.height);
        }
        if (propName === "depthAwareUpsampling" && oldProp !== value)
          this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer);
        if (propName === "transparencyAware" && oldProp !== value) {
          this.autoDetectTransparency = false;
          this.configureTransparencyTarget();
        }
        if (propName === "stencil" && oldProp !== value) {
          this.beautyRenderTarget.dispose();
          this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
            minFilter: LinearFilter,
            magFilter: NearestFilter,
            type: HalfFloatType,
            format: RGBAFormat,
            stencilBuffer: value
          });
          this.beautyRenderTarget.depthTexture = new DepthTexture(this.width, this.height, value ? UnsignedInt248Type : UnsignedIntType);
          this.beautyRenderTarget.depthTexture.format = value ? DepthStencilFormat : DepthFormat;
        }
        return true;
      }
    });
    this.samples = [];
    this.samplesDenoise = [];
    this.autoDetectTransparency = true;
    this.frame = 0;
    this.lastViewMatrix = new Matrix4();
    this.lastProjectionMatrix = new Matrix4();
    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: NearestFilter,
      type: HalfFloatType,
      format: RGBAFormat,
      stencilBuffer: false
    });
    this.beautyRenderTarget.depthTexture = new DepthTexture(this.width, this.height, UnsignedIntType);
    this.beautyRenderTarget.depthTexture.format = DepthFormat;
    this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer);
    this.configureSampleDependentPasses();
    this.configureHalfResTargets();
    this.detectTransparency();
    this.configureTransparencyTarget();
    this.writeTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false
    });
    this.readTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false
    });
    this.accumulationRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false,
      format: RGBAFormat,
      type: HalfFloatType,
      stencilBuffer: false,
      depthBuffer: false,
      alpha: true
    });
    this.bluenoise = new DataTexture($05f6997e4b65da14$var$bluenoiseBits, 128, 128);
    this.accumulationQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial({
      uniforms: {
        frame: {
          value: 0
        },
        tDiffuse: {
          value: null
        }
      },
      transparent: true,
      opacity: 1,
      vertexShader: `
             varying vec2 vUv;
             void main() {
                 vUv = uv;
                 gl_Position = vec4(position, 1);
             }`,
      fragmentShader: `
             uniform sampler2D tDiffuse;
             uniform float frame;
                varying vec2 vUv;
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    gl_FragColor = vec4(color.rgb, 1.0 / (frame + 1.0));
                }
                `
    }));
    this.bluenoise.colorSpace = NoColorSpace;
    this.bluenoise.wrapS = RepeatWrapping;
    this.bluenoise.wrapT = RepeatWrapping;
    this.bluenoise.minFilter = NearestFilter;
    this.bluenoise.magFilter = NearestFilter;
    this.bluenoise.needsUpdate = true;
    this.lastTime = 0;
    this._r = new Vector2();
    this._c = new Color();
  }
  configureHalfResTargets() {
    this.firstFrame();
    if (this.configuration.halfRes) {
      this.depthDownsampleTarget = /*new THREE.WebGLRenderTarget(this.width / 2, this.height / 2, {
          minFilter: THREE.NearestFilter,
          magFilter: THREE.NearestFilter,
          depthBuffer: false,
          format: THREE.RedFormat,
          type: THREE.FloatType
      });*/
      new WebGLMultipleRenderTargets(this.width / 2, this.height / 2, 2);
      this.depthDownsampleTarget.texture[0].format = RedFormat;
      this.depthDownsampleTarget.texture[0].type = FloatType;
      this.depthDownsampleTarget.texture[0].minFilter = NearestFilter;
      this.depthDownsampleTarget.texture[0].magFilter = NearestFilter;
      this.depthDownsampleTarget.texture[0].depthBuffer = false;
      this.depthDownsampleTarget.texture[1].format = RGBAFormat;
      this.depthDownsampleTarget.texture[1].type = HalfFloatType;
      this.depthDownsampleTarget.texture[1].minFilter = NearestFilter;
      this.depthDownsampleTarget.texture[1].magFilter = NearestFilter;
      this.depthDownsampleTarget.texture[1].depthBuffer = false;
      this.depthDownsampleQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial((0, $26aca173e0984d99$export$1efdf491687cd442)));
    } else {
      if (this.depthDownsampleTarget) {
        this.depthDownsampleTarget.dispose();
        this.depthDownsampleTarget = null;
      }
      if (this.depthDownsampleQuad) {
        this.depthDownsampleQuad.dispose();
        this.depthDownsampleQuad = null;
      }
    }
  }
  detectTransparency() {
    if (this.autoDetectTransparency) {
      let isTransparency = false;
      this.scene.traverse((obj) => {
        if (obj.material && obj.material.transparent)
          isTransparency = true;
      });
      this.configuration.transparencyAware = isTransparency;
    }
  }
  configureTransparencyTarget() {
    if (this.configuration.transparencyAware) {
      this.transparencyRenderTargetDWFalse = new WebGLRenderTarget(this.width, this.height, {
        minFilter: LinearFilter,
        magFilter: NearestFilter,
        type: HalfFloatType,
        format: RGBAFormat
      });
      this.transparencyRenderTargetDWTrue = new WebGLRenderTarget(this.width, this.height, {
        minFilter: LinearFilter,
        magFilter: NearestFilter,
        type: HalfFloatType,
        format: RGBAFormat
      });
      this.transparencyRenderTargetDWTrue.depthTexture = new DepthTexture(this.width, this.height, UnsignedIntType);
      this.depthCopyPass = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial({
        uniforms: {
          depthTexture: {
            value: this.beautyRenderTarget.depthTexture
          }
        },
        vertexShader: (
          /* glsl */
          `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1);
            }`
        ),
        fragmentShader: (
          /* glsl */
          `
            uniform sampler2D depthTexture;
            varying vec2 vUv;
            void main() {
               gl_FragDepth = texture2D(depthTexture, vUv).r + 0.00001;
               gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            }
            `
        )
      }));
    } else {
      if (this.transparencyRenderTargetDWFalse) {
        this.transparencyRenderTargetDWFalse.dispose();
        this.transparencyRenderTargetDWFalse = null;
      }
      if (this.transparencyRenderTargetDWTrue) {
        this.transparencyRenderTargetDWTrue.dispose();
        this.transparencyRenderTargetDWTrue = null;
      }
      if (this.depthCopyPass) {
        this.depthCopyPass.dispose();
        this.depthCopyPass = null;
      }
    }
  }
  renderTransparency(renderer) {
    const oldBackground = this.scene.background;
    const oldClearColor = renderer.getClearColor(new Color());
    const oldClearAlpha = renderer.getClearAlpha();
    const oldVisibility = /* @__PURE__ */ new Map();
    const oldAutoClearDepth = renderer.autoClearDepth;
    this.scene.traverse((obj) => {
      oldVisibility.set(obj, obj.visible);
    });
    this.scene.background = null;
    renderer.autoClearDepth = false;
    renderer.setClearColor(new Color(0, 0, 0), 0);
    this.depthCopyPass.material.uniforms.depthTexture.value = this.beautyRenderTarget.depthTexture;
    renderer.setRenderTarget(this.transparencyRenderTargetDWFalse);
    this.scene.traverse((obj) => {
      if (obj.material)
        obj.visible = oldVisibility.get(obj) && obj.material.transparent && !obj.material.depthWrite && !obj.userData.treatAsOpaque;
    });
    renderer.clear(true, true, true);
    this.depthCopyPass.render(renderer);
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(this.transparencyRenderTargetDWTrue);
    this.scene.traverse((obj) => {
      if (obj.material)
        obj.visible = oldVisibility.get(obj) && obj.material.transparent && obj.material.depthWrite && !obj.userData.treatAsOpaque;
    });
    renderer.clear(true, true, true);
    this.depthCopyPass.render(renderer);
    renderer.render(this.scene, this.camera);
    this.scene.traverse((obj) => {
      obj.visible = oldVisibility.get(obj);
    });
    renderer.setClearColor(oldClearColor, oldClearAlpha);
    this.scene.background = oldBackground;
    renderer.autoClearDepth = oldAutoClearDepth;
  }
  configureSampleDependentPasses() {
    this.firstFrame();
    this.configureAOPass(this.configuration.logarithmicDepthBuffer);
    this.configureDenoisePass(this.configuration.logarithmicDepthBuffer);
  }
  configureAOPass(logarithmicDepthBuffer = false) {
    this.firstFrame();
    this.samples = this.generateHemisphereSamples(this.configuration.aoSamples);
    const e = {
      ...(0, $1ed45968c1160c3c$export$c9b263b9a17dffd7)
    };
    e.fragmentShader = e.fragmentShader.replace("16", this.configuration.aoSamples).replace("16.0", this.configuration.aoSamples + ".0");
    if (logarithmicDepthBuffer)
      e.fragmentShader = "#define LOGDEPTH\n" + e.fragmentShader;
    if (this.configuration.halfRes)
      e.fragmentShader = "#define HALFRES\n" + e.fragmentShader;
    if (this.effectShaderQuad) {
      this.effectShaderQuad.material.dispose();
      this.effectShaderQuad.material = new ShaderMaterial(e);
    } else
      this.effectShaderQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(e));
  }
  configureDenoisePass(logarithmicDepthBuffer = false) {
    this.firstFrame();
    this.samplesDenoise = this.generateDenoiseSamples(this.configuration.denoiseSamples, 11);
    const p2 = {
      ...(0, $e52378cd0f5a973d$export$57856b59f317262e)
    };
    p2.fragmentShader = p2.fragmentShader.replace("16", this.configuration.denoiseSamples);
    if (logarithmicDepthBuffer)
      p2.fragmentShader = "#define LOGDEPTH\n" + p2.fragmentShader;
    if (this.poissonBlurQuad) {
      this.poissonBlurQuad.material.dispose();
      this.poissonBlurQuad.material = new ShaderMaterial(p2);
    } else
      this.poissonBlurQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(p2));
  }
  configureEffectCompositer(logarithmicDepthBuffer = false) {
    this.firstFrame();
    const e = {
      ...(0, $12b21d24d1192a04$export$a815acccbd2c9a49)
    };
    if (logarithmicDepthBuffer)
      e.fragmentShader = "#define LOGDEPTH\n" + e.fragmentShader;
    if (this.configuration.halfRes && this.configuration.depthAwareUpsampling)
      e.fragmentShader = "#define HALFRES\n" + e.fragmentShader;
    if (this.effectCompositerQuad) {
      this.effectCompositerQuad.material.dispose();
      this.effectCompositerQuad.material = new ShaderMaterial(e);
    } else
      this.effectCompositerQuad = new (0, $e4ca8dcb0218f846$export$dcd670d73db751f5)(new ShaderMaterial(e));
  }
  /**
       * 
       * @param {Number} n 
       * @returns {THREE.Vector3[]}
       */
  generateHemisphereSamples(n2) {
    const points = [];
    for (let k = 0; k < n2; k++) {
      const theta = 2.399963 * k;
      let r = Math.sqrt(k + 0.5) / Math.sqrt(n2);
      const x = r * Math.cos(theta);
      const y = r * Math.sin(theta);
      const z = Math.sqrt(1 - (x * x + y * y));
      points.push(new Vector3(x, y, z));
    }
    return points;
  }
  /**
       * 
       * @param {number} numSamples 
       * @param {number} numRings 
       * @returns {THREE.Vector2[]}
       */
  generateDenoiseSamples(numSamples, numRings) {
    const angleStep = 2 * Math.PI * numRings / numSamples;
    const invNumSamples = 1 / numSamples;
    const radiusStep = invNumSamples;
    const samples = [];
    let radius = invNumSamples;
    let angle = 0;
    for (let i = 0; i < numSamples; i++) {
      samples.push(new Vector2(Math.cos(angle), Math.sin(angle)).multiplyScalar(Math.pow(radius, 0.75)));
      radius += radiusStep;
      angle += angleStep;
    }
    return samples;
  }
  setSize(width, height) {
    this.firstFrame();
    this.width = width;
    this.height = height;
    const c3 = this.configuration.halfRes ? 0.5 : 1;
    this.beautyRenderTarget.setSize(width, height);
    this.writeTargetInternal.setSize(width * c3, height * c3);
    this.readTargetInternal.setSize(width * c3, height * c3);
    this.accumulationRenderTarget.setSize(width * c3, height * c3);
    if (this.configuration.halfRes)
      this.depthDownsampleTarget.setSize(width * c3, height * c3);
    if (this.configuration.transparencyAware) {
      this.transparencyRenderTargetDWFalse.setSize(width, height);
      this.transparencyRenderTargetDWTrue.setSize(width, height);
    }
  }
  firstFrame() {
    this.needsFrame = true;
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (renderer.capabilities.logarithmicDepthBuffer !== this.configuration.logarithmicDepthBuffer) {
      this.configuration.logarithmicDepthBuffer = renderer.capabilities.logarithmicDepthBuffer;
      this.configureAOPass(this.configuration.logarithmicDepthBuffer);
      this.configureDenoisePass(this.configuration.logarithmicDepthBuffer);
      this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer);
    }
    this.detectTransparency();
    this.camera.updateMatrixWorld();
    if (this.lastViewMatrix.equals(this.camera.matrixWorldInverse) && this.lastProjectionMatrix.equals(this.camera.projectionMatrix) && this.configuration.accumulate && !this.needsFrame)
      this.frame++;
    else {
      renderer.setRenderTarget(this.accumulationRenderTarget);
      renderer.clear(true, true, true);
      this.frame = 0;
      this.needsFrame = false;
    }
    this.lastViewMatrix.copy(this.camera.matrixWorldInverse);
    this.lastProjectionMatrix.copy(this.camera.projectionMatrix);
    let gl;
    let ext;
    let timerQuery;
    if (this.debugMode) {
      gl = renderer.getContext();
      ext = gl.getExtension("EXT_disjoint_timer_query_webgl2");
      if (ext === null) {
        console.error("EXT_disjoint_timer_query_webgl2 not available, disabling debug mode.");
        this.debugMode = false;
      }
    }
    if (this.configuration.autoRenderBeauty) {
      renderer.setRenderTarget(this.beautyRenderTarget);
      renderer.render(this.scene, this.camera);
      if (this.configuration.transparencyAware)
        this.renderTransparency(renderer);
    }
    if (this.debugMode) {
      timerQuery = gl.createQuery();
      gl.beginQuery(ext.TIME_ELAPSED_EXT, timerQuery);
    }
    const xrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    this._r.set(this.width, this.height);
    let trueRadius = this.configuration.aoRadius;
    if (this.configuration.halfRes && this.configuration.screenSpaceRadius)
      trueRadius *= 0.5;
    if (this.frame < 1024 / this.configuration.aoSamples) {
      if (this.configuration.halfRes) {
        renderer.setRenderTarget(this.depthDownsampleTarget);
        this.depthDownsampleQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture;
        this.depthDownsampleQuad.material.uniforms.resolution.value = this._r;
        this.depthDownsampleQuad.material.uniforms["near"].value = this.camera.near;
        this.depthDownsampleQuad.material.uniforms["far"].value = this.camera.far;
        this.depthDownsampleQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
        this.depthDownsampleQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
        this.depthDownsampleQuad.material.uniforms["logDepth"].value = this.configuration.logarithmicDepthBuffer;
        this.depthDownsampleQuad.render(renderer);
      }
      this.effectShaderQuad.material.uniforms["sceneDiffuse"].value = this.beautyRenderTarget.texture;
      this.effectShaderQuad.material.uniforms["sceneDepth"].value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[0] : this.beautyRenderTarget.depthTexture;
      this.effectShaderQuad.material.uniforms["sceneNormal"].value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[1] : null;
      this.effectShaderQuad.material.uniforms["projMat"].value = this.camera.projectionMatrix;
      this.effectShaderQuad.material.uniforms["viewMat"].value = this.camera.matrixWorldInverse;
      this.effectShaderQuad.material.uniforms["projViewMat"].value = this.camera.projectionMatrix.clone().multiply(this.camera.matrixWorldInverse.clone());
      this.effectShaderQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
      this.effectShaderQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
      this.effectShaderQuad.material.uniforms["cameraPos"].value = this.camera.getWorldPosition(new Vector3());
      this.effectShaderQuad.material.uniforms["resolution"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;
      this.effectShaderQuad.material.uniforms["time"].value = performance.now() / 1e3;
      this.effectShaderQuad.material.uniforms["samples"].value = this.samples;
      this.effectShaderQuad.material.uniforms["bluenoise"].value = this.bluenoise;
      this.effectShaderQuad.material.uniforms["radius"].value = trueRadius;
      this.effectShaderQuad.material.uniforms["distanceFalloff"].value = this.configuration.distanceFalloff;
      this.effectShaderQuad.material.uniforms["near"].value = this.camera.near;
      this.effectShaderQuad.material.uniforms["far"].value = this.camera.far;
      this.effectShaderQuad.material.uniforms["logDepth"].value = renderer.capabilities.logarithmicDepthBuffer;
      this.effectShaderQuad.material.uniforms["ortho"].value = this.camera.isOrthographicCamera;
      this.effectShaderQuad.material.uniforms["screenSpaceRadius"].value = this.configuration.screenSpaceRadius;
      this.effectShaderQuad.material.uniforms["frame"].value = this.frame;
      renderer.setRenderTarget(this.writeTargetInternal);
      this.effectShaderQuad.render(renderer);
      for (let i = 0; i < this.configuration.denoiseIterations; i++) {
        [this.writeTargetInternal, this.readTargetInternal] = [
          this.readTargetInternal,
          this.writeTargetInternal
        ];
        this.poissonBlurQuad.material.uniforms["tDiffuse"].value = this.readTargetInternal.texture;
        this.poissonBlurQuad.material.uniforms["sceneDepth"].value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[0] : this.beautyRenderTarget.depthTexture;
        this.poissonBlurQuad.material.uniforms["projMat"].value = this.camera.projectionMatrix;
        this.poissonBlurQuad.material.uniforms["viewMat"].value = this.camera.matrixWorldInverse;
        this.poissonBlurQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
        this.poissonBlurQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
        this.poissonBlurQuad.material.uniforms["cameraPos"].value = this.camera.getWorldPosition(new Vector3());
        this.poissonBlurQuad.material.uniforms["resolution"].value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r;
        this.poissonBlurQuad.material.uniforms["time"].value = performance.now() / 1e3;
        this.poissonBlurQuad.material.uniforms["blueNoise"].value = this.bluenoise;
        this.poissonBlurQuad.material.uniforms["radius"].value = this.configuration.denoiseRadius * (this.configuration.halfRes ? 0.5 : 1);
        this.poissonBlurQuad.material.uniforms["worldRadius"].value = trueRadius;
        this.poissonBlurQuad.material.uniforms["distanceFalloff"].value = this.configuration.distanceFalloff;
        this.poissonBlurQuad.material.uniforms["index"].value = i;
        this.poissonBlurQuad.material.uniforms["poissonDisk"].value = this.samplesDenoise;
        this.poissonBlurQuad.material.uniforms["near"].value = this.camera.near;
        this.poissonBlurQuad.material.uniforms["far"].value = this.camera.far;
        this.poissonBlurQuad.material.uniforms["logDepth"].value = renderer.capabilities.logarithmicDepthBuffer;
        this.poissonBlurQuad.material.uniforms["screenSpaceRadius"].value = this.configuration.screenSpaceRadius;
        renderer.setRenderTarget(this.writeTargetInternal);
        this.poissonBlurQuad.render(renderer);
      }
      renderer.setRenderTarget(this.accumulationRenderTarget);
      const oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      this.accumulationQuad.material.uniforms["tDiffuse"].value = this.writeTargetInternal.texture;
      this.accumulationQuad.material.uniforms["frame"].value = this.frame;
      this.accumulationQuad.render(renderer);
      renderer.autoClear = oldAutoClear;
    }
    if (this.configuration.transparencyAware) {
      this.effectCompositerQuad.material.uniforms["transparencyDWFalse"].value = this.transparencyRenderTargetDWFalse.texture;
      this.effectCompositerQuad.material.uniforms["transparencyDWTrue"].value = this.transparencyRenderTargetDWTrue.texture;
      this.effectCompositerQuad.material.uniforms["transparencyDWTrueDepth"].value = this.transparencyRenderTargetDWTrue.depthTexture;
      this.effectCompositerQuad.material.uniforms["transparencyAware"].value = true;
    }
    this.effectCompositerQuad.material.uniforms["sceneDiffuse"].value = this.beautyRenderTarget.texture;
    this.effectCompositerQuad.material.uniforms["sceneDepth"].value = this.beautyRenderTarget.depthTexture;
    this.effectCompositerQuad.material.uniforms["near"].value = this.camera.near;
    this.effectCompositerQuad.material.uniforms["far"].value = this.camera.far;
    this.effectCompositerQuad.material.uniforms["projectionMatrixInv"].value = this.camera.projectionMatrixInverse;
    this.effectCompositerQuad.material.uniforms["viewMatrixInv"].value = this.camera.matrixWorld;
    this.effectCompositerQuad.material.uniforms["logDepth"].value = renderer.capabilities.logarithmicDepthBuffer;
    this.effectCompositerQuad.material.uniforms["ortho"].value = this.camera.isOrthographicCamera;
    this.effectCompositerQuad.material.uniforms["downsampledDepth"].value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[0] : this.beautyRenderTarget.depthTexture;
    this.effectCompositerQuad.material.uniforms["resolution"].value = this._r;
    this.effectCompositerQuad.material.uniforms["blueNoise"].value = this.bluenoise;
    this.effectCompositerQuad.material.uniforms["intensity"].value = this.configuration.intensity;
    this.effectCompositerQuad.material.uniforms["renderMode"].value = this.configuration.renderMode;
    this.effectCompositerQuad.material.uniforms["screenSpaceRadius"].value = this.configuration.screenSpaceRadius;
    this.effectCompositerQuad.material.uniforms["radius"].value = trueRadius;
    this.effectCompositerQuad.material.uniforms["distanceFalloff"].value = this.configuration.distanceFalloff;
    this.effectCompositerQuad.material.uniforms["gammaCorrection"].value = this.configuration.gammaCorrection;
    this.effectCompositerQuad.material.uniforms["tDiffuse"].value = this.accumulationRenderTarget.texture;
    this.effectCompositerQuad.material.uniforms["color"].value = this._c.copy(this.configuration.color).convertSRGBToLinear();
    this.effectCompositerQuad.material.uniforms["colorMultiply"].value = this.configuration.colorMultiply;
    this.effectCompositerQuad.material.uniforms["cameraPos"].value = this.camera.getWorldPosition(new Vector3());
    this.effectCompositerQuad.material.uniforms["fog"].value = !!this.scene.fog;
    if (this.scene.fog) {
      if (this.scene.fog.isFog) {
        this.effectCompositerQuad.material.uniforms["fogExp"].value = false;
        this.effectCompositerQuad.material.uniforms["fogNear"].value = this.scene.fog.near;
        this.effectCompositerQuad.material.uniforms["fogFar"].value = this.scene.fog.far;
      } else if (this.scene.fog.isFogExp2) {
        this.effectCompositerQuad.material.uniforms["fogExp"].value = true;
        this.effectCompositerQuad.material.uniforms["fogDensity"].value = this.scene.fog.density;
      } else
        console.error(`Unsupported fog type ${this.scene.fog.constructor.name} in SSAOPass.`);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
    this.effectCompositerQuad.render(renderer);
    if (this.debugMode) {
      gl.endQuery(ext.TIME_ELAPSED_EXT);
      $05f6997e4b65da14$var$checkTimerQuery(timerQuery, gl, this);
    }
    renderer.xr.enabled = xrEnabled;
  }
  /**
       * Enables the debug mode of the AO, meaning the lastTime value will be updated.
       */
  enableDebugMode() {
    this.debugMode = true;
  }
  /**
       * Disables the debug mode of the AO, meaning the lastTime value will not be updated.
       */
  disableDebugMode() {
    this.debugMode = false;
  }
  /**
       * Sets the display mode of the AO
       * @param {"Combined" | "AO" | "No AO" | "Split" | "Split AO"} mode - The display mode. 
       */
  setDisplayMode(mode) {
    this.configuration.renderMode = [
      "Combined",
      "AO",
      "No AO",
      "Split",
      "Split AO"
    ].indexOf(mode);
  }
  /**
       * 
       * @param {"Performance" | "Low" | "Medium" | "High" | "Ultra"} mode 
       */
  setQualityMode(mode) {
    if (mode === "Performance") {
      this.configuration.aoSamples = 8;
      this.configuration.denoiseSamples = 4;
      this.configuration.denoiseRadius = 12;
    } else if (mode === "Low") {
      this.configuration.aoSamples = 16;
      this.configuration.denoiseSamples = 4;
      this.configuration.denoiseRadius = 12;
    } else if (mode === "Medium") {
      this.configuration.aoSamples = 16;
      this.configuration.denoiseSamples = 8;
      this.configuration.denoiseRadius = 12;
    } else if (mode === "High") {
      this.configuration.aoSamples = 64;
      this.configuration.denoiseSamples = 8;
      this.configuration.denoiseRadius = 6;
    } else if (mode === "Ultra") {
      this.configuration.aoSamples = 64;
      this.configuration.denoiseSamples = 16;
      this.configuration.denoiseRadius = 6;
    }
  }
};

// node_modules/three/examples/jsm/shaders/GammaCorrectionShader.js
var GammaCorrectionShader = {
  uniforms: {
    "tDiffuse": { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = LinearTosRGB( tex );

		}`
  )
};

// node_modules/openbim-components/navigation/OrthoPerspectiveCamera/src/projections.js
var ProjectionManager = class {
  get projection() {
    return this._currentProjection;
  }
  constructor(components, camera) {
    this.components = components;
    this._previousDistance = -1;
    this._camera = camera;
    const perspective = "Perspective";
    this._currentCamera = camera.get(perspective);
    this._currentProjection = perspective;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async setProjection(projection) {
    if (this.projection === projection)
      return;
    if (projection === "Orthographic") {
      this.setOrthoCamera();
    } else {
      await this.setPerspectiveCamera();
    }
    await this.updateActiveCamera();
  }
  setOrthoCamera() {
    if (this._camera.currentMode.id === "FirstPerson") {
      return;
    }
    this._previousDistance = this._camera.controls.distance;
    this._camera.controls.distance = 200;
    const { width, height } = this.getDims();
    this.setupOrthoCamera(height, width);
    this._currentCamera = this._camera.get("Orthographic");
    this._currentProjection = "Orthographic";
  }
  // This small delay is needed to hide weirdness during the transition
  async updateActiveCamera() {
    await new Promise((resolve) => {
      setTimeout(() => {
        this._camera.activeCamera = this._currentCamera;
        resolve();
      }, 50);
    });
  }
  getDims() {
    const lineOfSight = new Vector3();
    this._camera.get("Perspective").getWorldDirection(lineOfSight);
    const target = new Vector3();
    this._camera.controls.getTarget(target);
    const distance = target.clone().sub(this._camera.get("Perspective").position);
    const depth = distance.dot(lineOfSight);
    const dims = this.components.renderer.getSize();
    const aspect = dims.x / dims.y;
    const camera = this._camera.get("Perspective");
    const height = depth * 2 * Math.atan(camera.fov * (Math.PI / 180) / 2);
    const width = height * aspect;
    return { width, height };
  }
  setupOrthoCamera(height, width) {
    this._camera.controls.mouseButtons.wheel = CameraControls.ACTION.ZOOM;
    this._camera.controls.mouseButtons.middle = CameraControls.ACTION.ZOOM;
    const pCamera = this._camera.get("Perspective");
    const oCamera = this._camera.get("Orthographic");
    oCamera.zoom = 1;
    oCamera.left = width / -2;
    oCamera.right = width / 2;
    oCamera.top = height / 2;
    oCamera.bottom = height / -2;
    oCamera.updateProjectionMatrix();
    oCamera.position.copy(pCamera.position);
    oCamera.quaternion.copy(pCamera.quaternion);
    this._camera.controls.camera = oCamera;
  }
  async setPerspectiveCamera() {
    this._camera.controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    this._camera.controls.mouseButtons.middle = CameraControls.ACTION.DOLLY;
    const pCamera = this._camera.get("Perspective");
    const oCamera = this._camera.get("Orthographic");
    pCamera.position.copy(oCamera.position);
    pCamera.quaternion.copy(oCamera.quaternion);
    this._camera.controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    this._camera.controls.distance = this._previousDistance;
    await this._camera.controls.zoomTo(1);
    pCamera.updateProjectionMatrix();
    this._camera.controls.camera = pCamera;
    this._currentCamera = pCamera;
    this._currentProjection = "Perspective";
  }
};

// node_modules/openbim-components/navigation/OrthoPerspectiveCamera/src/orbit-mode.js
var OrbitMode = class {
  constructor(camera) {
    this.camera = camera;
    this.enabled = true;
    this.id = "Orbit";
    this.projectionChanged = new Event();
    this.activateOrbitControls();
  }
  /** {@link NavigationMode.toggle} */
  toggle(active) {
    this.enabled = active;
    if (active) {
      this.activateOrbitControls();
    }
  }
  activateOrbitControls() {
    const controls = this.camera.controls;
    controls.minDistance = 1;
    controls.maxDistance = 300;
    controls.truckSpeed = 2;
  }
};

// node_modules/openbim-components/navigation/OrthoPerspectiveCamera/src/first-person-mode.js
var FirstPersonMode = class {
  constructor(camera) {
    this.camera = camera;
    this.enabled = false;
    this.id = "FirstPerson";
    this.projectionChanged = new Event();
  }
  /** {@link NavigationMode.toggle} */
  toggle(active) {
    this.enabled = active;
    if (active) {
      const projection = this.camera.getProjection();
      if (projection !== "Perspective") {
        this.camera.setNavigationMode("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const controls = this.camera.controls;
    const cameraPosition = new Vector3();
    controls.camera.getWorldPosition(cameraPosition);
    const newTargetPosition = new Vector3();
    controls.distance--;
    controls.camera.getWorldPosition(newTargetPosition);
    controls.minDistance = 1;
    controls.maxDistance = 1;
    controls.distance = 1;
    controls.moveTo(newTargetPosition.x, newTargetPosition.y, newTargetPosition.z);
    controls.truckSpeed = 50;
    controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM_TRUCK;
  }
};

// node_modules/openbim-components/navigation/OrthoPerspectiveCamera/src/plan-mode.js
var PlanMode = class {
  constructor(camera) {
    this.camera = camera;
    this.enabled = false;
    this.id = "Plan";
    this.projectionChanged = new Event();
    this.mouseInitialized = false;
    this.defaultAzimuthSpeed = camera.controls.azimuthRotateSpeed;
    this.defaultPolarSpeed = camera.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.toggle} */
  toggle(active) {
    this.enabled = active;
    const controls = this.camera.controls;
    controls.azimuthRotateSpeed = active ? 0 : this.defaultAzimuthSpeed;
    controls.polarRotateSpeed = active ? 0 : this.defaultPolarSpeed;
    if (!this.mouseInitialized) {
      this.mouseAction1 = controls.touches.one;
      this.mouseAction2 = controls.touches.two;
      this.mouseInitialized = true;
    }
    if (active) {
      controls.mouseButtons.left = CameraControls.ACTION.TRUCK;
      controls.touches.one = CameraControls.ACTION.TOUCH_TRUCK;
      controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM;
    } else {
      controls.mouseButtons.left = CameraControls.ACTION.ROTATE;
      controls.touches.one = this.mouseAction1;
      controls.touches.two = this.mouseAction2;
    }
  }
};

// node_modules/openbim-components/navigation/OrthoPerspectiveCamera/index.js
var OrthoPerspectiveCamera = class extends SimpleCamera {
  constructor(components) {
    super(components);
    this.projectionChanged = new Event();
    this._userInputButtons = {};
    this._frustumSize = 50;
    this._navigationModes = /* @__PURE__ */ new Map();
    this.uiElement = new UIElement();
    this._orthoCamera = this.newOrthoCamera();
    this._navigationModes.set("Orbit", new OrbitMode(this));
    this._navigationModes.set("FirstPerson", new FirstPersonMode(this));
    this._navigationModes.set("Plan", new PlanMode(this));
    this.currentMode = this._navigationModes.get("Orbit");
    this.currentMode.toggle(true, { preventTargetAdjustment: true });
    this.toggleEvents(true);
    this._projectionManager = new ProjectionManager(components, this);
    if (components.ui.enabled) {
      this.setUI();
    }
    this.onAspectUpdated.add(() => this.setOrthoCameraAspect());
  }
  setUI() {
    const mainButton = new Button(this.components);
    mainButton.materialIcon = "video_camera_back";
    mainButton.tooltip = "Camera";
    const projection = new Button(this.components, {
      materialIconName: "camera",
      name: "Projection"
    });
    const perspective = new Button(this.components, { name: "Perspective" });
    perspective.active = true;
    perspective.onClick.add(() => this.setProjection("Perspective"));
    const orthographic = new Button(this.components, { name: "Orthographic" });
    orthographic.onClick.add(() => this.setProjection("Orthographic"));
    projection.addChild(perspective, orthographic);
    const navigation = new Button(this.components, {
      materialIconName: "open_with",
      name: "Navigation"
    });
    const orbit = new Button(this.components, { name: "Orbit Around" });
    orbit.onClick.add(() => this.setNavigationMode("Orbit"));
    const plan = new Button(this.components, { name: "Plan View" });
    plan.onClick.add(() => this.setNavigationMode("Plan"));
    const firstPerson = new Button(this.components, { name: "First person" });
    firstPerson.onClick.add(() => this.setNavigationMode("FirstPerson"));
    navigation.addChild(orbit, plan, firstPerson);
    mainButton.addChild(navigation, projection);
    this.projectionChanged.add((camera) => {
      if (camera instanceof PerspectiveCamera) {
        perspective.active = true;
        orthographic.active = false;
      } else {
        perspective.active = false;
        orthographic.active = true;
      }
    });
    this.uiElement.set({ main: mainButton });
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    await super.dispose();
    this.toggleEvents(false);
    this._orthoCamera.removeFromParent();
  }
  /**
   * Similar to {@link Component.get}, but with an optional argument
   * to specify which camera to get.
   *
   * @param projection - The camera corresponding to the
   * {@link CameraProjection} specified. If no projection is specified,
   * the active camera will be returned.
   */
  get(projection) {
    if (!projection) {
      return this.activeCamera;
    }
    return projection === "Orthographic" ? this._orthoCamera : this._perspectiveCamera;
  }
  /** Returns the current {@link CameraProjection}. */
  getProjection() {
    return this._projectionManager.projection;
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and Viceversa.
   */
  async toggleProjection() {
    const projection = this.getProjection();
    const newProjection = projection === "Perspective" ? "Orthographic" : "Perspective";
    await this.setProjection(newProjection);
  }
  /**
   * Sets the current {@link CameraProjection}. This triggers the event
   * {@link projectionChanged}.
   *
   * @param projection - The new {@link CameraProjection} to set.
   */
  async setProjection(projection) {
    await this._projectionManager.setProjection(projection);
    await this.projectionChanged.trigger(this.activeCamera);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  toggleUserInput(active) {
    if (active) {
      this.enableUserInput();
    } else {
      this.disableUserInput();
    }
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  setNavigationMode(mode) {
    if (this.currentMode.id === mode)
      return;
    this.currentMode.toggle(false);
    if (!this._navigationModes.has(mode)) {
      throw new Error("The specified mode does not exist!");
    }
    this.currentMode = this._navigationModes.get(mode);
    this.currentMode.toggle(true);
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(meshes = this.components.meshes, offset2 = 1.5) {
    if (!this.enabled)
      return;
    const maxNum = Number.MAX_VALUE;
    const minNum = Number.MIN_VALUE;
    const min2 = new Vector3(maxNum, maxNum, maxNum);
    const max2 = new Vector3(minNum, minNum, minNum);
    for (const mesh of meshes) {
      const box2 = new Box3().setFromObject(mesh);
      if (box2.min.x < min2.x)
        min2.x = box2.min.x;
      if (box2.min.y < min2.y)
        min2.y = box2.min.y;
      if (box2.min.z < min2.z)
        min2.z = box2.min.z;
      if (box2.max.x > max2.x)
        max2.x = box2.max.x;
      if (box2.max.y > max2.y)
        max2.y = box2.max.y;
      if (box2.max.z > max2.z)
        max2.z = box2.max.z;
    }
    const box = new Box3(min2, max2);
    const sceneSize = new Vector3();
    box.getSize(sceneSize);
    const sceneCenter = new Vector3();
    box.getCenter(sceneCenter);
    const radius = Math.max(sceneSize.x, sceneSize.y, sceneSize.z) * offset2;
    const sphere = new Sphere(sceneCenter, radius);
    await this.controls.fitToSphere(sphere, true);
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left;
    this._userInputButtons.right = this.controls.mouseButtons.right;
    this._userInputButtons.middle = this.controls.mouseButtons.middle;
    this._userInputButtons.wheel = this.controls.mouseButtons.wheel;
    this.controls.mouseButtons.left = 0;
    this.controls.mouseButtons.right = 0;
    this.controls.mouseButtons.middle = 0;
    this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    if (Object.keys(this._userInputButtons).length === 0)
      return;
    this.controls.mouseButtons.left = this._userInputButtons.left;
    this.controls.mouseButtons.right = this._userInputButtons.right;
    this.controls.mouseButtons.middle = this._userInputButtons.middle;
    this.controls.mouseButtons.wheel = this._userInputButtons.wheel;
  }
  newOrthoCamera() {
    const dims = this.components.renderer.getSize();
    const aspect = dims.x / dims.y;
    return new OrthographicCamera(this._frustumSize * aspect / -2, this._frustumSize * aspect / 2, this._frustumSize / 2, this._frustumSize / -2, 0.1, 1e3);
  }
  setOrthoCameraAspect() {
    const size = this.components.renderer.getSize();
    const aspect = size.x / size.y;
    this._orthoCamera.left = -this._frustumSize * aspect / 2;
    this._orthoCamera.right = this._frustumSize * aspect / 2;
    this._orthoCamera.top = this._frustumSize / 2;
    this._orthoCamera.bottom = -this._frustumSize / 2;
    this._orthoCamera.updateProjectionMatrix();
  }
  toggleEvents(active) {
    const modes = Object.values(this._navigationModes);
    for (const mode of modes) {
      if (active) {
        mode.projectionChanged.on(this.projectionChanged.trigger);
      } else {
        mode.projectionChanged.reset();
      }
    }
  }
};

// node_modules/openbim-components/navigation/PostproductionRenderer/src/plane-distance-shader.js
function getPlaneDistanceMaterial() {
  return new ShaderMaterial({
    side: 2,
    clipping: true,
    uniforms: {},
    vertexShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
    
       vec4 absPosition = vec4(position, 1.0);
       vec3 trueNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          trueNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       trueNormal = (normalize(modelMatrix * vec4(trueNormal, 0.))).xyz;
       
       vec3 planePosition = absPosition.xyz / 40.;
       float d = abs(dot(trueNormal, planePosition));
       vColor = vec4(abs(trueNormal), d);
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      gl_FragColor = vColor;
    }
    `
  });
}

// node_modules/openbim-components/navigation/PostproductionRenderer/src/projected-normal-shader.js
function getProjectedNormalMaterial() {
  return new ShaderMaterial({
    side: 2,
    clipping: true,
    uniforms: {},
    vertexShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
       
       vec4 absPosition = vec4(position, 1.0);
       vNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          vNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       vNormal = (normalize(modelMatrix * vec4(vNormal, 0.))).xyz;
       
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       vCameraPosition = cameraPosition;
       vPosition = absPosition.xyz;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      vec3 cameraPixelVec = normalize(vCameraPosition - vPosition);
      float difference = abs(dot(vNormal, cameraPixelVec));
      
      // This achieves a double gloss effect: when the surface is perpendicular and when it's parallel
      difference = abs((difference * 2.) - 1.);
      
      gl_FragColor = vec4(difference, difference, difference, 1.);
    }
    `
  });
}

// node_modules/openbim-components/navigation/PostproductionRenderer/src/custom-effects-pass.js
var CustomEffectsPass = class extends Pass {
  get lineColor() {
    return this._lineColor;
  }
  set lineColor(lineColor) {
    this._lineColor = lineColor;
    const material = this.fsQuad.material;
    material.uniforms.lineColor.value.set(lineColor);
  }
  get tolerance() {
    return this._tolerance;
  }
  set tolerance(value) {
    this._tolerance = value;
    const material = this.fsQuad.material;
    material.uniforms.tolerance.value = value;
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(value) {
    this._opacity = value;
    const material = this.fsQuad.material;
    material.uniforms.opacity.value = value;
  }
  get glossEnabled() {
    return this._glossEnabled;
  }
  set glossEnabled(active) {
    if (active === this._glossEnabled)
      return;
    this._glossEnabled = active;
    const material = this.fsQuad.material;
    material.uniforms.glossEnabled.value = active ? 1 : 0;
  }
  get glossExponent() {
    return this._glossExponent;
  }
  set glossExponent(value) {
    this._glossExponent = value;
    const material = this.fsQuad.material;
    material.uniforms.glossExponent.value = value;
  }
  get minGloss() {
    return this._minGloss;
  }
  set minGloss(value) {
    this._minGloss = value;
    const material = this.fsQuad.material;
    material.uniforms.minGloss.value = value;
  }
  get maxGloss() {
    new MeshBasicMaterial().color.convertLinearToSRGB();
    return this._maxGloss;
  }
  set maxGloss(value) {
    this._maxGloss = value;
    const material = this.fsQuad.material;
    material.uniforms.maxGloss.value = value;
  }
  get outlineEnabled() {
    return this._outlineEnabled;
  }
  set outlineEnabled(active) {
    if (active === this._outlineEnabled)
      return;
    this._outlineEnabled = active;
    const material = this.fsQuad.material;
    material.uniforms.outlineEnabled.value = active ? 1 : 0;
  }
  constructor(resolution, components) {
    super();
    this.excludedMeshes = [];
    this.outlinedMeshes = {};
    this._outlineScene = new Scene();
    this._outlineEnabled = false;
    this._lineColor = 10066329;
    this._opacity = 0.4;
    this._tolerance = 3;
    this._glossEnabled = true;
    this._glossExponent = 1.9;
    this._minGloss = -0.1;
    this._maxGloss = 0.1;
    this._outlinesNeedsUpdate = false;
    this.components = components;
    this.renderScene = components.scene.get();
    this.renderCamera = components.camera.get();
    this.resolution = new Vector2(resolution.x, resolution.y);
    this.fsQuad = new FullScreenQuad();
    this.fsQuad.material = this.createOutlinePostProcessMaterial();
    this.planeBuffer = this.newRenderTarget();
    this.glossBuffer = this.newRenderTarget();
    this.outlineBuffer = this.newRenderTarget();
    const normalMaterial = getPlaneDistanceMaterial();
    normalMaterial.clippingPlanes = components.renderer.clippingPlanes;
    this.normalOverrideMaterial = normalMaterial;
    const glossMaterial = getProjectedNormalMaterial();
    glossMaterial.clippingPlanes = components.renderer.clippingPlanes;
    this.glossOverrideMaterial = glossMaterial;
  }
  async dispose() {
    this.planeBuffer.dispose();
    this.glossBuffer.dispose();
    this.outlineBuffer.dispose();
    this.normalOverrideMaterial.dispose();
    this.glossOverrideMaterial.dispose();
    this.fsQuad.dispose();
    this.excludedMeshes = [];
    this._outlineScene.children = [];
    const disposer = await this.components.tools.get(Disposer);
    for (const name in this.outlinedMeshes) {
      const style = this.outlinedMeshes[name];
      for (const mesh of style.meshes) {
        disposer.destroy(mesh, true, true);
      }
      style.material.dispose();
    }
  }
  setSize(width, height) {
    this.planeBuffer.setSize(width, height);
    this.glossBuffer.setSize(width, height);
    this.outlineBuffer.setSize(width, height);
    this.resolution.set(width, height);
    const material = this.fsQuad.material;
    material.uniforms.screenSize.value.set(this.resolution.x, this.resolution.y, 1 / this.resolution.x, 1 / this.resolution.y);
  }
  render(renderer, writeBuffer, readBuffer) {
    const depthBufferValue = writeBuffer.depthBuffer;
    writeBuffer.depthBuffer = false;
    const previousOverrideMaterial = this.renderScene.overrideMaterial;
    const previousBackground = this.renderScene.background;
    this.renderScene.background = null;
    for (const mesh of this.excludedMeshes) {
      mesh.visible = false;
    }
    renderer.setRenderTarget(this.planeBuffer);
    this.renderScene.overrideMaterial = this.normalOverrideMaterial;
    renderer.render(this.renderScene, this.renderCamera);
    if (this._glossEnabled) {
      renderer.setRenderTarget(this.glossBuffer);
      this.renderScene.overrideMaterial = this.glossOverrideMaterial;
      renderer.render(this.renderScene, this.renderCamera);
    }
    this.renderScene.overrideMaterial = previousOverrideMaterial;
    if (this._outlineEnabled) {
      let outlinedMeshesFound = false;
      for (const name in this.outlinedMeshes) {
        const style = this.outlinedMeshes[name];
        for (const mesh of style.meshes) {
          outlinedMeshesFound = true;
          mesh.userData.materialPreOutline = mesh.material;
          mesh.material = style.material;
          mesh.userData.groupsPreOutline = mesh.geometry.groups;
          mesh.geometry.groups = [];
          if (mesh instanceof InstancedMesh) {
            mesh.userData.colorPreOutline = mesh.instanceColor;
            mesh.instanceColor = null;
          }
          mesh.userData.parentPreOutline = mesh.parent;
          this._outlineScene.add(mesh);
        }
      }
      if (outlinedMeshesFound || this._outlinesNeedsUpdate) {
        renderer.setRenderTarget(this.outlineBuffer);
        renderer.render(this._outlineScene, this.renderCamera);
        this._outlinesNeedsUpdate = outlinedMeshesFound;
      }
      for (const name in this.outlinedMeshes) {
        const style = this.outlinedMeshes[name];
        for (const mesh of style.meshes) {
          mesh.material = mesh.userData.materialPreOutline;
          mesh.geometry.groups = mesh.userData.groupsPreOutline;
          if (mesh instanceof InstancedMesh) {
            mesh.instanceColor = mesh.userData.colorPreOutline;
          }
          if (mesh.userData.parentPreOutline) {
            mesh.userData.parentPreOutline.add(mesh);
          }
          mesh.userData.materialPreOutline = void 0;
          mesh.userData.groupsPreOutline = void 0;
          mesh.userData.colorPreOutline = void 0;
          mesh.userData.parentPreOutline = void 0;
        }
      }
    }
    for (const mesh of this.excludedMeshes) {
      mesh.visible = true;
    }
    this.renderScene.background = previousBackground;
    const material = this.fsQuad.material;
    material.uniforms.planeBuffer.value = this.planeBuffer.texture;
    material.uniforms.glossBuffer.value = this.glossBuffer.texture;
    material.uniforms.outlineBuffer.value = this.outlineBuffer.texture;
    material.uniforms.sceneColorBuffer.value = readBuffer.texture;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      this.fsQuad.render(renderer);
    }
    writeBuffer.depthBuffer = depthBufferValue;
  }
  get vertexShader() {
    return `
	  varying vec2 vUv;
	  void main() {
	  	vUv = uv;
	  	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	  }
	`;
  }
  get fragmentShader() {
    return `
	  uniform sampler2D sceneColorBuffer;
	  uniform sampler2D planeBuffer;
	  uniform sampler2D glossBuffer;
	  uniform sampler2D outlineBuffer;
	  uniform vec4 screenSize;
	  uniform vec3 lineColor;
	  
	  uniform float outlineEnabled;
	  
      uniform int width;
	  uniform float opacity;
      uniform float tolerance;
      uniform float glossExponent;
      uniform float minGloss;
      uniform float maxGloss;
      uniform float glossEnabled;

	  varying vec2 vUv;

	  vec4 getValue(sampler2D buffer, int x, int y) {
	  	return texture2D(buffer, vUv + screenSize.zw * vec2(x, y));
	  }

      float normalDiff(vec3 normal1, vec3 normal2) {
        return ((dot(normal1, normal2) - 1.) * -1.) / 2.;
      }

      // Returns 0 if it's background, 1 if it's not
      float getIsBackground(vec3 normal) {
        float background = 1.0;
        background *= step(normal.x, 0.);
        background *= step(normal.y, 0.);
        background *= step(normal.z, 0.);
        background = (background - 1.) * -1.;
        return background;
      }

	  void main() {
	  
	    vec4 sceneColor = getValue(sceneColorBuffer, 0, 0);
	    vec3 normSceneColor = normalize(sceneColor.rgb);
  
        vec4 plane = getValue(planeBuffer, 0, 0);
	    vec3 normal = plane.xyz;
        float distance = plane.w;
  
        vec3 normalTop = getValue(planeBuffer, 0, width).rgb;
        vec3 normalBottom = getValue(planeBuffer, 0, -width).rgb;
        vec3 normalRight = getValue(planeBuffer, width, 0).rgb;
        vec3 normalLeft = getValue(planeBuffer, -width, 0).rgb;
        vec3 normalTopRight = getValue(planeBuffer, width, width).rgb;
        vec3 normalTopLeft = getValue(planeBuffer, -width, width).rgb;
        vec3 normalBottomRight = getValue(planeBuffer, width, -width).rgb;
        vec3 normalBottomLeft = getValue(planeBuffer, -width, -width).rgb;
  
        float distanceTop = getValue(planeBuffer, 0, width).a;
        float distanceBottom = getValue(planeBuffer, 0, -width).a;
        float distanceRight = getValue(planeBuffer, width, 0).a;
        float distanceLeft = getValue(planeBuffer, -width, 0).a;
        float distanceTopRight = getValue(planeBuffer, width, width).a;
        float distanceTopLeft = getValue(planeBuffer, -width, width).a;
        float distanceBottomRight = getValue(planeBuffer, width, -width).a;
        float distanceBottomLeft = getValue(planeBuffer, -width, -width).a;
        
        vec3 sceneColorTop = normalize(getValue(sceneColorBuffer, 1, 0).rgb);
        vec3 sceneColorBottom = normalize(getValue(sceneColorBuffer, -1, 0).rgb);
        vec3 sceneColorLeft = normalize(getValue(sceneColorBuffer, 0, -1).rgb);
        vec3 sceneColorRight = normalize(getValue(sceneColorBuffer, 0, 1).rgb);
        vec3 sceneColorTopRight = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomRight = normalize(getValue(sceneColorBuffer, -1, 1).rgb);
        vec3 sceneColorTopLeft = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomLeft = normalize(getValue(sceneColorBuffer, -1, 1).rgb);

        // Checks if the planes of this texel and the neighbour texels are different

        float planeDiff = 0.0;

        planeDiff += step(0.001, normalDiff(normal, normalTop));
        planeDiff += step(0.001, normalDiff(normal, normalBottom));
        planeDiff += step(0.001, normalDiff(normal, normalLeft));
        planeDiff += step(0.001, normalDiff(normal, normalRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopLeft));
        planeDiff += step(0.001, normalDiff(normal, normalBottomRight));
        planeDiff += step(0.001, normalDiff(normal, normalBottomLeft));
        
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTop));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottom));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorRight));
       	planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomLeft));

        planeDiff += step(0.001, abs(distance - distanceTop));
        planeDiff += step(0.001, abs(distance - distanceBottom));
        planeDiff += step(0.001, abs(distance - distanceLeft));
        planeDiff += step(0.001, abs(distance - distanceRight));
        planeDiff += step(0.001, abs(distance - distanceTopRight));
        planeDiff += step(0.001, abs(distance - distanceTopLeft));
        planeDiff += step(0.001, abs(distance - distanceBottomRight));
        planeDiff += step(0.001, abs(distance - distanceBottomLeft));

        // Add extra background outline

        int width2 = width + 1;
        vec3 normalTop2 = getValue(planeBuffer, 0, width2).rgb;
        vec3 normalBottom2 = getValue(planeBuffer, 0, -width2).rgb;
        vec3 normalRight2 = getValue(planeBuffer, width2, 0).rgb;
        vec3 normalLeft2 = getValue(planeBuffer, -width2, 0).rgb;
        vec3 normalTopRight2 = getValue(planeBuffer, width2, width2).rgb;
        vec3 normalTopLeft2 = getValue(planeBuffer, -width2, width2).rgb;
        vec3 normalBottomRight2 = getValue(planeBuffer, width2, -width2).rgb;
        vec3 normalBottomLeft2 = getValue(planeBuffer, -width2, -width2).rgb;

        planeDiff += -(getIsBackground(normalTop2) - 1.);
        planeDiff += -(getIsBackground(normalBottom2) - 1.);
        planeDiff += -(getIsBackground(normalRight2) - 1.);
        planeDiff += -(getIsBackground(normalLeft2) - 1.);
        planeDiff += -(getIsBackground(normalTopRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomLeft2) - 1.);

        // Tolerance sets the minimum amount of differences to consider
        // this texel an edge

        float line = step(tolerance, planeDiff);

        // Exclude background and apply opacity

        float background = getIsBackground(normal);
        line *= background;
        line *= opacity;
        
        // Add gloss
        
        vec3 gloss = getValue(glossBuffer, 0, 0).xyz;
        float diffGloss = abs(maxGloss - minGloss);
        vec3 glossExpVector = vec3(glossExponent,glossExponent,glossExponent);
        gloss = min(pow(gloss, glossExpVector), vec3(1.,1.,1.));
        gloss *= diffGloss;
        gloss += minGloss;
        vec4 glossedColor = sceneColor + vec4(gloss, 1.) * glossEnabled;
        
        vec4 corrected = mix(sceneColor, glossedColor, background);
        
        // Draw lines
        
        corrected = mix(corrected, vec4(lineColor, 1.), line);
        
        // Add outline
        
        vec4 outlinePreview =getValue(outlineBuffer, 0, 0);
        float outlineColorCorrection = 1. / max(0.2, outlinePreview.a);
        vec3 outlineColor = outlinePreview.rgb * outlineColorCorrection;
        
        // thickness between 10 and 2, opacity between 1 and 0.2
	    int outlineThickness = int(outlinePreview.a * 10.);
	    
	    float outlineDiff = 0.;
        
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, -outlineThickness).a);
        
        float outLine = step(4., outlineDiff) * step(outlineDiff, 12.) * outlineEnabled;
        corrected = mix(corrected, vec4(outlineColor, 1.), outLine);
        
        gl_FragColor = corrected;
	}
			`;
  }
  createOutlinePostProcessMaterial() {
    return new ShaderMaterial({
      uniforms: {
        opacity: { value: this._opacity },
        debugVisualize: { value: 0 },
        sceneColorBuffer: { value: null },
        tolerance: { value: this._tolerance },
        planeBuffer: { value: null },
        glossBuffer: { value: null },
        outlineBuffer: { value: null },
        glossEnabled: { value: 1 },
        minGloss: { value: this._minGloss },
        maxGloss: { value: this._maxGloss },
        outlineEnabled: { value: 0 },
        glossExponent: { value: this._glossExponent },
        width: { value: 1 },
        lineColor: { value: new Color(this._lineColor) },
        screenSize: {
          value: new Vector4(this.resolution.x, this.resolution.y, 1 / this.resolution.x, 1 / this.resolution.y)
        }
      },
      vertexShader: this.vertexShader,
      fragmentShader: this.fragmentShader
    });
  }
  newRenderTarget() {
    const planeBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);
    planeBuffer.texture.colorSpace = "srgb-linear";
    planeBuffer.texture.format = RGBAFormat;
    planeBuffer.texture.type = HalfFloatType;
    planeBuffer.texture.minFilter = NearestFilter;
    planeBuffer.texture.magFilter = NearestFilter;
    planeBuffer.texture.generateMipmaps = false;
    planeBuffer.stencilBuffer = false;
    return planeBuffer;
  }
};

// node_modules/openbim-components/navigation/PostproductionRenderer/src/postproduction.js
var Postproduction = class {
  get basePass() {
    if (!this._basePass) {
      throw new Error("Custom effects not initialized!");
    }
    return this._basePass;
  }
  get gammaPass() {
    if (!this._gammaPass) {
      throw new Error("Custom effects not initialized!");
    }
    return this._gammaPass;
  }
  get customEffects() {
    if (!this._customEffects) {
      throw new Error("Custom effects not initialized!");
    }
    return this._customEffects;
  }
  get n8ao() {
    if (!this._n8ao) {
      throw new Error("Custom effects not initialized!");
    }
    return this._n8ao;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(active) {
    if (!this._initialized) {
      this.initialize();
    }
    this._enabled = active;
  }
  get settings() {
    return { ...this._settings };
  }
  constructor(components, renderer) {
    this.components = components;
    this.renderer = renderer;
    this.excludedItems = /* @__PURE__ */ new Set();
    this._enabled = false;
    this._initialized = false;
    this._settings = {
      gamma: true,
      custom: true,
      ao: false
    };
    this._renderTarget = new WebGLRenderTarget(window.innerWidth, window.innerHeight);
    this._renderTarget.texture.colorSpace = "srgb-linear";
    this.composer = new EffectComposer(this.renderer, this._renderTarget);
    this.composer.setSize(window.innerWidth, window.innerHeight);
  }
  async dispose() {
    var _a2, _b2, _c, _d;
    this._renderTarget.dispose();
    (_a2 = this._depthTexture) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    await ((_b2 = this._customEffects) === null || _b2 === void 0 ? void 0 : _b2.dispose());
    (_c = this._gammaPass) === null || _c === void 0 ? void 0 : _c.dispose();
    (_d = this._n8ao) === null || _d === void 0 ? void 0 : _d.dispose();
    this.excludedItems.clear();
  }
  setPasses(settings) {
    let settingsChanged = false;
    for (const name in settings) {
      const key = name;
      if (this.settings[key] !== settings[key]) {
        settingsChanged = true;
        break;
      }
    }
    if (!settingsChanged) {
      return;
    }
    for (const name in settings) {
      const key = name;
      if (this._settings[key] !== void 0) {
        this._settings[key] = settings[key];
      }
    }
    this.updatePasses();
  }
  setSize(width, height) {
    if (this._initialized) {
      this.composer.setSize(width, height);
      this.basePass.setSize(width, height);
      this.n8ao.setSize(width, height);
      this.customEffects.setSize(width, height);
      this.gammaPass.setSize(width, height);
    }
  }
  update() {
    if (!this._enabled)
      return;
    this.composer.render();
  }
  updateCamera() {
    const camera = this.components.camera.get();
    if (this._n8ao) {
      this._n8ao.camera = camera;
    }
    if (this._customEffects) {
      this._customEffects.renderCamera = camera;
    }
    if (this._basePass) {
      this._basePass.camera = camera;
    }
  }
  initialize() {
    const scene = this.components.scene.get();
    const camera = this.components.camera.get();
    if (!scene || !camera)
      return;
    if (this.components.camera instanceof OrthoPerspectiveCamera) {
      this.components.camera.projectionChanged.add(() => {
        this.updateCamera();
      });
    }
    const renderer = this.components.renderer;
    this.renderer.clippingPlanes = renderer.clippingPlanes;
    this.renderer.outputColorSpace = "srgb";
    this.renderer.toneMapping = NoToneMapping;
    this.newBasePass(scene, camera);
    this.newSaoPass(scene, camera);
    this.newGammaPass();
    this.newCustomPass();
    this._initialized = true;
    this.updatePasses();
  }
  updateProjection(camera) {
    this.composer.passes.forEach((pass) => {
      pass.camera = camera;
    });
    this.update();
  }
  updatePasses() {
    for (const pass of this.composer.passes) {
      this.composer.removePass(pass);
    }
    if (this._basePass) {
      this.composer.addPass(this.basePass);
    }
    if (this._settings.gamma) {
      this.composer.addPass(this.gammaPass);
    }
    if (this._settings.ao) {
      this.composer.addPass(this.n8ao);
    }
    if (this._settings.custom) {
      this.composer.addPass(this.customEffects);
    }
  }
  newCustomPass() {
    this._customEffects = new CustomEffectsPass(new Vector2(window.innerWidth, window.innerHeight), this.components);
  }
  newGammaPass() {
    this._gammaPass = new ShaderPass(GammaCorrectionShader);
  }
  newSaoPass(scene, camera) {
    const { width, height } = this.components.renderer.getSize();
    this._n8ao = new $05f6997e4b65da14$export$2d57db20b5eb5e0a(scene, camera, width, height);
    const { configuration } = this._n8ao;
    configuration.aoSamples = 16;
    configuration.denoiseSamples = 1;
    configuration.denoiseRadius = 13;
    configuration.aoRadius = 1;
    configuration.distanceFalloff = 4;
    configuration.aoRadius = 1;
    configuration.intensity = 4;
    configuration.halfRes = true;
    configuration.color = new Color().setHex(13421772, "srgb-linear");
  }
  newBasePass(scene, camera) {
    this._basePass = new RenderPass(scene, camera);
  }
};

// node_modules/openbim-components/navigation/PostproductionRenderer/index.js
var PostproductionRenderer = class extends SimpleRenderer {
  constructor(components, container) {
    super(components, container);
    this.postproduction = new Postproduction(components, this._renderer);
    this.setPostproductionSize();
    this.onResize.add(() => this.resizePostproduction());
  }
  /** {@link Updateable.update} */
  async update(_delta) {
    var _a2, _b2;
    if (!this.enabled)
      return;
    await this.onBeforeUpdate.trigger();
    const scene = (_a2 = this.components.scene) === null || _a2 === void 0 ? void 0 : _a2.get();
    const camera = (_b2 = this.components.camera) === null || _b2 === void 0 ? void 0 : _b2.get();
    if (!scene || !camera)
      return;
    if (this.postproduction.enabled) {
      this.postproduction.composer.render();
    } else {
      this._renderer.render(scene, camera);
    }
    this._renderer2D.render(scene, camera);
    await this.onAfterUpdate.trigger();
  }
  /** {@link Disposable.dispose}. */
  async dispose() {
    await super.dispose();
    await this.postproduction.dispose();
  }
  /** {@link Resizeable.resize}. */
  resizePostproduction() {
    if (this.postproduction) {
      this.setPostproductionSize();
    }
  }
  setPostproductionSize() {
    const { clientWidth, clientHeight } = this.container;
    this.postproduction.setSize(clientWidth, clientHeight);
  }
};

// node_modules/openbim-components/fragments/FragmentHighlighter/index.js
var FragmentHighlighter = class _FragmentHighlighter extends Component {
  get outlineEnabled() {
    return this._outlineEnabled;
  }
  set outlineEnabled(value) {
    this._outlineEnabled = value;
    if (!value) {
      delete this._postproduction.customEffects.outlinedMeshes.fragments;
    }
  }
  get _postproduction() {
    if (!(this.components.renderer instanceof PostproductionRenderer)) {
      throw new Error("Postproduction renderer is needed for outlines!");
    }
    const renderer = this.components.renderer;
    return renderer.postproduction;
  }
  constructor(components) {
    super(components);
    this.enabled = true;
    this.highlightMats = {};
    this.events = {};
    this.multiple = "ctrlKey";
    this.zoomFactor = 1.5;
    this.zoomToSelection = false;
    this.selection = {};
    this.excludeOutline = /* @__PURE__ */ new Set();
    this.fillEnabled = true;
    this.outlineMaterial = new MeshBasicMaterial({
      color: "white",
      transparent: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.4
    });
    this._eventsActive = false;
    this._outlineEnabled = true;
    this._outlinedMeshes = {};
    this._invisibleMaterial = new MeshBasicMaterial({ visible: false });
    this._tempMatrix = new Matrix4();
    this._default = {
      selectName: "select",
      hoverName: "hover",
      mouseDown: false,
      mouseMoved: false,
      selectionMaterial: new MeshBasicMaterial({
        color: "#BCF124",
        transparent: true,
        opacity: 0.85,
        depthTest: true
      }),
      highlightMaterial: new MeshBasicMaterial({
        color: "#6528D7",
        transparent: true,
        opacity: 0.2,
        depthTest: true
      })
    };
    this.onMouseDown = () => {
      if (!this.enabled)
        return;
      this._default.mouseDown = true;
    };
    this.onMouseUp = async (event) => {
      if (!this.enabled)
        return;
      if (event.target !== this.components.renderer.get().domElement)
        return;
      this._default.mouseDown = false;
      if (this._default.mouseMoved || event.button !== 0) {
        this._default.mouseMoved = false;
        return;
      }
      this._default.mouseMoved = false;
      const mult = this.multiple === "none" ? true : !event[this.multiple];
      await this.highlight(this._default.selectName, mult, this.zoomToSelection);
    };
    this.onMouseMove = async () => {
      if (!this.enabled)
        return;
      if (this._default.mouseMoved) {
        await this.clearFills(this._default.hoverName);
        return;
      }
      this._default.mouseMoved = this._default.mouseDown;
      await this.highlight(this._default.hoverName, true, false);
    };
    this.components.tools.add(_FragmentHighlighter.uuid, this);
  }
  get() {
    return this.highlightMats;
  }
  async dispose() {
    this.setupEvents(false);
    this._default.highlightMaterial.dispose();
    this._default.selectionMaterial.dispose();
    for (const matID in this.highlightMats) {
      const mats = this.highlightMats[matID] || [];
      for (const mat of mats) {
        mat.dispose();
      }
    }
    for (const id in this._outlinedMeshes) {
      const mesh = this._outlinedMeshes[id];
      mesh.geometry.dispose();
    }
    this.outlineMaterial.dispose();
    this._invisibleMaterial.dispose();
    this.highlightMats = {};
    this.selection = {};
    for (const name in this.events) {
      this.events[name].onClear.reset();
      this.events[name].onHighlight.reset();
    }
    this.events = {};
  }
  async add(name, material) {
    if (this.highlightMats[name]) {
      throw new Error("A highlight with this name already exists.");
    }
    this.highlightMats[name] = material;
    this.selection[name] = {};
    this.events[name] = {
      onHighlight: new Event(),
      onClear: new Event()
    };
    await this.update();
  }
  async update() {
    if (!this.fillEnabled) {
      return;
    }
    const fragments = await this.components.tools.get(FragmentManager);
    for (const fragmentID in fragments.list) {
      const fragment = fragments.list[fragmentID];
      this.addHighlightToFragment(fragment);
      const outlinedMesh = this._outlinedMeshes[fragmentID];
      if (outlinedMesh) {
        fragment.mesh.updateMatrixWorld(true);
        outlinedMesh.applyMatrix4(fragment.mesh.matrixWorld);
      }
    }
  }
  async highlight(name, removePrevious = true, zoomToSelection = this.zoomToSelection) {
    var _a2;
    if (!this.enabled)
      return null;
    this.checkSelection(name);
    const fragments = await this.components.tools.get(FragmentManager);
    const fragList = [];
    const meshes = fragments.meshes;
    const result = this.components.raycaster.castRay(meshes);
    if (!result) {
      await this.clear(name);
      return null;
    }
    const mesh = result.object;
    const geometry = mesh.geometry;
    const index = (_a2 = result.face) === null || _a2 === void 0 ? void 0 : _a2.a;
    const instanceID = result.instanceId;
    if (!geometry || index === void 0 || instanceID === void 0) {
      return null;
    }
    if (removePrevious) {
      await this.clear(name);
    }
    if (!this.selection[name][mesh.uuid]) {
      this.selection[name][mesh.uuid] = /* @__PURE__ */ new Set();
    }
    fragList.push(mesh.fragment);
    const blockID = mesh.fragment.getVertexBlockID(geometry, index);
    const itemID = mesh.fragment.getItemID(instanceID, blockID).replace(/\..*/, "");
    const idNum = parseInt(itemID, 10);
    this.selection[name][mesh.uuid].add(itemID);
    this.addComposites(mesh, idNum, name);
    await this.regenerate(name, mesh.uuid);
    const group = mesh.fragment.group;
    if (group) {
      const keys2 = group.data[idNum][0];
      for (let i = 0; i < keys2.length; i++) {
        const fragKey = keys2[i];
        const fragID = group.keyFragments[fragKey];
        const fragment = fragments.list[fragID];
        fragList.push(fragment);
        if (!this.selection[name][fragID]) {
          this.selection[name][fragID] = /* @__PURE__ */ new Set();
        }
        this.selection[name][fragID].add(itemID);
        this.addComposites(fragment.mesh, idNum, name);
        await this.regenerate(name, fragID);
      }
    }
    await this.events[name].onHighlight.trigger(this.selection[name]);
    if (zoomToSelection) {
      await this.zoomSelection(name);
    }
    return { id: itemID, fragments: fragList };
  }
  async highlightByID(name, ids, removePrevious = true, zoomToSelection = this.zoomToSelection) {
    if (!this.enabled)
      return;
    if (removePrevious) {
      await this.clear(name);
    }
    const styles = this.selection[name];
    for (const fragID in ids) {
      if (!styles[fragID]) {
        styles[fragID] = /* @__PURE__ */ new Set();
      }
      const fragments = await this.components.tools.get(FragmentManager);
      const fragment = fragments.list[fragID];
      const idsNum = /* @__PURE__ */ new Set();
      for (const id of ids[fragID]) {
        styles[fragID].add(id);
        idsNum.add(parseInt(id, 10));
      }
      for (const id of idsNum) {
        this.addComposites(fragment.mesh, id, name);
      }
      await this.regenerate(name, fragID);
    }
    await this.events[name].onHighlight.trigger(this.selection[name]);
    if (zoomToSelection) {
      await this.zoomSelection(name);
    }
  }
  /**
   * Clears any selection previously made by calling {@link highlight}.
   */
  async clear(name) {
    await this.clearFills(name);
    if (!name || !this.excludeOutline.has(name)) {
      await this.clearOutlines();
    }
  }
  async setup() {
    this.enabled = true;
    this.outlineMaterial.color.set(15794042);
    this.excludeOutline.add(this._default.hoverName);
    await this.add(this._default.selectName, [this._default.selectionMaterial]);
    await this.add(this._default.hoverName, [this._default.highlightMaterial]);
    this.setupEvents(true);
  }
  async regenerate(name, fragID) {
    if (this.fillEnabled) {
      await this.updateFragmentFill(name, fragID);
    }
    if (this._outlineEnabled) {
      await this.updateFragmentOutline(name, fragID);
    }
  }
  async zoomSelection(name) {
    if (!this.fillEnabled && !this._outlineEnabled) {
      return;
    }
    const bbox = await this.components.tools.get(FragmentBoundingBox);
    const fragments = await this.components.tools.get(FragmentManager);
    bbox.reset();
    const selected = this.selection[name];
    if (!Object.keys(selected).length) {
      return;
    }
    for (const fragID in selected) {
      const fragment = fragments.list[fragID];
      if (this.fillEnabled) {
        const highlight = fragment.fragments[name];
        if (highlight) {
          bbox.addMesh(highlight.mesh);
        }
      }
      if (this._outlineEnabled && this._outlinedMeshes[fragID]) {
        bbox.addMesh(this._outlinedMeshes[fragID]);
      }
    }
    const sphere = bbox.getSphere();
    sphere.radius *= this.zoomFactor;
    const camera = this.components.camera;
    await camera.controls.fitToSphere(sphere, true);
  }
  addComposites(mesh, itemID, name) {
    const composites = mesh.fragment.composites[itemID];
    if (composites) {
      for (let i = 1; i < composites; i++) {
        const compositeID = toCompositeID(itemID, i);
        this.selection[name][mesh.uuid].add(compositeID);
      }
    }
  }
  async clearStyle(name) {
    const fragments = await this.components.tools.get(FragmentManager);
    for (const fragID in this.selection[name]) {
      const fragment = fragments.list[fragID];
      if (!fragment)
        continue;
      const selection = fragment.fragments[name];
      if (selection) {
        selection.mesh.removeFromParent();
      }
    }
    await this.events[name].onClear.trigger(null);
    this.selection[name] = {};
  }
  async updateFragmentFill(name, fragmentID) {
    const fragments = await this.components.tools.get(FragmentManager);
    const ids = this.selection[name][fragmentID];
    const fragment = fragments.list[fragmentID];
    if (!fragment)
      return;
    const selection = fragment.fragments[name];
    if (!selection)
      return;
    const fragmentParent = fragment.mesh.parent;
    if (!fragmentParent)
      return;
    fragmentParent.add(selection.mesh);
    const isBlockFragment = selection.blocks.count > 1;
    if (isBlockFragment) {
      fragment.getInstance(0, this._tempMatrix);
      selection.setInstance(0, {
        ids: Array.from(fragment.ids),
        transform: this._tempMatrix
      });
      selection.blocks.setVisibility(true, ids, true);
    } else {
      let i = 0;
      for (const id of ids) {
        selection.mesh.count = i + 1;
        const { instanceID } = fragment.getInstanceAndBlockID(id);
        fragment.getInstance(instanceID, this._tempMatrix);
        selection.setInstance(i, { ids: [id], transform: this._tempMatrix });
        i++;
      }
    }
  }
  checkSelection(name) {
    if (!this.selection[name]) {
      throw new Error(`Selection ${name} does not exist.`);
    }
  }
  addHighlightToFragment(fragment) {
    for (const name in this.highlightMats) {
      if (!fragment.fragments[name]) {
        const material = this.highlightMats[name];
        const subFragment = fragment.addFragment(name, material);
        if (fragment.blocks.count > 1) {
          subFragment.setInstance(0, {
            ids: Array.from(fragment.ids),
            transform: this._tempMatrix
          });
          subFragment.blocks.setVisibility(false);
        }
        subFragment.mesh.renderOrder = 2;
        subFragment.mesh.frustumCulled = false;
      }
    }
  }
  async clearFills(name) {
    const names = name ? [name] : Object.keys(this.selection);
    for (const name2 of names) {
      await this.clearStyle(name2);
    }
  }
  async clearOutlines() {
    const fragments = await this.components.tools.get(FragmentManager);
    const effects = this._postproduction.customEffects;
    const fragmentsOutline = effects.outlinedMeshes.fragments;
    if (fragmentsOutline) {
      fragmentsOutline.meshes.clear();
    }
    for (const fragID in this._outlinedMeshes) {
      const fragment = fragments.list[fragID];
      const isBlockFragment = fragment.blocks.count > 1;
      const mesh = this._outlinedMeshes[fragID];
      if (isBlockFragment) {
        mesh.geometry.setIndex([]);
      } else {
        mesh.count = 0;
      }
    }
  }
  async updateFragmentOutline(name, fragmentID) {
    const fragments = await this.components.tools.get(FragmentManager);
    if (!this.selection[name][fragmentID]) {
      return;
    }
    if (this.excludeOutline.has(name)) {
      return;
    }
    const ids = this.selection[name][fragmentID];
    const fragment = fragments.list[fragmentID];
    if (!fragment)
      return;
    const geometry = fragment.mesh.geometry;
    const customEffects = this._postproduction.customEffects;
    if (!customEffects.outlinedMeshes.fragments) {
      customEffects.outlinedMeshes.fragments = {
        meshes: /* @__PURE__ */ new Set(),
        material: this.outlineMaterial
      };
    }
    const outlineEffect = customEffects.outlinedMeshes.fragments;
    if (!this._outlinedMeshes[fragmentID]) {
      const newGeometry = new BufferGeometry();
      newGeometry.attributes = geometry.attributes;
      newGeometry.index = geometry.index;
      const newMesh = new InstancedMesh(newGeometry, this._invisibleMaterial, fragment.capacity);
      newMesh.frustumCulled = false;
      newMesh.renderOrder = 999;
      fragment.mesh.updateMatrixWorld(true);
      newMesh.applyMatrix4(fragment.mesh.matrixWorld);
      this._outlinedMeshes[fragmentID] = newMesh;
      const scene = this.components.scene.get();
      scene.add(newMesh);
    }
    const outlineMesh = this._outlinedMeshes[fragmentID];
    outlineEffect.meshes.add(outlineMesh);
    const isBlockFragment = fragment.blocks.count > 1;
    if (isBlockFragment) {
      const indices = fragment.mesh.geometry.index.array;
      const newIndex = [];
      const idsSet = new Set(ids);
      for (let i = 0; i < indices.length - 2; i += 3) {
        const index = indices[i];
        const blockID = fragment.mesh.geometry.attributes.blockID.array;
        const block = blockID[index];
        const itemID = fragment.mesh.fragment.getItemID(0, block);
        if (idsSet.has(itemID)) {
          newIndex.push(indices[i], indices[i + 1], indices[i + 2]);
        }
      }
      outlineMesh.geometry.setIndex(newIndex);
    } else {
      let counter = 0;
      for (const id of ids) {
        const { instanceID } = fragment.getInstanceAndBlockID(id);
        fragment.mesh.getMatrixAt(instanceID, this._tempMatrix);
        outlineMesh.setMatrixAt(counter++, this._tempMatrix);
      }
      outlineMesh.count = counter;
      outlineMesh.instanceMatrix.needsUpdate = true;
    }
  }
  setupEvents(active) {
    const container = this.components.renderer.get().domElement;
    if (active === this._eventsActive) {
      return;
    }
    this._eventsActive = active;
    if (active) {
      container.addEventListener("mousedown", this.onMouseDown);
      container.addEventListener("mouseup", this.onMouseUp);
      container.addEventListener("mousemove", this.onMouseMove);
    } else {
      container.removeEventListener("mousedown", this.onMouseDown);
      container.removeEventListener("mouseup", this.onMouseUp);
      container.removeEventListener("mousemove", this.onMouseMove);
    }
  }
};
FragmentHighlighter.uuid = "cb8a76f2-654a-4b50-80c6-66fd83cafd77";
ToolComponent.libraryUUIDs.add(FragmentHighlighter.uuid);

// node_modules/openbim-components/fragments/FragmentTree/src/tree-item.js
var FragmentTreeItem = class extends Component {
  get children() {
    return this._children;
  }
  set children(children) {
    this._children = children;
    children.forEach((child) => {
      const subTree = child.uiElement.get("tree");
      this.uiElement.get("tree").addChild(subTree);
    });
  }
  constructor(components, classifier, content) {
    super(components);
    this.name = "FragmentTreeItem";
    this.enabled = true;
    this.filter = {};
    this.uiElement = new UIElement();
    this.onSelected = new Event();
    this.onHovered = new Event();
    this._children = [];
    const main2 = new Button(components);
    const tree = new TreeView(components, content);
    this.uiElement.set({ main: main2, tree });
    tree.onClick.add(async () => {
      const found = await classifier.find(this.filter);
      await this.onSelected.trigger(found);
    });
    tree.get().onmouseenter = async () => {
      const found = await classifier.find(this.filter);
      await this.onHovered.trigger(found);
    };
  }
  async dispose() {
    this.uiElement.dispose();
    this.onSelected.reset();
    this.onHovered.reset();
    for (const child of this.children) {
      await child.dispose();
    }
  }
  get() {
    return { name: this.name, filter: this.filter, children: this.children };
  }
};

// node_modules/openbim-components/fragments/FragmentClassifier/index.js
var FragmentClassifier = class _FragmentClassifier extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this._groupSystems = {};
    components.tools.add(_FragmentClassifier.uuid, this);
  }
  /** {@link Component.get} */
  get() {
    return this._groupSystems;
  }
  async dispose() {
    this._groupSystems = {};
  }
  remove(guid) {
    for (const systemName in this._groupSystems) {
      const system = this._groupSystems[systemName];
      for (const groupName in system) {
        const group = system[groupName];
        delete group[guid];
      }
    }
  }
  async find(filter) {
    const fragments = await this.components.tools.get(FragmentManager);
    if (!filter) {
      const result2 = {};
      const fragList = fragments.list;
      for (const id in fragList) {
        const fragment = fragList[id];
        const items = fragment.items;
        const hidden = Object.keys(fragment.hiddenInstances);
        result2[id] = new Set(...items, ...hidden);
      }
      return result2;
    }
    const size = Object.keys(filter).length;
    const models = {};
    for (const name in filter) {
      const values = filter[name];
      if (!this._groupSystems[name]) {
        console.warn(`Classification ${name} does not exist.`);
        continue;
      }
      for (const value of values) {
        const found = this._groupSystems[name][value];
        if (found) {
          for (const guid in found) {
            if (!models[guid]) {
              models[guid] = {};
            }
            for (const id of found[guid]) {
              if (!models[guid][id]) {
                models[guid][id] = 1;
              } else {
                models[guid][id]++;
              }
            }
          }
        }
      }
    }
    const result = {};
    for (const guid in models) {
      const model = models[guid];
      for (const id in model) {
        const numberOfMatches = model[id];
        if (numberOfMatches === size) {
          if (!result[guid]) {
            result[guid] = /* @__PURE__ */ new Set();
          }
          result[guid].add(id);
          const fragment = fragments.list[guid];
          const composites = fragment.composites[id];
          if (composites) {
            const idNum = parseInt(id, 10);
            for (let i = 1; i < composites; i++) {
              const compositeID = toCompositeID(idNum, i);
              result[guid].add(compositeID);
            }
          }
        }
      }
    }
    return result;
  }
  byModel(modelID, group) {
    if (!this._groupSystems.model) {
      this._groupSystems.model = {};
    }
    const modelsClassification = this._groupSystems.model;
    if (!modelsClassification[modelID]) {
      modelsClassification[modelID] = {};
    }
    const currentModel = modelsClassification[modelID];
    for (const expressID in group.data) {
      const keys2 = group.data[expressID][0];
      for (const key of keys2) {
        const fragID = group.keyFragments[key];
        if (!currentModel[fragID]) {
          currentModel[fragID] = /* @__PURE__ */ new Set();
        }
        currentModel[fragID].add(expressID);
      }
    }
  }
  byPredefinedType(group) {
    var _a2;
    if (!group.properties) {
      throw new Error("To group by predefined type, properties are needed");
    }
    if (!this._groupSystems.predefinedTypes) {
      this._groupSystems.predefinedTypes = {};
    }
    const currentTypes = this._groupSystems.predefinedTypes;
    for (const expressID in group.data) {
      const entity = group.properties[expressID];
      if (!entity)
        continue;
      const predefinedType = String((_a2 = entity.PredefinedType) === null || _a2 === void 0 ? void 0 : _a2.value).toUpperCase();
      if (!currentTypes[predefinedType]) {
        currentTypes[predefinedType] = {};
      }
      const currentType = currentTypes[predefinedType];
      for (const expressID2 in group.data) {
        const keys2 = group.data[expressID2][0];
        for (const key of keys2) {
          const fragmentID = group.keyFragments[key];
          if (!currentType[fragmentID]) {
            currentType[fragmentID] = /* @__PURE__ */ new Set();
          }
          const currentFragment = currentType[fragmentID];
          currentFragment.add(entity.expressID);
        }
      }
    }
  }
  byEntity(group) {
    if (!this._groupSystems.entities) {
      this._groupSystems.entities = {};
    }
    for (const expressID in group.data) {
      const rels = group.data[expressID][1];
      const type2 = rels[1];
      const entity = IfcCategoryMap[type2];
      this.saveItem(group, "entities", entity, expressID);
    }
  }
  byStorey(group) {
    if (!group.properties) {
      throw new Error("To group by storey, properties are needed");
    }
    for (const expressID in group.data) {
      const rels = group.data[expressID][1];
      const storeyID = rels[0];
      const storey = group.properties[storeyID];
      if (storey === void 0)
        continue;
      const storeyName = group.properties[storeyID].Name.value;
      this.saveItem(group, "storeys", storeyName, expressID);
    }
  }
  byIfcRel(group, ifcRel, systemName) {
    const properties = group.properties;
    if (!properties)
      throw new Error("To group by IFC Rel, properties are needed");
    if (!IfcPropertiesUtils.isRel(ifcRel))
      return;
    IfcPropertiesUtils.getRelationMap(properties, ifcRel, (relatingID, relatedIDs) => {
      const { name: relatingName } = IfcPropertiesUtils.getEntityName(properties, relatingID);
      for (const expressID of relatedIDs) {
        this.saveItem(group, systemName, relatingName !== null && relatingName !== void 0 ? relatingName : "NO REL NAME", String(expressID));
      }
    });
  }
  saveItem(group, systemName, className, expressID) {
    if (!this._groupSystems[systemName]) {
      this._groupSystems[systemName] = {};
    }
    const keys2 = group.data[expressID];
    if (!keys2)
      return;
    for (const key of keys2[0]) {
      const fragmentID = group.keyFragments[key];
      if (fragmentID) {
        const system = this._groupSystems[systemName];
        if (!system[className]) {
          system[className] = {};
        }
        if (!system[className][fragmentID]) {
          system[className][fragmentID] = /* @__PURE__ */ new Set();
        }
        system[className][fragmentID].add(expressID);
      }
    }
  }
};
FragmentClassifier.uuid = "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7";
ToolComponent.libraryUUIDs.add(FragmentClassifier.uuid);

// node_modules/openbim-components/fragments/FragmentTree/index.js
var FragmentTree = class _FragmentTree extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this.onSelected = new Event();
    this.onHovered = new Event();
    this._title = "Model Tree";
    this.uiElement = new UIElement();
    this.components.tools.add(_FragmentTree.uuid, this);
  }
  get() {
    if (!this._tree) {
      throw new Error("Fragment tree not initialized yet!");
    }
    return this._tree;
  }
  async init() {
    const classifier = await this.components.tools.get(FragmentClassifier);
    const tree = new FragmentTreeItem(this.components, classifier, "Model Tree");
    this._tree = tree;
    if (this.components.ui.enabled) {
      this.setupUI(tree);
    }
  }
  async dispose() {
    this.onSelected.reset();
    this.onHovered.reset();
    this.uiElement.dispose();
    if (this._tree) {
      await this._tree.dispose();
    }
  }
  async update(groupSystems) {
    if (!this._tree)
      return;
    const classifier = await this.components.tools.get(FragmentClassifier);
    if (this._tree.children.length) {
      await this._tree.dispose();
      this._tree = new FragmentTreeItem(this.components, classifier, this._title);
    }
    this._tree.children = await this.regenerate(groupSystems);
  }
  setupUI(tree) {
    const window2 = new FloatingWindow(this.components);
    const subTree = tree.uiElement.get("tree");
    window2.addChild(subTree);
    window2.title = "Model tree";
    this.components.ui.add(window2);
    window2.visible = false;
    const main2 = new Button(this.components);
    main2.materialIcon = "account_tree";
    main2.tooltip = "Model tree";
    main2.onClick.add(() => {
      window2.visible = !window2.visible;
    });
    this.uiElement.set({ main: main2, window: window2 });
  }
  async regenerate(groupSystemNames, result = {}) {
    const classifier = await this.components.tools.get(FragmentClassifier);
    const systems = classifier.get();
    const groups = [];
    const currentSystemName = groupSystemNames[0];
    const systemGroups = systems[currentSystemName];
    if (!currentSystemName || !systemGroups) {
      return groups;
    }
    for (const name in systemGroups) {
      const classifier2 = await this.components.tools.get(FragmentClassifier);
      const filter = { ...result, [currentSystemName]: [name] };
      const found = await classifier2.find(filter);
      const hasElements = Object.keys(found).length > 0;
      if (hasElements) {
        const firstLetter = currentSystemName[0].toUpperCase();
        const treeItemName = firstLetter + currentSystemName.slice(1);
        const treeItem = new FragmentTreeItem(this.components, classifier2, `${treeItemName}: ${name}`);
        treeItem.onHovered.add((result2) => this.onHovered.trigger(result2));
        treeItem.onSelected.add((result2) => this.onSelected.trigger(result2));
        treeItem.filter = filter;
        groups.push(treeItem);
        treeItem.children = await this.regenerate(groupSystemNames.slice(1), filter);
      }
    }
    return groups;
  }
};
FragmentTree.uuid = "5af6ebe1-26fc-4053-936a-801b6c7cb37e";
ToolComponent.libraryUUIDs.add(FragmentTree.uuid);

// node_modules/openbim-components/fragments/FragmentHider/index.js
var FragmentHider = class _FragmentHider extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this.uiElement = new UIElement();
    this._localStorageID = "FragmentHiderCache";
    this._updateVisibilityOnFound = true;
    this._filterCards = {};
    this.components.tools.add(_FragmentHider.uuid, this);
    if (components.ui.enabled) {
      this.setupUI(components);
    }
  }
  setupUI(components) {
    const mainWindow = new FloatingWindow(components);
    mainWindow.title = "Filters";
    mainWindow.visible = false;
    components.ui.add(mainWindow);
    mainWindow.domElement.style.width = "530px";
    mainWindow.domElement.style.height = "400px";
    const mainButton = new Button(components, {
      materialIconName: "filter_alt",
      tooltip: "Visibility filters"
    });
    mainButton.onClick.add(() => {
      this.hideAllFinders();
      mainWindow.visible = !mainWindow.visible;
    });
    const topButtonContainerHtml = `<div class="flex"></div>`;
    const topButtonContainer = new SimpleUIComponent(components, topButtonContainerHtml);
    const createButton = new Button(components, {
      materialIconName: "add"
    });
    createButton.onClick.add(() => this.createStyleCard());
    topButtonContainer.addChild(createButton);
    mainWindow.addChild(topButtonContainer);
    this.uiElement.set({ window: mainWindow, main: mainButton });
  }
  async dispose() {
    this.uiElement.dispose();
  }
  async set(visible, items) {
    const fragments = await this.components.tools.get(FragmentManager);
    if (!items) {
      for (const id in fragments.list) {
        const fragment = fragments.list[id];
        if (fragment) {
          fragment.setVisibility(visible);
          await this.updateCulledVisibility(fragment);
        }
      }
      return;
    }
    for (const fragID in items) {
      const ids = items[fragID];
      const fragment = fragments.list[fragID];
      fragment.setVisibility(visible, ids);
      await this.updateCulledVisibility(fragment);
    }
  }
  async isolate(items) {
    await this.set(false);
    await this.set(true, items);
  }
  get() {
  }
  async update() {
    this._updateVisibilityOnFound = false;
    for (const id in this._filterCards) {
      const { finder } = this._filterCards[id];
      await finder.find();
    }
    this._updateVisibilityOnFound = true;
    await this.updateQueries();
  }
  async loadCached() {
    const serialized = localStorage.getItem(this._localStorageID);
    if (!serialized)
      return;
    const filters = JSON.parse(serialized);
    for (const filter of filters) {
      await this.createStyleCard(filter);
    }
    await this.update();
  }
  async updateCulledVisibility(fragment) {
    const culler = await this.components.tools.get(ScreenCuller);
    const colorMeshes = culler.get();
    const culled = colorMeshes.get(fragment.id);
    if (culled) {
      culled.count = fragment.mesh.count;
    }
  }
  async createStyleCard(config) {
    const filterCard = new SimpleUIComponent(this.components);
    if (config && config.id.length) {
      filterCard.id = config.id;
    }
    const { id } = filterCard;
    filterCard.domElement.className = `m-4 p-4 border-1 border-solid border-[#3A444E] rounded-md flex flex-col`;
    filterCard.domElement.innerHTML = `
        <div id="top-container-${id}" class="flex">
        </div>
        <div id="bottom-container-${id}" class="flex gap-4 items-center">
        </div>
    `;
    const deleteButton = new Button(this.components, {
      materialIconName: "close"
    });
    deleteButton.domElement.classList.add("self-end");
    deleteButton.onClick.add(() => this.deleteStyleCard(id));
    const topContainer = filterCard.getInnerElement("top-container");
    if (topContainer) {
      topContainer.appendChild(deleteButton.domElement);
    }
    const bottomContainer = filterCard.getInnerElement("bottom-container");
    if (!bottomContainer) {
      throw new Error("Error creating UI elements!");
    }
    const name = new TextInput(this.components);
    name.label = "Name";
    name.domElement.addEventListener("focusout", () => {
      this.cache();
    });
    if (config) {
      name.value = config.name;
    }
    bottomContainer.append(name.domElement);
    const visible = new CheckboxInput(this.components);
    visible.value = config ? config.visible : true;
    visible.label = "Visible";
    visible.onChange.add(() => this.updateQueries());
    const enabled = new CheckboxInput(this.components);
    enabled.value = config ? config.enabled : true;
    enabled.label = "Enabled";
    enabled.onChange.add(() => this.updateQueries());
    const checkBoxContainer = new SimpleUIComponent(this.components);
    checkBoxContainer.domElement.classList.remove("w-full");
    checkBoxContainer.addChild(visible);
    checkBoxContainer.addChild(enabled);
    bottomContainer.append(checkBoxContainer.domElement);
    const finder = new IfcPropertiesFinder(this.components);
    await finder.init();
    finder.loadCached(id);
    const queryBuilder = finder.uiElement.get("query");
    const mainButton = finder.uiElement.get("main");
    const finderWindow = finder.uiElement.get("queryWindow");
    queryBuilder.findButton.label = "Apply";
    bottomContainer.append(mainButton.domElement);
    finderWindow.onVisible.add(() => {
      this.hideAllFinders(finderWindow.id);
      const rect = mainButton.domElement.getBoundingClientRect();
      finderWindow.domElement.style.left = `${rect.x + 90}px`;
      finderWindow.domElement.style.top = `${rect.y - 120}px`;
    });
    finder.onFound.add((data) => {
      finderWindow.visible = false;
      mainButton.active = false;
      this._filterCards[id].fragments = data;
      this.cache();
      if (this._updateVisibilityOnFound) {
        this.updateQueries();
      }
    });
    const fragments = {};
    this._filterCards[id] = {
      styleCard: filterCard,
      fragments,
      name,
      finder,
      deleteButton,
      visible,
      enabled
    };
    const mainWindow = this.uiElement.get("window");
    mainWindow.addChild(filterCard);
  }
  async updateQueries() {
    await this.set(true);
    for (const id in this._filterCards) {
      const { enabled, visible, fragments } = this._filterCards[id];
      if (enabled.value) {
        await this.set(visible.value, fragments);
      }
    }
    this.cache();
  }
  async deleteStyleCard(id) {
    const found = this._filterCards[id];
    if (found) {
      await found.styleCard.dispose();
      await found.deleteButton.dispose();
      await found.name.dispose();
      found.finder.deleteCache();
      await found.finder.dispose();
      await found.visible.dispose();
      await found.enabled.dispose();
    }
    delete this._filterCards[id];
    await this.updateQueries();
  }
  hideAllFinders(excludeID) {
    for (const id in this._filterCards) {
      const { finder } = this._filterCards[id];
      const queryWindow = finder.uiElement.get("queryWindow");
      const mainButton = finder.uiElement.get("main");
      if (queryWindow.id === excludeID) {
        continue;
      }
      if (queryWindow.visible) {
        mainButton.domElement.click();
      }
    }
  }
  cache() {
    const filters = [];
    for (const id in this._filterCards) {
      const styleCard = this._filterCards[id];
      const { visible, enabled, name } = styleCard;
      filters.push({
        visible: visible.value,
        enabled: enabled.value,
        name: name.value,
        id
      });
    }
    const serialized = JSON.stringify(filters);
    localStorage.setItem(this._localStorageID, serialized);
  }
};
FragmentHider.uuid = "dd9ccf2d-8a21-4821-b7f6-2949add16a29";
ToolComponent.libraryUUIDs.add(FragmentHider.uuid);

// node_modules/openbim-components/fragments/FragmentCacher/index.js
var FragmentCacher = class _FragmentCacher extends LocalCacher {
  get fragmentsIDs() {
    const allIDs = this.ids;
    const fragIDs = allIDs.filter((id) => id.includes("-fragments"));
    if (!fragIDs.length)
      return fragIDs;
    return fragIDs.map((id) => id.replace("-fragments", ""));
  }
  constructor(components) {
    super(components);
    this._mode = "none";
    components.tools.list.set(_FragmentCacher.uuid, this);
    if (components.ui.enabled) {
      this.setupUI();
    }
  }
  setupUI() {
    const saveButton = this.uiElement.get("saveButton");
    saveButton.onClick.add(() => this.onSaveButtonClicked());
    const loadButton = this.uiElement.get("loadButton");
    loadButton.onClick.add(() => this.onLoadButtonClicked());
  }
  async getFragmentGroup(id) {
    const { fragmentsCacheID, propertiesCacheID } = this.getIDs(id);
    if (!fragmentsCacheID || !propertiesCacheID) {
      return null;
    }
    const fragments = await this.components.tools.get(FragmentManager);
    const fragmentFile = await this.get(fragmentsCacheID);
    if (fragmentFile === null) {
      throw new Error("Loading error");
    }
    const fragmentsData = await fragmentFile.arrayBuffer();
    const buffer = new Uint8Array(fragmentsData);
    const group = await fragments.load(buffer);
    const propertiesFile = await this.get(propertiesCacheID);
    if (propertiesFile !== null) {
      const propertiesData = await propertiesFile.text();
      group.properties = JSON.parse(propertiesData);
    }
    const scene = this.components.scene.get();
    scene.add(group);
    return group;
  }
  async saveFragmentGroup(group, id = group.uuid) {
    const fragments = await this.components.tools.get(FragmentManager);
    const { fragmentsCacheID, propertiesCacheID } = this.getIDs(id);
    const exported = fragments.export(group);
    const fragmentsFile = new File([new Blob([exported])], fragmentsCacheID);
    const fragmentsUrl = URL.createObjectURL(fragmentsFile);
    await this.save(fragmentsCacheID, fragmentsUrl);
    if (group.properties) {
      const json = JSON.stringify(group.properties);
      const jsonFile = new File([new Blob([json])], propertiesCacheID);
      const propertiesUrl = URL.createObjectURL(jsonFile);
      await this.save(propertiesCacheID, propertiesUrl);
    }
  }
  existsFragmentGroup(id) {
    const { fragmentsCacheID } = this.getIDs(id);
    return this.exists(fragmentsCacheID);
  }
  async onLoadButtonClicked() {
    const floatingMenu = this.uiElement.get("floatingMenu");
    floatingMenu.title = "Load saved items";
    if (floatingMenu.visible && this._mode === "load") {
      floatingMenu.visible = false;
      return;
    }
    this._mode = "load";
    const allIDs = this.fragmentsIDs;
    for (const card of this.cards) {
      await card.dispose();
    }
    this.cards = [];
    for (const id of allIDs) {
      const card = new SimpleUICard(this.components, id);
      card.title = id;
      this.cards.push(card);
      const deleteCardButton = new Button(this.components, {
        materialIconName: "delete"
      });
      card.addChild(deleteCardButton);
      deleteCardButton.onClick.add(async () => {
        const ids = Object.values(this.getIDs(id));
        await this.delete(ids);
        const index = this.cards.indexOf(card);
        this.cards.splice(index, 1);
        await card.dispose();
      });
      const loadFileButton = new Button(this.components, {
        materialIconName: "download"
      });
      card.addChild(loadFileButton);
      loadFileButton.onClick.add(async () => {
        await this.getFragmentGroup(id);
        await this.onFileLoaded.trigger({ id });
      });
      floatingMenu.addChild(card);
    }
    floatingMenu.visible = true;
  }
  async onSaveButtonClicked() {
    const floatingMenu = this.uiElement.get("floatingMenu");
    const fragments = await this.components.tools.get(FragmentManager);
    floatingMenu.title = "Save items";
    if (floatingMenu.visible && this._mode === "save") {
      floatingMenu.visible = false;
      return;
    }
    this._mode = "save";
    for (const card of this.cards) {
      await card.dispose();
    }
    this.cards = [];
    const savedIDs = this.fragmentsIDs;
    const ids = fragments.groups.map((group) => group.uuid);
    for (const id of ids) {
      if (savedIDs.includes(id))
        continue;
      const card = new SimpleUICard(this.components, id);
      card.title = id;
      this.cards.push(card);
      floatingMenu.addChild(card);
      const saveCardButton = new Button(this.components, {
        materialIconName: "save"
      });
      card.addChild(saveCardButton);
      saveCardButton.onClick.add(async () => {
        const group = fragments.groups.find((group2) => group2.uuid === id);
        if (group) {
          await this.saveFragmentGroup(group);
          const index = this.cards.indexOf(card);
          this.cards.splice(index, 1);
          await card.dispose();
          await this.onItemSaved.trigger({ id });
        }
      });
    }
    floatingMenu.visible = true;
  }
  getIDs(id) {
    return {
      fragmentsCacheID: `${id}-fragments`,
      propertiesCacheID: `${id}-properties`
    };
  }
};

// node_modules/openbim-components/fragments/FragmentExploder/index.js
var FragmentExploder = class _FragmentExploder extends Component {
  get() {
    return this._explodedFragments;
  }
  constructor(components) {
    super(components);
    this.enabled = false;
    this.height = 10;
    this.groupName = "storeys";
    this.uiElement = new UIElement();
    this._explodedFragments = /* @__PURE__ */ new Set();
    components.tools.add(_FragmentExploder.uuid, this);
    if (components.ui.enabled) {
      this.setupUI(components);
    }
  }
  async dispose() {
    this._explodedFragments.clear();
    this.uiElement.dispose();
  }
  async explode() {
    this.enabled = true;
    await this.update();
  }
  async reset() {
    this.enabled = false;
    await this.update();
  }
  async update() {
    const classifier = await this.components.tools.get(FragmentClassifier);
    const fragments = await this.components.tools.get(FragmentManager);
    const factor = this.enabled ? 1 : -1;
    let i = 0;
    const systems = classifier.get();
    const groups = systems[this.groupName];
    const mergedIDHeightMap = {};
    const yTransform = new Matrix4();
    for (const groupName in groups) {
      yTransform.elements[13] = i * factor * this.height;
      for (const fragID in groups[groupName]) {
        const fragment = fragments.list[fragID];
        const customID = groupName + fragID;
        if (!fragment) {
          continue;
        }
        if (this.enabled && this._explodedFragments.has(customID)) {
          continue;
        }
        if (!this.enabled && !this._explodedFragments.has(customID)) {
          continue;
        }
        if (this.enabled) {
          this._explodedFragments.add(customID);
        } else {
          this._explodedFragments.delete(customID);
        }
        if (fragment.blocks.count === 1) {
          const ids = groups[groupName][fragID];
          for (const id of ids) {
            const tempMatrix = new Matrix4();
            const { instanceID } = fragment.getInstanceAndBlockID(id);
            fragment.getInstance(instanceID, tempMatrix);
            tempMatrix.premultiply(yTransform);
            fragment.mesh.setMatrixAt(instanceID, tempMatrix);
            const composites = fragment.composites[id];
            if (composites) {
              for (let i2 = 1; i2 < composites; i2++) {
                const idNum = parseInt(id, 10);
                const compID = toCompositeID(idNum, i2);
                const { instanceID: instanceID2 } = fragment.getInstanceAndBlockID(compID);
                fragment.getInstance(instanceID2, tempMatrix);
                tempMatrix.premultiply(yTransform);
                fragment.mesh.setMatrixAt(instanceID2, tempMatrix);
              }
            }
          }
          fragment.mesh.instanceMatrix.needsUpdate = true;
        } else {
          if (!mergedIDHeightMap[fragID]) {
            mergedIDHeightMap[fragID] = {};
          }
          const ids = groups[groupName][fragID];
          for (const id of ids) {
            mergedIDHeightMap[fragID][id] = i * factor * this.height;
          }
        }
      }
      i++;
    }
    const v3 = new Vector3();
    for (const fragID in mergedIDHeightMap) {
      const heights = mergedIDHeightMap[fragID];
      const fragment = fragments.list[fragID];
      const geometry = fragment.mesh.geometry;
      const position = geometry.attributes.position;
      for (let i2 = 0; i2 < geometry.index.count; i2++) {
        const index = geometry.index.array[i2];
        const blockID = geometry.attributes.blockID.array[index];
        const id = fragment.getItemID(0, blockID);
        const height = heights[id];
        if (height === void 0)
          continue;
        yTransform.elements[13] = height;
        const x = position.array[index * 3];
        const y = position.array[index * 3 + 1];
        const z = position.array[index * 3 + 2];
        v3.set(x, y, z);
        v3.applyMatrix4(yTransform);
        position.setXYZ(index, v3.x, v3.y, v3.z);
      }
      position.needsUpdate = true;
    }
  }
  setupUI(components) {
    const main2 = new Button(components);
    this.uiElement.set({ main: main2 });
    main2.tooltip = "Explode";
    main2.materialIcon = "splitscreen";
    main2.onClick.add(async () => {
      if (this.enabled) {
        await this.reset();
      } else {
        await this.explode();
      }
    });
  }
};
FragmentExploder.uuid = "d260618b-ce88-4c7d-826c-6debb91de3e2";
ToolComponent.libraryUUIDs.add(FragmentExploder.uuid);

// node_modules/openbim-components/fragments/FragmentPlans/src/plan-objects.js
var PlanObjects = class {
  get visible() {
    return this._visible;
  }
  set visible(active) {
    this._visible = active;
    const scene = this.components.scene.get();
    for (const id in this._objects) {
      const { root, marker } = this._objects[id];
      if (active) {
        scene.add(root);
        root.add(marker);
      } else {
        root.removeFromParent();
        marker.removeFromParent();
      }
    }
  }
  constructor(components) {
    this.offsetFactor = 0.2;
    this.uiElement = new UIElement();
    this.planClicked = new Event();
    this._scale = new Vector2(1, 1);
    this._min = new Vector3();
    this._max = new Vector3();
    this._objects = {};
    this._visible = false;
    this._planeGeometry = new PlaneGeometry(1, 1, 1);
    this._linesGeometry = new BufferGeometry();
    this.lineMaterial = new LineDashedMaterial({
      color: 12382500,
      dashSize: 0.2,
      gapSize: 0.2
    });
    this._material = new MeshBasicMaterial({
      transparent: true,
      opacity: 0.3,
      color: 1712424,
      depthTest: false
    });
    this.components = components;
    this.resetBounds();
    this.createPlaneOutlineGeometry();
    if (components.ui.enabled) {
      this.setUI(components);
    }
  }
  async dispose() {
    this.planClicked.reset();
    this.visible = false;
    for (const id in this._objects) {
      const { marker, button, outline, root, plane } = this._objects[id];
      await button.dispose();
      outline.removeFromParent();
      outline.geometry = null;
      outline.material = [];
      root.removeFromParent();
      root.children = [];
      plane.removeFromParent();
      plane.material = [];
      plane.geometry = null;
      marker.element.remove();
    }
    this._objects = {};
    this._planeGeometry.dispose();
    this._material.dispose();
    this.uiElement.dispose();
    this.lineMaterial.dispose();
    this._material.dispose();
    this.components = null;
  }
  add(config) {
    const { id, point, name } = config;
    const root = new Group();
    root.position.copy(point);
    const plane = new Mesh(this._planeGeometry, this._material);
    plane.rotation.x = -Math.PI / 2;
    root.add(plane);
    const outline = new LineSegments(this._linesGeometry, this.lineMaterial);
    outline.computeLineDistances();
    outline.rotation.x = -Math.PI / 2;
    root.add(outline);
    const button = new Button(this.components, {
      materialIconName: "location_on",
      tooltip: name
    });
    button.onClick.add(async () => {
      await this.planClicked.trigger({ id: config.id });
    });
    const { domElement } = button;
    domElement.classList.remove("bg-transparent");
    domElement.className += " transition-none rounded-full";
    const marker = new CSS2DObject(domElement);
    root.add(marker);
    this._objects[id] = { root, plane, outline, marker, button };
  }
  setBounds(points, override2 = false) {
    if (override2) {
      this.resetBounds();
    }
    const bbox = FragmentBoundingBox.getBounds(points, this._min, this._max);
    this._min = bbox.min;
    this._max = bbox.max;
    const dimensions = FragmentBoundingBox.getDimensions(bbox);
    const { width, depth, center } = dimensions;
    const offset2 = (width + depth / 2) * this.offsetFactor;
    const newScale = new Vector2(width + offset2, depth + offset2);
    const previousScaleMatrix = this.newScaleMatrix(this._scale);
    const newScaleMatrix = this.newScaleMatrix(newScale);
    previousScaleMatrix.invert();
    this._planeGeometry.applyMatrix4(previousScaleMatrix);
    this._linesGeometry.applyMatrix4(previousScaleMatrix);
    this._planeGeometry.applyMatrix4(newScaleMatrix);
    this._linesGeometry.applyMatrix4(newScaleMatrix);
    for (const id in this._objects) {
      const { root, outline } = this._objects[id];
      outline.computeLineDistances();
      root.position.x = center.x;
      root.position.z = center.z;
    }
  }
  setUI(components) {
    const button = new Button(components, {
      materialIconName: "layers",
      tooltip: "3D Plans"
    });
    button.onClick.add(() => {
      this.visible = !this.visible;
    });
    this.uiElement.set({ main: button });
  }
  resetBounds() {
    this._min = FragmentBoundingBox.newBound(true);
    this._max = FragmentBoundingBox.newBound(false);
  }
  newScaleMatrix(scale) {
    const { x, y } = scale;
    return new Matrix4().fromArray([
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
  }
  createPlaneOutlineGeometry() {
    const vertices = new Float32Array([
      -0.5,
      -0.5,
      0,
      -0.5,
      0.5,
      0,
      -0.5,
      0.5,
      0,
      0.5,
      0.5,
      0,
      0.5,
      0.5,
      0,
      0.5,
      -0.5,
      0,
      0.5,
      -0.5,
      0,
      -0.5,
      -0.5,
      0
    ]);
    const posAttr = new BufferAttribute(vertices, 3);
    this._linesGeometry.setAttribute("position", posAttr);
  }
};

// node_modules/openbim-components/navigation/EdgesClipper/src/clipping-fills.js
var import_earcut = __toESM(require_earcut());
var ClippingFills = class {
  get visible() {
    return this.mesh.parent !== null;
  }
  set visible(value) {
    const style = this.getStyle();
    if (value) {
      const scene = this._components.scene.get();
      scene.add(this.mesh);
      if (style) {
        style.meshes.add(this.mesh);
      }
    } else {
      this.mesh.removeFromParent();
      if (style) {
        style.meshes.delete(this.mesh);
      }
    }
  }
  set geometry(geometry) {
    this._geometry = geometry;
    this.mesh.geometry.attributes.position = geometry.attributes.position;
  }
  constructor(components, plane, geometry, material) {
    this.mesh = new Mesh(new BufferGeometry());
    this._precission = 1e4;
    this._tempVector = new Vector3();
    this._plane2DCoordinateSystem = new Matrix4();
    this._components = components;
    this.mesh.material = material;
    this.mesh.frustumCulled = false;
    this._plane = plane;
    const { x, y, z } = plane.normal;
    if (Math.abs(x) === 1) {
      this._planeAxis = "x";
    } else if (Math.abs(y) === 1) {
      this._planeAxis = "y";
    } else if (Math.abs(z) === 1) {
      this._planeAxis = "z";
    }
    this._geometry = geometry;
    this.mesh.geometry.attributes.position = geometry.attributes.position;
    const offset2 = plane.normal.clone().multiplyScalar(0.01);
    this.mesh.position.copy(offset2);
    this.visible = true;
  }
  dispose() {
    const style = this.getStyle();
    if (style) {
      style.meshes.delete(this.mesh);
    }
    this.mesh.geometry.dispose();
    this.mesh.removeFromParent();
    this.mesh.geometry = null;
    this.mesh = null;
    this._plane = null;
    this._geometry = null;
  }
  update(elements, blockByIndex) {
    const buffer = this._geometry.attributes.position.array;
    if (!buffer)
      return;
    this.updatePlane2DCoordinateSystem();
    const allIndices = [];
    let start2 = 0;
    for (let i = 0; i < elements.length; i++) {
      const end2 = elements[i];
      const verticesByBlock = {};
      for (let j = start2; j < end2; j += 2) {
        let block = blockByIndex[j];
        if (block === void 0) {
          block = -1;
        }
        if (!verticesByBlock[block]) {
          verticesByBlock[block] = [];
        }
        verticesByBlock[block].push(j * 3);
      }
      for (const block in verticesByBlock) {
        const vertices = verticesByBlock[block];
        if (!vertices.length) {
          continue;
        }
        const indices = this.computeFill(vertices, buffer);
        for (const index of indices) {
          allIndices.push(index);
        }
      }
      start2 = end2;
    }
    this.mesh.geometry.setIndex(allIndices);
  }
  computeFill(vertices, buffer) {
    const indices = /* @__PURE__ */ new Map();
    const all2DVertices = {};
    const shapes = /* @__PURE__ */ new Map();
    let nextShapeID = 0;
    const shapesEnds = /* @__PURE__ */ new Map();
    const shapesStarts = /* @__PURE__ */ new Map();
    const openShapes = /* @__PURE__ */ new Set();
    const p2 = this._precission;
    for (let i = 0; i < vertices.length; i++) {
      const startVertexIndex = vertices[i];
      let x1 = 0;
      let y1 = 0;
      let x2 = 0;
      let y2 = 0;
      const globalX1 = buffer[startVertexIndex];
      const globalY1 = buffer[startVertexIndex + 1];
      const globalZ1 = buffer[startVertexIndex + 2];
      const globalX2 = buffer[startVertexIndex + 3];
      const globalY2 = buffer[startVertexIndex + 4];
      const globalZ2 = buffer[startVertexIndex + 5];
      this._tempVector.set(globalX1, globalY1, globalZ1);
      this._tempVector.applyMatrix4(this._plane2DCoordinateSystem);
      x1 = Math.trunc(this._tempVector.x * p2) / p2;
      y1 = Math.trunc(this._tempVector.y * p2) / p2;
      this._tempVector.set(globalX2, globalY2, globalZ2);
      this._tempVector.applyMatrix4(this._plane2DCoordinateSystem);
      x2 = Math.trunc(this._tempVector.x * p2) / p2;
      y2 = Math.trunc(this._tempVector.y * p2) / p2;
      if (x1 === x2 && y1 === y2) {
        continue;
      }
      const startCode = `${x1}|${y1}`;
      const endCode = `${x2}|${y2}`;
      if (!indices.has(startCode)) {
        indices.set(startCode, startVertexIndex / 3);
      }
      if (!indices.has(endCode)) {
        indices.set(endCode, startVertexIndex / 3 + 1);
      }
      const start2 = indices.get(startCode);
      const end2 = indices.get(endCode);
      all2DVertices[start2] = [x1, y1];
      all2DVertices[end2] = [x2, y2];
      const startMatchesStart = shapesStarts.has(start2);
      const startMatchesEnd = shapesEnds.has(start2);
      const endMatchesStart = shapesStarts.has(end2);
      const endMatchesEnd = shapesEnds.has(end2);
      const noMatches = !startMatchesStart && !startMatchesEnd && !endMatchesStart && !endMatchesEnd;
      if (noMatches) {
        shapesStarts.set(start2, nextShapeID);
        shapesEnds.set(end2, nextShapeID);
        openShapes.add(nextShapeID);
        shapes.set(nextShapeID, [start2, end2]);
        nextShapeID++;
      } else if (startMatchesStart && endMatchesEnd) {
        const startIndex = shapesStarts.get(start2);
        const endIndex = shapesEnds.get(end2);
        const isShapeMerge = startIndex !== endIndex;
        if (isShapeMerge) {
          const endShape = shapes.get(endIndex);
          const startShape = shapes.get(startIndex);
          if (!endShape || !startShape) {
            continue;
          }
          shapes.delete(startIndex);
          openShapes.delete(startIndex);
          shapesEnds.set(startShape[startShape.length - 1], endIndex);
          shapesEnds.delete(endShape[endShape.length - 1]);
          for (const index of startShape) {
            endShape.push(index);
          }
        } else {
          openShapes.delete(endIndex);
        }
        shapesStarts.delete(start2);
        shapesEnds.delete(end2);
      } else if (startMatchesEnd && endMatchesStart) {
        const startIndex = shapesStarts.get(end2);
        const endIndex = shapesEnds.get(start2);
        const isShapeMerge = startIndex !== endIndex;
        if (isShapeMerge) {
          const endShape = shapes.get(endIndex);
          const startShape = shapes.get(startIndex);
          if (!endShape || !startShape) {
            continue;
          }
          shapes.delete(startIndex);
          openShapes.delete(startIndex);
          shapesEnds.set(startShape[startShape.length - 1], endIndex);
          shapesEnds.delete(endShape[endShape.length - 1]);
          for (const index of startShape) {
            endShape.push(index);
          }
        } else {
          openShapes.delete(endIndex);
        }
        shapesStarts.delete(end2);
        shapesEnds.delete(start2);
      } else if (startMatchesStart && endMatchesStart) {
        const startIndex1 = shapesStarts.get(end2);
        const startIndex2 = shapesStarts.get(start2);
        const startShape2 = shapes.get(startIndex2);
        const startShape1 = shapes.get(startIndex1);
        if (!startShape2 || !startShape1) {
          continue;
        }
        shapes.delete(startIndex1);
        openShapes.delete(startIndex1);
        shapesStarts.delete(startShape2[0]);
        shapesStarts.delete(startShape1[0]);
        shapesEnds.delete(startShape1[startShape1.length - 1]);
        shapesStarts.set(startShape1[startShape1.length - 1], startIndex2);
        startShape1.reverse();
        startShape2.splice(0, 0, ...startShape1);
      } else if (startMatchesEnd && endMatchesEnd) {
        const endIndex1 = shapesEnds.get(end2);
        const endIndex2 = shapesEnds.get(start2);
        const endShape2 = shapes.get(endIndex2);
        const endShape1 = shapes.get(endIndex1);
        if (!endShape2 || !endShape1) {
          continue;
        }
        shapes.delete(endIndex1);
        openShapes.delete(endIndex1);
        shapesEnds.delete(endShape2[endShape2.length - 1]);
        shapesEnds.delete(endShape1[endShape1.length - 1]);
        shapesStarts.delete(endShape1[0]);
        shapesEnds.set(endShape1[0], endIndex2);
        endShape1.reverse();
        endShape2.push(...endShape1);
      } else if (startMatchesStart) {
        const shapeIndex = shapesStarts.get(start2);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.unshift(end2);
        shapesStarts.delete(start2);
        shapesStarts.set(end2, shapeIndex);
      } else if (startMatchesEnd) {
        const shapeIndex = shapesEnds.get(start2);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.push(end2);
        shapesEnds.delete(start2);
        shapesEnds.set(end2, shapeIndex);
      } else if (endMatchesStart) {
        const shapeIndex = shapesStarts.get(end2);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.unshift(start2);
        shapesStarts.delete(end2);
        shapesStarts.set(start2, shapeIndex);
      } else if (endMatchesEnd) {
        const shapeIndex = shapesEnds.get(end2);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.push(start2);
        shapesEnds.delete(end2);
        shapesEnds.set(start2, shapeIndex);
      }
    }
    const trueIndices = [];
    for (const [id, shape] of shapes) {
      if (openShapes.has(id)) {
        continue;
      }
      const vertices2 = [];
      const indexMap = /* @__PURE__ */ new Map();
      let counter = 0;
      for (const index of shape) {
        const vertex = all2DVertices[index];
        vertices2.push(vertex[0], vertex[1]);
        indexMap.set(counter++, index);
      }
      const result = (0, import_earcut.default)(vertices2);
      for (const index of result) {
        const trueIndex = indexMap.get(index);
        if (trueIndex === void 0) {
          throw new Error("Map error!");
        }
        trueIndices.push(trueIndex);
      }
    }
    return trueIndices;
  }
  updatePlane2DCoordinateSystem() {
    this._plane2DCoordinateSystem = new Matrix4();
    const xAxis = new Vector3(1, 0, 0);
    const yAxis = new Vector3(0, 1, 0);
    const zAxis = this._plane.normal;
    const pos = new Vector3();
    this._plane.coplanarPoint(pos);
    if (this._planeAxis === "x") {
      xAxis.crossVectors(yAxis, zAxis);
    } else if (this._planeAxis === "y") {
      yAxis.crossVectors(zAxis, xAxis);
    } else if (this._planeAxis === "z") {
    } else {
      xAxis.crossVectors(yAxis, zAxis).normalize();
      yAxis.crossVectors(zAxis, xAxis);
    }
    this._plane2DCoordinateSystem.fromArray([
      xAxis.x,
      xAxis.y,
      xAxis.z,
      0,
      yAxis.x,
      yAxis.y,
      yAxis.z,
      0,
      zAxis.x,
      zAxis.y,
      zAxis.z,
      0,
      pos.x,
      pos.y,
      pos.z,
      1
    ]);
    this._plane2DCoordinateSystem.invert();
  }
  getStyle() {
    const renderer = this._components.renderer;
    if (this.styleName && renderer instanceof PostproductionRenderer) {
      const effects = renderer.postproduction.customEffects;
      return effects.outlinedMeshes[this.styleName];
    }
    return null;
  }
};

// node_modules/openbim-components/navigation/EdgesClipper/src/clipping-edges.js
var ClippingEdges = class extends Component {
  /** {@link Hideable.visible} */
  get visible() {
    return this._visible;
  }
  set fillVisible(visible) {
    for (const name in this._edges) {
      const edges2 = this._edges[name];
      if (edges2.fill) {
        edges2.fill.visible = visible;
      }
    }
  }
  constructor(components, plane, styles) {
    super(components);
    this.onAfterUpdate = new Event();
    this.onBeforeUpdate = new Event();
    this.name = "ClippingEdges";
    this.enabled = true;
    this.fillNeedsUpdate = false;
    this.blockByIndex = {};
    this._edges = {};
    this._visible = true;
    this._inverseMatrix = new Matrix4();
    this._localPlane = new Plane();
    this._tempLine = new Line3();
    this._tempVector = new Vector3();
    this._plane = plane;
    this._styles = styles;
  }
  async setVisible(visible) {
    this._visible = visible;
    const names = Object.keys(this._edges);
    for (const edgeName of names) {
      this.updateEdgesVisibility(edgeName, visible);
    }
    if (visible) {
      await this.update();
    }
  }
  /** {@link Updateable.update} */
  async update() {
    const styles = this._styles.get();
    await this.updateDeletedEdges(styles);
    for (const name in styles) {
      this.drawEdges(name);
    }
    this.fillNeedsUpdate = false;
  }
  /** {@link Component.get} */
  get() {
    return this._edges;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    const names = Object.keys(this._edges);
    for (const name of names) {
      await this.disposeEdge(name);
    }
  }
  newEdgesMesh(styleName) {
    const styles = this._styles.get();
    const material = styles[styleName].lineMaterial;
    const edgesGeometry = new BufferGeometry();
    const buffer = new Float32Array(3e5);
    const linePosAttr = new BufferAttribute(buffer, 3, false);
    linePosAttr.setUsage(DynamicDrawUsage);
    edgesGeometry.setAttribute("position", linePosAttr);
    const lines = new LineSegments(edgesGeometry, material);
    lines.frustumCulled = false;
    return lines;
  }
  newFillMesh(name, geometry) {
    const styles = this._styles.get();
    const style = styles[name];
    const fillMaterial = style.fillMaterial;
    if (fillMaterial) {
      const fills = new ClippingFills(this.components, this._plane, geometry, fillMaterial);
      this.newFillOutline(name, fills, style);
      return fills;
    }
    return void 0;
  }
  newFillOutline(name, fills, style) {
    if (!style.outlineMaterial)
      return;
    const renderer = this.components.renderer;
    if (renderer instanceof PostproductionRenderer) {
      const pRenderer = renderer;
      const outlines = pRenderer.postproduction.customEffects.outlinedMeshes;
      if (!outlines[name]) {
        outlines[name] = {
          meshes: /* @__PURE__ */ new Set(),
          material: style.outlineMaterial
        };
      }
      fills.styleName = name;
    }
  }
  // Source: https://gkjohnson.github.io/three-mesh-bvh/example/bundle/clippedEdges.html
  drawEdges(styleName) {
    this.blockByIndex = {};
    const style = this._styles.get()[styleName];
    if (!this._edges[styleName]) {
      this.initializeStyle(styleName);
    }
    const edges2 = this._edges[styleName];
    let index = 0;
    const posAttr = edges2.mesh.geometry.attributes.position;
    posAttr.array.fill(0);
    const indexes = [];
    let lastIndex = 0;
    for (const mesh of style.meshes) {
      if (!mesh.geometry) {
        continue;
      }
      if (!mesh.geometry.boundsTree) {
        throw new Error("Boundstree not found for clipping edges subset.");
      }
      const instanced = mesh;
      if (instanced.count === 0) {
        continue;
      }
      if (instanced.count > 1) {
        for (let i = 0; i < instanced.count; i++) {
          const isFragment = instanced instanceof FragmentMesh;
          const fMesh = instanced;
          const ids = style.fragments[fMesh.fragment.id];
          if (isFragment && ids) {
            const itemID = fMesh.fragment.items[i];
            if (!ids.has(itemID)) {
              continue;
            }
          }
          const tempMesh = new Mesh(mesh.geometry);
          tempMesh.matrix.copy(mesh.matrix);
          const tempMatrix = new Matrix4();
          instanced.getMatrixAt(i, tempMatrix);
          tempMesh.applyMatrix4(tempMatrix);
          tempMesh.applyMatrix4(mesh.matrix);
          tempMesh.updateMatrix();
          tempMesh.updateMatrixWorld();
          this._inverseMatrix.copy(tempMesh.matrixWorld).invert();
          this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix);
          index = this.shapecast(tempMesh, posAttr, index, style);
          if (index !== lastIndex) {
            indexes.push(index);
            lastIndex = index;
          }
        }
      } else {
        this._inverseMatrix.copy(mesh.matrixWorld).invert();
        this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix);
        const isFragment = mesh instanceof FragmentMesh;
        index = this.shapecast(mesh, posAttr, index, style, isFragment);
        if (index !== lastIndex) {
          indexes.push(index);
          lastIndex = index;
        }
      }
    }
    edges2.mesh.geometry.setDrawRange(0, index);
    edges2.mesh.position.copy(this._plane.normal).multiplyScalar(1e-4);
    posAttr.needsUpdate = true;
    const attributes = edges2.mesh.geometry.attributes;
    const position = attributes.position;
    if (!Number.isNaN(position.array[0])) {
      const scene = this.components.scene.get();
      scene.add(edges2.mesh);
      if (this.fillNeedsUpdate && edges2.fill) {
        edges2.fill.geometry = edges2.mesh.geometry;
        edges2.fill.update(indexes, this.blockByIndex);
      }
    }
  }
  initializeStyle(name) {
    const mesh = this.newEdgesMesh(name);
    const geometry = mesh.geometry;
    const fill = this.newFillMesh(name, geometry);
    this._edges[name] = { mesh, name, fill };
  }
  shapecast(mesh, posAttr, index, style, isMultiblockFragment = false) {
    mesh.geometry.boundsTree.shapecast({
      intersectsBounds: (box) => {
        return this._localPlane.intersectsBox(box);
      },
      // @ts-ignore
      intersectsTriangle: (tri, triangleIndex) => {
        if (isMultiblockFragment && style.fragments) {
          const fMesh = mesh;
          const ids = style.fragments[fMesh.fragment.id];
          if (ids !== void 0) {
            const index2 = fMesh.geometry.index.array[triangleIndex * 3];
            const blockID = fMesh.geometry.attributes.blockID.array[index2];
            const id = fMesh.fragment.getItemID(0, blockID);
            if (!ids.has(id)) {
              return;
            }
          }
        }
        let count = 0;
        this._tempLine.start.copy(tri.a);
        this._tempLine.end.copy(tri.b);
        if (this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const result = this._tempVector.applyMatrix4(mesh.matrixWorld);
          posAttr.setXYZ(index, result.x, result.y, result.z);
          count++;
          index++;
        }
        this._tempLine.start.copy(tri.b);
        this._tempLine.end.copy(tri.c);
        if (this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const result = this._tempVector.applyMatrix4(mesh.matrixWorld);
          posAttr.setXYZ(index, result.x, result.y, result.z);
          count++;
          index++;
        }
        this._tempLine.start.copy(tri.c);
        this._tempLine.end.copy(tri.a);
        if (this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const result = this._tempVector.applyMatrix4(mesh.matrixWorld);
          posAttr.setXYZ(index, result.x, result.y, result.z);
          count++;
          index++;
        }
        if (count !== 2) {
          index -= count;
        }
        if (count === 2 && isMultiblockFragment) {
          const fMesh = mesh;
          const vertexIndex = fMesh.geometry.index.array[triangleIndex * 3];
          const block = fMesh.geometry.attributes.blockID.array[vertexIndex];
          this.blockByIndex[index - 2] = block;
        }
      }
    });
    return index;
  }
  updateEdgesVisibility(edgeName, visible) {
    const edges2 = this._edges[edgeName];
    if (edges2.fill) {
      edges2.fill.visible = visible;
    }
    edges2.mesh.visible = visible;
    if (visible) {
      const scene = this.components.scene.get();
      scene.add(edges2.mesh);
    } else {
      edges2.mesh.removeFromParent();
    }
  }
  async updateDeletedEdges(styles) {
    const names = Object.keys(this._edges);
    for (const name of names) {
      if (styles[name] === void 0) {
        await this.disposeEdge(name);
        this.disposeOutline(name);
      }
    }
  }
  disposeOutline(name) {
    const renderer = this.components.renderer;
    if (renderer instanceof PostproductionRenderer) {
      const outlines = renderer.postproduction.customEffects.outlinedMeshes;
      delete outlines[name];
    }
  }
  async disposeEdge(name) {
    const disposer = await this.components.tools.get(Disposer);
    const edge = this._edges[name];
    if (edge.fill) {
      edge.fill.dispose();
    }
    disposer.destroy(edge.mesh, false);
    delete this._edges[name];
  }
};

// node_modules/openbim-components/navigation/EdgesClipper/src/edges-plane.js
var EdgesPlane = class extends SimplePlane {
  constructor(components, origin, normal, material, styles) {
    super(components, origin, normal, material, 5, false);
    this.edgesMaxUpdateRate = 50;
    this.lastUpdate = -1;
    this.updateTimeout = -1;
    this.updateFill = async () => {
      this.edges.fillNeedsUpdate = true;
      await this.edges.update();
      if (this._visible) {
        this.edges.fillVisible = true;
      }
    };
    this.update = async () => {
      if (!this.enabled)
        return;
      this._plane.setFromNormalAndCoplanarPoint(this._normal, this._helper.position);
      const now = Date.now();
      if (this.lastUpdate + this.edgesMaxUpdateRate < now) {
        this.lastUpdate = now;
        await this.edges.update();
      } else if (this.updateTimeout === -1) {
        this.updateTimeout = window.setTimeout(() => {
          this.update();
          this.updateTimeout = -1;
        }, this.edgesMaxUpdateRate);
      }
    };
    this.hideFills = () => {
      this.edges.fillVisible = false;
    };
    this.edges = new ClippingEdges(components, this._plane, styles);
    this.toggleControls(true);
    this.edges.setVisible(true);
    this.onDraggingEnded.add(this.updateFill);
    this.onDraggingStarted.add(this.hideFills);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return super.enabled;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    await super.dispose();
    await this.edges.dispose();
  }
  /** {@link Component.enabled} */
  async setEnabled(state) {
    super.enabled = state;
    if (state) {
      await this.update();
    }
  }
  async setVisible(state) {
    super.visible = state;
    this.toggleControls(state);
    await this.edges.setVisible(true);
  }
};

// node_modules/openbim-components/navigation/EdgesClipper/src/edges-styles.js
var EdgesStyles = class extends Component {
  constructor(components) {
    super(components);
    this.name = "EdgesStyles";
    this.enabled = true;
    this._styles = {};
    this._defaultLineMaterial = new LineBasicMaterial({
      color: 0,
      linewidth: 1e-3
    });
    this.onAfterUpdate = new Event();
    this.onBeforeUpdate = new Event();
  }
  get() {
    return this._styles;
  }
  async update(_delta) {
    await this.onBeforeUpdate.trigger(this._styles);
    await this.onAfterUpdate.trigger(this._styles);
  }
  // Creates a new style that applies to all clipping edges for generic models
  create(name, meshes, lineMaterial = this._defaultLineMaterial, fillMaterial, outlineMaterial) {
    for (const mesh of meshes) {
      if (!mesh.geometry.boundsTree)
        mesh.geometry.computeBoundsTree();
    }
    const renderer = this.components.renderer;
    lineMaterial.clippingPlanes = renderer.clippingPlanes;
    const newStyle = {
      name,
      lineMaterial,
      meshes,
      fillMaterial,
      outlineMaterial,
      fragments: {}
    };
    this._styles[name] = newStyle;
    return newStyle;
  }
  async dispose() {
    const styles = Object.keys(this._styles);
    for (const style of styles) {
      this.deleteStyle(style);
    }
    this._styles = {};
  }
  deleteStyle(id, disposeMaterials = true) {
    var _a2, _b2;
    const style = this._styles[id];
    if (style) {
      style.meshes.clear();
      if (disposeMaterials) {
        style.lineMaterial.dispose();
        (_a2 = style.fillMaterial) === null || _a2 === void 0 ? void 0 : _a2.dispose();
        (_b2 = style.outlineMaterial) === null || _b2 === void 0 ? void 0 : _b2.dispose();
      }
    }
    delete this._styles[id];
  }
};

// node_modules/openbim-components/navigation/EdgesClipper/index.js
var EdgesClipper = class _EdgesClipper extends SimpleClipper {
  constructor(components) {
    super(components);
    this.components.tools.list.set(_EdgesClipper.uuid, this);
    this.PlaneType = EdgesPlane;
    this.styles = new EdgesStyles(components);
  }
  /** {@link Component.get} */
  async dispose() {
    await super.dispose();
    await this.styles.dispose();
  }
  /**
   * Updates all the lines of the {@link ClippingEdges}.
   */
  async updateEdges(updateFills = false) {
    if (!this.enabled)
      return;
    for (const plane of this._planes) {
      if (updateFills) {
        await plane.updateFill();
      } else {
        await plane.update();
      }
    }
  }
  newPlaneInstance(point, normal) {
    return new this.PlaneType(this.components, point, normal, this._material, this.styles);
  }
};

// node_modules/openbim-components/fragments/FragmentPlans/index.js
var FragmentPlans = class _FragmentPlans extends Component {
  get commands() {
    return this.uiElement.get("commandsMenu").commands;
  }
  set commands(commands) {
    this.uiElement.get("commandsMenu").commands = commands;
  }
  constructor(components) {
    super(components);
    this.onNavigated = new Event();
    this.onExited = new Event();
    this.enabled = false;
    this.currentPlan = null;
    this.defaultSectionOffset = 1.5;
    this.defaultCameraOffset = 30;
    this.storeys = [];
    this.uiElement = new UIElement();
    this._plans = [];
    this._floorPlanViewCached = false;
    this._previousCamera = new Vector3();
    this._previousTarget = new Vector3();
    this._previousProjection = "Perspective";
    this.components.tools.add(_FragmentPlans.uuid, this);
    this.objects = new PlanObjects(components);
    if (components.ui.enabled) {
      this.setUI(components);
    }
  }
  /** {@link Component.get} */
  get() {
    return this._plans;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onExited.reset();
    this.onNavigated.reset();
    this.storeys = [];
    this._plans = [];
    await this.objects.dispose();
    this.uiElement.dispose();
  }
  // TODO: Compute georreference matrix when generating fragmentsgroup
  // so that we can correctly add floors in georreferenced models
  // where the IfcSite / IfcBuilding have location information
  async computeAllPlanViews(model) {
    if (!model.properties) {
      throw new Error("Properties are needed to compute plan views!");
    }
    const { properties } = model;
    const floorsProps = IfcPropertiesUtils.getAllItemsOfType(properties, IFCBUILDINGSTOREY);
    const coordHeight = model.coordinationMatrix.elements[13];
    const units = IfcPropertiesUtils.getUnits(properties);
    for (const floor of floorsProps) {
      const floorHeight = { value: 0 };
      this.getAbsoluteFloorHeight(floor.ObjectPlacement.value, model.properties, floorHeight);
      const height = floorHeight.value * units + coordHeight;
      await this.create({
        name: floor.Name.value,
        id: floor.GlobalId.value,
        normal: new Vector3(0, -1, 0),
        point: new Vector3(0, height, 0),
        ortho: true,
        offset: this.defaultSectionOffset
      });
    }
    const { min: min2, max: max2 } = model.boundingBox;
    this.objects.setBounds([min2, max2]);
  }
  /**
   * Creates a new floor plan in the navigator.
   *
   * @param config - Necessary data to initialize the floor plan.
   */
  async create(config) {
    const previousPlan = this._plans.find((plan2) => plan2.id === config.id);
    if (previousPlan) {
      throw new Error(`There's already a plan with the id: ${config.id}`);
    }
    const plane = await this.createClippingPlane(config);
    plane.visible = false;
    const plan = { ...config, plane };
    this._plans.push(plan);
    this.objects.add(config);
  }
  /**
   * Make the navigator go to the specified floor plan.
   *
   * @param id - Floor plan to go to.
   * @param animate - Whether to animate the camera transition.
   */
  async goTo(id, animate = false) {
    var _a2;
    if (((_a2 = this.currentPlan) === null || _a2 === void 0 ? void 0 : _a2.id) === id) {
      return;
    }
    this.objects.visible = false;
    await this.onNavigated.trigger({ id });
    this.storeCameraPosition();
    await this.hidePreviousClippingPlane();
    this.updateCurrentPlan(id);
    await this.activateCurrentPlan();
    if (!this.enabled) {
      await this.moveCameraTo2DPlanPosition(animate);
      this.enabled = true;
    }
    if (this.components.ui.enabled) {
      this.uiElement.get("exitButton").enabled = true;
    }
  }
  /**
   * Deactivate navigator and go back to the previous view.
   *
   * @param animate - Whether to animate the camera transition.
   */
  async exitPlanView(animate = false) {
    if (!this.enabled)
      return;
    this.enabled = false;
    await this.onExited.trigger();
    this.cacheFloorplanView();
    const camera = this.components.camera;
    camera.setNavigationMode("Orbit");
    await camera.setProjection(this._previousProjection);
    if (this.currentPlan && this.currentPlan.plane) {
      await this.currentPlan.plane.setEnabled(false);
      await this.currentPlan.plane.edges.setVisible(false);
    }
    this.currentPlan = null;
    await camera.controls.setLookAt(this._previousCamera.x, this._previousCamera.y, this._previousCamera.z, this._previousTarget.x, this._previousTarget.y, this._previousTarget.z, animate);
    if (this.components.ui.enabled) {
      this.uiElement.get("exitButton").enabled = false;
    }
  }
  async updatePlansList() {
    if (!this.components.ui.enabled) {
      return;
    }
    const defaultText = this.uiElement.get("defaultText");
    const planList = this.uiElement.get("planList");
    const commandsMenu = this.uiElement.get("commandsMenu");
    await planList.dispose(true);
    if (!this._plans.length) {
      defaultText.visible = true;
      return;
    }
    defaultText.visible = false;
    commandsMenu.update();
    const commandsExist = commandsMenu.hasCommands;
    for (const plan of this._plans) {
      const height = Math.trunc(plan.point.y * 10) / 10;
      const description = `Height: ${height}`;
      const simpleCard = new SimpleUICard(this.components);
      simpleCard.title = plan.name;
      simpleCard.description = description;
      const toolbar = new Toolbar(this.components);
      this.components.ui.addToolbar(toolbar);
      simpleCard.addChild(toolbar);
      toolbar.domElement.classList.remove("shadow-md", "backdrop-blur-xl", "bg-ifcjs-100");
      const planButton = new Button(this.components, {
        materialIconName: "arrow_outward"
      });
      planButton.onClick.add(async () => {
        await this.goTo(plan.id);
      });
      toolbar.addChild(planButton);
      const extraButton = new Button(this.components, {
        materialIconName: "expand_more"
      });
      extraButton.onClick.add((event) => {
        if (event) {
          commandsMenu.commandData = plan;
          commandsMenu.popup(event.x, event.y);
        }
      });
      if (!commandsExist) {
        extraButton.enabled = false;
      }
      toolbar.addChild(extraButton);
      simpleCard.domElement.classList.remove("bg-ifcjs-120");
      simpleCard.domElement.classList.remove("border-transparent");
      simpleCard.domElement.className += ` min-w-[300px] my-2 border-1 border-solid border-[#3A444E] `;
      planList.addChild(simpleCard);
    }
  }
  setUI(components) {
    this.setupPlanObjectUI();
    const topButtonContainer = new SimpleUIComponent(this.components, `<div class="flex"></div>`);
    const exitButton = new Button(components);
    exitButton.materialIcon = "logout";
    topButtonContainer.addChild(exitButton);
    exitButton.enabled = false;
    exitButton.onClick.add(() => this.exitPlanView());
    const main2 = new Button(components, {
      tooltip: "Plans list"
    });
    main2.materialIcon = "folder_copy";
    const floatingWindow = new FloatingWindow(components);
    floatingWindow.title = "Floor Plans";
    components.ui.add(floatingWindow);
    floatingWindow.visible = false;
    floatingWindow.addChild(topButtonContainer);
    const planList = new SimpleUIComponent(components, `<div class="flex flex-col"></div>`);
    floatingWindow.addChild(planList);
    const defaultText = new SimpleUIComponent(components, `<p>No plans yet.</p>`);
    floatingWindow.addChild(defaultText);
    const commandsMenu = new CommandsMenu(components);
    components.ui.add(commandsMenu);
    commandsMenu.visible = false;
    this.uiElement.set({
      main: main2,
      floatingWindow,
      planList,
      defaultText,
      exitButton,
      commandsMenu
    });
    main2.onClick.add(() => {
      floatingWindow.visible = !floatingWindow.visible;
    });
  }
  storeCameraPosition() {
    if (this.enabled) {
      this.cacheFloorplanView();
    } else {
      this.store3dCameraPosition();
    }
  }
  async createClippingPlane(config) {
    const { normal, point } = config;
    const clippingPoint = point.clone();
    if (config.offset) {
      clippingPoint.y += config.offset;
    }
    const clipper = await this.components.tools.get(EdgesClipper);
    const plane = clipper.createFromNormalAndCoplanarPoint(normal, clippingPoint);
    await plane.setEnabled(false);
    await plane.edges.update();
    await plane.edges.setVisible(false);
    return plane;
  }
  cacheFloorplanView() {
    this._floorPlanViewCached = true;
    const camera = this.components.camera;
    camera.controls.saveState();
  }
  async moveCameraTo2DPlanPosition(animate) {
    const camera = this.components.camera;
    if (this._floorPlanViewCached) {
      await camera.controls.reset(animate);
    } else {
      await camera.controls.setLookAt(0, 100, 0, 0, 0, 0, animate);
    }
  }
  async activateCurrentPlan() {
    if (!this.currentPlan)
      throw new Error("Current plan is not defined.");
    const camera = this.components.camera;
    if (this.currentPlan.plane) {
      await this.currentPlan.plane.setEnabled(true);
      this.currentPlan.plane.edges.fillNeedsUpdate = true;
      await this.currentPlan.plane.edges.setVisible(true);
    }
    camera.setNavigationMode("Plan");
    const projection = this.currentPlan.ortho ? "Orthographic" : "Perspective";
    await camera.setProjection(projection);
  }
  store3dCameraPosition() {
    const camera = this.components.camera;
    const activeCamera = this.components.camera.get();
    activeCamera.getWorldPosition(this._previousCamera);
    camera.controls.getTarget(this._previousTarget);
    this._previousProjection = camera.getProjection();
  }
  updateCurrentPlan(id) {
    const foundPlan = this._plans.find((plan) => plan.id === id);
    if (!foundPlan) {
      throw new Error("The specified plan is undefined!");
    }
    this.currentPlan = foundPlan;
  }
  async hidePreviousClippingPlane() {
    if (this.currentPlan) {
      const plane = this.currentPlan.plane;
      if (plane) {
        await plane.setEnabled(false);
      }
      if (this.currentPlan.plane instanceof EdgesPlane) {
        await this.currentPlan.plane.edges.setVisible(false);
      }
    }
  }
  setupPlanObjectUI() {
    this.objects.planClicked.add(async ({ id }) => {
      const button = this.objects.uiElement.get("main");
      if (!this.enabled) {
        if (button.innerElements.icon && button.innerElements.tooltip) {
          button.materialIcon = "logout";
          button.tooltip = "Exit floorplans";
        }
        button.onClick.add(() => {
          this.exitPlanView();
          if (button.innerElements.icon && button.innerElements.tooltip) {
            button.materialIcon = "layers";
            button.tooltip = "3D plans";
          }
          button.onClick.add(() => this.objects.visible = !this.objects.visible);
        });
      }
      this.goTo(id);
    });
  }
  getAbsoluteFloorHeight(placementID, properties, height) {
    const placementRef = properties[placementID];
    if (!placementRef)
      return;
    const placement = properties[placementRef.RelativePlacement.value];
    const location2 = properties[placement.Location.value];
    const currentHeight = location2.Coordinates[2].value;
    height.value += currentHeight;
    const parentRef = placementRef.PlacementRelTo;
    if (parentRef && parentRef.value !== null) {
      this.getAbsoluteFloorHeight(parentRef.value, properties, height);
    }
  }
};
FragmentPlans.uuid = "a80874aa-1c93-43a4-80f2-df346da086b1";
ToolComponent.libraryUUIDs.add(FragmentPlans.uuid);

// node_modules/openbim-components/fragments/FragmentClipStyler/index.js
var FragmentClipStyler = class _FragmentClipStyler extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this.localStorageID = "FragmentClipStyler";
    this.styleCards = {};
    this.uiElement = new UIElement();
    this._defaultStyles = `
     {
        "B0ebxzZQvZ": {
            "name": "thick",
            "lineColor": "#36593e",
            "lineThickness": 0.5,
            "fillColor": "#ccdb9a",
            "categories": "IFCWALLSTANDARDCASE, IFCWALL,IFCSLAB, IFCROOF"
        },
        "kG9B1Ojv08": {
            "name": "thin",
            "lineColor": "#92a59b",
            "lineThickness": 0.25,
            "fillColor": "#e6ffdb",
            "categories": "IFCWINDOW, IFCDOOR"
        }
    }
  `;
    this.components.tools.add(_FragmentClipStyler.uuid, this);
    if (components.ui.enabled) {
      this.setupUI(components);
    }
  }
  async setup(force = false) {
    const noCards = Object.keys(this.styleCards).length === 0;
    if (force || noCards) {
      localStorage.setItem(this.localStorageID, this._defaultStyles);
      await this.loadCachedStyles();
    }
  }
  get() {
    const saved = localStorage.getItem(this.localStorageID);
    if (saved) {
      const parsed = JSON.parse(saved);
      return Object.values(parsed);
    }
    return [];
  }
  async dispose() {
    for (const id in this.styleCards) {
      await this.deleteStyleCard(id, false);
    }
    this.uiElement.dispose();
  }
  async update(ids = Object.keys(this.styleCards)) {
    const clipper = await this.components.tools.get(EdgesClipper);
    const fragments = await this.components.tools.get(FragmentManager);
    const classifier = await this.components.tools.get(FragmentClassifier);
    for (const id of ids) {
      const card = this.styleCards[id];
      if (!card)
        return;
      const allStyles = clipper.styles.get();
      const style = allStyles[id];
      if (!style)
        return;
      style.meshes.clear();
      const categoryList = card.categories.value.split(",");
      const entities = categoryList.map((item) => item.replace(" ", ""));
      const found = await classifier.find({ entities });
      for (const fragID in found) {
        const { mesh } = fragments.list[fragID];
        style.fragments[fragID] = new Set(found[fragID]);
        style.meshes.add(mesh);
      }
    }
    await clipper.updateEdges(true);
    this.cacheStyles();
  }
  async loadCachedStyles() {
    const savedData = localStorage.getItem(this.localStorageID);
    if (savedData) {
      const savedStyles = JSON.parse(savedData);
      for (const id in savedStyles) {
        const savedStyle = savedStyles[id];
        await this.createStyleCard(savedStyle);
      }
    }
  }
  setupUI(components) {
    const mainWindow = new FloatingWindow(components);
    mainWindow.title = "Clipping styles";
    mainWindow.visible = false;
    components.ui.add(mainWindow);
    mainWindow.domElement.style.width = "530px";
    mainWindow.domElement.style.height = "400px";
    const mainButton = new Button(components, {
      materialIconName: "format_paint",
      tooltip: "Clipping styles"
    });
    mainButton.onClick.add(() => {
      mainWindow.visible = !mainWindow.visible;
    });
    const topButtonContainerHtml = `<div class="flex"></div>`;
    const topButtonContainer = new SimpleUIComponent(components, topButtonContainerHtml);
    const createButton = new Button(components, {
      materialIconName: "add"
    });
    createButton.onClick.add(() => this.createStyleCard());
    topButtonContainer.addChild(createButton);
    mainWindow.addChild(topButtonContainer);
    this.uiElement.set({ mainWindow, mainButton });
  }
  cacheStyles() {
    const styles = {};
    for (const id in this.styleCards) {
      const styleCard = this.styleCards[id];
      styles[id] = {
        name: styleCard.name.value,
        lineColor: styleCard.lineColor.value,
        lineThickness: styleCard.lineThickness.value,
        fillColor: styleCard.fillColor.value,
        categories: styleCard.categories.value
      };
    }
    const serialized = JSON.stringify(styles);
    localStorage.setItem(this.localStorageID, serialized);
  }
  async deleteStyleCard(id, updateCache = true) {
    const found = this.styleCards[id];
    const clipper = await this.components.tools.get(EdgesClipper);
    clipper.styles.deleteStyle(id, true);
    if (found) {
      await found.styleCard.dispose();
      await found.deleteButton.dispose();
      await found.name.dispose();
      await found.categories.dispose();
      await found.lineThickness.dispose();
      await found.lineColor.dispose();
      await found.fillColor.dispose();
    }
    delete this.styleCards[id];
    await clipper.updateEdges(true);
    if (updateCache) {
      this.cacheStyles();
    }
  }
  async createStyleCard(config) {
    const styleCard = new SimpleUIComponent(this.components);
    const { id } = styleCard;
    const styleRowClass = `flex gap-4`;
    styleCard.domElement.className = `m-4 p-4 border-1 border-solid border-[#3A444E] rounded-md flex flex-col gap-4`;
    styleCard.domElement.innerHTML = `
        <div id="first-row-${id}" class="${styleRowClass}">
        </div>
        <div class="${styleRowClass}">
            <div id="name-${id}" class="flex-1">
            </div>
            <div id="line-color-${id}">
            </div>
        </div>
        <div class="${styleRowClass}">
            <div id="range-${id}" class="flex-1">
            </div>
            <div id="fill-color-${id}">
            </div>
        </div>
        <div id="categories-${id}">
        </div>
    `;
    const deleteButton = new Button(this.components, {
      materialIconName: "close"
    });
    deleteButton.onClick.add(() => this.deleteStyleCard(id));
    const firstRow = styleCard.getInnerElement("first-row");
    if (firstRow) {
      firstRow.insertBefore(deleteButton.domElement, firstRow.firstChild);
    }
    const nameInput = new TextInput(this.components);
    nameInput.label = "Name";
    if (config) {
      nameInput.value = config.name;
    }
    const name = styleCard.getInnerElement(`name`);
    if (name) {
      name.append(nameInput.domElement);
    }
    nameInput.domElement.addEventListener("focusout", () => this.cacheStyles());
    const lineColor = new ColorInput(this.components);
    lineColor.label = "Line color";
    const lineColorContainer = styleCard.getInnerElement("line-color");
    if (lineColorContainer) {
      lineColorContainer.append(lineColor.domElement);
    }
    lineColor.value = config ? config.lineColor : "#808080";
    const fillColor = new ColorInput(this.components);
    fillColor.label = "Fill color";
    if (config) {
      fillColor.value = config.fillColor;
    }
    const fillColorContainer = styleCard.getInnerElement("fill-color");
    if (fillColorContainer) {
      fillColorContainer.append(fillColor.domElement);
    }
    const lineThickness = new RangeInput(this.components);
    lineThickness.label = "Line thickness";
    lineThickness.min = 0;
    lineThickness.max = 1;
    lineThickness.step = 0.05;
    lineThickness.value = config ? config.lineThickness : 0.25;
    const range = styleCard.getInnerElement("range");
    if (range) {
      range.append(lineThickness.domElement);
    }
    const categories = new TextInput(this.components);
    categories.label = "Categories";
    const categoriesContainer = styleCard.getInnerElement("categories");
    if (categoriesContainer) {
      categoriesContainer.append(categories.domElement);
    }
    this.styleCards[id] = {
      styleCard,
      name: nameInput,
      lineThickness,
      categories,
      deleteButton,
      fillColor,
      lineColor
    };
    this.uiElement.get("mainWindow").addChild(styleCard);
    const fillMaterial = new MeshBasicMaterial({
      color: fillColor.value,
      side: 2
    });
    let saveTimer;
    const saveStyles = () => {
      if (saveTimer) {
        clearTimeout(saveTimer);
      }
      saveTimer = setTimeout(() => this.cacheStyles(), 2e3);
    };
    fillColor.onChange.add(() => {
      fillMaterial.color.set(fillColor.value);
      saveStyles();
    });
    const lineMaterial = new LineBasicMaterial({
      color: lineColor.value
    });
    const outlineMaterial = new MeshBasicMaterial({
      color: lineColor.value,
      opacity: lineThickness.value,
      side: 2,
      transparent: true
    });
    lineThickness.onChange.add(() => {
      outlineMaterial.opacity = lineThickness.value;
      saveStyles();
    });
    lineColor.onChange.add(() => {
      lineMaterial.color.set(lineColor.value);
      outlineMaterial.color.set(lineColor.value);
      saveStyles();
    });
    const clipper = await this.components.tools.get(EdgesClipper);
    clipper.styles.create(id, /* @__PURE__ */ new Set(), lineMaterial, fillMaterial, outlineMaterial);
    categories.domElement.addEventListener("focusout", () => this.update([id]));
    if (config) {
      categories.value = config.categories;
    }
    this.cacheStyles();
  }
};
FragmentClipStyler.uuid = "14de9fbd-2151-4c01-8e07-22a2667e1126";
ToolComponent.libraryUUIDs.add(FragmentClipStyler.uuid);

// node_modules/openbim-components/services/CloudProcessor/index.js
var CloudProcessor = class extends Component {
  constructor(components, token) {
    super(components);
    this.tools = [];
    this.name = "CloudProcessor";
    this.enabled = true;
    this.modelProcessed = new Event();
    this.checkInterval = 5e3;
    this._models = [];
    this._urls = {
      base: "https://01wj0udft7.execute-api.eu-central-1.amazonaws.com/v1/models",
      token: "?accessToken="
    };
    this._urls.token += token;
  }
  /**
   * Retrieves a tool component by its name.
   */
  get() {
    return this._models;
  }
  async update() {
    const { base, token } = this._urls;
    const url = `${base}${token}`;
    const result = await fetch(url);
    const parsed = await result.json();
    this._models = parsed.models;
  }
  async upload(fileUrl) {
    const response = await this.createModel();
    const uploadUrl = response.uploadUrl;
    const read2 = await fetch(fileUrl);
    const body = await read2.arrayBuffer();
    await fetch(uploadUrl, { method: "PUT", body });
    this.setupModelProcessEvent(response.model._id);
  }
  async delete(modelID) {
    const { base, token } = this._urls;
    const url = `${base}/${modelID}${token}`;
    const result = await fetch(url, { method: "DELETE" });
    return result.json();
  }
  async getModel(modelID) {
    const { base, token } = this._urls;
    const modelUrl = `${base}/${modelID}${token}`;
    const modelResponse = await fetch(modelUrl);
    return modelResponse.json();
  }
  setupModelProcessEvent(modelID) {
    const interval = setInterval(async () => {
      const response = await this.getModel(modelID);
      if (response.model.status === "PROCESSED") {
        await this.modelProcessed.trigger(response);
        clearInterval(interval);
      }
    }, this.checkInterval);
  }
  async createModel() {
    const { base, token } = this._urls;
    const url = `${base}${token}`;
    const result = await fetch(url, { method: "POST" });
    return result.json();
  }
};

// node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "h": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/three/examples/jsm/shaders/VerticalBlurShader.js
var VerticalBlurShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "v": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/openbim-components/navigation/ShadowDropper/index.js
var ShadowDropper = class _ShadowDropper extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this.cameraHeight = 10;
    this.darkness = 1.2;
    this.opacity = 1;
    this.resolution = 512;
    this.amount = 3.5;
    this.planeColor = 16777215;
    this.shadowOffset = 0;
    this.shadowExtraScaleFactor = 1.5;
    this.shadows = {};
    this.tempMaterial = new MeshBasicMaterial({ visible: false });
    this.depthMaterial = new MeshDepthMaterial();
    this.components.tools.add(_ShadowDropper.uuid, this);
    this.initializeDepthMaterial();
  }
  /** {@link Component.get} */
  get() {
    return this.shadows;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    for (const id in this.shadows) {
      await this.deleteShadow(id);
    }
    this.tempMaterial.dispose();
    this.depthMaterial.dispose();
    this.components = null;
  }
  /**
   * Creates a blurred dropped shadow of the given mesh.
   *
   * @param model - the mesh whose shadow to generate.
   * @param id - the name of this shadow.
   */
  renderShadow(model, id) {
    if (this.shadows[id]) {
      throw new Error(`There is already a shadow with ID ${id}`);
    }
    const { size, center, min: min2 } = this.getSizeCenterMin(model);
    const shadow = this.createShadow(id, size);
    this.initializeShadow(shadow, center, min2);
    this.createPlanes(shadow, size);
    this.bakeShadow(model, shadow);
    return shadow.root;
  }
  /**
   * Deletes the specified shadow (if it exists).
   *
   * @param id - the name of this shadow.
   */
  async deleteShadow(id) {
    const disposer = await this.components.tools.get(Disposer);
    const shadow = this.shadows[id];
    delete this.shadows[id];
    if (!shadow)
      throw new Error(`No shadow with ID ${id} was found.`);
    disposer.destroy(shadow.root);
    disposer.destroy(shadow.blurPlane);
    shadow.rt.dispose();
    shadow.rtBlur.dispose();
  }
  createPlanes(currentShadow, size) {
    const planeGeometry = new PlaneGeometry(size.x, size.z).rotateX(Math.PI / 2);
    this.createBasePlane(currentShadow, planeGeometry);
    _ShadowDropper.createBlurPlane(currentShadow, planeGeometry);
  }
  initializeShadow(shadow, center, min2) {
    this.initializeRoot(shadow, center, min2);
    _ShadowDropper.initializeRenderTargets(shadow);
    _ShadowDropper.initializeCamera(shadow);
  }
  bakeShadow(meshes, shadow) {
    const scene = this.components.scene.get();
    const areModelsInScene = meshes.map((mesh) => !!mesh.parent);
    for (let i = 0; i < meshes.length; i++) {
      if (!areModelsInScene[i]) {
        scene.add(meshes[i]);
      }
    }
    const children = scene.children.filter((obj) => !meshes.includes(obj) && obj !== shadow.root);
    for (let i = children.length - 1; i >= 0; i--) {
      scene.remove(children[i]);
    }
    const initialBackground = scene.background;
    scene.background = null;
    scene.overrideMaterial = this.depthMaterial;
    const previousVisibleAttributes = [];
    for (const mesh of meshes) {
      previousVisibleAttributes.push(mesh.visible);
      mesh.visible = true;
    }
    const renderer = this.components.renderer.get();
    renderer.setRenderTarget(shadow.rt);
    renderer.render(scene, shadow.camera);
    scene.overrideMaterial = null;
    this.blurShadow(shadow, this.amount);
    this.blurShadow(shadow, this.amount * 0.4);
    renderer.setRenderTarget(null);
    scene.background = initialBackground;
    for (let i = 0; i < meshes.length; i++) {
      meshes[i].visible = previousVisibleAttributes[i];
    }
    for (let i = children.length - 1; i >= 0; i--) {
      scene.add(children[i]);
    }
    for (let i = 0; i < meshes.length; i++) {
      if (!areModelsInScene[i]) {
        scene.remove(meshes[i]);
      }
    }
  }
  static initializeCamera(shadow) {
    shadow.camera.rotation.x = Math.PI / 2;
    shadow.root.add(shadow.camera);
  }
  static initializeRenderTargets(shadow) {
    shadow.rt.texture.generateMipmaps = false;
    shadow.rtBlur.texture.generateMipmaps = false;
  }
  initializeRoot(shadow, center, min2) {
    const scene = this.components.scene.get();
    shadow.root.position.set(center.x, min2.y - this.shadowOffset, center.z);
    scene.add(shadow.root);
  }
  // Plane simulating the "ground". This is not needed for BIM models generally
  // private createGroundColorPlane(_shadow: Shadow, planeGeometry: BufferGeometry) {
  //   const fillPlaneMaterial = new MeshBasicMaterial({
  //     color: this.planeColor,
  //     opacity: this.opacity,
  //     transparent: true,
  //     depthWrite: false,
  //     clippingPlanes: this.context.getClippingPlanes()
  //   });
  //   const fillPlane = new Mesh(planeGeometry, fillPlaneMaterial);
  //   fillPlane.rotateX(Math.PI);
  //   fillPlane.renderOrder = -1;
  //   shadow.root.add(fillPlane);
  // }
  createBasePlane(shadow, planeGeometry) {
    const planeMaterial = this.createPlaneMaterial(shadow);
    const plane = new Mesh(planeGeometry, planeMaterial);
    plane.renderOrder = 2;
    shadow.root.add(plane);
    plane.scale.y = -1;
  }
  static createBlurPlane(shadow, planeGeometry) {
    shadow.blurPlane.geometry = planeGeometry;
    shadow.blurPlane.visible = false;
    shadow.root.add(shadow.blurPlane);
  }
  createPlaneMaterial(shadow) {
    const renderer = this.components.renderer;
    return new MeshBasicMaterial({
      map: shadow.rt.texture,
      opacity: this.opacity,
      transparent: true,
      depthWrite: false,
      clippingPlanes: renderer.clippingPlanes
    });
  }
  // like MeshDepthMaterial, but goes from black to transparent
  initializeDepthMaterial() {
    this.depthMaterial.depthTest = false;
    this.depthMaterial.depthWrite = false;
    const oldShader = "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );";
    const newShader = "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );";
    this.depthMaterial.userData.darkness = { value: this.darkness };
    this.depthMaterial.onBeforeCompile = (shader) => {
      shader.uniforms.darkness = this.depthMaterial.userData.darkness;
      shader.fragmentShader = /* glsl */
      `
						uniform float darkness;
						${shader.fragmentShader.replace(oldShader, newShader)}
					`;
    };
  }
  createShadow(id, size) {
    this.shadows[id] = {
      root: new Group(),
      rt: new WebGLRenderTarget(this.resolution, this.resolution),
      rtBlur: new WebGLRenderTarget(this.resolution, this.resolution),
      blurPlane: new Mesh(),
      camera: this.createCamera(size)
    };
    return this.shadows[id];
  }
  createCamera(size) {
    return new OrthographicCamera(-size.x / 2, size.x / 2, size.z / 2, -size.z / 2, 0, this.cameraHeight);
  }
  getSizeCenterMin(meshes) {
    const parent = meshes[0].parent;
    const group = new Group();
    group.children = meshes;
    const boundingBox = new Box3().setFromObject(group);
    parent === null || parent === void 0 ? void 0 : parent.add(...meshes);
    const size = new Vector3();
    boundingBox.getSize(size);
    size.x *= this.shadowExtraScaleFactor;
    size.z *= this.shadowExtraScaleFactor;
    const center = new Vector3();
    boundingBox.getCenter(center);
    const min2 = boundingBox.min;
    return { size, center, min: min2 };
  }
  blurShadow(shadow, amount) {
    const horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);
    horizontalBlurMaterial.depthTest = false;
    const verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);
    verticalBlurMaterial.depthTest = false;
    shadow.blurPlane.visible = true;
    shadow.blurPlane.material = horizontalBlurMaterial;
    shadow.blurPlane.material.uniforms.tDiffuse.value = shadow.rt.texture;
    horizontalBlurMaterial.uniforms.h.value = amount * 1 / 256;
    const renderer = this.components.renderer.get();
    renderer.setRenderTarget(shadow.rtBlur);
    renderer.render(shadow.blurPlane, shadow.camera);
    shadow.blurPlane.material = verticalBlurMaterial;
    shadow.blurPlane.material.uniforms.tDiffuse.value = shadow.rtBlur.texture;
    verticalBlurMaterial.uniforms.v.value = amount * 1 / 256;
    renderer.setRenderTarget(shadow.rt);
    renderer.render(shadow.blurPlane, shadow.camera);
    shadow.blurPlane.visible = false;
  }
};
ShadowDropper.uuid = "f833a09a-a3ab-4c58-b03e-da5298c7a1b6";
ToolComponent.libraryUUIDs.add(ShadowDropper.uuid);

// node_modules/openbim-components/measurement/LengthMeasurement/src/types.js
var DimensionLabelClassName = "text-white text-sm bg-ifcjs-100 rounded-md px-3 py-1";
var DimensionPreviewClassName = "bg-ifcjs-100 rounded-full w-[8px] h-[8px]";

// node_modules/openbim-components/measurement/LengthMeasurement/src/index.js
var SimpleDimensionLine = class _SimpleDimensionLine {
  set visible(value) {
    this.label.visible = value;
    this._endpoints[0].visible = value;
    this._endpoints[1].visible = value;
    if (value) {
      this._components.scene.get().add(this._root);
    } else {
      this._root.removeFromParent();
    }
  }
  set endPoint(point) {
    this.end = point;
    const position = this._line.geometry.attributes.position;
    position.setXYZ(1, point.x, point.y, point.z);
    position.needsUpdate = true;
    this._endpoints[1].get().position.copy(point);
    this.updateLabel();
  }
  set startPoint(point) {
    this.start = point;
    const position = this._line.geometry.attributes.position;
    position.setXYZ(0, point.x, point.y, point.z);
    position.needsUpdate = true;
    this._endpoints[0].get().position.copy(point);
    this.updateLabel();
  }
  get _center() {
    let dir = this.end.clone().sub(this.start);
    const len = dir.length() * 0.5;
    dir = dir.normalize().multiplyScalar(len);
    return this.start.clone().add(dir);
  }
  constructor(components, data) {
    this.boundingBox = new Mesh();
    this._root = new Group();
    this._endpoints = [];
    this._components = components;
    this.start = data.start;
    this.end = data.end;
    this._length = this.getLength();
    this._line = this.createLine(data);
    this.newEndpointElement(data.endpointElement);
    this.newEndpointElement(data.endpointElement.cloneNode(true));
    this.label = this.newText();
    this._root.renderOrder = 2;
    this._components.scene.get().add(this._root);
  }
  async dispose() {
    const disposer = await this._components.tools.get(Disposer);
    this.visible = false;
    disposer.destroy(this._root);
    disposer.destroy(this._line);
    for (const marker of this._endpoints) {
      await marker.dispose();
    }
    this._endpoints.length = 0;
    await this.label.dispose();
    if (this.boundingBox) {
      disposer.destroy(this.boundingBox);
    }
    this._components = null;
  }
  createBoundingBox() {
    this.boundingBox.geometry = new BoxGeometry(1, 1, this._length);
    this.boundingBox.position.copy(this._center);
    this.boundingBox.lookAt(this.end);
    this.boundingBox.visible = false;
    this._root.add(this.boundingBox);
  }
  toggleLabel() {
    this.label.toggleVisibility();
  }
  newEndpointElement(element) {
    const isFirst = this._endpoints.length === 0;
    const position = isFirst ? this.start : this.end;
    const marker = new Simple2DMarker(this._components, element);
    marker.get().position.copy(position);
    this._endpoints.push(marker);
    this._root.add(marker.get());
  }
  updateLabel() {
    this._length = this.getLength();
    this.label.get().element.textContent = this.getTextContent();
    this.label.get().position.copy(this._center);
    this._line.computeLineDistances();
  }
  createLine(data) {
    const axisGeom = new BufferGeometry();
    axisGeom.setFromPoints([data.start, data.end]);
    const line = new Line(axisGeom, data.lineMaterial);
    this._root.add(line);
    return line;
  }
  newText() {
    const htmlText = document.createElement("div");
    htmlText.className = DimensionLabelClassName;
    htmlText.textContent = this.getTextContent();
    const label = new Simple2DMarker(this._components, htmlText);
    label.get().position.copy(this._center);
    this._root.add(label.get());
    return label;
  }
  getTextContent() {
    return `${this._length / _SimpleDimensionLine.scale} ${_SimpleDimensionLine.units}`;
  }
  getLength() {
    return parseFloat(this.start.distanceTo(this.end).toFixed(2));
  }
};
SimpleDimensionLine.scale = 1;
SimpleDimensionLine.units = "m";

// node_modules/openbim-components/measurement/LengthMeasurement/index.js
var LengthMeasurement = class _LengthMeasurement extends Component {
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(value) {
    if (!value)
      this.cancelCreation();
    this._enabled = value;
    this._vertexPicker.enabled = value;
    if (this.components.ui.enabled) {
      const main2 = this.uiElement.get("main");
      main2.active = value;
    }
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible} */
  set visible(value) {
    this._visible = value;
    if (!this._visible) {
      this.enabled = false;
    }
    for (const dimension of this._measurements) {
      dimension.visible = this._visible;
    }
  }
  /**
   * The [Color](https://threejs.org/docs/#api/en/math/Color)
   * of the geometry of the dimensions.
   */
  set color(color2) {
    this._lineMaterial.color = color2;
  }
  constructor(components) {
    super(components);
    this.onBeforeUpdate = new Event();
    this.onAfterUpdate = new Event();
    this.onAfterCreate = new Event();
    this.onBeforeCreate = new Event();
    this.onAfterDelete = new Event();
    this.onBeforeDelete = new Event();
    this.onBeforeCancel = new Event();
    this.onAfterCancel = new Event();
    this.uiElement = new UIElement();
    this.snapDistance = 0.25;
    this._lineMaterial = new LineBasicMaterial({
      color: "#DC2626",
      linewidth: 2,
      depthTest: false
    });
    this._measurements = [];
    this._visible = true;
    this._enabled = false;
    this._temp = {
      isDragging: false,
      start: new Vector3(),
      end: new Vector3(),
      dimension: void 0
    };
    this.create = async (data) => {
      const plane = data instanceof Object3D ? data : void 0;
      if (!this._enabled)
        return;
      await this.onBeforeCreate.trigger(this);
      if (!this._temp.isDragging) {
        this.drawStart(plane);
        return;
      }
      await this.endCreation();
    };
    this.onKeyDown = (e) => {
      if (!this.enabled)
        return;
      if (e.key === "Escape") {
        if (this._temp.isDragging) {
          this.cancelCreation();
        } else {
          this.enabled = false;
        }
      }
    };
    this.components.tools.add(_LengthMeasurement.uuid, this);
    this._raycaster = new SimpleRaycaster(this.components);
    this._vertexPicker = new VertexPicker(components, {
      previewElement: this.newEndpoint(),
      snapDistance: this.snapDistance
    });
    if (components.ui.enabled) {
      this.setUI();
    }
  }
  setUI() {
    const main2 = new Button(this.components);
    this.uiElement.set({ main: main2 });
    main2.materialIcon = "straighten";
    main2.onClick.add(() => {
      if (!this.enabled) {
        this.setupEvents(true);
        main2.active = true;
        this.enabled = true;
      } else {
        this.enabled = false;
        main2.active = false;
        this.setupEvents(false);
      }
    });
  }
  /** {@link Component.get} */
  get() {
    return this._measurements;
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.setupEvents(false);
    this.enabled = false;
    this.onBeforeUpdate.reset();
    this.onAfterUpdate.reset();
    this.onBeforeCreate.reset();
    this.onAfterCreate.reset();
    this.onBeforeDelete.reset();
    this.onAfterDelete.reset();
    this.onBeforeCancel.reset();
    this.onAfterCancel.reset();
    this.uiElement.dispose();
    if (this.previewElement) {
      this.previewElement.remove();
    }
    for (const measure of this._measurements) {
      await measure.dispose();
    }
    this._lineMaterial.dispose();
    this._measurements = [];
    await this._vertexPicker.dispose();
  }
  /** {@link Updateable.update} */
  async update(_delta) {
    if (this._enabled) {
      await this.onBeforeUpdate.trigger(this);
      if (this._temp.isDragging) {
        this.drawInProcess();
      }
      await this.onAfterUpdate.trigger(this);
    }
  }
  /** Deletes the dimension that the user is hovering over with the mouse or touch event. */
  async delete() {
    if (!this._enabled || this._measurements.length === 0)
      return;
    const boundingBoxes = this.getBoundingBoxes();
    const intersect = this._raycaster.castRay(boundingBoxes);
    if (!intersect)
      return;
    const dimension = this._measurements.find((dim) => dim.boundingBox === intersect.object);
    if (dimension) {
      const index = this._measurements.indexOf(dimension);
      this._measurements.splice(index, 1);
      await dimension.dispose();
      await this.onAfterDelete.trigger(this);
    }
  }
  /** Deletes all the dimensions that have been previously created. */
  async deleteAll() {
    for (const dim of this._measurements) {
      await dim.dispose();
      await this.onAfterDelete.trigger(this);
    }
    this._measurements = [];
  }
  /** Cancels the drawing of the current dimension. */
  cancelCreation() {
    var _a2;
    if (!this._temp.dimension)
      return;
    this._temp.isDragging = false;
    (_a2 = this._temp.dimension) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    this._temp.dimension = void 0;
  }
  drawStart(plane) {
    const items = plane ? [plane] : void 0;
    const intersects = this._raycaster.castRay(items);
    const point = this._vertexPicker.get();
    if (!(intersects && point))
      return;
    this._temp.isDragging = true;
    this._temp.start = plane ? intersects.point : point;
  }
  drawInProcess() {
    const intersects = this._raycaster.castRay();
    if (!intersects)
      return;
    const found = this._vertexPicker.get();
    if (!found)
      return;
    this._temp.end = found;
    if (!this._temp.dimension) {
      this._temp.dimension = this.drawDimension();
    }
    this._temp.dimension.endPoint = this._temp.end;
  }
  async endCreation() {
    if (!this._temp.dimension)
      return;
    this._temp.dimension.createBoundingBox();
    this._measurements.push(this._temp.dimension);
    await this.onAfterCreate.trigger(this._temp.dimension);
    this._temp.dimension = void 0;
    this._temp.isDragging = false;
  }
  drawDimension() {
    return new SimpleDimensionLine(this.components, {
      start: this._temp.start,
      end: this._temp.end,
      lineMaterial: this._lineMaterial,
      endpointElement: this.newEndpoint()
    });
  }
  newEndpoint() {
    const element = document.createElement("div");
    element.className = "w-2 h-2 bg-red-600 rounded-full";
    return element;
  }
  getBoundingBoxes() {
    return this._measurements.map((dim) => dim.boundingBox).filter((box) => box !== void 0);
  }
  setupEvents(active) {
    const viewerContainer = this.components.ui.viewerContainer;
    if (active) {
      viewerContainer.addEventListener("click", this.create);
      window.addEventListener("keydown", this.onKeyDown);
    } else {
      viewerContainer.removeEventListener("click", this.create);
      window.removeEventListener("keydown", this.onKeyDown);
    }
  }
};
LengthMeasurement.uuid = "2f9bcacf-18a9-4be6-a293-e898eae64ea1";
ToolComponent.libraryUUIDs.add(LengthMeasurement.uuid);

// node_modules/openbim-components/navigation/ViewpointsManager/index.js
var ViewpointsManager = class extends Component {
  constructor(components) {
    super(components);
    this.name = "ViewpointsManager";
    this.uiElement = new UIElement();
    this.enabled = true;
    this.list = [];
    this.selectionHighlighter = "";
    this.onViewpointViewed = new Event();
    this.onViewpointAdded = new Event();
    this.components = components;
  }
  initialize(config) {
    this.selectionHighlighter = config.selectionHighlighter;
    this._drawManager = config.drawManager;
    if (this.components.ui.enabled) {
      this.setUI();
    }
  }
  setUI() {
    const viewerContainer = this.components.renderer.get().domElement.parentElement;
    const window2 = new FloatingWindow(this.components);
    window2.title = "Viewpoints";
    viewerContainer.append(window2.get());
    window2.visible = false;
    const main2 = new Button(this.components, {
      materialIconName: "photo_camera"
    });
    const newButton = new Button(this.components, {
      materialIconName: "add",
      name: "New viewpoint"
    });
    const listButton = new Button(this.components, {
      materialIconName: "format_list_bulleted",
      name: "Viewpoints list"
    });
    listButton.onClick.add(() => {
      window2.visible = !window2.visible;
    });
    main2.addChild(listButton, newButton);
    this.uiElement.set({ main: main2, newButton, window: window2 });
  }
  get() {
    throw new Error("Method not implemented.");
  }
  async add(data) {
    var _a2;
    const { title, description } = data;
    if (!title) {
      return void 0;
    }
    const guid = generateUUID().toLowerCase();
    const dimensions = [];
    const dimensionsComp = await this.components.tools.get(LengthMeasurement);
    const allDimensions = dimensionsComp.get();
    for (const dimension of allDimensions) {
      dimensions.push({ start: dimension.start, end: dimension.end });
    }
    const highlighter = await this.components.tools.get(FragmentHighlighter);
    const selection = highlighter.selection[this.selectionHighlighter];
    const camera = this.components.camera;
    const controls = camera.controls;
    const target = new Vector3();
    const position = new Vector3();
    controls.getTarget(target);
    controls.getPosition(position);
    const projection = camera.getProjection();
    const annotations = (_a2 = this._drawManager) === null || _a2 === void 0 ? void 0 : _a2.saveDrawing(guid);
    const viewpoint = {
      guid,
      title,
      target,
      position,
      selection,
      // filter,
      description,
      dimensions,
      annotations,
      projection
    };
    const card = new SimpleUICard(this.components, viewpoint.guid);
    card.title = title;
    card.description = description;
    card.domElement.onclick = () => this.view(viewpoint.guid);
    this.uiElement.get("window").addChild(card);
    this.list.push(viewpoint);
    await this.onViewpointAdded.trigger(guid);
    return viewpoint;
  }
  retrieve(guid) {
    return this.list.find((v3) => v3.guid === guid);
  }
  async view(guid) {
    const viewpoint = this.retrieve(guid);
    if (!viewpoint) {
      return;
    }
    if (this._drawManager && viewpoint.annotations) {
      this._drawManager.viewport.clear();
      this._drawManager.enabled = true;
      this._drawManager.viewport.get().append(viewpoint.annotations);
    }
    const dimensionsComponent = this.components.tools.get(LengthMeasurement);
    viewpoint.dimensions.forEach((data) => {
      const dimension = new SimpleDimensionLine(this.components, {
        start: data.start,
        end: data.end,
        // @ts-ignore
        lineMaterial: dimensionsComponent._lineMaterial,
        // @ts-ignore
        endpoint: dimensionsComponent._endpointMesh
      });
      dimension.createBoundingBox();
      dimensionsComponent._dimensions.push(dimension);
    });
    const selection = {};
    for (const fragmentID in viewpoint.selection) {
      selection[fragmentID] = viewpoint.selection[fragmentID];
    }
    const highlighter = await this.components.tools.get(FragmentHighlighter);
    await highlighter.highlightByID(this.selectionHighlighter, selection, true);
    const camera = this.components.camera;
    const controls = camera.controls;
    controls.setLookAt(viewpoint.position.x, viewpoint.position.y, viewpoint.position.z, viewpoint.target.x, viewpoint.target.y, viewpoint.target.z, true);
    await this.onViewpointViewed.trigger(guid);
  }
};

// node_modules/openbim-components/navigation/CubeMap/index.js
var CubeMap = class _CubeMap extends Component {
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (this._visible) {
      this._cubeWrapper.classList.remove("hidden");
    } else {
      this._cubeWrapper.classList.add("hidden");
    }
  }
  constructor(components) {
    var _a2;
    super(components);
    this.enabled = true;
    this.onAfterUpdate = new Event();
    this.onBeforeUpdate = new Event();
    this.offset = 1;
    this._cubeFaceClass = "flex justify-center font-bold hover:bg-ifcjs-200 hover:text-ifcjs-100 text-white select-none text-xl items-center cursor-pointer text-center text-ifcjs-100 absolute w-[60px] h-[60px] border-solid border-ifcjs-120";
    this._cyan = "bg-[#3CE6FEDD]";
    this._pink = "bg-[#BD4BF3DD]";
    this._blue = "bg-[#201491DD]";
    this._cube = document.createElement("div");
    this._cubeWrapper = document.createElement("div");
    this._matrix = new Matrix4();
    this._faceOrientations = {
      front: new Vector3(0, 0, 1),
      top: new Vector3(0, 1, 0),
      bottom: new Vector3(0, -1, 0),
      right: new Vector3(1, 0, 0),
      left: new Vector3(-1, 0, 0),
      back: new Vector3(0, 0, -1)
    };
    this.update = () => {
      this._matrix.extractRotation(this._camera.get().matrixWorldInverse);
      this._cube.style.transform = `translateZ(-300px) ${this.getCameraCSSMatrix(this._matrix)}`;
    };
    this.components.tools.add(_CubeMap.uuid, this);
    this._cubeWrapper.id = "tooeen-cube-map";
    this._cubeWrapper.className = "absolute z-10";
    this.setPosition("bottom-right");
    this._cube.className = "w-[60px] h-[60px] relative";
    this.setSize("400");
    this._cube.style.transformStyle = "preserve-3d";
    this._cube.style.transform = "translateZ(-300px)";
    this._cube.style.textTransform = "uppercase";
    this._cubeWrapper.append(this._cube);
    if (components.camera.isUpdateable()) {
      components.camera.onAfterUpdate.add(this.update);
    }
    const frontFace = document.createElement("div");
    frontFace.id = "cube-map-front";
    frontFace.className = `${this._cubeFaceClass} ${this._cyan}`;
    frontFace.style.transform = "rotateX(180deg) translateZ(-30px)";
    frontFace.style.transition = "all 0.2s";
    frontFace.onclick = () => this.orientToFace("front");
    const topFace = document.createElement("div");
    topFace.className = `${this._cubeFaceClass} ${this._pink}`;
    topFace.style.transform = "rotateX(90deg) translateZ(-30px)";
    topFace.style.transition = "all 0.2s";
    topFace.onclick = () => this.orientToFace("top");
    const bottomFace = document.createElement("div");
    bottomFace.className = `${this._cubeFaceClass} ${this._pink}`;
    bottomFace.style.transform = "rotateX(270deg) translateZ(-30px)";
    bottomFace.style.transition = "all 0.2s";
    bottomFace.onclick = () => this.orientToFace("bottom");
    const rightFace = document.createElement("div");
    rightFace.className = `${this._cubeFaceClass} ${this._blue}`;
    rightFace.style.transform = "rotateY(-270deg) rotateX(180deg) translateZ(-30px)";
    rightFace.style.transition = "all 0.2s";
    rightFace.onclick = () => this.orientToFace("right");
    const leftFace = document.createElement("div");
    leftFace.className = `${this._cubeFaceClass} ${this._blue}`;
    leftFace.style.transform = "rotateY(-90deg) rotateX(180deg) translateZ(-30px)";
    leftFace.style.transition = "all 0.2s";
    leftFace.onclick = () => this.orientToFace("left");
    const backFace = document.createElement("div");
    backFace.className = `${this._cubeFaceClass} ${this._cyan}`;
    backFace.style.transform = "translateZ(-30px) rotateZ(180deg)";
    backFace.style.transition = "all 0.2s";
    backFace.onclick = () => this.orientToFace("back");
    this._cube.append(frontFace, topFace, bottomFace, rightFace, leftFace, backFace);
    (_a2 = this._viewerContainer) === null || _a2 === void 0 ? void 0 : _a2.append(this._cubeWrapper);
    this.visible = true;
  }
  async dispose() {
    this.onAfterUpdate.reset();
    this.onBeforeUpdate.reset();
    this._cube.remove();
    this._cubeWrapper.remove();
    this.components = null;
  }
  setSize(value = "350") {
    this._cubeWrapper.style.perspective = `${value}px`;
  }
  setPosition(corner) {
    this._cubeWrapper.classList.remove("top-8", "bottom-8", "left-8", "right-8");
    const wrapperPositions = {
      "top-left": ["top-8", "left-8"],
      "top-right": ["top-8", "right-8"],
      "bottom-right": ["bottom-8", "right-8"],
      "bottom-left": ["bottom-8", "left-8"]
    };
    this._cubeWrapper.classList.add(...wrapperPositions[corner]);
  }
  orientToFace(orientation) {
    const camera = this._camera.get();
    if (this._camera instanceof OrthoPerspectiveCamera) {
      const controls = this._camera.controls;
      const projection = this._camera.getProjection();
      const target = camera.position.clone().add(this._faceOrientations[orientation].clone().multiplyScalar(-1));
      const { x, y, z } = camera.position;
      if (projection === "Perspective") {
        controls.setLookAt(x, y, z, target.x, target.y, target.z, true);
      } else {
        const pos = new Vector3();
        if (orientation === "top")
          pos.set(0, 200, 0);
        if (orientation === "bottom")
          pos.set(0, -200, 0);
        if (orientation === "left")
          pos.set(-200, 0, 0);
        if (orientation === "right")
          pos.set(200, 0, 0);
        if (orientation === "front")
          pos.set(0, 0, 200);
        if (orientation === "back")
          pos.set(0, 0, -200);
        controls.setPosition(pos.x, pos.y, pos.z, true);
        controls.setTarget(0, 0, 0, true);
      }
      this._camera.fit(void 0, this.offset);
    }
  }
  get _viewerContainer() {
    return this.components.renderer.get().domElement.parentElement;
  }
  get _camera() {
    return this.components.camera;
  }
  getCameraCSSMatrix(matrix) {
    const { elements } = matrix;
    const epsilon = (value) => {
      return Math.abs(value) < 1e-10 ? 0 : value;
    };
    return `matrix3d(
            ${epsilon(elements[0])},
            ${epsilon(-elements[1])},
            ${epsilon(elements[2])},
            ${epsilon(elements[3])},
            ${epsilon(elements[4])},
            ${epsilon(-elements[5])},
            ${epsilon(elements[6])},
            ${epsilon(elements[7])},
            ${epsilon(elements[8])},
            ${epsilon(-elements[9])},
            ${epsilon(elements[10])},
            ${epsilon(elements[11])},
            ${epsilon(elements[12])},
            ${epsilon(-elements[13])},
            ${epsilon(elements[14])},
            ${epsilon(elements[15])})
        `;
  }
  get() {
    return this._cubeWrapper;
  }
};
CubeMap.uuid = "53311ea3-323a-476f-ae4a-d681778e8f67";
ToolComponent.libraryUUIDs.add(CubeMap.uuid);

// node_modules/openbim-components/navigation/MiniMap/index.js
var MiniMap = class _MiniMap extends Component {
  get lockRotation() {
    return this._lockRotation;
  }
  set lockRotation(active) {
    this._lockRotation = active;
    if (active) {
      this._camera.rotation.z = 0;
    }
  }
  get zoom() {
    return this._camera.zoom;
  }
  set zoom(value) {
    this._camera.zoom = value;
    this._camera.updateProjectionMatrix();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(active) {
    this._enabled = active;
    const canvas = this.uiElement.get("canvas");
    canvas.visible = active;
  }
  constructor(components) {
    super(components);
    this.uiElement = new UIElement();
    this.onAfterUpdate = new Event();
    this.onBeforeUpdate = new Event();
    this.onResize = new Event();
    this.frontOffset = 0;
    this.overrideMaterial = new MeshDepthMaterial();
    this.backgroundColor = new Color(395274);
    this._enabled = true;
    this._lockRotation = true;
    this._size = new Vector2(320, 160);
    this._tempVector1 = new Vector3();
    this._tempVector2 = new Vector3();
    this._tempTarget = new Vector3();
    this.down = new Vector3(0, -1, 0);
    this.updatePlanes = () => {
      const planes = [];
      const renderer = this._components.renderer.get();
      for (const plane of renderer.clippingPlanes) {
        planes.push(plane);
      }
      planes.push(this._plane);
      this._renderer.clippingPlanes = planes;
    };
    this.components.tools.add(_MiniMap.uuid, this);
    const main2 = new Button(components);
    const canvas = new Canvas(components);
    this.uiElement.set({ main: main2, canvas });
    main2.materialIcon = "map";
    main2.onClick.add(() => {
      canvas.visible = !canvas.visible;
    });
    const range = new RangeInput(components);
    canvas.addChild(range);
    this._components = components;
    const htmlCanvas = canvas.get();
    this._renderer = new WebGLRenderer({ canvas: htmlCanvas });
    this._renderer.setSize(this._size.x, this._size.y);
    const frustumSize = 1;
    const aspect = this._size.x / this._size.y;
    this._camera = new OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2);
    this._components.renderer.onClippingPlanesUpdated.add(this.updatePlanes);
    this._camera.position.set(0, 200, 0);
    this._camera.zoom = 0.1;
    this._camera.rotation.x = -Math.PI / 2;
    this._plane = new Plane(this.down, 200);
    this.updatePlanes();
  }
  async dispose() {
    this.enabled = false;
    this.uiElement.dispose();
    this.onBeforeUpdate.reset();
    this.onAfterUpdate.reset();
    this.onResize.reset();
    this.overrideMaterial.dispose();
    this._renderer.dispose();
  }
  get() {
    return this._camera;
  }
  async update() {
    if (!this.enabled)
      return;
    await this.onBeforeUpdate.trigger();
    const scene = this._components.scene.get();
    const cameraComponent = this._components.camera;
    const controls = cameraComponent.controls;
    controls.getPosition(this._tempVector1);
    this._camera.position.x = this._tempVector1.x;
    this._camera.position.z = this._tempVector1.z;
    if (this.frontOffset !== 0) {
      controls.getTarget(this._tempVector2);
      this._tempVector2.sub(this._tempVector1);
      this._tempVector2.normalize().multiplyScalar(this.frontOffset);
      this._camera.position.x += this._tempVector2.x;
      this._camera.position.z += this._tempVector2.z;
    }
    if (!this._lockRotation) {
      controls.getTarget(this._tempTarget);
      const angle = Math.atan2(this._tempTarget.x - this._tempVector1.x, this._tempTarget.z - this._tempVector1.z);
      this._camera.rotation.z = angle + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const previousBackground = scene.background;
    scene.background = this.backgroundColor;
    this._renderer.render(scene, this._camera);
    scene.background = previousBackground;
    await this.onAfterUpdate.trigger();
  }
  getSize() {
    const canvas = this.uiElement.get("canvas");
    return canvas.getSize();
  }
  async resize(size) {
    const canvas = this.uiElement.get("canvas");
    if (size) {
      this._size.copy(size);
      canvas.resize(size);
      this._renderer.setSize(size.x, size.y);
      const aspect = size.x / size.y;
      const frustumSize = 1;
      this._camera.left = frustumSize * aspect / -2;
      this._camera.right = frustumSize * aspect / 2;
      this._camera.top = frustumSize / 2;
      this._camera.bottom = -frustumSize / 2;
      this._camera.updateProjectionMatrix();
      await this.onResize.trigger(size);
    }
  }
};
MiniMap.uuid = "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f";
ToolComponent.libraryUUIDs.add(MiniMap.uuid);

// node_modules/openbim-components/annotation/SVGArrow/index.js
var SVGArrow = class _SVGArrow extends Component {
  constructor(components, startPoint, endPoint) {
    super(components);
    this.name = "SVGRectangle";
    this.enabled = true;
    this.id = tooeenRandomId();
    this._line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    this._polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    this._marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    this._arrow = document.createElementNS("http://www.w3.org/2000/svg", "g");
    this._startPoint = new Vector2();
    this._endPoint = new Vector2();
    this._marker.setAttribute("id", `${this.id}-arrowhead`);
    this._marker.setAttribute("markerWidth", "5");
    this._marker.setAttribute("markerHeight", "6");
    this._marker.setAttribute("refX", "4");
    this._marker.setAttribute("refY", "3");
    this._marker.setAttribute("orient", "auto");
    this._polygon.setAttribute("points", "0 0, 5 3, 0 6");
    this._marker.appendChild(this._polygon);
    this._line.setAttribute("marker-end", `url(#${this.id}-arrowhead)`);
    this._arrow.append(this._marker, this._line);
    this.startPoint = startPoint !== null && startPoint !== void 0 ? startPoint : this.startPoint;
    this.endPoint = endPoint !== null && endPoint !== void 0 ? endPoint : this.endPoint;
    this._arrow.id = this.id;
    this.setStyle();
  }
  async dispose() {
    this._arrow.remove();
    this._marker.remove();
    this._polygon.remove();
    this._line.remove();
    this.components = null;
  }
  setStyle(style) {
    var _a2, _b2, _c, _d;
    this._line.setAttribute("stroke", (_a2 = style === null || style === void 0 ? void 0 : style.strokeColor) !== null && _a2 !== void 0 ? _a2 : "red");
    this._line.setAttribute("stroke-width", (_c = (_b2 = style === null || style === void 0 ? void 0 : style.strokeWidth) === null || _b2 === void 0 ? void 0 : _b2.toString()) !== null && _c !== void 0 ? _c : "4");
    this._polygon.setAttribute("fill", (_d = style === null || style === void 0 ? void 0 : style.strokeColor) !== null && _d !== void 0 ? _d : "red");
  }
  reset() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
  }
  clone() {
    return new _SVGArrow(this.components, this.startPoint, this.endPoint);
  }
  set x1(value) {
    this._startPoint.x = value;
    this._line.setAttribute("x1", value.toString());
  }
  set y1(value) {
    this._startPoint.y = value;
    this._line.setAttribute("y1", value.toString());
  }
  set startPoint(point) {
    this.x1 = point.x;
    this.y1 = point.y;
  }
  get startPoint() {
    return this._startPoint;
  }
  set x2(value) {
    this._endPoint.x = value;
    this._line.setAttribute("x2", value.toString());
  }
  set y2(value) {
    this._endPoint.y = value;
    this._line.setAttribute("y2", value.toString());
  }
  set endPoint(point) {
    this.x2 = point.x;
    this.y2 = point.y;
  }
  get endPoint() {
    return this._endPoint;
  }
  get() {
    return this._arrow;
  }
};

// node_modules/openbim-components/annotation/ArrowAnnotation/index.js
var ArrowAnnotation = class extends BaseSVGAnnotation {
  constructor(components, drawManager) {
    super(components);
    this.name = "ArrowAnnotation";
    this.canvas = null;
    this.uiElement = new UIElement();
    this.cancel = () => {
      if (!this._isDrawing) {
        return;
      }
      this._isDrawing = false;
      this._previewElement.reset();
      this._previewElement.get().remove();
    };
    this.start = (event) => {
      var _a2, _b2, _c, _d;
      if (!this.canDraw) {
        return void 0;
      }
      if (!this._isDrawing) {
        this._isDrawing = true;
        this._previewElement.setStyle((_a2 = this.drawManager) === null || _a2 === void 0 ? void 0 : _a2.viewport.config);
        this._previewElement.x1 = event.clientX;
        this._previewElement.y1 = event.clientY;
        this._previewElement.x2 = event.clientX;
        this._previewElement.y2 = event.clientY;
        (_b2 = this.svgViewport) === null || _b2 === void 0 ? void 0 : _b2.append(this._previewElement.get());
      } else {
        const arrow2 = this._previewElement.clone();
        arrow2.setStyle((_c = this.drawManager) === null || _c === void 0 ? void 0 : _c.viewport.config);
        (_d = this.svgViewport) === null || _d === void 0 ? void 0 : _d.append(arrow2.get());
        this.cancel();
        return arrow2;
      }
      return void 0;
    };
    this.draw = (e) => {
      if (!this.canDraw || !this._isDrawing) {
        return;
      }
      this._previewElement.x1 = e.clientX;
      this._previewElement.y1 = e.clientY;
    };
    this._previewElement = new SVGArrow(components);
    this.drawManager = drawManager;
    const main2 = new Button(components);
    this.uiElement.set({ main: main2 });
    main2.label = "Arrow";
    main2.materialIcon = "north_east";
    main2.onClick.add(() => {
      if (this.drawManager) {
        this.drawManager.activateTool(this);
      } else {
        this.enabled = !this.enabled;
      }
    });
  }
  async dispose() {
    await super.dispose();
    this._previewElement.dispose();
  }
};

// node_modules/openbim-components/annotation/SVGCircle/index.js
var SVGCircle = class _SVGCircle extends Component {
  constructor(components, centerPoint, radius) {
    super(components);
    this.id = tooeenRandomId();
    this.name = "SVGRectangle";
    this.enabled = true;
    this._circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this._centerPoint = new Vector2();
    this._radius = 20;
    this.centerPoint = centerPoint !== null && centerPoint !== void 0 ? centerPoint : this.centerPoint;
    this.radius = radius !== null && radius !== void 0 ? radius : this.radius;
    this._circle.id = this.id;
    this.setStyle();
  }
  async dispose() {
    this._circle.remove();
    this.components = null;
  }
  setStyle(style) {
    var _a2, _b2, _c, _d;
    this._circle.setAttribute("stroke", (_a2 = style === null || style === void 0 ? void 0 : style.strokeColor) !== null && _a2 !== void 0 ? _a2 : "red");
    this._circle.setAttribute("stroke-width", (_c = (_b2 = style === null || style === void 0 ? void 0 : style.strokeWidth) === null || _b2 === void 0 ? void 0 : _b2.toString()) !== null && _c !== void 0 ? _c : "4");
    this._circle.setAttribute("fill", (_d = style === null || style === void 0 ? void 0 : style.fillColor) !== null && _d !== void 0 ? _d : "transparent");
  }
  reset() {
    this.cx = 0;
    this.cy = 0;
    this.radius = 0;
  }
  clone() {
    return new _SVGCircle(this.components, this.centerPoint, this.radius);
  }
  set radius(value) {
    this._radius = value;
    this._circle.setAttribute("r", value.toString());
  }
  get radius() {
    return this._radius;
  }
  set cx(value) {
    this._centerPoint.x = value;
    this._circle.setAttribute("cx", value.toString());
  }
  set cy(value) {
    this._centerPoint.y = value;
    this._circle.setAttribute("cy", value.toString());
  }
  set centerPoint(point) {
    this.cx = point.x;
    this.cy = point.y;
  }
  get centerPoint() {
    return this._centerPoint;
  }
  get() {
    return this._circle;
  }
};

// node_modules/openbim-components/annotation/CircleAnnotation/index.js
var CircleAnnotation = class extends BaseSVGAnnotation {
  constructor(components, drawManager) {
    super(components);
    this.name = "CircleAnnotation";
    this.canvas = null;
    this.uiElement = new UIElement();
    this._cursorPosition = new Vector2();
    this.start = (e) => {
      var _a2, _b2, _c, _d;
      if (!this.canDraw) {
        return void 0;
      }
      if (!this._isDrawing) {
        this._isDrawing = true;
        this._previewElement.setStyle((_a2 = this.drawManager) === null || _a2 === void 0 ? void 0 : _a2.viewport.config);
        this._previewElement.cx = e.clientX;
        this._previewElement.cy = e.clientY;
        (_b2 = this.svgViewport) === null || _b2 === void 0 ? void 0 : _b2.append(this._previewElement.get());
      } else {
        const circle = this._previewElement.clone();
        circle.setStyle((_c = this.drawManager) === null || _c === void 0 ? void 0 : _c.viewport.config);
        (_d = this.svgViewport) === null || _d === void 0 ? void 0 : _d.append(circle.get());
        this.cancel();
        return circle;
      }
      return void 0;
    };
    this.cancel = () => {
      if (!this._isDrawing) {
        return;
      }
      this._isDrawing = false;
      this._previewElement.reset();
      this._previewElement.get().remove();
    };
    this.draw = (e) => {
      if (!this.canDraw || !this._isDrawing) {
        return;
      }
      this._cursorPosition.x = e.clientX;
      this._cursorPosition.y = e.clientY;
      this._previewElement.radius = this._cursorPosition.distanceTo(this._previewElement.centerPoint);
    };
    this._previewElement = new SVGCircle(components);
    this.drawManager = drawManager;
    const main2 = new Button(components);
    this.uiElement.set({ main: main2 });
    main2.label = "Circle";
    main2.materialIcon = "radio_button_unchecked";
    main2.onClick.add(() => {
      if (this.drawManager) {
        this.drawManager.activateTool(this);
      } else {
        this.enabled = !this.enabled;
      }
    });
  }
  async dispose() {
    await super.dispose();
    this._previewElement.dispose();
  }
};

// node_modules/openbim-components/annotation/SVGText/index.js
var SVGText = class _SVGText extends Component {
  constructor(components, text, startPoint) {
    super(components);
    this.id = tooeenRandomId();
    this.name = "SVGRectangle";
    this.enabled = true;
    this._startPoint = new Vector2();
    this._text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    this._text.setAttribute("fill", "red");
    this._text.classList.add("text-2xl", "font-medium");
    this.text = text !== null && text !== void 0 ? text : "";
    this.startPoint = startPoint !== null && startPoint !== void 0 ? startPoint : this.startPoint;
    this._text.id = this.id;
  }
  async dispose() {
    this._text.remove();
  }
  setStyle(style) {
    var _a2;
    this._text.setAttribute("fill", (_a2 = style === null || style === void 0 ? void 0 : style.strokeColor) !== null && _a2 !== void 0 ? _a2 : "red");
  }
  set text(value) {
    this._text.textContent = value;
  }
  get text() {
    var _a2;
    return (_a2 = this._text.textContent) !== null && _a2 !== void 0 ? _a2 : "";
  }
  reset() {
    this.x = 0;
    this.y = 0;
  }
  clone() {
    return new _SVGText(this.components, this.text, this.startPoint);
  }
  set x(value) {
    this._startPoint.x = value;
    this._text.setAttribute("x", value.toString());
  }
  set y(value) {
    this._startPoint.y = value;
    this._text.setAttribute("y", value.toString());
  }
  set startPoint(point) {
    this.x = point.x;
    this.y = point.y;
  }
  get startPoint() {
    return this._startPoint;
  }
  get() {
    return this._text;
  }
};

// node_modules/openbim-components/annotation/TextAnnotation/index.js
var TextAnnotation = class extends BaseSVGAnnotation {
  constructor(components, drawManager) {
    super(components);
    this.name = "TextAnnotation";
    this.uiElement = new UIElement();
    this.canvas = null;
    this.cancel = () => {
      if (!this._isDrawing) {
        return;
      }
      this._isDrawing = false;
      this._previewElement.reset();
      this._previewElement.get().remove();
    };
    this.start = (e) => {
      var _a2, _b2, _c, _d;
      if (!this.canDraw) {
        return void 0;
      }
      if (!this._isDrawing) {
        this._isDrawing = true;
        const text = prompt("Enter your text", this._previewElement.text);
        if (!text) {
          this.cancel();
          return void 0;
        }
        this._previewElement.setStyle((_a2 = this.drawManager) === null || _a2 === void 0 ? void 0 : _a2.viewport.config);
        this._previewElement.text = text;
        this._previewElement.x = e.clientX;
        this._previewElement.y = e.clientY;
        (_b2 = this.svgViewport) === null || _b2 === void 0 ? void 0 : _b2.append(this._previewElement.get());
      } else {
        const text = this._previewElement.clone();
        text.setStyle((_c = this.drawManager) === null || _c === void 0 ? void 0 : _c.viewport.config);
        (_d = this.svgViewport) === null || _d === void 0 ? void 0 : _d.append(text.get());
        this.cancel();
        return text;
      }
      return void 0;
    };
    this.draw = (e) => {
      if (!this.canDraw || !this._isDrawing) {
        return;
      }
      this._previewElement.x = e.clientX;
      this._previewElement.y = e.clientY;
    };
    this._previewElement = new SVGText(components);
    this.drawManager = drawManager;
    const main2 = new Button(components);
    this.uiElement.set({ main: main2 });
    main2.label = "Text";
    main2.materialIcon = "title";
    main2.onClick.add(() => {
      if (this.drawManager) {
        this.drawManager.activateTool(this);
      } else {
        this.enabled = !this.enabled;
      }
    });
  }
  async dispose() {
    await super.dispose();
    await this._previewElement.dispose();
  }
};

// node_modules/openbim-components/annotation/SVGRectangle/index.js
var SVGRectangle = class _SVGRectangle extends Component {
  constructor(components, startPoint, endPoint) {
    super(components);
    this.id = tooeenRandomId();
    this.name = "SVGRectangle";
    this.enabled = true;
    this._startPoint = new Vector2();
    this._endPoint = new Vector2();
    this._dimensions = new Vector2();
    this._rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    this.startPoint = startPoint !== null && startPoint !== void 0 ? startPoint : this.startPoint;
    this.endPoint = endPoint !== null && endPoint !== void 0 ? endPoint : this.endPoint;
    this._rect.setAttribute("rx", "5");
    this._rect.id = this.id;
    this.setStyle();
  }
  async dispose() {
    this._rect.remove();
    this.components = null;
  }
  setStyle(style) {
    var _a2, _b2, _c, _d;
    this._rect.setAttribute("stroke", (_a2 = style === null || style === void 0 ? void 0 : style.strokeColor) !== null && _a2 !== void 0 ? _a2 : "red");
    this._rect.setAttribute("stroke-width", (_c = (_b2 = style === null || style === void 0 ? void 0 : style.strokeWidth) === null || _b2 === void 0 ? void 0 : _b2.toString()) !== null && _c !== void 0 ? _c : "4");
    this._rect.setAttribute("fill", (_d = style === null || style === void 0 ? void 0 : style.fillColor) !== null && _d !== void 0 ? _d : "transparent");
  }
  reset() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
  }
  clone() {
    return new _SVGRectangle(this.components, this.startPoint, this.endPoint);
  }
  set x1(value) {
    this._startPoint.x = value;
    this._rect.setAttribute("x", value.toString());
  }
  set y1(value) {
    this._startPoint.y = value;
    this._rect.setAttribute("y", value.toString());
  }
  set startPoint(point) {
    this.x1 = point.x;
    this.y1 = point.y;
  }
  get startPoint() {
    return this._startPoint;
  }
  set x2(value) {
    const lessThanStart = value < this.startPoint.x;
    this._endPoint.x = lessThanStart ? this.startPoint.x : value;
    this.x1 = lessThanStart ? value : this.startPoint.x;
    this._dimensions.x = this.endPoint.x - this.startPoint.x;
    this._rect.setAttribute("width", this._dimensions.x.toString());
  }
  set y2(value) {
    const lessThanStart = value < this.startPoint.y;
    this._endPoint.y = lessThanStart ? this.startPoint.y : value;
    this.y1 = lessThanStart ? value : this.startPoint.y;
    this._dimensions.y = this.endPoint.y - this.startPoint.y;
    this._rect.setAttribute("height", this._dimensions.y.toString());
  }
  set endPoint(point) {
    this.x2 = point.x;
    this.y2 = point.y;
  }
  get endPoint() {
    return this._endPoint;
  }
  set width(value) {
    this.x2 = this.startPoint.x + value;
  }
  get width() {
    return this._dimensions.x;
  }
  set height(value) {
    this.y2 = this.startPoint.y + value;
  }
  get height() {
    return this._dimensions.y;
  }
  set dimensions(value) {
    this.width = value.x;
    this.height = value.y;
  }
  get dimensions() {
    return this._dimensions;
  }
  get() {
    return this._rect;
  }
};

// node_modules/openbim-components/annotation/RectangleAnnotation/index.js
var RectangleAnnotation = class extends BaseSVGAnnotation {
  constructor(components, drawManager) {
    super(components);
    this.name = "RectangleAnnotation";
    this.canvas = null;
    this.uiElement = new UIElement();
    this._startPoint = new Vector2();
    this.start = (e) => {
      var _a2, _b2, _c, _d;
      if (!this.canDraw) {
        return void 0;
      }
      if (!this._isDrawing) {
        this._isDrawing = true;
        this._previewElement.setStyle((_a2 = this.drawManager) === null || _a2 === void 0 ? void 0 : _a2.viewport.config);
        this._startPoint.set(e.clientX, e.clientY);
        (_b2 = this.svgViewport) === null || _b2 === void 0 ? void 0 : _b2.append(this._previewElement.get());
      } else {
        const rectangle = this._previewElement.clone();
        rectangle.setStyle((_c = this.drawManager) === null || _c === void 0 ? void 0 : _c.viewport.config);
        (_d = this.svgViewport) === null || _d === void 0 ? void 0 : _d.append(rectangle.get());
        this.cancel();
        return rectangle;
      }
      return void 0;
    };
    this.cancel = () => {
      if (!this._isDrawing) {
        return;
      }
      this._isDrawing = false;
      this._startPoint.x = 0;
      this._startPoint.y = 0;
      this._previewElement.reset();
      this._previewElement.get().remove();
    };
    this.draw = (e) => {
      if (!this.canDraw || !this._isDrawing) {
        return;
      }
      this._previewElement.x1 = this._startPoint.x;
      this._previewElement.y1 = this._startPoint.y;
      this._previewElement.x2 = e.clientX;
      this._previewElement.y2 = e.clientY;
    };
    this._previewElement = new SVGRectangle(components);
    this.drawManager = drawManager;
    const main2 = new Button(components);
    this.uiElement.set({ main: main2 });
    main2.label = "Rectangle";
    main2.materialIcon = "crop_square";
    main2.onClick.add(() => {
      if (this.drawManager) {
        this.drawManager.activateTool(this);
      } else {
        this.enabled = !this.enabled;
      }
    });
  }
  async dispose() {
    await super.dispose();
    this._previewElement.dispose();
  }
};

// node_modules/openbim-components/annotation/DrawManager/index.js
var DrawManager = class extends Component {
  get isDrawing() {
    return this._isDrawing;
  }
  set isDrawing(value) {
    this._isDrawing = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this.uiElement.get("main").active = value;
    this.uiElement.get("drawingTools").visible = value;
    this.viewport.enabled = value;
  }
  constructor(components) {
    super(components);
    this.name = "DrawManager";
    this.uiElement = new UIElement();
    this.drawingTools = {};
    this.drawings = {};
    this._enabled = false;
    this._isDrawing = false;
    this.viewport = new SimpleSVGViewport(components);
    this.setUI();
    this.enabled = false;
  }
  async dispose() {
    this.uiElement.dispose();
    await this.viewport.dispose();
    for (const name in this.drawings) {
      this.drawings[name].remove();
    }
    this.drawings = {};
    this.components = null;
  }
  saveDrawing(name) {
    const currentDrawing = this.drawings[name];
    currentDrawing === null || currentDrawing === void 0 ? void 0 : currentDrawing.childNodes.forEach((child) => currentDrawing.removeChild(child));
    const drawing = this.viewport.getDrawing();
    const group = currentDrawing !== null && currentDrawing !== void 0 ? currentDrawing : document.createElementNS("http://www.w3.org/2000/svg", "g");
    group.id = name;
    group.append(...drawing);
    this.viewport.get().append(group);
    this.drawings[name] = group;
    return group;
  }
  addDrawingTool(name, tool) {
    const existingTool = this.drawingTools[name];
    if (!existingTool) {
      const main2 = this.uiElement.get("main");
      this.uiElement.get("drawingTools").addChild(main2);
      this.drawingTools[name] = tool;
    }
  }
  activateTool(tool) {
    const drawingTools = Object.values(this.drawingTools);
    drawingTools.forEach((tool2) => tool2.enabled = false);
    tool.enabled = true;
  }
  get activeTool() {
    const drawingTools = Object.values(this.drawingTools);
    return drawingTools.find((tool) => tool.enabled === true);
  }
  setUI() {
    const drawingTools = new Toolbar(this.components, { position: "top" });
    this.components.ui.addToolbar(drawingTools);
    const main2 = new Button(this.components);
    main2.materialIcon = "gesture";
    main2.onClick.add(() => this.enabled = !this.enabled);
    this.uiElement.set({ drawingTools, main: main2 });
  }
  get() {
    throw new Error("Method not implemented.");
  }
};

// node_modules/openbim-components/integrations/mapbox/index.js
var MAPBOX = __toESM(require_mapbox_gl());

// node_modules/openbim-components/integrations/mapbox/src/mapbox-renderer.js
var MapboxRenderer = class extends BaseRenderer {
  constructor(components, map, coords, rotation = new Vector3(Math.PI / 2, 0, 0)) {
    super(components);
    this.enabled = true;
    this.onBeforeUpdate = new Event();
    this.onAfterUpdate = new Event();
    this.onInitialized = new Event();
    this._labelRenderer = new CSS2DRenderer();
    this._renderer = new WebGLRenderer();
    this._initError = "Mapbox scene isn't initialized yet!";
    this.updateLabelRendererSize = () => {
      var _a2;
      if ((_a2 = this._renderer) === null || _a2 === void 0 ? void 0 : _a2.domElement) {
        this._labelRenderer.setSize(this._renderer.domElement.clientWidth, this._renderer.domElement.clientHeight);
      }
    };
    this._components = components;
    this._map = map;
    this._modelTransform = this.newModelTransform(coords, rotation);
    this.setupMap(map);
    this.setup3DBuildings();
  }
  /** {@link Component.get} */
  get() {
    return this._renderer;
  }
  /** {@link Resizeable.getSize} */
  getSize() {
    if (!this._renderer) {
      throw new Error(this._initError);
    }
    return new Vector2(this._renderer.domElement.clientWidth, this._renderer.domElement.clientHeight);
  }
  /** {@link Resizeable.resize}. Mapbox automatically handles this. */
  resize() {
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onInitialized.reset();
    this.enabled = false;
    this.setupEvents(false);
    this._renderer.dispose();
    this._map.remove();
    this._map = null;
  }
  initialize(context) {
    const canvas = this._map.getCanvas();
    const renderer = new WebGLRenderer({
      canvas,
      context,
      antialias: true
    });
    this._renderer = renderer;
    this._renderer.autoClear = false;
    this.initializeLabelRenderer();
    this.onInitialized.trigger(renderer);
  }
  setupMap(map) {
    const scene = this._components.scene.get();
    const onAdd = (_map, gl) => this.initialize(gl);
    const render = (_gl, matrix) => this.render(scene, matrix);
    const customLayer = this.newMapboxLayer(onAdd, render);
    map.on("style.load", () => {
      map.addLayer(customLayer, "waterway-label");
    });
  }
  newMapboxLayer(onAdd, render) {
    return {
      id: "3d-model",
      type: "custom",
      renderingMode: "3d",
      onAdd,
      render
    };
  }
  newModelTransform(coords, rotation) {
    return {
      translateX: coords.x,
      translateY: coords.y,
      translateZ: coords.z,
      rotateX: rotation.x,
      rotateY: rotation.y,
      rotateZ: rotation.z,
      scale: coords.meterInMercatorCoordinateUnits()
    };
  }
  // Source: https://docs.mapbox.com/mapbox-gl-js/example/add-3d-model/
  render(scene, matrix) {
    if (!this._renderer || !this.enabled)
      return;
    this.onBeforeUpdate.trigger(this);
    const rotationX = new Matrix4().makeRotationAxis(new Vector3(1, 0, 0), this._modelTransform.rotateX);
    const rotationY = new Matrix4().makeRotationAxis(new Vector3(0, 1, 0), this._modelTransform.rotateY);
    const rotationZ = new Matrix4().makeRotationAxis(new Vector3(0, 0, 1), this._modelTransform.rotateZ);
    const m2 = new Matrix4().fromArray(matrix);
    const l2 = new Matrix4().makeTranslation(this._modelTransform.translateX, this._modelTransform.translateY, this._modelTransform.translateZ).scale(new Vector3(this._modelTransform.scale, -this._modelTransform.scale, this._modelTransform.scale)).multiply(rotationX).multiply(rotationY).multiply(rotationZ);
    const camera = this._components.camera.get();
    camera.projectionMatrix = m2.multiply(l2);
    this._renderer.resetState();
    this._renderer.render(scene, camera);
    this._labelRenderer.render(scene, camera);
    this._map.triggerRepaint();
    this.onAfterUpdate.trigger(this);
  }
  initializeLabelRenderer() {
    var _a2, _b2;
    this.updateLabelRendererSize();
    this.setupEvents(true);
    this._labelRenderer.domElement.style.position = "absolute";
    this._labelRenderer.domElement.style.top = "0px";
    const dom = this._labelRenderer.domElement;
    (_b2 = (_a2 = this._renderer) === null || _a2 === void 0 ? void 0 : _a2.domElement.parentElement) === null || _b2 === void 0 ? void 0 : _b2.appendChild(dom);
  }
  // Source: https://docs.mapbox.com/mapbox-gl-js/example/3d-buildings/
  setup3DBuildings() {
    this._map.on("load", () => {
      const layers = this._map.getStyle().layers;
      const labelLayerId = layers.find((layer) => layer.type === "symbol" && layer.layout["text-field"]).id;
      this._map.addLayer({
        id: "add-3d-buildings",
        source: "composite",
        "source-layer": "building",
        filter: ["==", "extrude", "true"],
        type: "fill-extrusion",
        minzoom: 15,
        paint: {
          "fill-extrusion-color": "#aaa",
          // Use an 'interpolate' expression to
          // add a smooth transition effect to
          // the buildings as the user zooms in.
          "fill-extrusion-height": [
            "interpolate",
            ["linear"],
            ["zoom"],
            15,
            0,
            15.05,
            ["get", "height"]
          ],
          "fill-extrusion-base": [
            "interpolate",
            ["linear"],
            ["zoom"],
            15,
            0,
            15.05,
            ["get", "min_height"]
          ],
          "fill-extrusion-opacity": 0.6
        }
      }, labelLayerId);
    });
  }
  setupEvents(active) {
    if (active) {
      window.addEventListener("resize", this.updateLabelRendererSize);
    } else {
      window.removeEventListener("resize", this.updateLabelRendererSize);
    }
  }
};

// node_modules/openbim-components/integrations/mapbox/src/mapbox-camera.js
var MapboxCamera = class extends Component {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this._camera = new PerspectiveCamera();
  }
  /** {@link Component.get} */
  get() {
    return this._camera;
  }
};

// node_modules/openbim-components/integrations/mapbox/index.js
var MapboxWindow = class {
  /**
   * @param config: information needed to initialize the scene, including
   * the Mapbox access token and the HTML div element to display the scene.
   */
  constructor(config) {
    this.minTargetZoom = 15e-4;
    this._style = "mapbox://styles/mapbox/light-v10";
    this._labels = {};
    this._buildings = [];
    this._components = new Components();
    this._center = [0, 0];
    const merc = MAPBOX.MercatorCoordinate;
    const coords = merc.fromLngLat(this._center, 0);
    this._map = this.newMap(config);
    this.setupComponents(coords);
    this.setupScene();
    this.add(config.buildings);
  }
  /**
   * Add a new set of buildings to the GIS scene.
   *
   * @param buildings The array of {@link MapboxBuilding} to add.
   * @param fitToScreen Whether to center the camera to see all buildings.
   */
  add(buildings, fitToScreen = true) {
    for (const building of buildings) {
      const { id, lng, lat, htmlElement } = building;
      if (lng === void 0 || lat === void 0)
        continue;
      const label = new CSS2DObject(htmlElement);
      const center = MAPBOX.MercatorCoordinate.fromLngLat({ lng: this._center[0], lat: this._center[1] }, 0);
      const units = center.meterInMercatorCoordinateUnits();
      const model = MAPBOX.MercatorCoordinate.fromLngLat({ lng, lat }, 0);
      model.x /= units;
      model.y /= units;
      center.x /= units;
      center.y /= units;
      label.position.set(model.x - center.x, 0, model.y - center.y);
      this._components.scene.get().add(label);
      this._labels[id] = label;
      this._buildings.push(building);
    }
    if (this._buildings.length && fitToScreen) {
      this.centerMapToBuildings();
    }
  }
  /**
   * Removes a building from the map.
   *
   * @param id The {@link MapboxBuilding} to remove.
   */
  remove(id) {
    const label = this._labels[id];
    delete this._labels[id];
    label.removeFromParent();
    label.element = void 0;
    const found = this._buildings.find((building) => building.id === id);
    if (found) {
      const index = this._buildings.indexOf(found);
      this._buildings.splice(index, 1);
    }
  }
  /**
   * Removes all buildings from the map.
   */
  removeAll() {
    for (const id in this._labels) {
      this.remove(id);
    }
  }
  /**
   * Disposes all the data of the map. This needs to be called if the
   * component that contains the map is deleted: otherwise, a memory leak
   * will be created.
   */
  async dispose() {
    for (const id in this._labels) {
      const label = this._labels[id];
      label.removeFromParent();
      label.element.remove();
    }
    this._buildings = [];
    this._labels = {};
    await this._components.dispose();
    this._map = null;
    this._components = null;
  }
  centerMapToBuildings() {
    let maxLng = -Number.MAX_VALUE;
    let maxLat = -Number.MAX_VALUE;
    let minLng = Number.MAX_VALUE;
    let minLat = Number.MAX_VALUE;
    for (const building of this._buildings) {
      if (building.lng > maxLng) {
        maxLng = building.lng;
      }
      if (building.lng < minLng) {
        minLng = building.lng;
      }
      if (building.lat > maxLat) {
        maxLat = building.lat;
      }
      if (building.lat < minLat) {
        minLat = building.lat;
      }
    }
    const factor = 0.4;
    const width = Math.max(this.minTargetZoom, maxLng - minLng);
    const height = Math.max(this.minTargetZoom, maxLat - minLat);
    maxLng += factor * width;
    maxLat += factor * height;
    minLng -= factor * width;
    minLat -= factor * height;
    if (maxLng > 180)
      maxLng = 180;
    if (minLng < -180)
      minLng = -180;
    if (maxLat > 90)
      maxLat = 90;
    if (minLat < -90)
      minLat = -90;
    this._map.fitBounds([minLng, minLat, maxLng, maxLat]);
  }
  newMap(config) {
    return new MAPBOX.Map({
      ...config,
      pitch: 60,
      bearing: -40,
      zoom: 4,
      style: this._style,
      antialias: true
    });
  }
  setupComponents(coords) {
    this._components.scene = new SimpleScene(this._components);
    this._components.camera = new MapboxCamera(this._components);
    const renderer = new MapboxRenderer(this._components, this._map, coords);
    this._components.renderer = renderer;
    renderer.onInitialized.add(() => {
      this._components.raycaster = new SimpleRaycaster(this._components);
      this._components.init();
    });
  }
  setupScene() {
    const scene = this._components.scene.get();
    scene.background = null;
    const directionalLight = new DirectionalLight(16777215);
    directionalLight.position.set(0, -70, 100).normalize();
    scene.add(directionalLight);
    const directionalLight2 = new DirectionalLight(16777215);
    directionalLight2.position.set(0, 70, 100).normalize();
    scene.add(directionalLight2);
  }
};

// node_modules/openbim-components/measurement/AreaMeasurement/src/index.js
var AreaMeasureElement = class extends Component {
  constructor(components, points) {
    super(components);
    this.name = "AreaShape";
    this.enabled = true;
    this.visible = true;
    this.points = [];
    this.workingPlane = null;
    this._rotationMatrix = null;
    this._dimensionLines = [];
    this._defaultLineMaterial = new LineBasicMaterial({ color: "red" });
    this.onAreaComputed = new Event();
    this.onWorkingPlaneComputed = new Event();
    this.onPointAdded = new Event();
    this.onPointRemoved = new Event();
    const htmlText = document.createElement("div");
    htmlText.className = DimensionLabelClassName;
    this.labelMarker = new Simple2DMarker(components, htmlText);
    this.labelMarker.visible = false;
    this.onPointAdded.add((point) => {
      if (this.points.length === 3 && !this._dimensionLines[2]) {
        this.addDimensionLine(point, this.points[0]);
        this.labelMarker.visible = true;
      }
    });
    points === null || points === void 0 ? void 0 : points.forEach((point) => this.setPoint(point));
  }
  setPoint(point, index) {
    let _index;
    if (!index) {
      _index = this.points.length === 0 ? 0 : this.points.length;
    } else {
      _index = index;
    }
    if (_index === 0) {
      this.points[0] = point;
      return;
    }
    if (_index < 0 || _index > this.points.length)
      return;
    const existingIndex = this.points.length > _index;
    this.points[_index] = point;
    this.onPointAdded.trigger(point);
    if (!existingIndex) {
      this.addDimensionLine(this.points[_index - 1], point);
    }
    const { previousLine, nextLine } = this.getLinesBetweenIndex(_index);
    if (previousLine)
      previousLine.endPoint = point;
    if (nextLine)
      nextLine.startPoint = point;
  }
  removePoint(index) {
    if (this.points.length === 3)
      return;
    this.points.splice(index, 1);
    const { previousLine, nextLine } = this.getLinesBetweenIndex(index);
    if (nextLine)
      previousLine.endPoint = nextLine.end;
    nextLine === null || nextLine === void 0 ? void 0 : nextLine.dispose();
    this._dimensionLines.splice(index, 1);
    this.onPointRemoved.trigger();
  }
  toggleLabel() {
    this.labelMarker.toggleVisibility();
  }
  addDimensionLine(start2, end2) {
    const element = document.createElement("div");
    element.className = "w-2 h-2 bg-red-600 rounded-full";
    const dimensionLine = new SimpleDimensionLine(this.components, {
      start: start2,
      end: end2,
      lineMaterial: this._defaultLineMaterial,
      endpointElement: element
    });
    dimensionLine.toggleLabel();
    if (this._dimensionLines.length > 1) {
      this._dimensionLines.splice(this._dimensionLines.length - 1, 0, dimensionLine);
    } else {
      this._dimensionLines.push(dimensionLine);
    }
    return dimensionLine;
  }
  getLinesBetweenIndex(index) {
    const previousLineIndex = index === 0 ? this._dimensionLines.length - 1 : index - 1;
    const previousLine = this._dimensionLines[previousLineIndex];
    const nextLine = this._dimensionLines[index];
    return { previousLine, nextLine };
  }
  computeWorkingPlane() {
    this.workingPlane = new Plane().setFromCoplanarPoints(this.points[0], this.points[1], this.points[2]);
    const referenceVector = new Vector3(0, 1, 0);
    const theta = this.workingPlane.normal.angleTo(referenceVector);
    const rotationAxis = new Vector3().crossVectors(this.workingPlane.normal, referenceVector).normalize();
    this._rotationMatrix = new Matrix4().makeRotationAxis(rotationAxis, theta);
    this.onWorkingPlaneComputed.trigger(this.workingPlane);
  }
  computeArea() {
    if (!(this._rotationMatrix && this.workingPlane)) {
      this.onAreaComputed.trigger(0);
      return 0;
    }
    let xSum = 0;
    let ySum = 0;
    const rotMatrix = this._rotationMatrix;
    const vectors2D = this.points.map((point) => {
      const transformedPoint = point.clone().applyMatrix4(rotMatrix);
      const vector2D = new Vector2(transformedPoint.x, transformedPoint.z);
      xSum += vector2D.x;
      ySum += vector2D.y;
      return vector2D;
    });
    const area2 = Math.abs(ShapeUtils.area(vectors2D));
    this.labelMarker.get().element.textContent = `${area2.toFixed(2)} m²`;
    this.labelMarker.get().position.set(xSum / vectors2D.length, -this.workingPlane.constant, ySum / vectors2D.length).applyMatrix4(rotMatrix.clone().invert());
    this.onAreaComputed.trigger(area2);
    return area2;
  }
  async dispose() {
    this.onAreaComputed.reset();
    this.onWorkingPlaneComputed.reset();
    this.onPointAdded.reset();
    this.onPointRemoved.reset();
    for (const line of this._dimensionLines) {
      line.dispose();
    }
    await this.labelMarker.dispose();
    this._dimensionLines = [];
    this.points = [];
    this._rotationMatrix = null;
    this.workingPlane = null;
    this._defaultLineMaterial.dispose();
    this.components = null;
  }
  get() {
    return {
      points: this.points,
      workingPlane: this.workingPlane,
      area: this.computeArea()
    };
  }
};

// node_modules/openbim-components/measurement/AreaMeasurement/index.js
var AreaMeasurement = class _AreaMeasurement extends Component {
  set enabled(value) {
    this._enabled = value;
    this._vertexPicker.enabled = value;
    if (this.components.ui.enabled) {
      const main2 = this.uiElement.get("main");
      main2.active = value;
    }
    this.setupEvents(value);
    if (!value)
      this.cancelCreation();
  }
  get enabled() {
    return this._enabled;
  }
  set workingPlane(plane) {
    this._vertexPicker.workingPlane = plane;
  }
  get workingPlane() {
    return this._vertexPicker.workingPlane;
  }
  constructor(components) {
    super(components);
    this.uiElement = new UIElement();
    this._enabled = false;
    this._currentAreaElement = null;
    this._clickCount = 0;
    this._measurements = [];
    this.onBeforeCreate = new Event();
    this.onAfterCreate = new Event();
    this.onBeforeCancel = new Event();
    this.onAfterCancel = new Event();
    this.onBeforeDelete = new Event();
    this.onAfterDelete = new Event();
    this.create = () => {
      if (!this.enabled)
        return;
      const point = this._vertexPicker.get();
      if (!point)
        return;
      if (!this._currentAreaElement) {
        const areaShape = new AreaMeasureElement(this.components);
        areaShape.onPointAdded.add(() => {
          if (this._clickCount === 3 && !areaShape.workingPlane) {
            areaShape.computeWorkingPlane();
            this._vertexPicker.workingPlane = areaShape.workingPlane;
          }
        });
        areaShape.onPointRemoved.add(() => this._clickCount--);
        this._currentAreaElement = areaShape;
      }
      this._currentAreaElement.setPoint(point, this._clickCount);
      this._currentAreaElement.computeArea();
      this._clickCount++;
    };
    this.onMouseMove = () => {
      const point = this._vertexPicker.get();
      if (!(point && this._currentAreaElement))
        return;
      this._currentAreaElement.setPoint(point, this._clickCount);
      this._currentAreaElement.computeArea();
    };
    this.onKeydown = (e) => {
      if (!this.enabled)
        return;
      if (e.key === "z" && e.ctrlKey && this._currentAreaElement)
        this._currentAreaElement.removePoint(this._clickCount - 1);
      if (e.key === "Enter" && this._currentAreaElement)
        this.endCreation();
      if (e.key === "Escape") {
        if (this._clickCount === 0 && !this._currentAreaElement) {
          this.enabled = false;
        } else {
          this.cancelCreation();
        }
      }
    };
    this.components.tools.add(_AreaMeasurement.uuid, this);
    this._vertexPicker = new VertexPicker(components);
    if (components.ui.enabled) {
      this.setUI();
    }
  }
  async dispose() {
    this.setupEvents(false);
    this.onBeforeCreate.reset();
    this.onAfterCreate.reset();
    this.onBeforeCancel.reset();
    this.onAfterCancel.reset();
    this.onBeforeDelete.reset();
    this.onAfterDelete.reset();
    this.uiElement.dispose();
    await this._vertexPicker.dispose();
    if (this._currentAreaElement) {
      await this._currentAreaElement.dispose();
    }
    for (const measure of this._measurements) {
      await measure.dispose();
    }
    this.components = null;
  }
  setUI() {
    const main2 = new Button(this.components);
    main2.materialIcon = "check_box_outline_blank";
    main2.onClick.add(() => {
      if (!this.enabled) {
        main2.active = true;
        this.enabled = true;
      } else {
        this.enabled = false;
        main2.active = false;
      }
    });
    this.uiElement.set({ main: main2 });
  }
  delete() {
  }
  /** Deletes all the dimensions that have been previously created. */
  async deleteAll() {
    for (const dim of this._measurements) {
      await dim.dispose();
      await this.onAfterDelete.trigger(this);
    }
    this._measurements = [];
  }
  endCreation() {
    if (this._currentAreaElement) {
      this._measurements.push(this._currentAreaElement);
      this._currentAreaElement.removePoint(this._clickCount);
      this._currentAreaElement.computeWorkingPlane();
      this._currentAreaElement.computeArea();
      this._currentAreaElement = null;
    }
    this._vertexPicker.workingPlane = null;
    this._clickCount = 0;
  }
  cancelCreation() {
    if (this._currentAreaElement) {
      this._currentAreaElement.dispose();
      this._currentAreaElement = null;
    }
    this._vertexPicker.workingPlane = null;
    this._clickCount = 0;
  }
  get() {
    return this._measurements;
  }
  setupEvents(active) {
    const viewerContainer = this.components.ui.viewerContainer;
    if (active) {
      viewerContainer.addEventListener("click", this.create);
      viewerContainer.addEventListener("mousemove", this.onMouseMove);
      window.addEventListener("keydown", this.onKeydown);
    } else {
      viewerContainer.removeEventListener("click", this.create);
      viewerContainer.removeEventListener("mousemove", this.onMouseMove);
      window.removeEventListener("keydown", this.onKeydown);
    }
  }
};
AreaMeasurement.uuid = "c453a99e-f054-4781-9060-33df617db4a5";
ToolComponent.libraryUUIDs.add(AreaMeasurement.uuid);

// node_modules/three/examples/jsm/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var LineMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
      vertexShader: ShaderLib["line"].vertexShader,
      fragmentShader: ShaderLib["line"].fragmentShader,
      clipping: true
      // required for clipping support
    });
    this.isLineMaterial = true;
    Object.defineProperties(this, {
      color: {
        enumerable: true,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(value) {
          this.uniforms.diffuse.value = value;
        }
      },
      worldUnits: {
        enumerable: true,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(value) {
          if (value === true) {
            this.defines.WORLD_UNITS = "";
          } else {
            delete this.defines.WORLD_UNITS;
          }
        }
      },
      linewidth: {
        enumerable: true,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(value) {
          this.uniforms.linewidth.value = value;
        }
      },
      dashed: {
        enumerable: true,
        get: function() {
          return Boolean("USE_DASH" in this.defines);
        },
        set(value) {
          if (Boolean(value) !== Boolean("USE_DASH" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_DASH = "";
          } else {
            delete this.defines.USE_DASH;
          }
        }
      },
      dashScale: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(value) {
          this.uniforms.dashScale.value = value;
        }
      },
      dashSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(value) {
          this.uniforms.dashSize.value = value;
        }
      },
      dashOffset: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(value) {
          this.uniforms.dashOffset.value = value;
        }
      },
      gapSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(value) {
          this.uniforms.gapSize.value = value;
        }
      },
      opacity: {
        enumerable: true,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(value) {
          this.uniforms.opacity.value = value;
        }
      },
      resolution: {
        enumerable: true,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(value) {
          this.uniforms.resolution.value.copy(value);
        }
      },
      alphaToCoverage: {
        enumerable: true,
        get: function() {
          return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(value) {
          if (Boolean(value) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_ALPHA_TO_COVERAGE = "";
            this.extensions.derivatives = true;
          } else {
            delete this.defines.USE_ALPHA_TO_COVERAGE;
            this.extensions.derivatives = false;
          }
        }
      }
    });
    this.setValues(parameters);
  }
};

// node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector2 = new Vector3();
var LineSegmentsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.isLineSegmentsGeometry = true;
    this.type = "LineSegmentsGeometry";
    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(index);
    this.setAttribute("position", new Float32BufferAttribute(positions, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  applyMatrix4(matrix) {
    const start2 = this.attributes.instanceStart;
    const end2 = this.attributes.instanceEnd;
    if (start2 !== void 0) {
      start2.applyMatrix4(matrix);
      end2.applyMatrix4(matrix);
      start2.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  setPositions(array) {
    let lineSegments;
    if (array instanceof Float32Array) {
      lineSegments = array;
    } else if (Array.isArray(array)) {
      lineSegments = new Float32Array(array);
    }
    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);
    this.setAttribute("instanceStart", new InterleavedBufferAttribute(instanceBuffer, 3, 0));
    this.setAttribute("instanceEnd", new InterleavedBufferAttribute(instanceBuffer, 3, 3));
    this.computeBoundingBox();
    this.computeBoundingSphere();
    return this;
  }
  setColors(array) {
    let colors;
    if (array instanceof Float32Array) {
      colors = array;
    } else if (Array.isArray(array)) {
      colors = new Float32Array(array);
    }
    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);
    this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(instanceColorBuffer, 3, 0));
    this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(instanceColorBuffer, 3, 3));
    return this;
  }
  fromWireframeGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromEdgesGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromMesh(mesh) {
    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));
    return this;
  }
  fromLineSegments(lineSegments) {
    const geometry = lineSegments.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const start2 = this.attributes.instanceStart;
    const end2 = this.attributes.instanceEnd;
    if (start2 !== void 0 && end2 !== void 0) {
      this.boundingBox.setFromBufferAttribute(start2);
      _box.setFromBufferAttribute(end2);
      this.boundingBox.union(_box);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (this.boundingBox === null) {
      this.computeBoundingBox();
    }
    const start2 = this.attributes.instanceStart;
    const end2 = this.attributes.instanceEnd;
    if (start2 !== void 0 && end2 !== void 0) {
      const center = this.boundingSphere.center;
      this.boundingBox.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = start2.count; i < il; i++) {
        _vector2.fromBufferAttribute(start2, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector2));
        _vector2.fromBufferAttribute(end2, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector2));
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
  }
  toJSON() {
  }
  applyMatrix(matrix) {
    console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
    return this.applyMatrix4(matrix);
  }
};

// node_modules/three/examples/jsm/lines/LineGeometry.js
var LineGeometry = class extends LineSegmentsGeometry {
  constructor() {
    super();
    this.isLineGeometry = true;
    this.type = "LineGeometry";
  }
  setPositions(array) {
    const length = array.length - 3;
    const points = new Float32Array(2 * length);
    for (let i = 0; i < length; i += 3) {
      points[2 * i] = array[i];
      points[2 * i + 1] = array[i + 1];
      points[2 * i + 2] = array[i + 2];
      points[2 * i + 3] = array[i + 3];
      points[2 * i + 4] = array[i + 4];
      points[2 * i + 5] = array[i + 5];
    }
    super.setPositions(points);
    return this;
  }
  setColors(array) {
    const length = array.length - 3;
    const colors = new Float32Array(2 * length);
    for (let i = 0; i < length; i += 3) {
      colors[2 * i] = array[i];
      colors[2 * i + 1] = array[i + 1];
      colors[2 * i + 2] = array[i + 2];
      colors[2 * i + 3] = array[i + 3];
      colors[2 * i + 4] = array[i + 4];
      colors[2 * i + 5] = array[i + 5];
    }
    super.setColors(colors);
    return this;
  }
  fromLine(line) {
    const geometry = line.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
};

// node_modules/three/examples/jsm/lines/LineSegments2.js
var _start = new Vector3();
var _end = new Vector3();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector3();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint = new Vector3();
var _box2 = new Box3();
var _sphere2 = new Sphere();
var _clipToWorldVector = new Vector4();
var _ray;
var _lineWidth;
function getWorldSpaceHalfWidth(camera, distance, resolution) {
  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  _clipToWorldVector.x = _lineWidth / resolution.width;
  _clipToWorldVector.y = _lineWidth / resolution.height;
  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));
}
function raycastWorldUnits(lineSegments, intersects) {
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  for (let i = 0, l2 = segmentCount; i < l2; i++) {
    _line.start.fromBufferAttribute(instanceStart, i);
    _line.end.fromBufferAttribute(instanceEnd, i);
    _line.applyMatrix4(matrixWorld);
    const pointOnLine = new Vector3();
    const point = new Vector3();
    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;
    if (isInside) {
      intersects.push({
        point,
        pointOnLine,
        distance: _ray.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv1: null
      });
    }
  }
}
function raycastScreenSpace(lineSegments, camera, intersects) {
  const projectionMatrix = camera.projectionMatrix;
  const material = lineSegments.material;
  const resolution = material.resolution;
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  const near = -camera.near;
  _ray.at(1, _ssOrigin);
  _ssOrigin.w = 1;
  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
  _ssOrigin.applyMatrix4(projectionMatrix);
  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
  _ssOrigin.x *= resolution.x / 2;
  _ssOrigin.y *= resolution.y / 2;
  _ssOrigin.z = 0;
  _ssOrigin3.copy(_ssOrigin);
  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
  for (let i = 0, l2 = segmentCount; i < l2; i++) {
    _start4.fromBufferAttribute(instanceStart, i);
    _end4.fromBufferAttribute(instanceEnd, i);
    _start4.w = 1;
    _end4.w = 1;
    _start4.applyMatrix4(_mvMatrix);
    _end4.applyMatrix4(_mvMatrix);
    const isBehindCameraNear = _start4.z > near && _end4.z > near;
    if (isBehindCameraNear) {
      continue;
    }
    if (_start4.z > near) {
      const deltaDist = _start4.z - _end4.z;
      const t = (_start4.z - near) / deltaDist;
      _start4.lerp(_end4, t);
    } else if (_end4.z > near) {
      const deltaDist = _end4.z - _start4.z;
      const t = (_end4.z - near) / deltaDist;
      _end4.lerp(_start4, t);
    }
    _start4.applyMatrix4(projectionMatrix);
    _end4.applyMatrix4(projectionMatrix);
    _start4.multiplyScalar(1 / _start4.w);
    _end4.multiplyScalar(1 / _end4.w);
    _start4.x *= resolution.x / 2;
    _start4.y *= resolution.y / 2;
    _end4.x *= resolution.x / 2;
    _end4.y *= resolution.y / 2;
    _line.start.copy(_start4);
    _line.start.z = 0;
    _line.end.copy(_end4);
    _line.end.z = 0;
    const param = _line.closestPointToPointParameter(_ssOrigin3, true);
    _line.at(param, _closestPoint);
    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);
    const isInClipSpace = zPos >= -1 && zPos <= 1;
    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;
    if (isInClipSpace && isInside) {
      _line.start.fromBufferAttribute(instanceStart, i);
      _line.end.fromBufferAttribute(instanceEnd, i);
      _line.start.applyMatrix4(matrixWorld);
      _line.end.applyMatrix4(matrixWorld);
      const pointOnLine = new Vector3();
      const point = new Vector3();
      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
      intersects.push({
        point,
        pointOnLine,
        distance: _ray.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv1: null
      });
    }
  }
}
var LineSegments2 = class extends Mesh {
  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLineSegments2 = true;
    this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const geometry = this.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const lineDistances = new Float32Array(2 * instanceStart.count);
    for (let i = 0, j = 0, l2 = instanceStart.count; i < l2; i++, j += 2) {
      _start.fromBufferAttribute(instanceStart, i);
      _end.fromBufferAttribute(instanceEnd, i);
      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
    }
    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
    geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
    geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
    return this;
  }
  raycast(raycaster, intersects) {
    const worldUnits = this.material.worldUnits;
    const camera = raycaster.camera;
    if (camera === null && !worldUnits) {
      console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    }
    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
    _ray = raycaster.ray;
    const matrixWorld = this.matrixWorld;
    const geometry = this.geometry;
    const material = this.material;
    _lineWidth = material.linewidth + threshold;
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    _sphere2.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
    let sphereMargin;
    if (worldUnits) {
      sphereMargin = _lineWidth * 0.5;
    } else {
      const distanceToSphere = Math.max(camera.near, _sphere2.distanceToPoint(_ray.origin));
      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);
    }
    _sphere2.radius += sphereMargin;
    if (_ray.intersectsSphere(_sphere2) === false) {
      return;
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    _box2.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
    let boxMargin;
    if (worldUnits) {
      boxMargin = _lineWidth * 0.5;
    } else {
      const distanceToBox = Math.max(camera.near, _box2.distanceToPoint(_ray.origin));
      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);
    }
    _box2.expandByScalar(boxMargin);
    if (_ray.intersectsBox(_box2) === false) {
      return;
    }
    if (worldUnits) {
      raycastWorldUnits(this, intersects);
    } else {
      raycastScreenSpace(this, camera, intersects);
    }
  }
};

// node_modules/three/examples/jsm/lines/Line2.js
var Line2 = class extends LineSegments2 {
  constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLine2 = true;
    this.type = "Line2";
  }
};

// node_modules/openbim-components/measurement/AngleMeasurement/src/index.js
var AngleMeasureElement = class extends Component {
  set lineMaterial(material) {
    this._lineMaterial.dispose();
    this._lineMaterial = material;
    this._line.material = material;
    this._lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
  }
  get lineMaterial() {
    return this._lineMaterial;
  }
  set labelMarker(marker) {
    this._labelMarker.dispose();
    this._labelMarker = marker;
  }
  get labelMarker() {
    return this._labelMarker;
  }
  get scene() {
    return this._components.scene.get();
  }
  constructor(components, points) {
    super(components);
    this.enabled = true;
    this.visible = true;
    this.points = [];
    this._lineMaterial = new LineMaterial({
      color: 6629591,
      linewidth: 2
    });
    this._lineGeometry = new LineGeometry();
    this._line = new Line2(this._lineGeometry, this._lineMaterial);
    this.onAngleComputed = new Event();
    this.onPointAdded = new Event();
    this._components = components;
    const htmlText = document.createElement("div");
    htmlText.className = DimensionLabelClassName;
    this._labelMarker = new Simple2DMarker(components, htmlText);
    this.labelMarker.visible = false;
    this.onPointAdded.add(() => {
      if (this.points.length === 1)
        this.scene.add(this._line);
      if (this.points.length === 3)
        this.labelMarker.visible = true;
    });
    this.onAngleComputed.add((angle) => {
      var _a2;
      this.labelMarker.get().element.textContent = `${angle.toFixed(2)}°`;
      this.labelMarker.get().position.copy((_a2 = this.points[1]) !== null && _a2 !== void 0 ? _a2 : new Vector3());
    });
    points === null || points === void 0 ? void 0 : points.forEach((point) => this.setPoint(point));
  }
  setPoint(point, index) {
    let _index;
    if (!index) {
      _index = this.points.length === 0 ? 0 : this.points.length;
    } else {
      _index = index;
    }
    if (![0, 1, 2].includes(_index))
      return;
    this.points[_index] = point;
    this.onPointAdded.trigger(point);
    const points = this.points.map((point2) => {
      return [point2.x, point2.y, point2.z];
    });
    this._lineGeometry.setPositions(points.flat());
  }
  toggleLabel() {
    this.labelMarker.toggleVisibility();
  }
  computeAngle() {
    const v0 = this.points[0];
    const v1 = this.points[1];
    const v22 = this.points[2];
    if (!(v0 && v1 && v22))
      return 0;
    const vA = new Vector3().subVectors(v1, v0);
    const vB = new Vector3().subVectors(v1, v22);
    const angle = MathUtils.radToDeg(vA.angleTo(vB));
    this.onAngleComputed.trigger(angle);
    return angle;
  }
  async dispose() {
    this.points = [];
    await this.labelMarker.dispose();
    this.onAngleComputed.reset();
    this.onPointAdded.reset();
    await this.labelMarker.dispose();
    this._line.removeFromParent();
    this._lineMaterial.dispose();
    this._lineGeometry.dispose();
    this._components = null;
  }
  get() {
    return {
      points: this.points,
      angle: this.computeAngle()
    };
  }
};

// node_modules/openbim-components/measurement/AngleMeasurement/index.js
var AngleMeasurement = class _AngleMeasurement extends Component {
  set lineMaterial(material) {
    this._lineMaterial.dispose();
    this._lineMaterial = material;
    this._lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
  }
  get lineMaterial() {
    return this._lineMaterial;
  }
  set enabled(value) {
    this._enabled = value;
    this.setupEvents(value);
    this._vertexPicker.enabled = value;
    if (this.components.ui.enabled) {
      const main2 = this.uiElement.get("main");
      main2.active = value;
    }
    if (!value)
      this.cancelCreation();
  }
  get enabled() {
    return this._enabled;
  }
  set workingPlane(plane) {
    this._vertexPicker.workingPlane = plane;
  }
  get workingPlane() {
    return this._vertexPicker.workingPlane;
  }
  constructor(components) {
    super(components);
    this.uiElement = new UIElement();
    this._enabled = false;
    this._currentAngleElement = null;
    this._clickCount = 0;
    this._measurements = [];
    this.onBeforeCreate = new Event();
    this.onAfterCreate = new Event();
    this.onBeforeCancel = new Event();
    this.onAfterCancel = new Event();
    this.onBeforeDelete = new Event();
    this.onAfterDelete = new Event();
    this.create = () => {
      if (!this.enabled)
        return;
      const point = this._vertexPicker.get();
      if (!point)
        return;
      if (!this._currentAngleElement) {
        const angleElement = new AngleMeasureElement(this.components);
        angleElement.lineMaterial = this.lineMaterial;
        this._currentAngleElement = angleElement;
      }
      this._currentAngleElement.setPoint(point, this._clickCount);
      this._currentAngleElement.setPoint(point, this._clickCount + 1);
      this._currentAngleElement.setPoint(point, this._clickCount + 2);
      this._currentAngleElement.computeAngle();
      this._clickCount++;
      if (this._clickCount === 3)
        this.endCreation();
    };
    this.onMouseMove = () => {
      const point = this._vertexPicker.get();
      if (!(point && this._currentAngleElement))
        return;
      this._currentAngleElement.setPoint(point, this._clickCount);
      this._currentAngleElement.computeAngle();
    };
    this.onKeyDown = (e) => {
      if (!this.enabled)
        return;
      if (e.key === "z" && e.ctrlKey && this._currentAngleElement) {
      }
      if (e.key === "Escape") {
        if (this._clickCount === 0 && !this._currentAngleElement) {
          this.enabled = false;
        } else {
          this.cancelCreation();
        }
      }
    };
    this.components.tools.add(_AngleMeasurement.uuid, this);
    this.components = components;
    this._lineMaterial = new LineMaterial({
      color: 6629591,
      linewidth: 2
    });
    this._vertexPicker = new VertexPicker(components);
    if (components.ui.enabled) {
      this.setUI();
    }
  }
  async dispose() {
    await this.setupEvents(false);
    this.onBeforeCreate.reset();
    this.onAfterCreate.reset();
    this.onBeforeCancel.reset();
    this.onAfterCancel.reset();
    this.onBeforeDelete.reset();
    this.onAfterDelete.reset();
    this.uiElement.dispose();
    this._lineMaterial.dispose();
    await this._vertexPicker.dispose();
    for (const measure of this._measurements) {
      await measure.dispose();
    }
    if (this._currentAngleElement) {
      await this._currentAngleElement.dispose();
    }
    this.components = null;
  }
  delete() {
  }
  /** Deletes all the dimensions that have been previously created. */
  async deleteAll() {
    for (const dim of this._measurements) {
      await dim.dispose();
      await this.onAfterDelete.trigger(this);
    }
    this._measurements = [];
  }
  endCreation() {
    if (this._currentAngleElement) {
      this._measurements.push(this._currentAngleElement);
      this._currentAngleElement.computeAngle();
      this._currentAngleElement = null;
    }
    this._clickCount = 0;
  }
  cancelCreation() {
    if (this._currentAngleElement) {
      this._currentAngleElement.dispose();
      this._currentAngleElement = null;
    }
    this._clickCount = 0;
  }
  get() {
    return this._measurements;
  }
  setUI() {
    const main2 = new Button(this.components);
    main2.materialIcon = "square_foot";
    main2.onClick.add(() => {
      if (!this.enabled) {
        main2.active = true;
        this.enabled = true;
      } else {
        this.enabled = false;
        main2.active = false;
      }
    });
    this.uiElement.set({ main: main2 });
  }
  setupEvents(active) {
    const viewerContainer = this.components.ui.viewerContainer;
    if (active) {
      viewerContainer.addEventListener("click", this.create);
      viewerContainer.addEventListener("mousemove", this.onMouseMove);
      window.addEventListener("keydown", this.onKeyDown);
    } else {
      const main2 = this.uiElement.get("main");
      main2.active = false;
      viewerContainer.removeEventListener("click", this.create);
      viewerContainer.removeEventListener("mousemove", this.onMouseMove);
      window.removeEventListener("keydown", this.onKeyDown);
    }
  }
};
AngleMeasurement.uuid = "622fb2c9-528c-4b0a-8a0e-6a1375f0a3aa";
ToolComponent.libraryUUIDs.add(AngleMeasurement.uuid);

// node_modules/openbim-components/import-export/dxf-exporter/index.js
var import_dxf_writer = __toESM(require_dxf_writer());

// node_modules/openbim-components/import-export/dxf-exporter/src/edge-utils.js
var _upVector = new Vector3(0, 1, 0);
var EPSILON2 = 1e-16;
var generateEdges = function() {
  const _v0 = new Vector3();
  const _v12 = new Vector3();
  const _normal = new Vector3();
  const _triangle = new Triangle();
  return function generateEdges2(geometry, projectionDir, thresholdAngle = 1) {
    const edges2 = [];
    const precisionPoints = 4;
    const precision = Math.pow(10, precisionPoints);
    const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
    const indexAttr = geometry.getIndex();
    const positionAttr = geometry.getAttribute("position");
    const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
    const indexArr = [0, 0, 0];
    const vertKeys = ["a", "b", "c"];
    const hashes = new Array(3);
    const edgeData = {};
    for (let i = 0; i < indexCount; i += 3) {
      if (indexAttr) {
        indexArr[0] = indexAttr.getX(i);
        indexArr[1] = indexAttr.getX(i + 1);
        indexArr[2] = indexAttr.getX(i + 2);
      } else {
        indexArr[0] = i;
        indexArr[1] = i + 1;
        indexArr[2] = i + 2;
      }
      const { a, b: b2, c: c3 } = _triangle;
      a.fromBufferAttribute(positionAttr, indexArr[0]);
      b2.fromBufferAttribute(positionAttr, indexArr[1]);
      c3.fromBufferAttribute(positionAttr, indexArr[2]);
      _triangle.getNormal(_normal);
      hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
      hashes[1] = `${Math.round(b2.x * precision)},${Math.round(b2.y * precision)},${Math.round(b2.z * precision)}`;
      hashes[2] = `${Math.round(c3.x * precision)},${Math.round(c3.y * precision)},${Math.round(c3.z * precision)}`;
      if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
        continue;
      }
      for (let j = 0; j < 3; j++) {
        const jNext = (j + 1) % 3;
        const vecHash0 = hashes[j];
        const vecHash1 = hashes[jNext];
        const v0 = _triangle[vertKeys[j]];
        const v1 = _triangle[vertKeys[jNext]];
        const hash3 = `${vecHash0}_${vecHash1}`;
        const reverseHash = `${vecHash1}_${vecHash0}`;
        if (reverseHash in edgeData && edgeData[reverseHash]) {
          const otherNormal = edgeData[reverseHash].normal;
          const meetsThreshold = _normal.dot(otherNormal) <= thresholdDot;
          const projectionThreshold = Math.sign(projectionDir.dot(_normal)) !== Math.sign(projectionDir.dot(otherNormal));
          if (meetsThreshold || projectionThreshold) {
            const line = new Line3();
            line.start.copy(v0);
            line.end.copy(v1);
            edges2.push(line);
          }
          edgeData[reverseHash] = null;
        } else if (!(hash3 in edgeData)) {
          edgeData[hash3] = {
            index0: indexArr[j],
            index1: indexArr[jNext],
            normal: _normal.clone()
          };
        }
      }
    }
    for (const key in edgeData) {
      if (edgeData[key]) {
        const { index0, index1 } = edgeData[key];
        _v0.fromBufferAttribute(positionAttr, index0);
        _v12.fromBufferAttribute(positionAttr, index1);
        const line = new Line3();
        line.start.copy(_v0);
        line.end.copy(_v12);
        edges2.push(line);
      }
    }
    return edges2;
  };
}();
var getOverlappingLine = function() {
  const _dir0 = new Vector3();
  const _dir1 = new Vector3();
  const _tempDir = new Vector3();
  const _orthoPlane = new Plane();
  const _line0 = new Line3();
  const _line1 = new Line3();
  const _tempLine = new Line3();
  return function getOverlappingLine2(line, triangle, lineTarget = new Line3()) {
    if (triangle.needsUpdate) {
      triangle.needsUpdate();
    }
    if (triangle.getArea() <= EPSILON2) {
      return null;
    }
    const { points, plane } = triangle;
    _line0.copy(line);
    _line0.delta(_dir0);
    const areCoplanar = plane.normal.dot(_dir0) === 0;
    if (!areCoplanar) {
      return null;
    }
    _dir0.cross(plane.normal).normalize();
    _orthoPlane.setFromNormalAndCoplanarPoint(_dir0, _line0.start);
    let intersectCount = 0;
    for (let i = 0; i < 3; i++) {
      const p1 = points[i];
      const p2 = points[(i + 1) % 3];
      _tempLine.start.copy(p1);
      _tempLine.end.copy(p2);
      if (_orthoPlane.distanceToPoint(_tempLine.end) === 0 && _orthoPlane.distanceToPoint(_tempLine.start) === 0) {
        _line1.copy(_tempLine);
        intersectCount = 2;
        break;
      } else if (_orthoPlane.intersectLine(_tempLine, intersectCount === 0 ? _line1.start : _line1.end)) {
        let p3;
        if (intersectCount === 0) {
          p3 = _line1.start;
        } else {
          p3 = _line1.end;
        }
        if (p3.distanceTo(p2) === 0) {
          continue;
        }
        intersectCount++;
        if (intersectCount === 2) {
          break;
        }
      }
    }
    if (intersectCount === 2) {
      _line0.delta(_dir0).normalize();
      _line1.delta(_dir1).normalize();
      if (_dir0.dot(_dir1) < 0) {
        const tmp = _line1.start;
        _line1.start = _line1.end;
        _line1.end = tmp;
      }
      const s1 = _line0.start.dot(_dir0);
      const e1 = _line0.end.dot(_dir0);
      const s22 = _line1.start.dot(_dir0);
      const e2 = _line1.end.dot(_dir0);
      const separated1 = e1 < s22;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s22 !== e1 && separated1 === separated2) {
        return null;
      }
      _tempDir.subVectors(_line0.start, _line1.start);
      if (_tempDir.dot(_dir0) > 0) {
        lineTarget.start.copy(_line0.start);
      } else {
        lineTarget.start.copy(_line1.start);
      }
      _tempDir.subVectors(_line0.end, _line1.end);
      if (_tempDir.dot(_dir0) < 0) {
        lineTarget.end.copy(_line0.end);
      } else {
        lineTarget.end.copy(_line1.end);
      }
      return lineTarget;
    }
    return null;
  };
}();
var getPlaneYAtPoint = function() {
  const testLine = new Line3();
  return function getPlaneYAtPoint2(plane, point, target = null) {
    testLine.start.copy(point);
    testLine.end.copy(point);
    testLine.start.y += 1e5;
    testLine.end.y -= 1e5;
    plane.intersectLine(testLine, target);
  };
}();
var isLineAbovePlane = function() {
  const _v0 = new Vector3();
  const _v12 = new Vector3();
  return function isLineAbovePlane2(plane, line) {
    _v0.lerpVectors(line.start, line.end, 0.5);
    getPlaneYAtPoint(plane, _v0, _v12);
    return _v12.y < _v0.y;
  };
}();
var isYProjectedLineDegenerate = function() {
  const _tempDir = new Vector3();
  const _upVector2 = new Vector3(0, 1, 0);
  return function isYProjectedLineDegenerate2(line) {
    line.delta(_tempDir).normalize();
    return Math.abs(_tempDir.dot(_upVector2)) >= 1 - EPSILON2;
  };
}();
function isYProjectedTriangleDegenerate(tri) {
  if (tri.needsUpdate) {
    tri.update();
  }
  return Math.abs(tri.plane.normal.dot(_upVector)) <= EPSILON2;
}
function isLineTriangleEdge(tri, line) {
  const triPoints = tri.points;
  let matches = 0;
  for (let i = 0; i < 3; i++) {
    const { start: start2, end: end2 } = line;
    const tp = triPoints[i];
    if (start2.distanceToSquared(tp) <= EPSILON2) {
      matches++;
    }
    if (end2.distanceToSquared(tp) <= EPSILON2) {
      matches++;
    }
  }
  return matches >= 2;
}
var getProjectedOverlaps = function() {
  const _target = new Line3();
  const _tempDir = new Vector3();
  const _tempVec0 = new Vector3();
  const _tempVec1 = new Vector3();
  const _line2 = new Line3();
  const _tri = new ExtendedTriangle();
  return function getProjectedOverlaps2(tri, line, overlapsTarget) {
    _line2.copy(line);
    _tri.copy(tri);
    _line2.start.y = 0;
    _line2.end.y = 0;
    _tri.a.y = 0;
    _tri.b.y = 0;
    _tri.c.y = 0;
    _tri.needsUpdate = true;
    _tri.update();
    if (getOverlappingLine(_line2, _tri, _target)) {
      _line2.delta(_tempDir);
      _tempVec0.subVectors(_target.start, _line2.start);
      _tempVec1.subVectors(_target.end, _line2.start);
      let d0 = _tempVec0.length() / _tempDir.length();
      let d1 = _tempVec1.length() / _tempDir.length();
      d0 = Math.min(Math.max(d0, 0), 1);
      d1 = Math.min(Math.max(d1, 0), 1);
      if (!(Math.abs(d0 - d1) <= EPSILON2)) {
        overlapsTarget.push(new Float32Array([d0, d1]));
      }
      return true;
    }
    return false;
  };
}();
var trimToBeneathTriPlane = function() {
  const _lineDirection = new Vector3();
  const _planeHit = new Vector3();
  const _centerPoint = new Vector3();
  const _planePoint = new Vector3();
  return function trimToBeneathTriPlane2(tri, line, lineTarget) {
    if (tri.needsUpdate) {
      tri.update();
    }
    lineTarget.copy(line);
    const { plane } = tri;
    if (isYProjectedTriangleDegenerate(tri)) {
      return false;
    }
    line.delta(_lineDirection);
    const areCoplanar = plane.normal.dot(_lineDirection) === 0;
    if (areCoplanar) {
      return false;
    }
    const doesLineIntersect = plane.intersectLine(line, _planeHit);
    if (doesLineIntersect) {
      const { start: start2, end: end2 } = lineTarget;
      let testPoint;
      let flipped = false;
      if (start2.distanceTo(_planeHit) > end2.distanceTo(_planeHit)) {
        testPoint = start2;
      } else {
        testPoint = end2;
        flipped = true;
      }
      _centerPoint.lerpVectors(testPoint, _planeHit, 0.5);
      getPlaneYAtPoint(tri.plane, _centerPoint, _planePoint);
      if (_planePoint.y < _centerPoint.y) {
        if (flipped)
          end2.copy(_planeHit);
        else
          start2.copy(_planeHit);
      } else if (flipped)
        start2.copy(_planeHit);
      else
        end2.copy(_planeHit);
      return true;
    }
    return false;
  };
}();
var overlapsToLines = function() {
  const newLine = new Line3();
  return function overlapsToLines2(line, overlaps, target = []) {
    compressEdgeOverlaps(overlaps);
    const invOverlaps = [[0, 1]];
    for (let i = 0, l2 = overlaps.length; i < l2; i++) {
      const invOverlap = invOverlaps[i];
      const overlap = overlaps[i];
      invOverlap[1] = overlap[0];
      invOverlaps.push(new Float32Array([overlap[1], 1]));
    }
    for (let i = 0, l2 = invOverlaps.length; i < l2; i++) {
      const { start: start2, end: end2 } = line;
      newLine.start.lerpVectors(start2, end2, invOverlaps[i][0]);
      newLine.end.lerpVectors(start2, end2, invOverlaps[i][1]);
      target.push(
        // @ts-ignore
        new Float32Array([
          newLine.start.x,
          newLine.start.y,
          newLine.start.z,
          newLine.end.x,
          newLine.end.y,
          newLine.end.z
        ])
      );
    }
    return target;
  };
}();
function edgesToGeometry(edges2, y = null) {
  const edgeArray = new Float32Array(edges2.length * 6);
  let c3 = 0;
  for (let i = 0, l2 = edges2.length; i < l2; i++) {
    const line = edges2[i];
    edgeArray[c3++] = line[0];
    edgeArray[c3++] = y === null ? line[1] : y;
    edgeArray[c3++] = line[2];
    edgeArray[c3++] = line[3];
    edgeArray[c3++] = y === null ? line[4] : y;
    edgeArray[c3++] = line[5];
  }
  const edgeGeom = new BufferGeometry();
  const edgeBuffer = new BufferAttribute(edgeArray, 3, true);
  edgeGeom.setAttribute("position", edgeBuffer);
  return edgeGeom;
}
function compressEdgeOverlaps(overlaps) {
  overlaps.sort((a, b2) => {
    return a[0] - b2[0];
  });
  for (let i = 1; i < overlaps.length; i++) {
    const overlap = overlaps[i];
    const prevOverlap = overlaps[i - 1];
    if (overlap[0] <= prevOverlap[1]) {
      prevOverlap[1] = Math.max(prevOverlap[1], overlap[1]);
      overlaps.splice(i, 1);
      i--;
    }
  }
}

// node_modules/openbim-components/import-export/dxf-exporter/src/edge-projector.js
var EdgeProjector = class {
  constructor() {
    this.params = {
      displayModel: "color",
      displayEdges: false,
      displayProjection: true,
      useBVH: true,
      sortEdges: true,
      amount: 50,
      color: 6710886
    };
    this._defaultMaterial = new LineBasicMaterial({
      color: this.params.color
    });
    this.projectedEdges = [];
  }
  dispose() {
    this.disposeGeometry();
    this._defaultMaterial.dispose();
  }
  disposeGeometry() {
    this.projectedEdges.forEach((edge) => {
      edge.geometry.dispose();
      if (Array.isArray(edge.material))
        edge.material.forEach((mat) => mat.dispose());
      else
        edge.material.dispose();
    });
    this.projectedEdges = [];
  }
  async project(meshes, height) {
    const projection = new LineSegments(new BufferGeometry(), this._defaultMaterial);
    const tempMatrix = new Matrix4();
    const v1 = new Vector3();
    const v22 = new Vector3();
    const v3 = new Vector3();
    const vertices = [];
    const indices = [];
    let nextIndex = 0;
    for (const mesh of meshes) {
      mesh.updateWorldMatrix(false, false);
      const transform = mesh.matrixWorld.clone();
      const pos = mesh.geometry.attributes.position.array;
      const index = mesh.geometry.index.array;
      for (let i = 0; i < mesh.count; i++) {
        const pastIndices = /* @__PURE__ */ new Map();
        mesh.getMatrixAt(i, tempMatrix);
        tempMatrix.multiply(transform);
        for (let j = 0; j < index.length; j += 3) {
          const index1 = index[j] * 3;
          const index2 = index[j + 1] * 3;
          const index3 = index[j + 2] * 3;
          v1.set(pos[index1], pos[index1 + 1], pos[index1 + 2]);
          v22.set(pos[index2], pos[index2 + 1], pos[index2 + 2]);
          v3.set(pos[index3], pos[index3 + 1], pos[index3 + 2]);
          v1.applyMatrix4(tempMatrix);
          v22.applyMatrix4(tempMatrix);
          v3.applyMatrix4(tempMatrix);
          if (v1.y > height && v22.y > height && v3.y > height) {
            continue;
          }
          if (!pastIndices.has(index1)) {
            pastIndices.set(index1, nextIndex++);
            vertices.push(v1.x, v1.y, v1.z);
          }
          if (!pastIndices.has(index2)) {
            pastIndices.set(index2, nextIndex++);
            vertices.push(v22.x, v22.y, v22.z);
          }
          if (!pastIndices.has(index3)) {
            pastIndices.set(index3, nextIndex++);
            vertices.push(v3.x, v3.y, v3.z);
          }
          const i1 = pastIndices.get(index1);
          const i2 = pastIndices.get(index2);
          const i3 = pastIndices.get(index3);
          if (i1 !== void 0 && i2 !== void 0 && i3 !== void 0) {
            indices.push(i1, i2, i3);
          }
        }
      }
    }
    const buffer = new Float32Array(vertices);
    const mergedGeometry = new BufferGeometry();
    mergedGeometry.setIndex(indices);
    const attribute = new BufferAttribute(buffer, 3);
    mergedGeometry.setAttribute("position", attribute);
    let task2 = this.updateEdges(this.params, mergedGeometry, projection);
    while (task2) {
      const res = task2.next();
      if (res.done) {
        task2 = null;
      }
    }
    this.projectedEdges.push(projection);
    mergedGeometry.dispose();
    return projection;
  }
  *updateEdges(params, mergedGeometry, projection) {
    yield;
    const bvh = new MeshBVH(mergedGeometry);
    yield;
    const edges2 = generateEdges(mergedGeometry, new Vector3(0, 1, 0), 50);
    if (params.sortEdges) {
      edges2.sort((a, b2) => {
        return Math.min(a.start.y, a.end.y) - Math.min(b2.start.y, b2.end.y);
      });
    }
    yield;
    const finalEdges = [];
    const tempLine = new Line3();
    const tempRay = new Ray();
    const tempVec = new Vector3();
    for (let i = 0, l2 = edges2.length; i < l2; i++) {
      const line = edges2[i];
      if (isYProjectedLineDegenerate(line)) {
        continue;
      }
      const lowestLineY = Math.min(line.start.y, line.end.y);
      const overlaps = [];
      bvh.shapecast({
        intersectsBounds: (box) => {
          if (!params.useBVH) {
            return true;
          }
          box.min.y = Math.min(lowestLineY, box.min.y);
          tempRay.origin.copy(line.start);
          line.delta(tempRay.direction).normalize();
          if (box.containsPoint(tempRay.origin)) {
            return true;
          }
          if (tempRay.intersectBox(box, tempVec)) {
            return tempRay.origin.distanceToSquared(tempVec) < line.distanceSq();
          }
          return false;
        },
        intersectsTriangle: (tri) => {
          const highestTriangleY = Math.max(tri.a.y, tri.b.y, tri.c.y);
          if (highestTriangleY < lowestLineY) {
            return false;
          }
          if (isYProjectedTriangleDegenerate(tri)) {
            return false;
          }
          if (isLineTriangleEdge(tri, line)) {
            return false;
          }
          trimToBeneathTriPlane(tri, line, tempLine);
          if (isLineAbovePlane(tri.plane, tempLine)) {
            return false;
          }
          if (tempLine.distance() < 1e-10) {
            return false;
          }
          if (getProjectedOverlaps(tri, line, overlaps)) {
            compressEdgeOverlaps(overlaps);
          }
          if (overlaps.length !== 0) {
            const [d0, d1] = overlaps[overlaps.length - 1];
            return d0 === 0 && d1 === 1;
          }
          return false;
        }
      });
      overlapsToLines(line, overlaps, finalEdges);
    }
    projection.geometry.dispose();
    projection.geometry = edgesToGeometry(finalEdges, 0);
  }
};

// node_modules/openbim-components/import-export/dxf-exporter/index.js
var DXFExporter = class _DXFExporter extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this.precission = 1e-3;
    this._projector = new EdgeProjector();
    this.components.tools.add(_DXFExporter.uuid, this);
  }
  get() {
    return this._projector;
  }
  dispose() {
    this._projector.dispose();
  }
  async export(name) {
    const drawing = new import_dxf_writer.default();
    drawing.setUnits("Meters");
    const fragPlans = await this.components.tools.get(FragmentPlans);
    const fragments = await this.components.tools.get(FragmentManager);
    const plans = fragPlans.get();
    const plan = plans.find((plan2) => plan2.name === name);
    if (!plan || !plan.plane) {
      throw new Error("Plan doesn't exist!");
    }
    const meshes = Object.values(fragments.list).map((frag) => frag.mesh);
    let height = plan.point.y;
    if (plan.offset) {
      height += plan.offset;
    }
    drawing.addLayer("projection", import_dxf_writer.default.ACI.BLUE, "CONTINUOUS");
    drawing.setActiveLayer("projection");
    const projectedLines = await this._projector.project(meshes, height);
    this.drawGeometry(projectedLines.geometry, drawing);
    projectedLines.geometry.dispose();
    projectedLines.material.dispose();
    const edges2 = plan.plane.edges.get();
    for (const layerName in edges2) {
      const mesh = edges2[layerName].mesh;
      const material = mesh.material;
      const { r, g, b: b2 } = material.color;
      let layerColor;
      if (r > g && r > b2) {
        layerColor = import_dxf_writer.default.ACI.RED;
      } else if (g > r && g > b2) {
        layerColor = import_dxf_writer.default.ACI.GREEN;
      } else if (b2 > r && b2 > g) {
        layerColor = import_dxf_writer.default.ACI.BLUE;
      } else {
        layerColor = import_dxf_writer.default.ACI.WHITE;
      }
      drawing.addLayer(layerName, layerColor, "CONTINUOUS");
      drawing.setActiveLayer(layerName);
      this.drawGeometry(mesh.geometry, drawing);
    }
    return drawing.toDxfString();
  }
  drawGeometry(geometry, drawing) {
    const pos = geometry.attributes.position.array;
    const range = Math.min(geometry.drawRange.count * 3, pos.length);
    for (let i = 0; i < range; i += 6) {
      const x1 = pos[i];
      const y1 = pos[i + 2];
      const x2 = pos[i + 3];
      const y2 = pos[i + 5];
      const diffX = Math.abs(x2 - x1);
      const diffY = Math.abs(y2 - y1);
      const approxDistance = diffX + diffY;
      if (approxDistance > this.precission) {
        drawing.drawLine(x1, y1, x2, y2);
      }
    }
  }
};
DXFExporter.uuid = "568f2167-24a3-4519-b552-3b04cc74a6a6";
ToolComponent.libraryUUIDs.add(DXFExporter.uuid);

// node_modules/openbim-clay/utils/buffer-manager.js
var BufferManager = class {
  /** The current size of the buffers. */
  get size() {
    const firstAttribute = this.attributes[0];
    return firstAttribute.count * 3;
  }
  get attributes() {
    return Object.values(this.geometry.attributes);
  }
  constructor(geometry) {
    this.geometry = geometry;
    this.bufferIncrease = 300;
    this.capacity = 0;
  }
  addAttribute(attribute) {
    this.geometry.setAttribute(attribute.name, attribute);
  }
  resetAttributes() {
    for (const attribute of this.attributes) {
      this.createAttribute(attribute.name);
    }
    this.capacity = 0;
  }
  createAttribute(name) {
    if (this.geometry.hasAttribute(name)) {
      this.geometry.deleteAttribute(name);
    }
    const attribute = new BufferAttribute(new Float32Array(0), 3);
    attribute.name = name;
    this.geometry.setAttribute(name, attribute);
  }
  updateCount(size) {
    for (const attribute of this.attributes) {
      attribute.count = size;
      attribute.needsUpdate = true;
    }
  }
  resizeIfNeeded(increase) {
    const newSize = this.size + increase * 3;
    const difference = newSize - this.capacity;
    if (difference >= 0) {
      const increase2 = Math.max(difference, this.bufferIncrease);
      const oldCapacity = this.capacity;
      this.capacity += increase2;
      for (const attribute of this.attributes) {
        this.resizeBuffers(attribute, oldCapacity);
      }
    }
  }
  resizeBuffers(attribute, oldCapacity) {
    this.geometry.deleteAttribute(attribute.name);
    const array = new Float32Array(this.capacity);
    const newAttribute = new BufferAttribute(array, 3);
    newAttribute.name = attribute.name;
    newAttribute.count = attribute.count;
    this.geometry.setAttribute(attribute.name, newAttribute);
    for (let i = 0; i < oldCapacity; i++) {
      const x = attribute.getX(i);
      const y = attribute.getY(i);
      const z = attribute.getZ(i);
      newAttribute.setXYZ(i, x, y, z);
    }
  }
};

// node_modules/openbim-clay/utils/id-index-map.js
var IdIndexMap = class {
  constructor() {
    this._idGenerator = 0;
    this._ids = [];
    this._indices = [];
  }
  /**
   * The number of items stored in this map
   */
  get size() {
    return this._ids.length;
  }
  /**
   * The list of IDs inside this map. IDs are generated as increasing natural
   * numbers starting from zero. The position of the ID in the array is
   * the index of that entity in the geometric buffer.
   * For instance, the ids of a map with 5 items would look like this:
   *
   * - [0, 1, 2, 3, 4]
   *
   * If the item with ID = 1 is deleted, the last item will replace the deleted
   * one to keep the continuity of the geometric buffer, resulting in this:
   *
   * - [0, 4, 2, 3]
   */
  get ids() {
    return this._ids;
  }
  /**
   * The list of indices of the geometric buffer. The position of the index in
   * the array is the ID of that entity. For instance, the ids of a map with 5
   * items would look like this:
   *
   * - [0, 1, 2, 3, 4]
   *
   * If the item with ID = 1 is deleted, the last item will replace the
   * deleted one to keep the continuity of the geometric buffer. The deleted
   * item will remain as null inside the array:
   *
   * - [0, null, 2, 3, 1]
   */
  get indices() {
    return this._indices;
  }
  /**
   * Adds a new item to the map, creating and assigning a new ID and a new index
   * to it. New items are assumed to be created at the end of the geometric
   * buffer.
   */
  add() {
    this._ids.push(this._idGenerator++);
    const index = this._ids.length - 1;
    this._indices.push(index);
    return index;
  }
  /**
   * Removes the specified item from the map and rearrange the indices to
   * keep the continuity of the geometric buffer.
   */
  remove(id) {
    const index = this.getIndex(id);
    if (index === null || index === void 0)
      return;
    const lastID = this._ids.pop();
    if (lastID === void 0) {
      throw new Error(`Error while removing item: ${id}`);
    }
    this._indices[id] = null;
    if (id === lastID)
      return;
    this._ids[index] = lastID;
    this._indices[lastID] = index;
  }
  /**
   * Resets this instance to the initial state.
   */
  reset() {
    this._idGenerator = 0;
    this._ids = [];
    this._indices = [];
  }
  /**
   * Gets the ID for the given index.
   * @param index index of the entity whose ID to find out.
   */
  getId(index) {
    return this._ids[index];
  }
  /**
   * Gets the index for the given ID.
   * @param id ID of the entity whose index to find out.
   */
  getIndex(id) {
    return this._indices[id];
  }
  /**
   * Gets the last index of the geometry buffer.
   */
  getLastIndex() {
    return this.size - 1;
  }
  /**
   * Gets the last ID in the geometry buffer.
   */
  getLastID() {
    return this._ids[this._ids.length - 1];
  }
};

// node_modules/openbim-clay/utils/selector.js
var Selector = class {
  constructor() {
    this.data = /* @__PURE__ */ new Set();
  }
  /**
   * Select or unselects the given faces.
   * @param active Whether to select or unselect.
   * @param ids List of faces IDs to select or unselect. If not
   * defined, all faces will be selected or deselected.
   * @param allItems all the existing items.
   */
  select(active, ids, allItems) {
    const all = new Set(allItems);
    const idsToUpdate = [];
    for (const id of ids) {
      const exists = all.has(id);
      if (!exists)
        continue;
      const isAlreadySelected = this.data.has(id);
      if (active) {
        if (isAlreadySelected)
          continue;
        this.data.add(id);
        idsToUpdate.push(id);
      } else {
        if (!isAlreadySelected)
          continue;
        this.data.delete(id);
        idsToUpdate.push(id);
      }
    }
    return idsToUpdate;
  }
  getUnselected(ids) {
    const notSelectedIDs = [];
    for (const id of ids) {
      if (!this.data.has(id)) {
        notSelectedIDs.push(id);
      }
    }
    return notSelectedIDs;
  }
};

// node_modules/openbim-clay/primitives/Primitive/index.js
var Primitive = class {
  constructor() {
    this.selected = new Selector();
    this._baseColor = new Color(0.5, 0.5, 0.5);
    this._selectColor = new Color(1, 0, 0);
    this.list = {};
  }
  /**
   * The list of ids of the {@link list} of items.
   */
  get ids() {
    const ids = [];
    for (const id in this.list) {
      ids.push(this.list[id].id);
    }
    return ids;
  }
  /**
   * The color of all the points.
   */
  get baseColor() {
    return this._baseColor;
  }
  /**
   * The color of all the points.
   */
  set baseColor(color2) {
    this._baseColor.copy(color2);
  }
  /**
   * The color of all the selected points.
   */
  get selectColor() {
    return this._selectColor;
  }
  /**
   * The color of all the selected points.
   */
  set selectColor(color2) {
    this._selectColor.copy(color2);
  }
  get _positionBuffer() {
    return this.mesh.geometry.attributes.position;
  }
  get _colorBuffer() {
    return this.mesh.geometry.attributes.color;
  }
  get _normalBuffer() {
    return this.mesh.geometry.attributes.normal;
  }
  get _attributes() {
    return Object.values(this.mesh.geometry.attributes);
  }
};

// node_modules/openbim-clay/primitives/Vertices/index.js
var Vertices = class extends Primitive {
  /**
   * The color of all the points.
   */
  set baseColor(color2) {
    super.baseColor = color2;
    const allIDs = this.idMap.ids;
    const unselected = this.selected.getUnselected(allIDs);
    this.updateColor(unselected);
  }
  /**
   * The color of all the selected points.
   */
  set selectColor(color2) {
    super.selectColor = color2;
    this.updateColor(this.selected.data);
  }
  /**
   * Creates a new instance of vertices
   * @param size Visualization point size
   */
  constructor(size = 0.1) {
    super();
    this.idMap = new IdIndexMap();
    const geometry = new BufferGeometry();
    const material = new PointsMaterial({
      size,
      vertexColors: true
    });
    this.mesh = new Points(geometry, material);
    this.mesh.frustumCulled = false;
    this._buffers = new BufferManager(geometry);
    this._buffers.createAttribute("position");
    this._buffers.createAttribute("color");
  }
  /**
   * Gets the coordinates of the vertex with the given ID.
   * @param id the id of the point to retrieve.
   */
  get(id) {
    const index = this.idMap.getIndex(id);
    if (index === null)
      return null;
    return [
      this._positionBuffer.getX(index),
      this._positionBuffer.getY(index),
      this._positionBuffer.getZ(index)
    ];
  }
  /**
   * Add new points
   * @param ids the vertices to edit.
   * @param coordinates the new coordinates for the vertex.
   */
  set(ids, coordinates) {
    const [x, y, z] = coordinates;
    for (const id of ids) {
      const index = this.idMap.getIndex(id);
      if (index === null)
        return;
      this._positionBuffer.setXYZ(index, x, y, z);
    }
    this._positionBuffer.needsUpdate = true;
  }
  /**
   * Add new points
   * @param coordinates Points to add.
   * @returns the list of ids of the created vertices.
   */
  add(coordinates) {
    this._buffers.resizeIfNeeded(coordinates.length);
    const ids = [];
    const { r, g, b: b2 } = this._baseColor;
    for (let i = 0; i < coordinates.length; i++) {
      const index = this.idMap.add();
      const id = this.idMap.getId(index);
      ids.push(id);
      const [x, y, z] = coordinates[i];
      this._positionBuffer.setXYZ(index, x, y, z);
      this._colorBuffer.setXYZ(index, r, g, b2);
    }
    this._buffers.updateCount(this.idMap.size);
    this.mesh.geometry.computeBoundingSphere();
    this.mesh.geometry.computeBoundingBox();
    return ids;
  }
  /**
   * Select or unselects the given vertices.
   * @param active Whether to select or unselect.
   * @param ids List of vertices IDs to select or deselect. If not
   * defined, all vertices will be selected or deselected.
   */
  select(active, ids = this.idMap.ids) {
    const idsToUpdate = this.selected.select(active, ids, this.idMap.ids);
    this.updateColor(idsToUpdate);
  }
  /**
   * Applies a transformation to the selected vertices.
   * @param matrix Transformation matrix to apply.
   * @param ids IDs of the vertices to transform.
   */
  transform(matrix, ids = this.selected.data) {
    const vector = new Vector3();
    for (const id of ids) {
      const index = this.idMap.getIndex(id);
      if (index === null)
        continue;
      const x = this._positionBuffer.getX(index);
      const y = this._positionBuffer.getY(index);
      const z = this._positionBuffer.getZ(index);
      vector.set(x, y, z);
      vector.applyMatrix4(matrix);
      this._positionBuffer.setXYZ(index, vector.x, vector.y, vector.z);
    }
    this._positionBuffer.needsUpdate = true;
  }
  /**
   * Quickly removes all the points and releases all the memory used.
   */
  clear() {
    this._buffers.resetAttributes();
    this.selected.data.clear();
    this.idMap.reset();
  }
  /**
   * Removes the selected points from the list
   */
  remove(ids = this.selected.data) {
    for (const id of ids) {
      for (const attribute of this._attributes) {
        this.removeFromBuffer(id, attribute);
      }
      this.idMap.remove(id);
    }
    this.select(false, ids);
    this._buffers.updateCount(this.idMap.size);
  }
  addAttribute(attribute) {
    this._buffers.addAttribute(attribute);
  }
  removeFromBuffer(id, buffer) {
    const lastIndex = this.idMap.getLastIndex();
    const index = this.idMap.getIndex(id);
    if (index !== null) {
      buffer.setXYZ(index, buffer.getX(lastIndex), buffer.getY(lastIndex), buffer.getZ(lastIndex));
    }
  }
  updateColor(ids = this.idMap.ids) {
    const colorBuffer = this._colorBuffer;
    for (const id of ids) {
      const isSelected = this.selected.data.has(id);
      const index = this.idMap.getIndex(id);
      if (index === null)
        continue;
      const color2 = isSelected ? this._selectColor : this._baseColor;
      colorBuffer.setXYZ(index, color2.r, color2.g, color2.b);
    }
    colorBuffer.needsUpdate = true;
  }
};

// node_modules/openbim-clay/primitives/Lines/index.js
var Lines = class extends Primitive {
  /**
   * The color of all the points.
   */
  set baseColor(color2) {
    super.baseColor = color2;
    const allIDs = this.idMap.ids;
    const unselected = this.selected.getUnselected(allIDs);
    this.updateColor(unselected);
    this.vertices.baseColor = color2;
  }
  /**
   * The color of all the selected points.
   */
  set selectColor(color2) {
    super.selectColor = color2;
    this.updateColor(this.selected.data);
    this.vertices.selectColor = color2;
  }
  constructor() {
    super();
    this.mesh = new LineSegments();
    this.list = {};
    this.vertices = new Vertices();
    this.idMap = new IdIndexMap();
    this.points = {};
    const material = new LineBasicMaterial({ vertexColors: true });
    const geometry = new BufferGeometry();
    this.mesh = new LineSegments(geometry, material);
    this._buffers = new BufferManager(geometry);
    this.setupAttributes();
  }
  /**
   * Quickly removes all the lines and releases all the memory used.
   */
  clear() {
    this.selected.data.clear();
    this.mesh.geometry.dispose();
    this.mesh.geometry = new BufferGeometry();
    this.setupAttributes();
    this.vertices.clear();
    this.idMap.reset();
    this.list = {};
    this.points = {};
  }
  /**
   * Adds a segment between two {@link points}.
   * @param ids - the IDs of the {@link points} that define the segments.
   */
  add(ids) {
    const createdIDs = [];
    const newVerticesCount = (ids.length - 1) * 2;
    this._buffers.resizeIfNeeded(newVerticesCount);
    const { r, g, b: b2 } = this._baseColor;
    for (let i = 0; i < ids.length - 1; i++) {
      const startID = ids[i];
      const endID = ids[i + 1];
      const start2 = this.vertices.get(startID);
      const end2 = this.vertices.get(endID);
      if (start2 === null || end2 === null)
        continue;
      const index = this.idMap.add();
      const id = this.idMap.getId(index);
      createdIDs.push(id);
      const startPoint = this.points[startID];
      const endPoint = this.points[endID];
      startPoint.start.add(id);
      endPoint.end.add(id);
      this._positionBuffer.setXYZ(index * 2, start2[0], start2[1], start2[2]);
      this._positionBuffer.setXYZ(index * 2 + 1, end2[0], end2[1], end2[2]);
      this._colorBuffer.setXYZ(index * 2, r, g, b2);
      this._colorBuffer.setXYZ(index * 2 + 1, r, g, b2);
      this.list[id] = { id, start: startID, end: endID };
    }
    const allVerticesCount = this.idMap.size * 2;
    this._buffers.updateCount(allVerticesCount);
    this.mesh.geometry.computeBoundingSphere();
    this.mesh.geometry.computeBoundingBox();
    return createdIDs;
  }
  get(id) {
    const line = this.list[id];
    const start2 = this.vertices.get(line.start);
    const end2 = this.vertices.get(line.end);
    if (!start2 || !end2)
      return null;
    return [start2, end2];
  }
  /**
   * Adds the points that can be used by one or many lines.
   * @param points the list of (x, y, z) coordinates of the points.
   */
  addPoints(points) {
    const ids = this.vertices.add(points);
    for (const id of ids) {
      this.points[id] = { start: /* @__PURE__ */ new Set(), end: /* @__PURE__ */ new Set() };
    }
    return ids;
  }
  /**
   * Select or unselects the given lines.
   * @param active Whether to select or unselect.
   * @param ids List of lines IDs to select or unselect. If not
   * defined, all lines will be selected or deselected.
   */
  select(active, ids = this.ids) {
    const allLines = this.idMap.ids;
    const lineIDs = ids || allLines;
    const idsToUpdate = this.selected.select(active, lineIDs, allLines);
    this.updateColor(idsToUpdate);
    const points = [];
    for (const id of idsToUpdate) {
      const line = this.list[id];
      points.push(line.start);
      points.push(line.end);
    }
    this.selectPoints(active, points);
  }
  selectPoints(active, ids) {
    this.vertices.select(active, ids);
  }
  /**
   * Removes the specified lines.
   * @param ids List of lines to remove. If no line is specified,
   * removes all the selected lines.
   */
  remove(ids = this.selected.data) {
    const position = this._positionBuffer;
    const color2 = this._colorBuffer;
    const points = [];
    for (const id of ids) {
      const line = this.list[id];
      if (line === void 0)
        continue;
      this.removeFromBuffer(id, position);
      this.removeFromBuffer(id, color2);
      this.idMap.remove(id);
      const startPoint = this.points[line.start];
      points.push(line.start, line.end);
      startPoint.start.delete(id);
      const endPoint = this.points[line.end];
      endPoint.end.delete(id);
      delete this.list[id];
      this.selected.data.delete(id);
    }
    position.needsUpdate = true;
    color2.needsUpdate = true;
    this.selectPoints(false, points);
  }
  /**
   * Removes the specified points and all lines that use them.
   * @param ids List of points to remove. If no point is specified,
   * removes all the selected points.
   */
  removePoints(ids = this.vertices.selected.data) {
    const lines = /* @__PURE__ */ new Set();
    for (const id of ids) {
      const point = this.points[id];
      if (!point)
        continue;
      for (const id2 of point.start) {
        lines.add(id2);
      }
      for (const id2 of point.end) {
        lines.add(id2);
      }
    }
    this.vertices.remove(ids);
    this.remove(lines);
  }
  /**
   * Sets a point of the line to a specific position.
   * @param id The point whose position to set.
   * @param coordinates The new coordinates of the point.
   */
  setPoint(id, coordinates) {
    const indices = /* @__PURE__ */ new Set();
    this.getPointIndices(id, indices);
    this.setLines(coordinates, indices);
    this.vertices.set([id], coordinates);
  }
  transform(matrix) {
    const indices = /* @__PURE__ */ new Set();
    const points = /* @__PURE__ */ new Set();
    for (const id of this.vertices.selected.data) {
      points.add(id);
      this.getPointIndices(id, indices);
    }
    this.transformLines(matrix, indices);
    this.vertices.transform(matrix, points);
  }
  getPointIndices(id, indices) {
    const point = this.points[id];
    for (const id2 of point.start) {
      const index = this.idMap.getIndex(id2);
      if (index === null) {
        continue;
      }
      indices.add(index * 2);
    }
    for (const id2 of point.end) {
      const index = this.idMap.getIndex(id2);
      if (index === null) {
        continue;
      }
      indices.add(index * 2 + 1);
    }
  }
  setupAttributes() {
    this._buffers.createAttribute("position");
    this._buffers.createAttribute("color");
  }
  removeFromBuffer(id, buffer) {
    const index = this.idMap.getIndex(id);
    if (index === null)
      return;
    const lastIndex = this.idMap.getLastIndex();
    const indices = [index * 2, index * 2 + 1];
    const lastIndices = [lastIndex * 2, lastIndex * 2 + 1];
    for (let i = 0; i < 2; i++) {
      const x = buffer.getX(lastIndices[i]);
      const y = buffer.getY(lastIndices[i]);
      const z = buffer.getZ(lastIndices[i]);
      buffer.setXYZ(indices[i], x, y, z);
    }
    buffer.count -= 2;
  }
  transformLines(matrix, indices) {
    const vector = new Vector3();
    for (const index of indices) {
      const x = this._positionBuffer.getX(index);
      const y = this._positionBuffer.getY(index);
      const z = this._positionBuffer.getZ(index);
      vector.set(x, y, z);
      vector.applyMatrix4(matrix);
      this._positionBuffer.setXYZ(index, vector.x, vector.y, vector.z);
    }
    this._positionBuffer.needsUpdate = true;
  }
  setLines(coords, indices) {
    const [x, y, z] = coords;
    for (const index of indices) {
      this._positionBuffer.setXYZ(index, x, y, z);
    }
    this._positionBuffer.needsUpdate = true;
  }
  updateColor(ids = this.ids) {
    const colorAttribute = this._colorBuffer;
    for (const id of ids) {
      const line = this.list[id];
      const isSelected = this.selected.data.has(line.id);
      const { r, g, b: b2 } = isSelected ? this._selectColor : this._baseColor;
      const index = this.idMap.getIndex(id);
      if (index === null)
        continue;
      colorAttribute.setXYZ(index * 2, r, g, b2);
      colorAttribute.setXYZ(index * 2 + 1, r, g, b2);
    }
    colorAttribute.needsUpdate = true;
  }
};

// node_modules/openbim-clay/primitives/Faces/index.js
var import_earcut2 = __toESM(require_earcut());

// node_modules/openbim-components/civil/RoadNavigator/index.js
var RoadNavigator = class _RoadNavigator extends Component {
  constructor(components) {
    super(components);
    this.enabled = true;
    this._lines = new Lines();
    this._defaultID = "RoadNavigator";
    this.components.tools.add(_RoadNavigator.uuid, this);
    const raycaster = this.components.raycaster.get();
    raycaster.params.Points = { threshold: 1 };
    this._lines.baseColor = new Color("#6528D7");
    const scene = components.scene.get();
    scene.add(this._lines.mesh);
    scene.add(this._lines.vertices.mesh);
    this.longSection = new Simple2DScene(components);
    this._longProjection = new Lines();
    const longSection = this.longSection.get();
    longSection.add(this._longProjection.mesh, this._longProjection.vertices.mesh);
  }
  get() {
    return this._lines;
  }
  drawPoint() {
    const found = this.components.raycaster.castRay();
    if (!found)
      return;
    const { x, y, z } = found.point;
    const [id] = this._lines.addPoints([[x, y, z]]);
    this._lines.vertices.mesh.geometry.computeBoundingSphere();
    const selected = Array.from(this._lines.vertices.selected.data);
    if (selected.length) {
      const previousPoint = selected[0];
      this._lines.add([previousPoint, id]);
    }
    this._lines.selectPoints(false);
    this._lines.selectPoints(true, [id]);
    this.updateLongProjection();
    this.cache();
  }
  select() {
    this._lines.selectPoints(false);
    const found = this.components.raycaster.castRay([
      this._lines.vertices.mesh
    ]);
    if (found && found.index !== void 0) {
      const id = this._lines.vertices.idMap.getId(found.index);
      this._lines.selectPoints(true, [id]);
    }
  }
  delete() {
    this._lines.removePoints();
    this._lines.vertices.selected.data.clear();
    this._lines.vertices.mesh.geometry.computeBoundingSphere();
    this.updateLongProjection();
    this.cache();
  }
  // TODO: All fragment clases should include built-in caching in dexie
  cache(id = this._defaultID) {
    const points = [];
    const lines = [];
    const newPointIDMap = /* @__PURE__ */ new Map();
    let pointCounter = 0;
    for (const key in this._lines.points) {
      const pointID = parseInt(key, 10);
      const coords = this._lines.vertices.get(pointID);
      if (!coords)
        continue;
      points.push(coords);
      newPointIDMap.set(pointID, pointCounter);
      pointCounter++;
    }
    for (const id2 in this._lines.list) {
      const line = this._lines.list[id2];
      const newStart = newPointIDMap.get(line.start);
      const newEnd = newPointIDMap.get(line.end);
      if (newStart !== void 0 && newEnd !== void 0) {
        lines.push([newStart, newEnd]);
      }
    }
    localStorage.setItem(id, JSON.stringify({ lines, points }));
  }
  loadCached(id = this._defaultID) {
    const cached = localStorage.getItem(id);
    if (!cached)
      return;
    const parsed = JSON.parse(cached);
    if (parsed.points && parsed.points.length) {
      this._lines.addPoints(parsed.points);
    }
    if (parsed.lines && parsed.lines.length) {
      for (const line of parsed.lines) {
        this._lines.add(line);
      }
    }
  }
  updateLongProjection() {
    this._longProjection.clear();
    const vertices = this._lines.mesh.geometry.attributes.position;
    console.log(vertices);
    const v1 = new Vector3();
    const v22 = new Vector3();
    const points = [];
    let accumulatedX = 0;
    for (let i = 0; i < vertices.count * 3 - 5; i += 6) {
      const x1 = vertices.array[i];
      const y1 = vertices.array[i + 1];
      const z1 = vertices.array[i + 2];
      const x2 = vertices.array[i + 3];
      const y2 = vertices.array[i + 4];
      const z2 = vertices.array[i + 5];
      v1.set(x1, y1, z1);
      v22.set(x2, y2, z2);
      const length = v1.distanceTo(v22);
      accumulatedX += length;
      points.push([accumulatedX, y2, 0]);
    }
    const ids = this._longProjection.addPoints(points);
    this._longProjection.add(ids);
  }
};
RoadNavigator.uuid = "85f2c89c-4c6b-4c7d-bc20-5b675874b228";
ToolComponent.libraryUUIDs.add(RoadNavigator.uuid);
export {
  AngleMeasurement,
  AreaMeasurement,
  ArrowAnnotation,
  AttributeSet,
  BaseRenderer,
  BaseSVGAnnotation,
  Button,
  Canvas,
  CheckboxInput,
  CircleAnnotation,
  CloudProcessor,
  ColorInput,
  CommandsMenu,
  Component,
  Components,
  CubeMap,
  DXFExporter,
  DimensionLabelClassName,
  DimensionPreviewClassName,
  Disposer,
  DragAndDropInput,
  DrawManager,
  Drawer,
  Dropdown,
  EdgesClipper,
  EdgesPlane,
  Event,
  FloatingWindow,
  FragmentBoundingBox,
  FragmentCacher,
  FragmentClassifier,
  FragmentClipStyler,
  FragmentExploder,
  FragmentHider,
  FragmentHighlighter,
  FragmentIfcLoader,
  FragmentManager,
  FragmentPlans,
  FragmentTree,
  GeometryVerticesMarker,
  IfcCategories,
  IfcCategoryMap,
  IfcElements,
  IfcJsonExporter,
  IfcPropertiesFinder,
  IfcPropertiesManager,
  IfcPropertiesProcessor,
  IfcPropertiesUtils,
  LengthMeasurement,
  LineIntersectionPicker,
  LocalCacher,
  MapboxWindow,
  MaterialManager,
  MiniMap,
  Modal,
  Mouse,
  OrthoPerspectiveCamera,
  PostproductionRenderer,
  PropertyTag,
  RangeInput,
  RectangleAnnotation,
  RoadNavigator,
  ScreenCuller,
  ShadowDropper,
  Simple2DMarker,
  Simple2DScene,
  SimpleCamera,
  SimpleClipper,
  SimpleDimensionLine,
  SimpleGrid,
  SimplePlane,
  SimpleRaycaster,
  SimpleRenderer,
  SimpleSVGViewport,
  SimpleScene,
  SimpleUICard,
  SimpleUIComponent,
  Spinner,
  TextAnnotation,
  TextArea,
  TextInput,
  ToastNotification,
  ToolComponent,
  Toolbar,
  TreeView,
  UIElement,
  UIManager,
  VertexPicker,
  ViewpointsManager,
  bufferGeometryToIndexed,
  generateExpressIDFragmentIDMap,
  generateIfcGUID,
  numberOfDigits,
  toCompositeID,
  tooeenRandomId
};
/*! Bundled license information:

mapbox-gl/dist/mapbox-gl.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

camera-controls/dist/camera-controls.module.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)

postprocessing/build/index.js:
  (**
   * postprocessing v6.35.3 build Sat Mar 30 2024
   * https://github.com/pmndrs/postprocessing
   * Copyright 2015-2024 Raoul van Rüschen
   * @license Zlib
   *)
*/
//# sourceMappingURL=openbim-components.js.map
